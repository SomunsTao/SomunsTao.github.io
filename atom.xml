<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Somuns ` Tao</title>
  
  <subtitle>Java Blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://somunstao.github.io/"/>
  <updated>2020-05-01T02:17:04.419Z</updated>
  <id>https://somunstao.github.io/</id>
  
  <author>
    <name>陈涛</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SpringBoot：自动配置解析</title>
    <link href="https://somunstao.github.io/2020/05/03/SpringBoot21%EF%BC%9A%20%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE/"/>
    <id>https://somunstao.github.io/2020/05/03/SpringBoot21%EF%BC%9A%20%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE/</id>
    <published>2020-05-02T16:00:00.000Z</published>
    <updated>2020-05-01T02:17:04.419Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://p99.pstatp.com/large/pgc-image/15367619528862cca2a0df9" alt="img"></p><p>原文链接：<a href="https://www.cnblogs.com/leihuazhe/p/7743479.html" target="_blank" rel="noopener">https://www.cnblogs.com/leihuazhe/p/7743479.html</a></p><hr><hr><blockquote><p>SpringBoot 自动配置主要通过 <code>@EnableAutoConfiguration</code>, <code>@Conditional</code>, <code>@EnableConfigurationProperties</code> 或者 <code>@ConfigurationProperties</code> 等几个注解来进行自动配置完成的。</p><p><code>@EnableAutoConfiguration</code> 开启自动配置，主要作用就是调用 <code>Spring-Core</code> 包里的 <code>loadFactoryNames()</code>，将 <code>autoconfig</code> 包里的已经写好的自动配置加载进来。</p><p><code>@Conditional</code> 条件注解，通过判断类路径下有没有相应配置的 <code>jar</code> 包来确定是否加载和自动配置这个类。</p><p><code>@EnableConfigurationProperties</code> 的作用就是，给自动配置提供具体的配置参数，只需要写在 <code>application.properties</code> 中，就可以通过映射写入配置类的 <code>POJO</code> 属性中。</p></blockquote><h3 id="EnableAutoConfiguration"><a href="#EnableAutoConfiguration" class="headerlink" title="@EnableAutoConfiguration"></a>@EnableAutoConfiguration</h3><p>@Enable*注释并不是<code>SpringBoot</code>新发明的注释，Spring 3框架就引入了这些注释，用这些注释替代XML配置文件。比如：<br><code>@EnableTransactionManagement</code>注释，它能够声明事务管理<br><code>@EnableWebMvc</code>注释，它能启用Spring MVC<br><code>@EnableScheduling</code>注释，它可以初始化一个调度器。</p><h4 id="这些注释事实上都是简单的配置，通过-Import注释导入。"><a href="#这些注释事实上都是简单的配置，通过-Import注释导入。" class="headerlink" title="这些注释事实上都是简单的配置，通过@Import注释导入。"></a><strong>这些注释事实上都是简单的配置，通过<code>@Import</code>注释导入</strong>。</h4><h5 id="从启动类的-SpringBootApplication进入，在里面找到了-EnableAutoConfiguration"><a href="#从启动类的-SpringBootApplication进入，在里面找到了-EnableAutoConfiguration" class="headerlink" title="从启动类的@SpringBootApplication进入，在里面找到了@EnableAutoConfiguration,"></a>从启动类的@SpringBootApplication进入，在里面找到了@EnableAutoConfiguration,</h5><p><img src="http://pic.hzways.com/1.png" alt="1.png"></p><p><img src="http://pic.hzways.com/2.png" alt="2.png"></p><h5 id="EnableAutoConfiguration里通过-Import导入了EnableAutoConfigurationImportSelector"><a href="#EnableAutoConfiguration里通过-Import导入了EnableAutoConfigurationImportSelector" class="headerlink" title="@EnableAutoConfiguration里通过@Import导入了EnableAutoConfigurationImportSelector,"></a>@EnableAutoConfiguration里通过@Import导入了<code>EnableAutoConfigurationImportSelector</code>,</h5><p><img src="http://pic.hzways.com/3.png" alt="3.png"></p><h5 id="进入他的父类AutoConfigurationImportSelector"><a href="#进入他的父类AutoConfigurationImportSelector" class="headerlink" title="进入他的父类AutoConfigurationImportSelector"></a>进入他的父类<code>AutoConfigurationImportSelector</code></h5><p><img src="http://pic.hzways.com/4.png" alt="4.png"></p><h5 id="找到selectImports-方法，他调用了getCandidateConfigurations-方法，在这里，这个方法又调用了Spring-Core包中的loadFactoryNames-方法。这个方法的作用是，会查询META-INF-spring-factories文件中包含的JAR文件。"><a href="#找到selectImports-方法，他调用了getCandidateConfigurations-方法，在这里，这个方法又调用了Spring-Core包中的loadFactoryNames-方法。这个方法的作用是，会查询META-INF-spring-factories文件中包含的JAR文件。" class="headerlink" title="找到selectImports()方法，他调用了getCandidateConfigurations()方法，在这里，这个方法又调用了Spring Core包中的loadFactoryNames()方法。这个方法的作用是，会查询META-INF/spring.factories文件中包含的JAR文件。"></a>找到<code>selectImports()</code>方法，他调用了<code>getCandidateConfigurations()</code>方法，在这里，这个方法又调用了Spring Core包中的<code>loadFactoryNames()</code>方法。这个方法的作用是，会查询<code>META-INF/spring.factories</code>文件中包含的<code>JAR</code>文件。</h5><p><img src="http://pic.hzways.com/5.png" alt="5.png"></p><h5 id="当找到spring-factories文件后，SpringFactoriesLoader将查询配置文件命名的属性。"><a href="#当找到spring-factories文件后，SpringFactoriesLoader将查询配置文件命名的属性。" class="headerlink" title="当找到spring.factories文件后，SpringFactoriesLoader将查询配置文件命名的属性。"></a>当找到spring.factories文件后，SpringFactoriesLoader将查询配置文件命名的属性。</h5><p><img src="http://pic.hzways.com/6.png" alt="6.png"></p><p><img src="http://pic.hzways.com/7.png" alt="7.png"></p><h5 id="Jar文件在org-springframework-boot-autoconfigure的spring-factories"><a href="#Jar文件在org-springframework-boot-autoconfigure的spring-factories" class="headerlink" title="Jar文件在org.springframework.boot.autoconfigure的spring.factories"></a><code>Jar</code>文件在<code>org.springframework.boot.autoconfigure的spring.factories</code></h5><p><img src="http://pic.hzways.com/8.png" alt="8.png"></p><h5 id="spring-factories内容如下-截取部分-在这个文件中，可以看到一系列Spring-Boot自动配置的列表"><a href="#spring-factories内容如下-截取部分-在这个文件中，可以看到一系列Spring-Boot自动配置的列表" class="headerlink" title="spring.factories内容如下(截取部分),在这个文件中，可以看到一系列Spring Boot自动配置的列表"></a><code>spring.factories</code>内容如下(截取部分),在这个文件中，可以看到一系列Spring Boot自动配置的列表</h5><figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="meta">org.springframework.boot.autoconfigure.EnableAutoConfiguration</span>=<span class="string">\</span></span><br><span class="line">org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.cloud.CloudAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.context.MessageSourceAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.couchbase.CouchbaseAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.dao.PersistenceExceptionTranslationAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.cassandra.CassandraDataAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.cassandra.CassandraRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.couchbase.CouchbaseDataAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.couchbase.CouchbaseRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchDataAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.jpa.JpaRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.ldap.LdapDataAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.ldap.LdapRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.mongo.MongoDataAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.mongo.MongoRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.neo4j.Neo4jDataAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.neo4j.Neo4jRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.solr.SolrRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.redis.RedisRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.rest.RepositoryRestMvcAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.web.SpringDataWebAutoConfiguration,\</span><br></pre></td></tr></table></figure><h3 id="下面我们来看自动配置redis的细节，RedisAutoConfiguration："><a href="#下面我们来看自动配置redis的细节，RedisAutoConfiguration：" class="headerlink" title="下面我们来看自动配置redis的细节，RedisAutoConfiguration："></a>下面我们来看自动配置redis的细节，RedisAutoConfiguration：</h3><h3 id="RedisAutoConfiguration"><a href="#RedisAutoConfiguration" class="headerlink" title="RedisAutoConfiguration"></a>RedisAutoConfiguration</h3><p><img src="http://pic.hzways.com/redis.png" alt="redis.png"></p><p>这个类进行了简单的Spring配置，声明了Redis所需典型Bean，和其它很多类一样，重度依赖于Spring Boot注释：<br>1）@ConditionOnClass激活一个配置，当类路径中存在这个类时才会配置该类<br>2）@EnableConfigurationProperties自动映射一个POJO到Spring Boot配置文件（默认是application.properties文件）的属性集。<br>3）@ConditionalOnMissingBean启用一个Bean定义，但必须是这个Bean之前未定义过才有效。<br>还可以使用@ AutoConfigureBefore注释、@AutoConfigureAfter注释来定义这些配置类的载入顺序。</p><h4 id="着重了解-Conditional注释，Spring-4框架的新特性"><a href="#着重了解-Conditional注释，Spring-4框架的新特性" class="headerlink" title="着重了解@Conditional注释，Spring 4框架的新特性"></a>着重了解@Conditional注释，Spring 4框架的新特性</h4><p>此注释使得只有在特定条件满足时才启用一些配置。SrpingBoot的AutoConfig大量使用了@Conditional，它会根据运行环境来动态注入Bean。这里介绍一些@Conditional的使用和原理，并自定义@Conditional来自定义功能。</p><ul><li>@Conditional是SpringFramework的功能，SpringBoot在它的基础上定义了</li><li>@ConditionalOnClass，@ConditionalOnProperty等一系列的注解来实现更丰富的内容。</li></ul><h4 id="具体几个-Conditon-注解的含义"><a href="#具体几个-Conditon-注解的含义" class="headerlink" title="具体几个@Conditon*注解的含义"></a>具体几个@Conditon*注解的含义</h4><h6 id="ConditionalOnBean"><a href="#ConditionalOnBean" class="headerlink" title="@ConditionalOnBean"></a>@ConditionalOnBean</h6><p>仅仅在当前上下文中存在某个对象时，才会实例化一个Bean</p><h6 id="ConditionalOnClass"><a href="#ConditionalOnClass" class="headerlink" title="@ConditionalOnClass"></a>@ConditionalOnClass</h6><p>某个class位于类路径上，才会实例化一个Bean)，该注解的参数对应的类必须存在，否则不解析该注解修饰的配置类</p><h6 id="ConditionalOnExpression"><a href="#ConditionalOnExpression" class="headerlink" title="@ConditionalOnExpression"></a>@ConditionalOnExpression</h6><p>当表达式为true的时候，才会实例化一个Bean</p><h6 id="ConditionalOnMissingBean"><a href="#ConditionalOnMissingBean" class="headerlink" title="@ConditionalOnMissingBean"></a>@ConditionalOnMissingBean</h6><p>仅仅在当前上下文中不存在某个对象时，才会实例化一个Bean，该注解表示，如果存在它修饰的类的bean，则不需要再创建这个bean，可以给该注解传入参数例如@ConditionOnMissingBean(name = “example”)，这个表示如果name为“example”的bean存在，这该注解修饰的代码块不执行</p><h6 id="ConditionalOnMissingClass"><a href="#ConditionalOnMissingClass" class="headerlink" title="@ConditionalOnMissingClass"></a>@ConditionalOnMissingClass</h6><p>某个class类路径上不存在的时候，才会实例化一个Bean</p><h6 id="ConditionalOnNotWebApplication"><a href="#ConditionalOnNotWebApplication" class="headerlink" title="@ConditionalOnNotWebApplication"></a>@ConditionalOnNotWebApplication</h6><p>不是web应用时，才会执行</p><hr><h3 id="2-Properties系列注释"><a href="#2-Properties系列注释" class="headerlink" title="2.Properties系列注释"></a>2.Properties系列注释</h3><p>@EnableConfigurationProperties<br>@ConfigurationProperties(prefix = “may”)</p><p>在需要注入配置的类上加上这个注解，prefix的意思是，以该前缀打头的配置，以下是例子</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"may"</span>)  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> String name;  </span><br><span class="line">    <span class="keyword">private</span> String gender;  </span><br><span class="line">    </span><br><span class="line">   <span class="comment">//省略setter,getter方法</span></span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>application.yml中的配置</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">may</span><br><span class="line">   name: youjie</span><br><span class="line">   gender: man</span><br></pre></td></tr></table></figure><p>如果不用系统初始的application.yml配置类，而是使用自己的如youjie.yml，可以如下配置</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"may"</span>,locations = <span class="string">"classpath:youjie.yml"</span>)  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User2</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> String name;  </span><br><span class="line">    <span class="keyword">private</span> String gender;  </span><br><span class="line">    </span><br><span class="line">   <span class="comment">//省略setter,getter方法</span></span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>过时：由于Spring-boot 1.5.2版本移除了，locations这个属性,因此上述这种方式在最新的版本中过时。<br>@PropertySource</p><p>Spring-boot 1.5.2版本之后，采用下面这种方式</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="comment">//@PropertySource只能加载.properties文件，需要将上面的yml文件，改为.properties文件</span></span><br><span class="line"><span class="meta">@PropertySource</span>(<span class="string">"classpath:may.properties"</span>)</span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix=<span class="string">"may"</span>) </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User2</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">private</span> String name;  </span><br><span class="line">        <span class="keyword">private</span> String gender;  </span><br><span class="line">        </span><br><span class="line">       <span class="comment">//省略setter,getter方法</span></span><br><span class="line">      </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>@EnableConfigurationProperties</p><p>最后注意在spring Boot入口类加上@EnableConfigurationProperties</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span>  </span><br><span class="line"><span class="meta">@EnableConfigurationProperties</span>(&#123;User<span class="class">.<span class="keyword">class</span>,<span class="title">User2</span>.<span class="title">class</span>&#125;)  </span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">DemoApplication</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        SpringApplication.run(DemoApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实这里@EnableConfigurationProperties({User.class,User2.class}) 可以省略</p><p><img src="http://pic.hzways.com/config.png" alt="config.png"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>SpringBoot 的 自动配置得益于 SpringFramework 强大的支撑，框架早已有很多工具和注解可以自动装配 Bean 。SpringBoot 通过 一个封装，将市面上通用的组件直接写好了配置类。当我们程序去依赖了这些组件的 jar 包后，启动 SpringBoot应用，于是自动加载开始了。</p><p>我们也可以定义自己的自动装配组件，依赖之后，Spring直接可以加载我们定义的 starter 。笔者将在后续文章中进行编码和解读。</p>]]></content>
    
    <summary type="html">
    
      you can &quot;just run&quot;
    
    </summary>
    
    
      <category term="SpringBoot" scheme="https://SomunsTao.github.io/categories/SpringBoot/"/>
    
    
      <category term="SpringBoot" scheme="https://SomunsTao.github.io/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot：启动原理解析</title>
    <link href="https://somunstao.github.io/2020/05/03/SpringBoot21%EF%BC%9A%E5%90%AF%E5%8A%A8%E5%8E%9F%E7%90%86/"/>
    <id>https://somunstao.github.io/2020/05/03/SpringBoot21%EF%BC%9A%E5%90%AF%E5%8A%A8%E5%8E%9F%E7%90%86/</id>
    <published>2020-05-02T16:00:00.000Z</published>
    <updated>2020-05-01T05:05:32.289Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://p99.pstatp.com/large/pgc-image/15367619528862cca2a0df9" alt="img"></p><p>原文链接：<a href="https://www.cnblogs.com/xiaoxi/p/7999885.html" target="_blank" rel="noopener">https://www.cnblogs.com/xiaoxi/p/7999885.html</a></p><p>原作者：平凡希</p><hr><hr><h1 id="spring-boot：启动原理解析"><a href="#spring-boot：启动原理解析" class="headerlink" title="spring boot：启动原理解析"></a><a href="https://www.cnblogs.com/xiaoxi/p/7999885.html" target="_blank" rel="noopener">spring boot：启动原理解析</a></h1><p>我们开发任何一个Spring Boot项目，都会用到如下的启动类</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 @SpringBootApplication</span><br><span class="line">2 public class Application &#123;</span><br><span class="line">3     public static void main(String[] args) &#123;</span><br><span class="line">4         SpringApplication.run(Application.class, args);</span><br><span class="line">5     &#125;</span><br><span class="line">6 &#125;</span><br></pre></td></tr></table></figure><p>从上面代码可以看出，Annotation定义（@SpringBootApplication）和类定义（SpringApplication.run）最为耀眼，所以要揭开SpringBoot的神秘面纱，我们要从这两位开始就可以了。</p><p><strong>一、SpringBootApplication背后的秘密</strong></p><p>@SpringBootApplication注解是Spring Boot的核心注解，它其实是一个组合注解：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 1 @Target(ElementType.TYPE)</span><br><span class="line"> 2 @Retention(RetentionPolicy.RUNTIME)</span><br><span class="line"> 3 @Documented</span><br><span class="line"> 4 @Inherited</span><br><span class="line"> 5 @SpringBootConfiguration</span><br><span class="line"> 6 @EnableAutoConfiguration</span><br><span class="line"> 7 @ComponentScan(excludeFilters &#x3D; &#123;</span><br><span class="line"> 8         @Filter(type &#x3D; FilterType.CUSTOM, classes &#x3D; TypeExcludeFilter.class),</span><br><span class="line"> 9         @Filter(type &#x3D; FilterType.CUSTOM, classes &#x3D; AutoConfigurationExcludeFilter.class) &#125;)</span><br><span class="line">10 public @interface SpringBootApplication &#123;</span><br><span class="line">11 ...</span><br><span class="line">12 &#125;</span><br></pre></td></tr></table></figure><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>虽然定义使用了多个Annotation进行了原信息标注，但实际上重要的只有三个Annotation：</p><ul><li>@Configuration（@SpringBootConfiguration点开查看发现里面还是应用了@Configuration）</li><li>@EnableAutoConfiguration</li><li>@ComponentScan</li></ul><p>即 @SpringBootApplication = (默认属性)@Configuration + @EnableAutoConfiguration + @ComponentScan。</p><p>所以，如果我们使用如下的SpringBoot启动类，整个SpringBoot应用依然可以与之前的启动类功能对等：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 @Configuration</span><br><span class="line">2 @EnableAutoConfiguration</span><br><span class="line">3 @ComponentScan</span><br><span class="line">4 public class Application &#123;</span><br><span class="line">5     public static void main(String[] args) &#123;</span><br><span class="line">6         SpringApplication.run(Application.class, args);</span><br><span class="line">7     &#125;</span><br><span class="line">8 &#125;</span><br></pre></td></tr></table></figure><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>每次写这3个比较累，所以写一个@SpringBootApplication方便点。接下来分别介绍这3个Annotation。</p><p><strong>1、@Configuration</strong></p><p>   这里的@Configuration对我们来说不陌生，它就是JavaConfig形式的Spring Ioc容器的配置类使用的那个@Configuration，SpringBoot社区推荐使用基于JavaConfig的配置形式，所以，这里的启动类标注了@Configuration之后，本身其实也是一个IoC容器的配置类。</p><p>举几个简单例子回顾下，XML跟config配置方式的区别：</p><p><strong>（1）表达形式层面</strong></p><p>基于XML配置的方式是这样：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 &lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">2 &lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">3        xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">4        xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans-3.0.xsd&quot;</span><br><span class="line">5        default-lazy-init&#x3D;&quot;true&quot;&gt;</span><br><span class="line">6     &lt;!--bean定义--&gt;</span><br><span class="line">7 &lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>而基于JavaConfig的配置方式是这样：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 @Configuration</span><br><span class="line">2 public class MockConfiguration&#123;</span><br><span class="line">3     &#x2F;&#x2F;bean定义</span><br><span class="line">4 &#125;</span><br></pre></td></tr></table></figure><p>任何一个标注了@Configuration的Java类定义都是一个JavaConfig配置类。</p><p><strong>（2）注册bean定义层面</strong></p><p>基于XML的配置形式是这样：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 &lt;bean id&#x3D;&quot;mockService&quot; class&#x3D;&quot;..MockServiceImpl&quot;&gt;</span><br><span class="line">2     ...</span><br><span class="line">3 &lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure><p>而基于JavaConfig的配置形式是这样的：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 @Configuration</span><br><span class="line">2 public class MockConfiguration&#123;</span><br><span class="line">3     @Bean</span><br><span class="line">4     public MockService mockService()&#123;</span><br><span class="line">5         return new MockServiceImpl();</span><br><span class="line">6     &#125;</span><br><span class="line">7 &#125;</span><br></pre></td></tr></table></figure><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>任何一个标注了@Bean的方法，其返回值将作为一个bean定义注册到Spring的IoC容器，方法名将默认成该bean定义的id。</p><p><strong>（3）表达依赖注入关系层面</strong></p><p>为了表达bean与bean之间的依赖关系，在XML形式中一般是这样：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 &lt;bean id&#x3D;&quot;mockService&quot; class&#x3D;&quot;..MockServiceImpl&quot;&gt;</span><br><span class="line">2     &lt;propery name &#x3D;&quot;dependencyService&quot; ref&#x3D;&quot;dependencyService&quot; &#x2F;&gt;</span><br><span class="line">3 &lt;&#x2F;bean&gt;</span><br><span class="line">4 </span><br><span class="line">5 &lt;bean id&#x3D;&quot;dependencyService&quot; class&#x3D;&quot;DependencyServiceImpl&quot;&gt;&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure><p>而基于JavaConfig的配置形式是这样的：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 1 @Configuration</span><br><span class="line"> 2 public class MockConfiguration&#123;</span><br><span class="line"> 3     @Bean</span><br><span class="line"> 4     public MockService mockService()&#123;</span><br><span class="line"> 5         return new MockServiceImpl(dependencyService());</span><br><span class="line"> 6     &#125;</span><br><span class="line"> 7     </span><br><span class="line"> 8     @Bean</span><br><span class="line"> 9     public DependencyService dependencyService()&#123;</span><br><span class="line">10         return new DependencyServiceImpl();</span><br><span class="line">11     &#125;</span><br><span class="line">12 &#125;</span><br></pre></td></tr></table></figure><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>如果一个bean的定义依赖其他bean，则直接调用对应的JavaConfig类中依赖bean的创建方法就可以了。</p><hr><p>@Configuration：提到@Configuration就要提到他的搭档@Bean。使用这两个注解就可以创建一个简单的spring配置类，可以用来替代相应的xml配置文件。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 &lt;beans&gt; </span><br><span class="line">2     &lt;bean id &#x3D; &quot;car&quot; class&#x3D;&quot;com.test.Car&quot;&gt; </span><br><span class="line">3         &lt;property name&#x3D;&quot;wheel&quot; ref &#x3D; &quot;wheel&quot;&gt;&lt;&#x2F;property&gt; </span><br><span class="line">4     &lt;&#x2F;bean&gt; </span><br><span class="line">5     &lt;bean id &#x3D; &quot;wheel&quot; class&#x3D;&quot;com.test.Wheel&quot;&gt;&lt;&#x2F;bean&gt; </span><br><span class="line">6 &lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure><p>相当于：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 1 @Configuration </span><br><span class="line"> 2 public class Conf &#123; </span><br><span class="line"> 3     @Bean </span><br><span class="line"> 4     public Car car() &#123; </span><br><span class="line"> 5         Car car &#x3D; new Car(); </span><br><span class="line"> 6         car.setWheel(wheel()); </span><br><span class="line"> 7         return car; </span><br><span class="line"> 8     &#125;</span><br><span class="line"> 9     </span><br><span class="line">10     @Bean </span><br><span class="line">11     public Wheel wheel() &#123; </span><br><span class="line">12         return new Wheel(); </span><br><span class="line">13     &#125; </span><br><span class="line">14 &#125;</span><br></pre></td></tr></table></figure><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>@Configuration的注解类标识这个类可以使用Spring IoC容器作为bean定义的来源。</p><p>@Bean注解告诉Spring，一个带有@Bean的注解方法将返回一个对象，该对象应该被注册为在Spring应用程序上下文中的bean。</p><p><strong>2、@ComponentScan</strong></p><p>   @ComponentScan这个注解在Spring中很重要，它对应XML配置中的元素，@ComponentScan的功能其实就是自动扫描并加载符合条件的组件（比如@Component和@Repository等）或者bean定义，最终将这些bean定义加载到IoC容器中。</p><p>   我们可以通过basePackages等属性来细粒度的定制@ComponentScan自动扫描的范围，如果不指定，则默认Spring框架实现会从声明@ComponentScan所在类的package进行扫描。</p><p>注：所以SpringBoot的启动类最好是放在root package下，因为默认不指定basePackages。</p><p><strong>3、@EnableAutoConfiguration</strong></p><p>  个人感觉@EnableAutoConfiguration这个Annotation最为重要，所以放在最后来解读，大家是否还记得Spring框架提供的各种名字为@Enable开头的Annotation定义？比如@EnableScheduling、@EnableCaching、@EnableMBeanExport等，@EnableAutoConfiguration的理念和做事方式其实一脉相承，简单概括一下就是，<strong>借助@Import的支持，收集和注册特定场景相关的bean定义。</strong></p><ul><li>@EnableScheduling是通过@Import将Spring调度框架相关的bean定义都加载到IoC容器。</li><li>@EnableMBeanExport是通过@Import将JMX相关的bean定义加载到IoC容器。</li></ul><p>而@EnableAutoConfiguration也是借助@Import的帮助，将所有符合自动配置条件的bean定义加载到IoC容器，仅此而已！</p><p>  @EnableAutoConfiguration会根据类路径中的jar依赖为项目进行自动配置，如：添加了spring-boot-starter-web依赖，会自动添加Tomcat和Spring MVC的依赖，Spring Boot会对Tomcat和Spring MVC进行自动配置。</p><p><img src="https://images2017.cnblogs.com/blog/249993/201712/249993-20171207162607144-677920507.png" alt="img"></p><p> @EnableAutoConfiguration作为一个复合Annotation，其自身定义关键信息如下：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 1 @SuppressWarnings(&quot;deprecation&quot;)</span><br><span class="line"> 2 @Target(ElementType.TYPE)</span><br><span class="line"> 3 @Retention(RetentionPolicy.RUNTIME)</span><br><span class="line"> 4 @Documented</span><br><span class="line"> 5 @Inherited</span><br><span class="line"> 6 @AutoConfigurationPackage</span><br><span class="line"> 7 @Import(EnableAutoConfigurationImportSelector.class)</span><br><span class="line"> 8 public @interface EnableAutoConfiguration &#123;</span><br><span class="line"> 9     ...</span><br><span class="line">10 &#125;</span><br></pre></td></tr></table></figure><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>  其中，最关键的要属@Import(EnableAutoConfigurationImportSelector.class)，借助EnableAutoConfigurationImportSelector，@EnableAutoConfiguration可以帮助SpringBoot应用将所有符合条件的@Configuration配置都加载到当前SpringBoot创建并使用的IoC容器。就像一只“八爪鱼”一样，借助于Spring框架原有的一个工具类：SpringFactoriesLoader的支持，@EnableAutoConfiguration可以智能的自动配置功效才得以大功告成！</p><p><img src="https://images2017.cnblogs.com/blog/249993/201712/249993-20171207163759488-1739516792.png" alt="img"></p><p><strong>自动配置幕后英雄：SpringFactoriesLoader详解</strong></p><p>SpringFactoriesLoader属于Spring框架私有的一种扩展方案，其主要功能就是从指定的配置文件META-INF/spring.factories加载配置。</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 1 public abstract class SpringFactoriesLoader &#123;</span><br><span class="line"> 2     &#x2F;&#x2F;...</span><br><span class="line"> 3     public static &lt;T&gt; List&lt;T&gt; loadFactories(Class&lt;T&gt; factoryClass, ClassLoader classLoader) &#123;</span><br><span class="line"> 4         ...</span><br><span class="line"> 5     &#125;</span><br><span class="line"> 6 </span><br><span class="line"> 7 </span><br><span class="line"> 8     public static List&lt;String&gt; loadFactoryNames(Class&lt;?&gt; factoryClass, ClassLoader classLoader) &#123;</span><br><span class="line"> 9         ....</span><br><span class="line">10     &#125;</span><br><span class="line">11 &#125;</span><br></pre></td></tr></table></figure><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>配合@EnableAutoConfiguration使用的话，它更多是提供一种配置查找的功能支持，即根据@EnableAutoConfiguration的完整类名org.springframework.boot.autoconfigure.EnableAutoConfiguration作为查找的Key，获取对应的一组@Configuration类。</p><p><img src="https://images2017.cnblogs.com/blog/249993/201712/249993-20171208161556484-1145877030.jpg" alt="img"></p><p>上图就是从SpringBoot的autoconfigure依赖包中的META-INF/spring.factories配置文件中摘录的一段内容，可以很好地说明问题。</p><p>所以，@EnableAutoConfiguration自动配置的魔法骑士就变成了：<strong>从classpath中搜寻所有的META-INF/spring.factories配置文件，并将其中org.springframework.boot.autoconfigure.EnableutoConfiguration对应的配置项通过反射（Java Refletion）实例化为对应的标注了@Configuration的JavaConfig形式的IoC容器配置类，然后汇总为一个并加载到IoC容器。</strong></p><p><strong>二、深入探索SpringApplication执行流程</strong></p><p>SpringApplication的run方法的实现是我们本次旅程的主要线路，该方法的主要流程大体可以归纳如下：</p><p>1） 如果我们使用的是SpringApplication的静态run方法，那么，这个方法里面首先要创建一个SpringApplication对象实例，然后调用这个创建好的SpringApplication的实例方法。在SpringApplication实例初始化的时候，它会提前做几件事情：</p><ul><li>根据classpath里面是否存在某个特征类（org.springframework.web.context.ConfigurableWebApplicationContext）来决定是否应该创建一个为Web应用使用的ApplicationContext类型。</li><li>使用SpringFactoriesLoader在应用的classpath中查找并加载所有可用的ApplicationContextInitializer。</li><li>使用SpringFactoriesLoader在应用的classpath中查找并加载所有可用的ApplicationListener。</li><li>推断并设置main方法的定义类。</li></ul><p>2） SpringApplication实例初始化完成并且完成设置后，就开始执行run方法的逻辑了，方法执行伊始，首先遍历执行所有通过SpringFactoriesLoader可以查找到并加载的SpringApplicationRunListener。调用它们的started()方法，告诉这些SpringApplicationRunListener，“嘿，SpringBoot应用要开始执行咯！”。</p><p>3） 创建并配置当前Spring Boot应用将要使用的Environment（包括配置要使用的PropertySource以及Profile）。</p><p>4） 遍历调用所有SpringApplicationRunListener的environmentPrepared()的方法，告诉他们：“当前SpringBoot应用使用的Environment准备好了咯！”。</p><p>5） 如果SpringApplication的showBanner属性被设置为true，则打印banner。</p><p>6） 根据用户是否明确设置了applicationContextClass类型以及初始化阶段的推断结果，决定该为当前SpringBoot应用创建什么类型的ApplicationContext并创建完成，然后根据条件决定是否添加ShutdownHook，决定是否使用自定义的BeanNameGenerator，决定是否使用自定义的ResourceLoader，当然，最重要的，将之前准备好的Environment设置给创建好的ApplicationContext使用。</p><p>7） ApplicationContext创建好之后，SpringApplication会再次借助Spring-FactoriesLoader，查找并加载classpath中所有可用的ApplicationContext-Initializer，然后遍历调用这些ApplicationContextInitializer的initialize（applicationContext）方法来对已经创建好的ApplicationContext进行进一步的处理。</p><p>8） 遍历调用所有SpringApplicationRunListener的contextPrepared()方法。</p><p>9） 最核心的一步，将之前通过@EnableAutoConfiguration获取的所有配置以及其他形式的IoC容器配置加载到已经准备完毕的ApplicationContext。</p><p>10） 遍历调用所有SpringApplicationRunListener的contextLoaded()方法。</p><p>11） 调用ApplicationContext的refresh()方法，完成IoC容器可用的最后一道工序。</p><p>12） 查找当前ApplicationContext中是否注册有CommandLineRunner，如果有，则遍历执行它们。</p><p>13） 正常情况下，遍历执行SpringApplicationRunListener的finished()方法、（如果整个过程出现异常，则依然调用所有SpringApplicationRunListener的finished()方法，只不过这种情况下会将异常信息一并传入处理）</p><p>去除事件通知点后，整个流程如下：</p><p><img src="https://images2017.cnblogs.com/blog/249993/201712/249993-20171212151321051-993064506.jpg" alt="img"></p><hr><p>本文以调试一个实际的SpringBoot启动程序为例，参考流程中主要类类图，来分析其启动逻辑和自动化配置原理。</p><p><img src="https://images2017.cnblogs.com/blog/249993/201712/249993-20171213142128051-351399772.png" alt="img"></p><p><strong>总览：</strong>   </p><p>  上图为SpringBoot启动结构图，我们发现启动流程主要分为三个部分，第一部分进行SpringApplication的初始化模块，配置一些基本的环境变量、资源、构造器、监听器，第二部分实现了应用具体的启动方案，包括启动流程的监听模块、加载配置环境模块、及核心的创建上下文环境模块，第三部分是自动化配置模块，该模块作为springboot自动配置核心，在后面的分析中会详细讨论。在下面的启动程序中我们会串联起结构中的主要功能。</p><p><strong>启动：</strong></p><p>   每个SpringBoot程序都有一个主入口，也就是main方法，main里面调用SpringApplication.run()启动整个spring-boot程序，该方法所在类需要使用@SpringBootApplication注解，以及@ImportResource注解(if need)，@SpringBootApplication包括三个注解，功能如下：</p><p>@EnableAutoConfiguration：SpringBoot根据应用所声明的依赖来对Spring框架进行自动配置。</p><p>@SpringBootConfiguration(内部为@Configuration)：被标注的类等于在spring的XML配置文件中(applicationContext.xml)，装配所有bean事务，提供了一个spring的上下文环境。</p><p>@ComponentScan：组件扫描，可自动发现和装配Bean，默认扫描SpringApplication的run方法里的Booter.class所在的包路径下文件，所以最好将该启动类放到根包路径下。</p><p><img src="https://images2017.cnblogs.com/blog/249993/201712/249993-20171213143558363-1466265945.png" alt="img"></p><p><strong>SpringBoot启动类</strong></p><p>首先进入run方法</p><p><img src="https://images2017.cnblogs.com/blog/249993/201712/249993-20171213144051754-1827098906.png" alt="img"></p><p>run方法中去创建了一个SpringApplication实例，在该构造方法内，我们可以发现其调用了一个初始化的initialize方法</p><p><img src="https://images2017.cnblogs.com/blog/249993/201712/249993-20171213144232926-834887500.png" alt="img"></p><p><img src="https://images2017.cnblogs.com/blog/249993/201712/249993-20171213144259160-129693850.png" alt="img"></p><p>这里主要是为SpringApplication对象赋一些初值。构造函数执行完毕后，我们回到run方法</p><p><img src="https://images2017.cnblogs.com/blog/249993/201712/249993-20171213144447066-1033381024.png" alt="img"></p><p>该方法中实现了如下几个关键步骤：</p><p>1.创建了应用的监听器SpringApplicationRunListeners并开始监听</p><p>2.加载SpringBoot配置环境(ConfigurableEnvironment)，如果是通过web容器发布，会加载StandardEnvironment，其最终也是继承了ConfigurableEnvironment，类图如下</p><p><img src="https://images2017.cnblogs.com/blog/249993/201712/249993-20171213144808707-1335729370.png" alt="img"></p><p>可以看出，*Environment最终都实现了PropertyResolver接口，我们平时通过environment对象获取配置文件中指定Key对应的value方法时，就是调用了propertyResolver接口的getProperty方法</p><p>3.配置环境(Environment)加入到监听器对象中(SpringApplicationRunListeners)</p><p>4.创建run方法的返回对象：ConfigurableApplicationContext(应用配置上下文)，我们可以看一下创建方法：</p><p><img src="https://images2017.cnblogs.com/blog/249993/201712/249993-20171213145353394-1416082242.png" alt="img"></p><p>方法会先获取显式设置的应用上下文(applicationContextClass)，如果不存在，再加载默认的环境配置（通过是否是web environment判断），默认选择AnnotationConfigApplicationContext注解上下文（通过扫描所有注解类来加载bean），最后通过BeanUtils实例化上下文对象，并返回。</p><p>ConfigurableApplicationContext类图如下：</p><p><img src="https://images2017.cnblogs.com/blog/249993/201712/249993-20171213154313488-1411301156.png" alt="img"></p><p>主要看其继承的两个方向：</p><p>LifeCycle：生命周期类，定义了start启动、stop结束、isRunning是否运行中等生命周期空值方法</p><p>ApplicationContext：应用上下文类，其主要继承了beanFactory(bean的工厂类)</p><p>5.回到run方法内，prepareContext方法将listeners、environment、applicationArguments、banner等重要组件与上下文对象关联</p><p>6.接下来的refreshContext(context)方法(初始化方法如下)将是实现spring-boot-starter-*(mybatis、redis等)自动化配置的关键，包括spring.factories的加载，bean的实例化等核心工作。</p><p><img src="https://images2017.cnblogs.com/blog/249993/201712/249993-20171213154943754-336827902.png" alt="img"></p><p>   配置结束后，Springboot做了一些基本的收尾工作，返回了应用环境上下文。回顾整体流程，Springboot的启动，主要创建了配置环境(environment)、事件监听(listeners)、应用上下文(applicationContext)，并基于以上条件，在容器中开始实例化我们需要的Bean，至此，通过SpringBoot启动的程序已经构造完成，接下来我们来探讨自动化配置是如何实现。</p><hr><p><strong>自动化配置：</strong></p><p>之前的启动结构图中，我们注意到无论是应用初始化还是具体的执行过程，都调用了SpringBoot自动配置模块。</p><p><img src="https://images2017.cnblogs.com/blog/249993/201712/249993-20171219161544990-1859845219.png" alt="img"></p><p>SpringBoot自动配置模块</p><p>  该配置模块的主要使用到了SpringFactoriesLoader，即Spring工厂加载器，该对象提供了loadFactoryNames方法，入参为factoryClass和classLoader，即需要传入上图中的工厂类名称和对应的类加载器，方法会根据指定的classLoader，加载该类加器搜索路径下的指定文件，即spring.factories文件，传入的工厂类为接口，而文件中对应的类则是接口的实现类，或最终作为实现类，所以文件中一般为如下图这种一对多的类名集合，获取到这些实现类的类名后，loadFactoryNames方法返回类名集合，方法调用方得到这些集合后，再通过反射获取这些类的类对象、构造方法，最终生成实例。</p><p><img src="https://images2017.cnblogs.com/blog/249993/201712/249993-20171219162725615-751500087.png" alt="img"></p><p>工厂接口与其若干实现类接口名称</p><p>下图有助于我们形象理解自动配置流程。</p><p><img src="https://images2017.cnblogs.com/blog/249993/201712/249993-20171219162844787-1104034109.png" alt="img"></p><p>SpringBoot自动化配置关键组件关系图 </p><p>  mybatis-spring-boot-starter、spring-boot-starter-web等组件的META-INF文件下均含有spring.factories文件，自动配置模块中，SpringFactoriesLoader收集到文件中的类全名并返回一个类全名的数组，返回的类全名通过反射被实例化，就形成了具体的工厂实例，工厂实例来生成组件具体需要的bean。</p><p>之前我们提到了EnableAutoConfiguration注解，其类图如下：</p><p><img src="https://images2017.cnblogs.com/blog/249993/201712/249993-20171219163356100-1697141132.png" alt="img"></p><p>可以发现其最终实现了ImportSelector(选择器)和BeanClassLoaderAware(bean类加载器中间件)，重点关注一下AutoConfigurationImportSelector的selectImports方法。</p><p><img src="https://images2017.cnblogs.com/blog/249993/201712/249993-20171219163452318-1362759499.png" alt="img"></p><p>  该方法在springboot启动流程——bean实例化前被执行，返回要实例化的类信息列表。我们知道，如果获取到类信息，spring自然可以通过类加载器将类加载到jvm中，现在我们已经通过spring-boot的starter依赖方式依赖了我们需要的组件，那么这些组建的类信息在select方法中也是可以被获取到的，不要急我们继续向下分析。</p><p><img src="https://images2017.cnblogs.com/blog/249993/201712/249993-20171219164025334-1624354890.png" alt="img"></p><p>该方法中的getCandidateConfigurations方法，通过方法注释了解到，其返回一个自动配置类的类名列表，方法调用了loadFactoryNames方法，查看该方法</p><p><img src="https://images2017.cnblogs.com/blog/249993/201712/249993-20171219164224912-643901744.png" alt="img"></p><p>  在上面的代码可以看到自动配置器会根据传入的factoryClass.getName()到项目系统路径下所有的spring.factories文件中找到相应的key，从而加载里面的类。我们就选取这个mybatis-spring-boot-autoconfigure下的spring.factories文件</p><p><img src="https://images2017.cnblogs.com/blog/249993/201712/249993-20171219164557240-1466961312.png" alt="img"></p><p>进入org.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration中，主要看一下类头：</p><p><img src="https://images2017.cnblogs.com/blog/249993/201712/249993-20171219164818162-646159475.png" alt="img"></p><p>发现Spring的@Configuration，俨然是一个通过注解标注的springBean，继续向下看，</p><p>@ConditionalOnClass({ SqlSessionFactory.class, SqlSessionFactoryBean.class})这个注解的意思是：当存在SqlSessionFactory.class, SqlSessionFactoryBean.class这两个类时才解析MybatisAutoConfiguration配置类，否则不解析这一个配置类，make sence，我们需要mybatis为我们返回会话对象，就必须有会话工厂相关类。</p><p>@CondtionalOnBean(DataSource.class)：只有处理已经被声明为bean的dataSource。</p><p>@ConditionalOnMissingBean(MapperFactoryBean.class)这个注解的意思是如果容器中不存在name指定的bean则创建bean注入，否则不执行（该类源码较长，篇幅限制不全粘贴）</p><p>   以上配置可以保证sqlSessionFactory、sqlSessionTemplate、dataSource等mybatis所需的组件均可被自动配置，@Configuration注解已经提供了Spring的上下文环境，所以以上组件的配置方式与Spring启动时通过mybatis.xml文件进行配置起到一个效果。通过分析我们可以发现，只要一个基于SpringBoot项目的类路径下存在SqlSessionFactory.class, SqlSessionFactoryBean.class，并且容器中已经注册了dataSourceBean，就可以触发自动化配置，意思说我们只要在maven的项目中加入了mybatis所需要的若干依赖，就可以触发自动配置，但引入mybatis原生依赖的话，每集成一个功能都要去修改其自动化配置类，那就得不到开箱即用的效果了。所以Spring-boot为我们提供了统一的starter可以直接配置好相关的类，触发自动配置所需的依赖(mybatis)如下：</p><p><img src="https://images2017.cnblogs.com/blog/249993/201712/249993-20171220160748068-2010633643.png" alt="img"></p><p>这里是截取的mybatis-spring-boot-starter的源码中pom.xml文件中所有依赖：</p><p><img src="https://images2017.cnblogs.com/blog/249993/201712/249993-20171220160934240-319846263.png" alt="img"></p><p> 因为maven依赖的传递性，我们只要依赖starter就可以依赖到所有需要自动配置的类，实现开箱即用的功能。也体现出Springboot简化了Spring框架带来的大量XML配置以及复杂的依赖管理，让开发人员可以更加关注业务逻辑的开发。</p>]]></content>
    
    <summary type="html">
    
      you can &quot;just run&quot;
    
    </summary>
    
    
      <category term="SpringBoot" scheme="https://SomunsTao.github.io/categories/SpringBoot/"/>
    
    
      <category term="SpringBoot" scheme="https://SomunsTao.github.io/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>Vue 13： VUE复习</title>
    <link href="https://somunstao.github.io/2020/04/23/Vue%2013%EF%BC%9A%20VUE%E5%A4%8D%E4%B9%A0/"/>
    <id>https://somunstao.github.io/2020/04/23/Vue%2013%EF%BC%9A%20VUE%E5%A4%8D%E4%B9%A0/</id>
    <published>2020-04-22T16:00:00.000Z</published>
    <updated>2020-08-01T15:19:56.696Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Vue实战"><a href="#Vue实战" class="headerlink" title="Vue实战"></a>Vue实战</h1><h2 id="1-Vue-引言"><a href="#1-Vue-引言" class="headerlink" title="1. Vue 引言"></a>1. Vue 引言</h2><blockquote><p><code>渐进式</code> JavaScript 框架   –摘自官网</p></blockquote><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 渐进式</span></span><br><span class="line"><span class="bullet">   1. </span>易用  html css javascript</span><br><span class="line"><span class="bullet">   2. </span>高效  开发前端页面 非常高效 </span><br><span class="line"><span class="bullet">   3. </span>灵活  开发灵活 多样性</span><br><span class="line"></span><br><span class="line"><span class="section"># 总结</span></span><br><span class="line"><span class="code">Vue 是一个javascript 框架</span></span><br><span class="line"></span><br><span class="line"><span class="section"># 后端服务端开发人员: </span></span><br><span class="line"><span class="code">Vue 渐进式javascript框架: 让我们通过操作很少的DOM,甚至不需要操作页面中任何DOM元素,就很容易的完成数据和视图绑定  双向绑定 MVVM  </span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">注意: 日后在使用Vue过程中页面中不要在引入Jquery框架</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">htmlcss---&gt;javascript -----&gt;jquery----&gt;angularjs -----&gt; Vue</span></span><br><span class="line"> </span><br><span class="line"> # Vue 作者</span><br><span class="line">  尤雨溪   国内的</span><br></pre></td></tr></table></figure><hr><h2 id="2-Vue入门"><a href="#2-Vue入门" class="headerlink" title="2. Vue入门"></a>2. Vue入门</h2><h3 id="2-1-下载Vuejs"><a href="#2-1-下载Vuejs" class="headerlink" title="2.1    下载Vuejs"></a>2.1    下载Vuejs</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//开发版本:</span></span><br><span class="line">&lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt;</span><br><span class="line">&lt;script src=<span class="string">"https://cdn.jsdelivr.net/npm/vue/dist/vue.js"</span>&gt;&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/生产版本:</span></span><br><span class="line"><span class="regexp">&lt;!-- 生产环境版本，优化了尺寸和速度 --&gt;</span></span><br><span class="line"><span class="regexp">&lt;script src="https:/</span><span class="regexp">/cdn.jsdelivr.net/</span>npm/vue<span class="string">"&gt;&lt;/script&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-2-Vue第一个入门应用"><a href="#2-2-Vue第一个入门应用" class="headerlink" title="2.2 Vue第一个入门应用"></a>2.2 Vue第一个入门应用</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">       &#123;&#123; msg &#125;&#125;  &#123;&#123;username&#125;&#125; &#123;&#123;pwd&#125;&#125;</span><br><span class="line"></span><br><span class="line">       <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">span</span>&gt;</span></span><br><span class="line">           &#123;&#123; username &#125;&#125;</span><br><span class="line">           <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123; msg &#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!--引入vue.js--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/vue/dist/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">       <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">           el:<span class="string">"#app"</span>,  <span class="comment">//element 用来给Vue实例定义一个作用范围</span></span></span><br><span class="line"><span class="actionscript">           data:&#123;      <span class="comment">//用来给Vue实例定义一些相关数据</span></span></span><br><span class="line"><span class="actionscript">               msg:<span class="string">"百知欢迎你,期待你的加入!"</span>,</span></span><br><span class="line"><span class="actionscript">               username:<span class="string">"hello Vue!"</span>,</span></span><br><span class="line"><span class="actionscript">               pwd :<span class="string">"12345"</span>,</span></span><br><span class="line">           &#125;,</span><br><span class="line">       &#125;);</span><br><span class="line">   <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 总结:</span></span><br><span class="line"><span class="code">1.vue实例(对象)中el属性: 代表Vue的作用范围  日后在Vue的作用范围内都可以使用Vue的语法</span></span><br><span class="line"><span class="code">2.vue实例(对象)中data属性: 用来给Vue实例绑定一些相关数据, 绑定的数据可以通过&#123;&#123;变量名&#125;&#125;在Vue作用范围内取出</span></span><br><span class="line"><span class="code">3.在使用&#123;&#123;&#125;&#125;进行获取data中数据时,可以在&#123;&#123;&#125;&#125;中书写表达式,运算符,调用相关方法,以及逻辑运算等</span></span><br><span class="line"><span class="code">4.el属性中可以书写任意的CSS选择器[jquery选择器],但是在使用Vue开发是推荐使用 id选择器</span></span><br></pre></td></tr></table></figure><hr><h2 id="3-v-text和v-html"><a href="#3-v-text和v-html" class="headerlink" title="3. v-text和v-html"></a>3. v-text和v-html</h2><h3 id="3-1-v-text"><a href="#3-1-v-text" class="headerlink" title="3.1 v-text"></a>3.1 v-text</h3><blockquote><p><code>v-text</code>:用来获取data中数据将数据以文本的形式渲染到指定标签内部             类似于javascript 中 innerText</p></blockquote><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span> <span class="attr">class</span>=<span class="string">"aa"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span> &gt;</span>&#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-text</span>=<span class="string">"message"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--引入vue.js--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/vue/dist/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">      <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">          el:<span class="string">"#app"</span>,</span></span><br><span class="line">          data:&#123;</span><br><span class="line"><span class="actionscript">              message:<span class="string">"百知欢迎您"</span></span></span><br><span class="line">          &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 总结</span></span><br><span class="line"><span class="code">1.&#123;&#123;&#125;&#125;(插值表达式)和v-text获取数据的区别在于 </span></span><br><span class="line"><span class="code">a.使用v-text取值会将标签中原有的数据覆盖 使用插值表达式的形式不会覆盖标签原有的数据</span></span><br><span class="line"><span class="code">b.使用v-text可以避免在网络环境较差的情况下出现插值闪烁</span></span><br></pre></td></tr></table></figure><h3 id="3-2-v-html"><a href="#3-2-v-html" class="headerlink" title="3.2 v-html"></a>3.2 v-html</h3><blockquote><p><code>v-html</code>:用来获取data中数据将数据中含有的html标签先解析在渲染到指定标签的内部  类似于javascript中 innerHTML</p></blockquote><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span> <span class="attr">class</span>=<span class="string">"aa"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-text</span>=<span class="string">"message"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-html</span>=<span class="string">"message"</span>&gt;</span>xxxxxx<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--引入vue.js--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/vue/dist/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">            el:<span class="string">"#app"</span>,</span></span><br><span class="line">            data:&#123;</span><br><span class="line"><span class="handlebars"><span class="xml">                message:"<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">''</span>&gt;</span>百知欢迎您<span class="tag">&lt;/<span class="name">a</span>&gt;</span>"</span></span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h2 id="4-vue中事件绑定-v-on"><a href="#4-vue中事件绑定-v-on" class="headerlink" title="4.vue中事件绑定(v-on)"></a>4.vue中事件绑定(v-on)</h2><h3 id="4-1-绑定事件基本语法"><a href="#4-1-绑定事件基本语法" class="headerlink" title="4.1 绑定事件基本语法"></a>4.1 绑定事件基本语法</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h2</span> <span class="attr">v-text</span>=<span class="string">"message"</span>&gt;</span><span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h2</span>&gt;</span>年龄:&#123;&#123; age &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"点我改变年龄"</span> <span class="attr">v-on:click</span>=<span class="string">"changeage"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--引入vue.js--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/vue/dist/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">      <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">          el:<span class="string">"#app"</span>,</span></span><br><span class="line">          data:&#123;</span><br><span class="line"><span class="actionscript">              message:<span class="string">"hello 欢迎来到百知课堂!"</span>,</span></span><br><span class="line">              age:23,</span><br><span class="line">          &#125;,</span><br><span class="line"><span class="actionscript">          methods:&#123;  <span class="comment">//methods 用来定义vue中时间</span></span></span><br><span class="line"><span class="actionscript">              changeage:<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="actionscript">                  alert(<span class="string">'点击触发'</span>);</span></span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 总结:</span></span><br><span class="line"><span class="code">事件  事件源:发生事件dom元素  事件: 发生特定的动作  click....  监听器  发生特定动作之后的事件处理程序 通常是js中函数</span></span><br><span class="line"><span class="code">1.在vue中绑定事件是通过v-on指令来完成的 v-on:事件名 如  v-on:click</span></span><br><span class="line"><span class="code">2.在v-on:事件名的赋值语句中是当前时间触发调用的函数名</span></span><br><span class="line"><span class="code">3.在vue中事件的函数统一定义在Vue实例的methods属性中</span></span><br><span class="line"><span class="code">4.在vue定义的事件中this指的就是当前的Vue实例,日后可以在事件中通过使用this获取Vue实例中相关数据</span></span><br></pre></td></tr></table></figure><h3 id="4-2-Vue中事件的简化语法"><a href="#4-2-Vue中事件的简化语法" class="headerlink" title="4.2 Vue中事件的简化语法"></a>4.2 Vue中事件的简化语法</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123; age &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"通过v-on事件修改年龄每次+1"</span> <span class="attr">v-on:click</span>=<span class="string">"changeage"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"通过@绑定时间修改年龄每次-1"</span> @<span class="attr">click</span>=<span class="string">"editage"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--引入vue.js--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/vue/dist/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">      <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">         el:<span class="string">"#app"</span>,  <span class="comment">//element: 用来指定vue作用范围</span></span></span><br><span class="line">         data:&#123;</span><br><span class="line">             age:23,</span><br><span class="line"><span class="actionscript">         &#125;,    <span class="comment">//data   : 用来定义vue实例中相关数据</span></span></span><br><span class="line">         methods:&#123;</span><br><span class="line"><span class="actionscript">             changeage:<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="actionscript">                 <span class="keyword">this</span>.age++;</span></span><br><span class="line">             &#125;,</span><br><span class="line"><span class="actionscript">             editage:<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="actionscript">                 <span class="keyword">this</span>.age--;</span></span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line"><span class="actionscript">         &#125;  <span class="comment">//methods: 用来定义事件的处理函数</span></span></span><br><span class="line">      &#125;);</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 总结:</span></span><br><span class="line"><span class="code">1.日后在vue中绑定事件时可以通过@符号形式 简化  v-on 的事件绑定</span></span><br></pre></td></tr></table></figure><h3 id="4-3-Vue事件函数两种写法"><a href="#4-3-Vue事件函数两种写法" class="headerlink" title="4.3 Vue事件函数两种写法"></a>4.3 Vue事件函数两种写法</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123;count&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"改变count的值"</span> @<span class="attr">click</span>=<span class="string">"changecount"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--引入vue.js--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/vue/dist/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">      <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">         el:<span class="string">"#app"</span>,</span></span><br><span class="line">         data:&#123;</span><br><span class="line">             count:1,</span><br><span class="line">         &#125;,</span><br><span class="line">         methods:&#123;</span><br><span class="line">             /*changecount:function()&#123;</span><br><span class="line"><span class="actionscript">                 <span class="keyword">this</span>.count++;</span></span><br><span class="line">             &#125;*/</span><br><span class="line">             changecount()&#123;</span><br><span class="line"><span class="actionscript">                 <span class="keyword">this</span>.count++;</span></span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 总结:</span></span><br><span class="line"><span class="code">1.在Vue中事件定义存在两种写法  一种是 函数名:function()&#123;&#125;  推荐    一种是  函数名()&#123;&#125; 推荐</span></span><br></pre></td></tr></table></figure><h3 id="4-4-Vue事件参数传递"><a href="#4-4-Vue事件参数传递" class="headerlink" title="4.4 Vue事件参数传递"></a>4.4 Vue事件参数传递</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123;count&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"改变count为指定的值"</span> @<span class="attr">click</span>=<span class="string">"changecount(23,'xiaohei')"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--引入vue.js--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/vue/dist/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">      <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">         el:<span class="string">"#app"</span>,</span></span><br><span class="line">         data:&#123;</span><br><span class="line">             count:1,</span><br><span class="line">         &#125;,</span><br><span class="line">         methods:&#123;</span><br><span class="line"><span class="actionscript">             <span class="comment">//定义changecount</span></span></span><br><span class="line">             changecount(count,name)&#123;</span><br><span class="line"><span class="actionscript">                 <span class="keyword">this</span>.count = count;</span></span><br><span class="line">                 alert(name);</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">         &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 总结:</span></span><br><span class="line"><span class="code">1.在使用事件时,可以直接在事件调用出给事件进行参数传递,在事件定义出通过定义对应变量接收传递的参数</span></span><br></pre></td></tr></table></figure><hr><h2 id="5-v-show-v-if-v-bind"><a href="#5-v-show-v-if-v-bind" class="headerlink" title="5.v-show v-if v-bind"></a>5.v-show v-if v-bind</h2><h3 id="5-1-v-show"><a href="#5-1-v-show" class="headerlink" title="5.1 v-show"></a>5.1 v-show</h3><blockquote><p><code>v-show</code>:用来控制页面中某个标签元素是否展示        底层使用控制是 display 属性</p></blockquote><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        v-show: 用来控制标签展示还是隐藏的</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span> <span class="attr">v-show</span>=<span class="string">"false"</span>&gt;</span>百知教育欢迎你的加入!<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span> <span class="attr">v-show</span>=<span class="string">"show"</span>&gt;</span>百知教育欢迎你的加入这是vue中定义变量true!<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"展示隐藏标签"</span> @<span class="attr">click</span>=<span class="string">"showmsg"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--引入vue.js--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/vue/dist/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">        el:<span class="string">"#app"</span>,</span></span><br><span class="line">        data:&#123;</span><br><span class="line"><span class="actionscript">            show:<span class="literal">false</span>,</span></span><br><span class="line">        &#125;,</span><br><span class="line">        methods:&#123;</span><br><span class="line"><span class="actionscript">            <span class="comment">//定义时间</span></span></span><br><span class="line">            showmsg()&#123;</span><br><span class="line"><span class="actionscript">               <span class="keyword">this</span>.show =  !<span class="keyword">this</span>.show;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 总结</span></span><br><span class="line"><span class="code">1.在使用v-show时可以直接书写boolean值控制元素展示,也可以通过变量控制标签展示和隐藏</span></span><br><span class="line"><span class="code">2.在v-show中可以通过boolean表达式控制标签的展示课隐藏</span></span><br></pre></td></tr></table></figure><h3 id="5-2-v-if"><a href="#5-2-v-if" class="headerlink" title="5.2 v-if"></a>5.2 v-if</h3><blockquote><p><code>v-if</code>: 用来控制页面元素是否展示                底层控制是DOM元素    操作DOM</p></blockquote><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span> <span class="attr">v-if</span>=<span class="string">"false"</span>&gt;</span>百知教育<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span> <span class="attr">v-if</span>=<span class="string">"show"</span>&gt;</span>百知教育欢迎你的加入<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--引入vue.js--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/vue/dist/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">        el:<span class="string">"#app"</span>,</span></span><br><span class="line">        data:&#123;</span><br><span class="line"><span class="actionscript">            show:<span class="literal">false</span></span></span><br><span class="line">        &#125;,</span><br><span class="line">        methods:&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="5-3-v-bind"><a href="#5-3-v-bind" class="headerlink" title="5.3 v-bind"></a>5.3 v-bind</h3><blockquote><p><code>v-bind</code>: 用来绑定标签的属性从而通过vue动态修改标签的属性</p></blockquote><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">width</span>=<span class="string">"300"</span> <span class="attr">v-bind:title</span>=<span class="string">"msg"</span> <span class="attr">v-bind:class</span>=<span class="string">"&#123;aa:showCss&#125;"</span>  <span class="attr">src</span>=<span class="string">"baizhilogo.jpg"</span> <span class="attr">alt</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--引入vue.js--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/vue/dist/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">        el:<span class="string">"#app"</span>,</span></span><br><span class="line">        data:&#123;</span><br><span class="line"><span class="actionscript">            msg:<span class="string">"百知教育官方logo!!!!"</span>,</span></span><br><span class="line"><span class="actionscript">            showCss:<span class="literal">true</span>,</span></span><br><span class="line">        &#125;,</span><br><span class="line">        methods:&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="5-4-v-bind-简化写法"><a href="#5-4-v-bind-简化写法" class="headerlink" title="5.4 v-bind 简化写法"></a>5.4 v-bind 简化写法</h3><blockquote><p>​    vue为了方便我们日后绑定标签的属性提供了对属性绑定的简化写法如 <code>v-bind:属性名</code> 简化之后 <code>:属性名</code></p></blockquote><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">width</span>=<span class="string">"300"</span> <span class="attr">:title</span>=<span class="string">"msg"</span> <span class="attr">:class</span>=<span class="string">"&#123;aa:showCss&#125;"</span>  <span class="attr">:src</span>=<span class="string">"src"</span> <span class="attr">alt</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"动态控制加入样式"</span> @<span class="attr">click</span>=<span class="string">"addCss"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"改变图片"</span> @<span class="attr">click</span>=<span class="string">"changeSrc"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--引入vue.js--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/vue/dist/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">        el:<span class="string">"#app"</span>,</span></span><br><span class="line">        data:&#123;</span><br><span class="line"><span class="actionscript">            msg:<span class="string">"百知教育官方logo!!!!"</span>,</span></span><br><span class="line"><span class="actionscript">            showCss:<span class="literal">true</span>,</span></span><br><span class="line"><span class="actionscript">            src:<span class="string">"https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1583490365568&amp;di=52a82bd614cd4030f97ada9441bb2d0e&amp;imgtype=0&amp;src=http%3A%2F%2Fimg.kanzhun.com%2Fimages%2Flogo%2F20160714%2F820a68f65b4e4a3634085055779c000c.jpg"</span></span></span><br><span class="line">        &#125;,</span><br><span class="line">        methods:&#123;</span><br><span class="line">            addCss()&#123;</span><br><span class="line"><span class="actionscript">                <span class="keyword">this</span>.showCss= !<span class="keyword">this</span>.showCss;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            changeSrc()&#123;</span><br><span class="line"><span class="actionscript">                <span class="keyword">this</span>.src = <span class="string">"https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=1925088662,1336364220&amp;fm=26&amp;gp=0.jpg"</span>;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h2 id="6-v-for的使用"><a href="#6-v-for的使用" class="headerlink" title="6.v-for的使用"></a>6.v-for的使用</h2><blockquote><p><code>v-for</code>: 作用就是用来对对象进行遍历的(数组也是对象的一种)</p></blockquote><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123; user.name &#125;&#125; &#123;&#123; user.age &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">       通过v-for遍历对象</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-for</span>=<span class="string">"(value,key,index) in user"</span>&gt;</span></span><br><span class="line">        &#123;&#123;index&#125;&#125; : &#123;&#123;key&#125;&#125; : &#123;&#123;value&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        通过v-for遍历数组</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"a,index in arr"</span> &gt;</span></span><br><span class="line">            &#123;&#123;index&#125;&#125; &#123;&#123;a&#125;&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        通过v-for遍历数组中对象</span></span><br><span class="line"><span class="comment">        :key 便于vue内部做重用和排序</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"user,index in users"</span> <span class="attr">:key</span>=<span class="string">"user.id"</span>&gt;</span></span><br><span class="line">            &#123;&#123;index+1&#125;&#125; &#123;&#123; user.name &#125;&#125;  === &#123;&#123; user.age &#125;&#125; ==== &#123;&#123; user.content &#125;&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--引入vue--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/vue/dist/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">        el: <span class="string">"#app"</span>,</span></span><br><span class="line">        data: &#123;</span><br><span class="line"><span class="actionscript">            user:&#123;name:<span class="string">"小陈"</span>,age:<span class="number">23</span>&#125;,</span></span><br><span class="line"><span class="actionscript">            arr:[<span class="string">"北京校区"</span>, <span class="string">"天津校区"</span>, <span class="string">"河南校区"</span>],</span></span><br><span class="line">            users:[</span><br><span class="line"><span class="actionscript">                &#123;id:<span class="string">"1"</span>,name:<span class="string">"xiaochen"</span>,age:<span class="number">23</span>,content:<span class="string">"我曾经也是一个单纯的少年!"</span>&#125;,</span></span><br><span class="line"><span class="actionscript">                &#123;id:<span class="string">"2"</span>,name:<span class="string">"小白"</span>,age:<span class="number">23</span>,content:<span class="string">"我曾经是一个邪恶的少年!"</span>&#125;,</span></span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;&#125;</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 总结</span></span><br><span class="line"><span class="code">1.在使用v-for的时候一定要注意加入:key 用来给vue内部提供重用和排序的唯一key</span></span><br></pre></td></tr></table></figure><hr><h2 id="7-v-model-双向绑定"><a href="#7-v-model-双向绑定" class="headerlink" title="7 .v-model 双向绑定"></a>7 .v-model 双向绑定</h2><blockquote><p><code>v-model</code>: 作用用来绑定标签元素的值与vue实例对象中data数据保持一致,从而实现双向的数据绑定机制</p></blockquote><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model</span>=<span class="string">"message"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"改变Data中值"</span> @<span class="attr">click</span>=<span class="string">"changeValue"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--引入vue--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/vue/dist/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">        el: <span class="string">"#app"</span>,</span></span><br><span class="line">        data: &#123;</span><br><span class="line"><span class="actionscript">            message:<span class="string">""</span></span></span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line">            changeValue()&#123;</span><br><span class="line"><span class="actionscript">                <span class="keyword">this</span>.message=<span class="string">'百知教育!'</span>;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 总结</span></span><br><span class="line"><span class="code">1.使用v-model指令可以实现数据的双向绑定 </span></span><br><span class="line"><span class="code">2.所谓双向绑定 表单中数据变化导致vue实例data数据变化   vue实例中data数据的变化导致表单中数据变化 称之为双向绑定</span></span><br><span class="line"></span><br><span class="line"><span class="section"># MVVM架构  双向绑定机制</span></span><br><span class="line"><span class="code">Model: 数据  Vue实例中绑定数据</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">VM:   ViewModel  监听器</span></span><br><span class="line"></span><br><span class="line"><span class="code">View:  页面  页面展示的数据</span></span><br></pre></td></tr></table></figure><hr><h2 id="8-事件修饰符"><a href="#8-事件修饰符" class="headerlink" title="8. 事件修饰符"></a>8. 事件修饰符</h2><blockquote><p><code>修饰符</code>: 作用用来和事件连用,用来决定事件触发条件或者是阻止事件的触发机制</p></blockquote><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.常用的事件修饰符</span></span><br><span class="line"><span class="code">.stop</span></span><br><span class="line"><span class="code">.prevent</span></span><br><span class="line"><span class="code">.capture</span></span><br><span class="line"><span class="code">.self</span></span><br><span class="line"><span class="code">.once</span></span><br><span class="line"><span class="code">.passive</span></span><br></pre></td></tr></table></figure><h3 id="8-1-stop事件修饰符"><a href="#8-1-stop事件修饰符" class="headerlink" title="8.1 stop事件修饰符"></a>8.1 stop事件修饰符</h3><blockquote><p>用来阻止事件冒泡</p></blockquote><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"aa"</span> @<span class="attr">click</span>=<span class="string">"divClick"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--用来阻止事件冒泡--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"按钮"</span> @<span class="attr">click.stop</span>=<span class="string">"btnClick"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--引入vue--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/vue/dist/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">        el: <span class="string">"#app"</span>,</span></span><br><span class="line">        data: &#123;&#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line">            btnClick()&#123;</span><br><span class="line"><span class="actionscript">                alert(<span class="string">'button被点击了'</span>);</span></span><br><span class="line">            &#125;,</span><br><span class="line">            divClick()&#123;</span><br><span class="line"><span class="actionscript">                alert(<span class="string">'div被点击了'</span>);</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="8-2-prevent-事件修饰符"><a href="#8-2-prevent-事件修饰符" class="headerlink" title="8.2 prevent 事件修饰符"></a>8.2 prevent 事件修饰符</h3><blockquote><p>用来阻止标签的默认行为</p></blockquote><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--用来阻止事件的默认行为--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://www.baizhibest.com/"</span> @<span class="attr">click.prevent</span>=<span class="string">"aClick"</span>&gt;</span>百知教育<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="8-3-self-事件修饰符"><a href="#8-3-self-事件修饰符" class="headerlink" title="8.3 self 事件修饰符"></a>8.3 self 事件修饰符</h3><blockquote><p>用来针对于当前标签的事件触发     ===========&gt; 只触发自己标签的上特定动作的事件     只关心自己标签上触发的事件 不监听事件冒泡</p></blockquote><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--只触发标签自身的事件--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"aa"</span> @<span class="attr">click.self</span>=<span class="string">"divClick"</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--用来阻止事件冒泡--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"按钮"</span> @<span class="attr">click.stop</span>=<span class="string">"btnClick"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"按钮1"</span> @<span class="attr">click</span>=<span class="string">"btnClick1"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="8-4-once-事件修饰符"><a href="#8-4-once-事件修饰符" class="headerlink" title="8.4 once 事件修饰符"></a>8.4 once 事件修饰符</h3><blockquote><p>once 一次 作用:  就是让指定事件只触发一次</p></blockquote><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">.prevent : 用来阻止事件的默认行为</span></span><br><span class="line"><span class="comment">.once    : 用来只执行一次特定的事件</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://www.baizhibest.com/"</span> @<span class="attr">click.prevent.once</span>=<span class="string">"aClick"</span>&gt;</span>百知教育<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h2 id="9-按键修饰符"><a href="#9-按键修饰符" class="headerlink" title="9. 按键修饰符"></a>9. 按键修饰符</h2><blockquote><p>作用: 用来与键盘中按键事件绑定在一起,用来修饰特定的按键事件的修饰符</p></blockquote><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 按键修饰符</span></span><br><span class="line"><span class="code">.enter</span></span><br><span class="line"><span class="code">.tab</span></span><br><span class="line"><span class="code">.delete (捕获“删除”和“退格”键)</span></span><br><span class="line"><span class="code">.esc</span></span><br><span class="line"><span class="code">.space</span></span><br><span class="line"><span class="code">.up</span></span><br><span class="line"><span class="code">.down</span></span><br><span class="line"><span class="code">.left</span></span><br><span class="line"><span class="code">.right</span></span><br></pre></td></tr></table></figure><h3 id="9-1-enter-回车键"><a href="#9-1-enter-回车键" class="headerlink" title="9.1 enter 回车键"></a>9.1 enter 回车键</h3><blockquote><p>用来在触发回车按键之后触发的事件</p></blockquote><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model</span>=<span class="string">"msg"</span> @<span class="attr">keyup.enter</span>=<span class="string">"keyups"</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="9-2-tab-键"><a href="#9-2-tab-键" class="headerlink" title="9.2 tab 键"></a>9.2 tab 键</h3><blockquote><p>用来捕获到tab键执行到当前标签是才会触发</p></blockquote><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> @<span class="attr">keyup.tab</span>=<span class="string">"keytabs"</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h2 id="10-Axios-基本使用"><a href="#10-Axios-基本使用" class="headerlink" title="10. Axios 基本使用"></a>10. Axios 基本使用</h2><h3 id="10-1-引言"><a href="#10-1-引言" class="headerlink" title="10.1 引言"></a>10.1 引言</h3><blockquote><p><code>Axios</code> 是一个异步请求技术,核心作用就是用来在页面中发送异步请求,并获取对应数据在页面中渲染       页面局部更新技术  Ajax</p></blockquote><h3 id="10-2-Axios-第一个程序"><a href="#10-2-Axios-第一个程序" class="headerlink" title="10.2 Axios 第一个程序"></a>10.2 Axios 第一个程序</h3><p>中文网站:<a href="https://www.kancloud.cn/yunye/axios/234845" target="_blank" rel="noopener">https://www.kancloud.cn/yunye/axios/234845</a></p><p>安装: <a href="https://unpkg.com/axios/dist/axios.min.js" target="_blank" rel="noopener">https://unpkg.com/axios/dist/axios.min.js</a></p><h4 id="10-2-1-GET方式的请求"><a href="#10-2-1-GET方式的请求" class="headerlink" title="10.2.1 GET方式的请求"></a>10.2.1 GET方式的请求</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//发送GET方式请求</span></span><br><span class="line"> axios.get(<span class="string">"http://localhost:8989/user/findAll?name=xiaochen"</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>)</span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(response.data);</span><br><span class="line"> &#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(err);</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure><h4 id="10-2-2-POST方式请求"><a href="#10-2-2-POST方式请求" class="headerlink" title="10.2.2 POST方式请求"></a>10.2.2 POST方式请求</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//发送POST方式请求</span></span><br><span class="line">  axios.post(<span class="string">"http://localhost:8989/user/save"</span>,&#123;</span><br><span class="line">      username:<span class="string">"xiaochen"</span>,</span><br><span class="line">      age:<span class="number">23</span>,</span><br><span class="line">      email:<span class="string">"xiaochen@zparkhr.com"</span>,</span><br><span class="line">      phone:<span class="number">13260426185</span></span><br><span class="line">  &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>)</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(response.data);</span><br><span class="line">  &#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><h4 id="10-2-3-axios并发请求"><a href="#10-2-3-axios并发请求" class="headerlink" title="10.2.3 axios并发请求"></a>10.2.3 axios并发请求</h4><blockquote><p><code>并发请求</code>:  将多个请求在同一时刻发送到后端服务接口,最后在集中处理每个请求的响应结果</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.创建一个查询所有请求</span></span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">findAll</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> axios.get(<span class="string">"http://localhost:8989/user/findAll?name=xiaochen"</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//2.创建一个保存的请求</span></span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">save</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> axios.post(<span class="string">"http://localhost:8989/user/save"</span>,&#123;</span><br><span class="line">           username:<span class="string">"xiaochen"</span>,</span><br><span class="line">           age:<span class="number">23</span>,</span><br><span class="line">           email:<span class="string">"xiaochen@zparkhr.com"</span>,</span><br><span class="line">           phone:<span class="number">13260426185</span></span><br><span class="line">       &#125;);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//3.并发执行</span></span><br><span class="line">   axios.all([findAll(),save()]).then(</span><br><span class="line">       axios.spread(<span class="function"><span class="keyword">function</span>(<span class="params">res1,res2</span>)</span>&#123;  <span class="comment">//用来将一组函数的响应结果汇总处理</span></span><br><span class="line">           <span class="built_in">console</span>.log(res1.data);</span><br><span class="line">           <span class="built_in">console</span>.log(res2.data);</span><br><span class="line">       &#125;)</span><br><span class="line">   );<span class="comment">//用来发送一组并发请求</span></span><br></pre></td></tr></table></figure><hr><h2 id="11-Vue-生命周期"><a href="#11-Vue-生命周期" class="headerlink" title="11. Vue 生命周期"></a>11. Vue 生命周期</h2><blockquote><p><code>生命周期钩子</code>   ====&gt;  <code>生命周期函数</code></p></blockquote><p>![img](C:/Users/ASUS/Desktop/ vue资料/Vue实战笔记完整版/Vue实战.assets/lifecycle.png)</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># Vue生命周期总结</span></span><br><span class="line"><span class="code">1.初始化阶段</span></span><br><span class="line"><span class="code">beforeCreate()&#123; //1.生命周期中第一个函数,该函数在执行时Vue实例仅仅完成了自身事件的绑定和生命周期函数的初始化工作,Vue实例中还没有 Data el methods相关属性</span></span><br><span class="line"><span class="code">            console.log("beforeCreate: "+this.msg);</span></span><br><span class="line"><span class="code">        &#125;,</span></span><br><span class="line"><span class="code">        created()&#123; //2.生命周期中第二个函数,该函数在执行时Vue实例已经初始化了data属性和methods中相关方法</span></span><br><span class="line"><span class="code">            console.log("created: "+this.msg);</span></span><br><span class="line"><span class="code">        &#125;,</span></span><br><span class="line"><span class="code">        beforeMount()&#123;//3.生命周期中第三个函数,该函数在执行时Vue将El中指定作用范围作为模板编译</span></span><br><span class="line"><span class="code">            console.log("beforeMount: "+document.getElementById("sp").innerText);</span></span><br><span class="line"><span class="code">        &#125;,</span></span><br><span class="line"><span class="code">        mounted()&#123;//4.生命周期中第四个函数,该函数在执行过程中,已经将数据渲染到界面中并且已经更新页面</span></span><br><span class="line"><span class="code">            console.log("Mounted: "+document.getElementById("sp").innerText);</span></span><br><span class="line"><span class="code">        &#125;</span></span><br><span class="line"><span class="code">        </span></span><br><span class="line"><span class="code">2.运行阶段</span></span><br><span class="line"><span class="code"> beforeUpdate()&#123;//5.生命周期中第五个函数,该函数是data中数据发生变化时执行 这个事件执行时仅仅是Vue实例中data数据变化页面显示的依然是原始数据</span></span><br><span class="line"><span class="code">            console.log("beforeUpdate:"+this.msg);</span></span><br><span class="line"><span class="code">            console.log("beforeUpdate:"+document.getElementById("sp").innerText);</span></span><br><span class="line"><span class="code">        &#125;,</span></span><br><span class="line"><span class="code">        updated()&#123;    //6.生命周期中第六个函数,该函数执行时data中数据发生变化,页面中数据也发生了变化  页面中数据已经和data中数据一致</span></span><br><span class="line"><span class="code">            console.log("updated:"+this.msg);</span></span><br><span class="line"><span class="code">            console.log("updated:"+document.getElementById("sp").innerText);</span></span><br><span class="line"><span class="code">        &#125;,</span></span><br><span class="line"><span class="code">        </span></span><br><span class="line"><span class="code">3.销毁阶段</span></span><br><span class="line"><span class="code"> beforeDestory()&#123;//7.生命周期第七个函数,该函数执行时,Vue中所有数据 methods componet 都没销毁</span></span><br><span class="line"></span><br><span class="line"><span class="code">        &#125;,</span></span><br><span class="line"><span class="code">        destoryed()&#123; //8.生命周期的第八个函数,该函数执行时,Vue实例彻底销毁</span></span><br><span class="line"></span><br><span class="line"><span class="code">        &#125;</span></span><br></pre></td></tr></table></figure><hr><h2 id="12-Vue中组件-Component"><a href="#12-Vue中组件-Component" class="headerlink" title="12. Vue中组件(Component)"></a>12. Vue中组件(Component)</h2><h3 id="12-1-组件作用"><a href="#12-1-组件作用" class="headerlink" title="12.1 组件作用"></a>12.1 组件作用</h3><p>组件作用: 用来减少Vue实例对象中代码量,日后在使用Vue开发过程中,可以根据 不能业务功能将页面中划分不同的多个组件,然后由多个组件去完成整个页面的布局,便于日后使用Vue进行开发时页面管理,方便开发人员维护。</p><h3 id="12-2-组件使用"><a href="#12-2-组件使用" class="headerlink" title="12.2 组件使用"></a>12.2 组件使用</h3><h4 id="12-2-1-全局组件注册"><a href="#12-2-1-全局组件注册" class="headerlink" title="12.2.1 全局组件注册"></a>12.2.1 全局组件注册</h4><p><code>说明:全局组件注册给Vue实例,日后可以在任意Vue实例的范围内使用该组件</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.开发全局组件</span></span><br><span class="line">Vue.component(<span class="string">'login'</span>,&#123;</span><br><span class="line">        template:<span class="string">'&lt;div&gt;&lt;h1&gt;用户登录&lt;/h1&gt;&lt;/div&gt;'</span></span><br><span class="line">    &#125;);</span><br><span class="line"><span class="comment">//2.使用全局组件  在Vue实例范围内</span></span><br><span class="line">&lt;login&gt;&lt;<span class="regexp">/login&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 注意:</span></span><br><span class="line"><span class="code">1.Vue.component用来开发全局组件 参数1: 组件的名称  参数2: 组件配置&#123;&#125;  template:''用来书写组件的html代码  template中必须有且只有一个root元素</span></span><br><span class="line"><span class="code">2.使用时需要在Vue的作用范围内根据组件名使用全局组件</span></span><br><span class="line"><span class="code">3.如果在注册组件过程中使用 驼峰命名组件的方式 在使用组件时 必须将驼峰的所有单词小写加入-线进行使用</span></span><br></pre></td></tr></table></figure><h4 id="12-2-2-局部组件注册"><a href="#12-2-2-局部组件注册" class="headerlink" title="12.2.2 局部组件注册"></a>12.2.2 局部组件注册</h4><p><code>说明:通过将组件注册给对应Vue实例中一个components属性来完成组件注册,这种方式不会对Vue实例造成累加</code></p><ul><li>第一种开发方式</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//局部组件登录模板声明</span></span><br><span class="line">  <span class="keyword">let</span> login =&#123;   <span class="comment">//具体局部组件名称</span></span><br><span class="line">      template:<span class="string">'&lt;div&gt;&lt;h2&gt;用户登录&lt;/h2&gt;&lt;/div&gt;'</span></span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">      el: <span class="string">"#app"</span>,</span><br><span class="line">      data: &#123;&#125;,</span><br><span class="line">      methods: &#123;&#125;,</span><br><span class="line">      components:&#123;  <span class="comment">//用来注册局部组件</span></span><br><span class="line">          login:login  <span class="comment">//注册局部组件</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//局部组件使用 在Vue实例范围内</span></span><br><span class="line">&lt;login&gt;&lt;<span class="regexp">/login&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>第二种开发方式</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.声明局部组件模板  template 标签 注意:在Vue实例作用范围外声明</span></span><br><span class="line">  &lt;template id=<span class="string">"loginTemplate"</span>&gt;</span><br><span class="line">      &lt;h1&gt;用户登录&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>template&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.定义变量用来保存模板配置对象</span></span><br><span class="line">    <span class="keyword">let</span> login =&#123;   <span class="comment">//具体局部组件名称</span></span><br><span class="line">        template:<span class="string">'#loginTemplate'</span>  <span class="comment">//使用自定义template标签选择器即可</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.注册组件</span></span><br><span class="line">    <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">        el: <span class="string">"#app"</span>,</span><br><span class="line">        data: &#123;&#125;,</span><br><span class="line">        methods: &#123;&#125;,</span><br><span class="line">        components:&#123;  <span class="comment">//用来注册局部组件</span></span><br><span class="line">            login:login  <span class="comment">//注册局部组件</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"> <span class="comment">//4.局部组件使用 在Vue实例范围内</span></span><br><span class="line"> &lt;login&gt;&lt;<span class="regexp">/login&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="12-3-Prop的使用"><a href="#12-3-Prop的使用" class="headerlink" title="12.3 Prop的使用"></a>12.3 Prop的使用</h3><p><code>作用:props用来给组件传递相应静态数据或者是动态数据的</code></p><h4 id="12-3-1-通过在组件上声明静态数据传递给组件内部"><a href="#12-3-1-通过在组件上声明静态数据传递给组件内部" class="headerlink" title="12.3.1 通过在组件上声明静态数据传递给组件内部"></a>12.3.1 通过在组件上声明静态数据传递给组件内部</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.声明组件模板配置对象</span></span><br><span class="line">    <span class="keyword">let</span> login = &#123;</span><br><span class="line">        template:<span class="string">"&lt;div&gt;&lt;h1&gt;欢迎:&#123;&#123; userName &#125;&#125; 年龄:&#123;&#123; age &#125;&#125;&lt;/h1&gt;&lt;/div&gt;"</span>,</span><br><span class="line">        props:[<span class="string">'userName'</span>,<span class="string">'age'</span>]  <span class="comment">//props作用 用来接收使用组件时通过组件标签传递的数据</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.注册组件</span></span><br><span class="line">    <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">        el: <span class="string">"#app"</span>,</span><br><span class="line">        data: &#123;&#125;,</span><br><span class="line">        methods: &#123;&#125;,</span><br><span class="line">        components:&#123;</span><br><span class="line">            login <span class="comment">//组件注册</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.通过组件完成数据传递</span></span><br><span class="line">&lt;login user-name=<span class="string">"小陈"</span> age=<span class="string">"23"</span>&gt;&lt;<span class="regexp">/login&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 总结:</span></span><br><span class="line"><span class="code">1.使用组件时可以在组件上定义多个属性以及对应数据</span></span><br><span class="line"><span class="code">2.在组件内部可以使用props数组生命多个定义在组件上的属性名 日后可以在组件中通过&#123;&#123; 属性名 &#125;&#125; 方式获取组件中属性值</span></span><br></pre></td></tr></table></figure><h4 id="12-3-2-通过在组件上声明动态数据传递给组件内部"><a href="#12-3-2-通过在组件上声明动态数据传递给组件内部" class="headerlink" title="12.3.2 通过在组件上声明动态数据传递给组件内部"></a>12.3.2 通过在组件上声明动态数据传递给组件内部</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.声明组件模板对象</span></span><br><span class="line">    <span class="keyword">const</span> login = &#123;</span><br><span class="line">        template:<span class="string">'&lt;div&gt;&lt;h2&gt;欢迎: &#123;&#123; name &#125;&#125; 年龄:&#123;&#123; age &#125;&#125;&lt;/h2&gt;&lt;/div&gt;'</span>,</span><br><span class="line">        props:[<span class="string">'name'</span>,<span class="string">'age'</span>]</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//2.注册局部组件</span></span><br><span class="line">    <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">        el: <span class="string">"#app"</span>,</span><br><span class="line">        data: &#123;</span><br><span class="line">            username:<span class="string">"小陈陈"</span>,</span><br><span class="line">            age:<span class="number">23</span></span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;&#125;,</span><br><span class="line">        components:&#123;</span><br><span class="line">            login <span class="comment">//注册组件</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.使用组件</span></span><br><span class="line"> &lt;login :name=<span class="string">"username"</span> :age=<span class="string">"age"</span>&gt;&lt;<span class="regexp">/login&gt;  /</span><span class="regexp">/使用v-bind形式将数据绑定Vue实例中data属性,日后data属性发生变化,组件内部数据跟着变化</span></span><br></pre></td></tr></table></figure><h4 id="12-3-3-prop的单向数据流"><a href="#12-3-3-prop的单向数据流" class="headerlink" title="12.3.3 prop的单向数据流"></a>12.3.3 prop的单向数据流</h4><p><code>单向数据流:所有的 prop 都使得其父子 prop 之间形成了一个**单向下行绑定**：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。</code></p><blockquote><p>所有的 prop 都使得其父子 prop 之间形成了一个<strong>单向下行绑定</strong>：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流向难以理解。</p><p>额外的，每次父级组件发生更新时，子组件中所有的 prop 都将会刷新为最新的值。这意味着你<strong>不</strong>应该在一个子组件内部改变 prop。如果你这样做了，Vue 会在浏览器的控制台中发出警告。—摘自官网</p></blockquote><h3 id="12-4-组件中定义数据和事件使用"><a href="#12-4-组件中定义数据和事件使用" class="headerlink" title="12.4 组件中定义数据和事件使用"></a>12.4 组件中定义数据和事件使用</h3><h5 id="1-组件中定义属于组件的数据"><a href="#1-组件中定义属于组件的数据" class="headerlink" title="1. 组件中定义属于组件的数据"></a>1. 组件中定义属于组件的数据</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//组件声明的配置对象</span></span><br><span class="line">    <span class="keyword">const</span> login = &#123;</span><br><span class="line">        template:<span class="string">'&lt;div&gt;&lt;h1&gt;&#123;&#123; msg &#125;&#125; 百知教育&lt;/h1&gt;&lt;ul&gt;&lt;li v-for="item,index in lists"&gt;&#123;&#123; index &#125;&#125;&#123;&#123; item &#125;&#125;&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;'</span>,</span><br><span class="line">        data()&#123;   <span class="comment">//使用data函数方式定义组件的数据   在templatehtml代码中通过插值表达式直接获取</span></span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                msg:<span class="string">"hello"</span>,</span><br><span class="line">                lists:[<span class="string">'java'</span>,<span class="string">'spring'</span>,<span class="string">'springboot'</span>]</span><br><span class="line">            &#125;<span class="comment">//组件自己内部数据</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="2-组件中事件定义"><a href="#2-组件中事件定义" class="headerlink" title="2.组件中事件定义"></a>2.组件中事件定义</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> login=&#123;</span><br><span class="line">       template:<span class="string">'&lt;div&gt;&lt;input type="button" value="点我触发组件中事件" @click="change"&gt;&lt;/div&gt;'</span>,</span><br><span class="line">       data()&#123;</span><br><span class="line">           <span class="keyword">return</span> &#123;</span><br><span class="line">               name:<span class="string">'小陈'</span></span><br><span class="line">           &#125;;</span><br><span class="line">       &#125;,</span><br><span class="line">       methods:&#123;</span><br><span class="line">           change()&#123;</span><br><span class="line">               alert(<span class="keyword">this</span>.name)</span><br><span class="line">               alert(<span class="string">'触发事件'</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 总结</span></span><br><span class="line"><span class="code">1.组件中定义事件和直接在Vue中定义事件基本一致 直接在组件内部对应的html代码上加入@事件名=函数名方式即可</span></span><br><span class="line"><span class="code">2.在组件内部使用methods属性用来定义对应的事件函数即可,事件函数中this 指向的是当前组件的实例</span></span><br></pre></td></tr></table></figure><h3 id="12-5-向子组件中传递事件并在子组件中调用改事件"><a href="#12-5-向子组件中传递事件并在子组件中调用改事件" class="headerlink" title="12.5 向子组件中传递事件并在子组件中调用改事件"></a>12.5 向子组件中传递事件并在子组件中调用改事件</h3><p><code>在子组件中调用传递过来的相关事件必须使用 this.$emit(&#39;函数名&#39;) 方式调用</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.声明组件</span></span><br><span class="line">    <span class="keyword">const</span> login = &#123;</span><br><span class="line">        template:<span class="string">"&lt;div&gt;&lt;h1&gt;百知教育 &#123;&#123; uname &#125;&#125;&lt;/h1&gt; &lt;input type='button' value='点我' @click='change'&gt;&lt;/div&gt;"</span>,</span><br><span class="line">        data()&#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                uname:<span class="keyword">this</span>.name</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        props:[<span class="string">'name'</span>],</span><br><span class="line">        methods:&#123;</span><br><span class="line">            change()&#123;</span><br><span class="line">                <span class="comment">//调用vue实例中函数</span></span><br><span class="line">                <span class="keyword">this</span>.$emit(<span class="string">'aaa'</span>);  <span class="comment">//调用组件传递过来的其他函数时需要使用 this.$emit('函数名调用')</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"> <span class="comment">//2.注册组件</span></span><br><span class="line">    <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">        el: <span class="string">"#app"</span>,</span><br><span class="line">        data: &#123;</span><br><span class="line">            username:<span class="string">"小陈"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line">            findAll()&#123;  <span class="comment">//一个事件函数  将这个函数传递给子组件</span></span><br><span class="line">                alert(<span class="string">'Vue 实例中定义函数'</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        components:&#123;</span><br><span class="line">            login,<span class="comment">//组件的注册</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.使用组件</span></span><br><span class="line">&lt;login  @find=<span class="string">"findAll"</span>&gt;&lt;<span class="regexp">/login&gt;    /</span><span class="regexp">/=====&gt; 在组件内部使用  this.$emit('find')</span></span><br></pre></td></tr></table></figure><hr><h2 id="13-Vue中路由-VueRouter"><a href="#13-Vue中路由-VueRouter" class="headerlink" title="13.Vue中路由(VueRouter)"></a>13.Vue中路由(VueRouter)</h2><h4 id="13-1-路由"><a href="#13-1-路由" class="headerlink" title="13.1 路由"></a>13.1 路由</h4><p><code>路由:根据请求的路径按照一定的路由规则进行请求的转发从而帮助我们实现统一请求的管理</code></p><h4 id="13-2-作用"><a href="#13-2-作用" class="headerlink" title="13.2 作用"></a>13.2 作用</h4><p><code>用来在vue中实现组件之间的动态切换</code></p><h4 id="13-3-使用路由"><a href="#13-3-使用路由" class="headerlink" title="13.3 使用路由"></a>13.3 使用路由</h4><ol><li><h5 id="引入路由"><a href="#引入路由" class="headerlink" title="引入路由"></a>引入路由</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script src=<span class="string">"https://cdn.jsdelivr.net/npm/vue/dist/vue.js"</span>&gt;&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;script src="https:/</span><span class="regexp">/unpkg.com/</span>vue-router/dist/vue-router.js<span class="string">"&gt;&lt;/script&gt;  //vue 路由js</span></span><br></pre></td></tr></table></figure></li><li><h5 id="创建组件对象"><a href="#创建组件对象" class="headerlink" title="创建组件对象"></a>创建组件对象</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//声明组件模板</span></span><br><span class="line"><span class="keyword">const</span> login = &#123;</span><br><span class="line">  template:<span class="string">'&lt;h1&gt;登录&lt;/h1&gt;'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> register = &#123;</span><br><span class="line">  template:<span class="string">'&lt;h1&gt;注册&lt;/h1&gt;'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><h5 id="定义路由对象的规则"><a href="#定义路由对象的规则" class="headerlink" title="定义路由对象的规则"></a>定义路由对象的规则</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> <span class="comment">//创建路由对象</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes:[</span><br><span class="line">    &#123;<span class="attr">path</span>:<span class="string">'/login'</span>,<span class="attr">component</span>:login&#125;,   <span class="comment">//path: 路由的路径  component:路径对应的组件</span></span><br><span class="line">    &#123;<span class="attr">path</span>:<span class="string">'/register'</span>,<span class="attr">component</span>:register&#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ol><ol start="4"><li><h5 id="将路由对象注册到vue实例"><a href="#将路由对象注册到vue实例" class="headerlink" title="将路由对象注册到vue实例"></a>将路由对象注册到vue实例</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">"#app"</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    username:<span class="string">"小陈"</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;&#125;,</span><br><span class="line">  router:router   <span class="comment">//设置路由对象</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ol><ol start="5"><li><h5 id="在页面中显示路由的组件"><a href="#在页面中显示路由的组件" class="headerlink" title="在页面中显示路由的组件"></a>在页面中显示路由的组件</h5><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--显示路由的组件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><h5 id="根据连接切换路由"><a href="#根据连接切换路由" class="headerlink" title="根据连接切换路由"></a>根据连接切换路由</h5><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#/login"</span>&gt;</span>点我登录<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#/register"</span>&gt;</span>点我注册<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="13-4-router-link使用"><a href="#13-4-router-link使用" class="headerlink" title="13.4 router-link使用"></a>13.4 router-link使用</h3><p><code>作用:用来替换我们在切换路由时使用a标签切换路由</code></p><p><code>好处:就是可以自动给路由路径加入#不需要手动加入</code></p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/login"</span> <span class="attr">tag</span>=<span class="string">"button"</span>&gt;</span>我要登录<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/register"</span> <span class="attr">tag</span>=<span class="string">"button"</span>&gt;</span>点我注册<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 总结:</span></span><br><span class="line"><span class="code">1.router-link 用来替换使用a标签实现路由切换 好处是不需要书写#号直接书写路由路径</span></span><br><span class="line"><span class="code">2.router-link to属性用来书写路由路径   tag属性:用来将router-link渲染成指定的标签</span></span><br></pre></td></tr></table></figure><h3 id="13-5-默认路由"><a href="#13-5-默认路由" class="headerlink" title="13.5 默认路由"></a>13.5 默认路由</h3><p><code>作用:用来在第一次进入界面是显示一个默认的组件</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes:[</span><br><span class="line">    <span class="comment">//&#123; path:'/',component:login&#125;,</span></span><br><span class="line">    &#123; <span class="attr">path</span>:<span class="string">'/'</span>,<span class="attr">redirect</span>:<span class="string">'/login'</span>&#125;,  <span class="comment">//redirect: 用来当访问的是默认路由 "/" 时 跳转到指定的路由展示  推荐使用</span></span><br><span class="line">    &#123; <span class="attr">path</span>:<span class="string">'/login'</span>, <span class="attr">component</span>:login&#125;,</span><br><span class="line">    &#123; <span class="attr">path</span>:<span class="string">'/register'</span>, <span class="attr">component</span>:register&#125;,</span><br><span class="line">  ]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="13-6-路由中参数传递"><a href="#13-6-路由中参数传递" class="headerlink" title="13.6 路由中参数传递"></a>13.6 路由中参数传递</h3><ul><li>第一种方式传递参数 传统方式</li></ul><ol><li><p>通过?号形式拼接参数</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/login?id=21&amp;name=zhangsan"</span>&gt;</span>我要登录<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>组件中获取参数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> login = &#123;</span><br><span class="line">  template:<span class="string">'&lt;h1&gt;用户登录&lt;/h1&gt;'</span>,</span><br><span class="line">  data()&#123;<span class="keyword">return</span> &#123;&#125;&#125;,</span><br><span class="line">  methods:&#123;&#125;,</span><br><span class="line">  created()&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"=============&gt;"</span>+<span class="keyword">this</span>.$route.query.id+<span class="string">"======&gt;"</span>+<span class="keyword">this</span>.$route.query.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><ul><li>第二种方式传递参数 restful</li></ul><ol><li><p>通过使用路径方式传递参数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;router-link to=<span class="string">"/register/24/张三"</span>&gt;我要注册&lt;<span class="regexp">/router-link&gt;</span></span><br><span class="line"><span class="regexp">var router = new VueRouter(&#123;</span></span><br><span class="line"><span class="regexp">  routes:[</span></span><br><span class="line"><span class="regexp">    &#123;path:'/register/:id/:name',component:register&#125;   //定义路径中获取对应参数</span></span><br><span class="line"><span class="regexp">  ]</span></span><br><span class="line"><span class="regexp">&#125;);</span></span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><p>组件中获取参数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> register = &#123;</span><br><span class="line">  template:<span class="string">'&lt;h1&gt;用户注册&#123;&#123; $route.params.name &#125;&#125;&lt;/h1&gt;'</span>,</span><br><span class="line">  created()&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"注册组件中id:   "</span>+<span class="keyword">this</span>.$route.params.id+<span class="keyword">this</span>.$route.params.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><h3 id="13-7-嵌套路由"><a href="#13-7-嵌套路由" class="headerlink" title="13.7 嵌套路由"></a>13.7 嵌套路由</h3><ol><li><h5 id="声明最外层和内层路由"><a href="#声明最外层和内层路由" class="headerlink" title="声明最外层和内层路由"></a>声明最外层和内层路由</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template id=<span class="string">"product"</span>&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line"></span><br><span class="line">        &lt;h1&gt;商品管理&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">        &lt;router-link to="/</span>product/add<span class="string">"&gt;商品添加&lt;/router-link&gt;</span></span><br><span class="line"><span class="string">        &lt;router-link to="</span>/product/edit<span class="string">"&gt;商品编辑&lt;/router-link&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        &lt;router-view&gt;&lt;/router-view&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">&lt;/template&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">//声明组件模板</span></span><br><span class="line"><span class="string">const product=&#123;</span></span><br><span class="line"><span class="string">  template:'#product'</span></span><br><span class="line"><span class="string">&#125;;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">const add = &#123;</span></span><br><span class="line"><span class="string">  template:'&lt;h4&gt;商品添加&lt;/h4&gt;'</span></span><br><span class="line"><span class="string">&#125;;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">const edit = &#123;</span></span><br><span class="line"><span class="string">  template:'&lt;h4&gt;商品编辑&lt;/h4&gt;'</span></span><br><span class="line"><span class="string">&#125;;</span></span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><h5 id="创建路由对象含有嵌套路由"><a href="#创建路由对象含有嵌套路由" class="headerlink" title="创建路由对象含有嵌套路由"></a>创建路由对象含有嵌套路由</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">        routes:[</span><br><span class="line">            &#123;</span><br><span class="line">                path:<span class="string">'/product'</span>,</span><br><span class="line">                component:product,</span><br><span class="line">                children:[</span><br><span class="line">                    &#123;<span class="attr">path</span>:<span class="string">'add'</span>,<span class="attr">component</span>: add&#125;,</span><br><span class="line">                    &#123;<span class="attr">path</span>:<span class="string">'edit'</span>,<span class="attr">component</span>: edit&#125;,</span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">        ]</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure></li></ol><ol start="3"><li><h5 id="注册路由对象"><a href="#注册路由对象" class="headerlink" title="注册路由对象"></a>注册路由对象</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">"#app"</span>,</span><br><span class="line">    data: &#123;&#125;,</span><br><span class="line">    methods: &#123;&#125;,</span><br><span class="line">    router,<span class="comment">//定义路由对象</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>测试路由</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/product"</span>&gt;</span>商品管理<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br></pre></td></tr></table></figure><hr></li></ol><h2 id="14-Vue-CLI-脚手架"><a href="#14-Vue-CLI-脚手架" class="headerlink" title="14. Vue CLI 脚手架"></a>14. Vue CLI 脚手架</h2><h3 id="14-1-什么是CLI"><a href="#14-1-什么是CLI" class="headerlink" title="14.1 什么是CLI"></a>14.1 什么是CLI</h3><p>命令行界面（英语：command-line interface，缩写：<em>CLI</em>）是在图形用户界面得到普及之前使用最为广泛的用户界面，它通常不支持鼠标，用户通过键盘输入指令，计算机接收到指令后，予以执行。也有人称之为字符用户界面（CUI）</p><h3 id="14-2-什么是Vue-CLI"><a href="#14-2-什么是Vue-CLI" class="headerlink" title="14.2 什么是Vue CLI"></a>14.2 什么是Vue CLI</h3><p>Vue CLI 是一个基于 Vue.js 进行快速开发的完整系统。使用Vue 脚手架之后我们开发的页面将是一个完整系统(项目)。</p><h3 id="14-3-Vue-CLI优势"><a href="#14-3-Vue-CLI优势" class="headerlink" title="14.3 Vue CLI优势"></a>14.3 Vue CLI优势</h3><ul><li>通过 <code>vue-cli</code> 搭建交互式的项目脚手架。bootstrap css js jquery js     通过执行命令方式下载相关依赖</li><li>通过 <code>@vue/cli</code> + <code>@vue/cli-service-global</code> 快速开始零配置原型开发    vue页面 vuejs  vuerouter        axios(一条命令)</li><li>一个运行时依赖 (<code>@vue/cli-service</code>)，该依赖：<ul><li>可升级；  一条命令</li><li>基于 webpack 构建，并带有合理的默认配置；  webpack  项目打包方式     编译好的项目源码===&gt;部署到服务器上直接使用</li><li>可以通过项目内的配置文件进行配置；               默认配置文件,通过修改默认配置文件达到自己想要的项目环境            </li><li>可以通过插件进行扩展。                                       vue v-charts  elementui </li></ul></li><li>一个丰富的官方插件集合，集成了前端生态中最好的工具。Nodejs(tomcat)  Vue VueRouter webpack yarn</li><li>一套完全图形化的创建和管理 Vue.js 项目的用户界面</li></ul><h3 id="14-4-Vue-CLI安装"><a href="#14-4-Vue-CLI安装" class="headerlink" title="14.4 Vue CLI安装"></a>14.4 Vue CLI安装</h3><h5 id="1-环境准备"><a href="#1-环境准备" class="headerlink" title="1. 环境准备"></a>1. 环境准备</h5><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section">#1.下载nodejs</span></span><br><span class="line"><span class="code">http://nodejs.cn/download/</span></span><br><span class="line"><span class="code">windows系统:   .msi  安装包(exe)指定安装位置   .zip(压缩包)直接解压缩指定目录</span></span><br><span class="line"><span class="code">  mac os 系统:   .pkg  安装包格式自动配置环境变量  .tar.gz(压缩包)解压缩安装到指定名</span></span><br><span class="line"></span><br><span class="line"><span class="section">#2.配置nodejs环境变量</span></span><br><span class="line"><span class="code">windows系统:</span></span><br><span class="line"><span class="code">1.计算上右键属性----&gt;  高级属性 ----&gt;环境变量 添加如下配置:</span></span><br><span class="line"><span class="code">NODE_HOME=  nodejs安装目录</span></span><br><span class="line"><span class="code">        PATH    = xxxx;%NODE_HOME%</span></span><br><span class="line"><span class="code">    2.macos 系统</span></span><br><span class="line"><span class="code">    推荐使用.pkg安装直接配置node环境</span></span><br><span class="line"> </span><br><span class="line"><span class="section">#3.验证nodejs环境是否成功</span></span><br><span class="line"><span class="code">node -v </span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section">#4.npm介绍</span></span><br><span class="line"><span class="code">node package mangager    nodejs包管理工具       前端主流技术  npm 进行统一管理</span></span><br><span class="line"><span class="code">maven 管理java后端依赖   远程仓库(中心仓库)      阿里云镜像</span></span><br><span class="line"><span class="code">npm   管理前端系统依赖    远程仓库(中心仓库)      配置淘宝镜像</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section">#5.配置淘宝镜像</span></span><br><span class="line"><span class="code">  npm config set registry https://registry.npm.taobao.org</span></span><br><span class="line"><span class="code">  npm config get registry</span></span><br><span class="line"></span><br><span class="line"><span class="section">#6.配置npm下载依赖位置</span></span><br><span class="line"><span class="code"> windows:</span></span><br><span class="line"><span class="code">npm config set cache "D:\nodereps\npm-cache"</span></span><br><span class="line"><span class="code">npm config set prefix "D:\nodereps\npm_global"</span></span><br><span class="line"><span class="code"> mac os:</span></span><br><span class="line"><span class="code"> npm config set cache "/Users/chenyannan/dev/nodereps"</span></span><br><span class="line"><span class="code">npm config set prefix "/Users/chenyannan/dev/nodereps"</span></span><br><span class="line"></span><br><span class="line"><span class="section">#7.验证nodejs环境配置</span></span><br><span class="line"><span class="code">npm config ls</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">    ; userconfig /Users/chenyannan/.npmrc</span></span><br><span class="line"><span class="code">    cache = "/Users/chenyannan/dev/nodereps"</span></span><br><span class="line"><span class="code">    prefix = "/Users/chenyannan/dev/nodereps"</span></span><br><span class="line"><span class="code">    registry = "https://registry.npm.taobao.org/"</span></span><br></pre></td></tr></table></figure><h5 id="2-安装脚手架"><a href="#2-安装脚手架" class="headerlink" title="2.安装脚手架"></a>2.安装脚手架</h5><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section">#0.卸载脚手架</span></span><br><span class="line"><span class="code">npm uninstall -g @vue/cli  //卸载3.x版本脚手架</span></span><br><span class="line"><span class="code">npm uninstall -g vue-cli  //卸载2.x版本脚手架</span></span><br><span class="line"></span><br><span class="line"><span class="section">#1.Vue Cli官方网站</span></span><br><span class="line"><span class="code">https://cli.vuejs.org/zh/guide/</span></span><br><span class="line"></span><br><span class="line"><span class="section">#2.安装vue Cli</span></span><br><span class="line"><span class="code">npm install -g vue-cli</span></span><br></pre></td></tr></table></figure><h5 id="3-第一个vue脚手架项目"><a href="#3-第一个vue脚手架项目" class="headerlink" title="3.第一个vue脚手架项目"></a>3.第一个vue脚手架项目</h5><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.创建vue脚手架第一个项目</span></span><br><span class="line"><span class="code">vue init webpack 项目名</span></span><br><span class="line"><span class="section"># 2.创建第一个项目</span></span><br><span class="line"><span class="code">hello     -------------&gt;项目名</span></span><br><span class="line"><span class="code">    -build  -------------&gt;用来使用webpack打包使用build依赖</span></span><br><span class="line"><span class="code">    -config -------------&gt;用来做整个项目配置目录</span></span><br><span class="line"><span class="code">    -node_modules  ------&gt;用来管理项目中使用依赖</span></span><br><span class="line"><span class="code">    -src ------&gt;用来书写vue的源代码[重点]</span></span><br><span class="line"><span class="code">    +assets      ------&gt;用来存放静态资源 [重点]</span></span><br><span class="line"><span class="code">      components   ------&gt;用来书写Vue组件 [重点]</span></span><br><span class="line"><span class="code">      router ------&gt;用来配置项目中路由[重点]</span></span><br><span class="line"><span class="code">      App.vue      ------&gt;项目中根组件[重点]</span></span><br><span class="line"><span class="code">      main.js      ------&gt;项目中主入口[重点]</span></span><br><span class="line"><span class="code">    -static        ------&gt;其它静态</span></span><br><span class="line"><span class="code">    -.babelrc      ------&gt; 将es6语法转为es5运行</span></span><br><span class="line"><span class="code">    -.editorconfig ------&gt; 项目编辑配置</span></span><br><span class="line"><span class="code">    -.gitignore    ------&gt; git版本控制忽略文件</span></span><br><span class="line"><span class="code">    -.postcssrc.js ------&gt; 源码相关js</span></span><br><span class="line"><span class="code">    -index.html    ------&gt; 项目主页</span></span><br><span class="line"><span class="code">    -package.json  ------&gt; 类似与pom.xml 依赖管理  jquery 不建议手动修改</span></span><br><span class="line"><span class="code">    -package-lock.json ----&gt; 对package.json加锁</span></span><br><span class="line"><span class="code">    -README.md         ----&gt; 项目说明文件</span></span><br><span class="line"></span><br><span class="line"><span class="section"># 3.如何运行在项目的根目录中执行</span></span><br><span class="line"><span class="code">npm start 运行前端系统</span></span><br><span class="line"></span><br><span class="line"><span class="section"># 4.如何访问项目</span></span><br><span class="line"><span class="code">http://localhost:8081    </span></span><br><span class="line"></span><br><span class="line"><span class="section"># 5.Vue Cli中项目开发方式</span></span><br><span class="line"><span class="code"> 注意: 一切皆组件   一个组件中   js代码  html代码  css样式</span></span><br><span class="line"><span class="code"> </span></span><br><span class="line"><span class="bullet"> 1. </span>VueCli开发方式是在项目中开发一个一个组件对应一个业务功能模块,日后可以将多个组件组合到一起形成一个前端系统</span><br><span class="line"><span class="bullet"> 2. </span>日后在使用vue Cli进行开发时不再书写html,编写的是一个个组件(组件后缀.vue结尾的文件),日后打包时vue cli会将组件编译成运行的html文件</span><br></pre></td></tr></table></figure><h5 id="4-如何开发Vue脚手架"><a href="#4-如何开发Vue脚手架" class="headerlink" title="4.如何开发Vue脚手架"></a>4.如何开发Vue脚手架</h5><p><code>注意:在Vue cli 中一切皆组件</code></p><hr><h2 id="15-在脚手架中使用axios"><a href="#15-在脚手架中使用axios" class="headerlink" title="15.在脚手架中使用axios"></a>15.在脚手架中使用axios</h2><h3 id="15-1-安装axios"><a href="#15-1-安装axios" class="headerlink" title="15.1 安装axios"></a>15.1 安装axios</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.安装axios</span></span><br><span class="line"><span class="code">npm install axios --save-dev</span></span><br><span class="line"></span><br><span class="line"><span class="section"># 2.配置main.js中引入axios</span></span><br><span class="line"><span class="code">import axios from 'axios';</span></span><br><span class="line"></span><br><span class="line"><span class="code">Vue.prototype.$http=axios;</span></span><br><span class="line"></span><br><span class="line"><span class="section"># 3.使用axios</span></span><br><span class="line"><span class="code">在需要发送异步请求的位置:this.$http.get("url").then((res)=&gt;&#123;&#125;) this.$http.post("url").then((res)=&gt;&#123;&#125;)</span></span><br></pre></td></tr></table></figure><hr><h2 id="16-Vue-Cli脚手架项目打包和部署"><a href="#16-Vue-Cli脚手架项目打包和部署" class="headerlink" title="16.Vue Cli脚手架项目打包和部署"></a>16.Vue Cli脚手架项目打包和部署</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.在项目根目录中执行如下命令:</span></span><br><span class="line"><span class="code">  vue run build</span></span><br><span class="line"></span><br><span class="line"><span class="code">注意:vue脚手架打包的项目必须在服务器上运行不能直接双击运行</span></span><br><span class="line"></span><br><span class="line"><span class="section"># 2.打包之后当前项目中变化</span></span><br><span class="line"><span class="code"> 在打包之后项目中出现dist目录,dist目录就是vue脚手架项目生产目录或者说是直接部署目录</span></span><br><span class="line"></span><br><span class="line"><span class="section"># 3.</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      前端体系、前后端分离
    
    </summary>
    
    
      <category term="Vue" scheme="https://SomunsTao.github.io/categories/Vue/"/>
    
    
      <category term="Vue" scheme="https://SomunsTao.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue 12： 知识总结</title>
    <link href="https://somunstao.github.io/2020/04/22/Vue%2012%EF%BC%9A%E6%80%BB%E7%BB%93/"/>
    <id>https://somunstao.github.io/2020/04/22/Vue%2012%EF%BC%9A%E6%80%BB%E7%BB%93/</id>
    <published>2020-04-21T16:00:00.000Z</published>
    <updated>2020-08-01T15:19:42.152Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Vue-知识总结"><a href="#Vue-知识总结" class="headerlink" title="Vue 知识总结"></a>Vue 知识总结</h1><h5 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h5><blockquote><p>基于vue 2+ 写一份知识总结，可以说是学习笔记</p></blockquote><h5 id="目录："><a href="#目录：" class="headerlink" title="目录："></a>目录：</h5><blockquote><p>一、vue实例的基本结构<br>二、vue事件处理、绑定属性<br>三、vue指令、自定义指令<br>四、vue过滤器<br>五、vue数据监听<br>六、vue组件<br>七、vue-router<br>八、axios</p></blockquote><h5 id="一、Vue-实例的基本结构"><a href="#一、Vue-实例的基本结构" class="headerlink" title="一、Vue 实例的基本结构"></a>一、Vue 实例的基本结构</h5><p><a href="https://cn.vuejs.org/v2/api/" target="_blank" rel="noopener">Vue官网API</a></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">  &lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;p&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Welcome</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var vm &#x3D; new Vue(&#123;</span><br><span class="line">  el: &#39;#app&#39;, &#x2F;&#x2F;等价于后面的 .$mount(&#39;#app&#39;) 用其中之一就可以了</span><br><span class="line">  render: h &#x3D;&gt; h(App), &#x2F;&#x2F;理解不够深入，参考（https:&#x2F;&#x2F;cn.vuejs.org&#x2F;v2&#x2F;api&#x2F;?#render）</span><br><span class="line">  data: &#123; </span><br><span class="line">    &#x2F;&#x2F;页面响应的数据都放在这里如上（组件只接受 function 且必须返回一个对象），zhicvm.$data 访问这里面的data</span><br><span class="line">    msg: &#39;Welcome&#39;,</span><br><span class="line">  &#125;,</span><br><span class="line">  props:&#123;</span><br><span class="line">    &#x2F;&#x2F;props 可以是数组或对象，接收任何值</span><br><span class="line">  &#125;,</span><br><span class="line">  methods:  &#123;</span><br><span class="line">    &#x2F;&#x2F;页面或组件定义的方法的集合，可通过 vm.reset() 直接调用</span><br><span class="line">    reset: function()&#123;</span><br><span class="line">      this.msg &#x3D; &#39;这是重新设置之后的数据&#39;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    &#x2F;&#x2F;计算属性(computed)与方法(methods) 类似，如果计算数据量比较大，建议放到这里</span><br><span class="line">    &#x2F;&#x2F;计算属性的结果会被缓存，除非依赖的响应式属性变化才会重新计算。</span><br><span class="line">    &#x2F;&#x2F;参考（https:&#x2F;&#x2F;cn.vuejs.org&#x2F;v2&#x2F;api&#x2F;?#computed）</span><br><span class="line">  &#125;,</span><br><span class="line">  components：&#123;</span><br><span class="line">    &#x2F;&#x2F; 局部组件注册的地方</span><br><span class="line">    &#39;component-a&#39;: ComponentA,</span><br><span class="line">    &#39;component-b&#39;: ComponentB</span><br><span class="line">  &#125;,</span><br><span class="line">  directives: &#123;</span><br><span class="line">    &#x2F;&#x2F; 局部指令注册的地方</span><br><span class="line">    focus: &#123;</span><br><span class="line">      &#x2F;&#x2F; 指令的定义</span><br><span class="line">      inserted: function (el,binding) &#123;</span><br><span class="line">        el.focus(); </span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  filters:&#123;</span><br><span class="line">    &#x2F;&#x2F; 局部过滤器注册的地方</span><br><span class="line">  &#125;,</span><br><span class="line">  &#x2F;&#x2F;生命周期钩子</span><br><span class="line">  beforeCreate: function ()&#123;&#125;, &#x2F;&#x2F;在实例初始化之后，数据观测 (data observer) 和 event&#x2F;watcher 事件配置之前被调用。</span><br><span class="line">  created: function ()&#123;&#125;,&#x2F;&#x2F;在实例创建完成后被立即调用。</span><br><span class="line">  beforeMount: function ()&#123;&#125;,&#x2F;&#x2F;在挂载开始之前被调用：相关的 render 函数首次被调用。</span><br><span class="line">  mounted: function ()&#123;&#125;,&#x2F;&#x2F;el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子。</span><br><span class="line">  beforeUpdate: function ()&#123;&#125;,&#x2F;&#x2F;数据更新时调用，发生在虚拟 DOM 打补丁之前。</span><br><span class="line">  updated: function ()&#123;&#125;,&#x2F;&#x2F;由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。</span><br><span class="line">  beforeDestroy: function ()&#123;&#125;,&#x2F;&#x2F;实例销毁之前调用。在这一步，实例仍然完全可用。</span><br><span class="line">  destroyed: function ()&#123;</span><br><span class="line">    &#x2F;&#x2F;Vue 实例销毁后调用。</span><br><span class="line">    &#x2F;&#x2F;调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;).$mount(&#39;#app&#39;)</span><br></pre></td></tr></table></figure><h5 id="二、Vue-事件处理、绑定属性"><a href="#二、Vue-事件处理、绑定属性" class="headerlink" title="二、Vue 事件处理、绑定属性"></a>二、Vue 事件处理、绑定属性</h5><p><a href="https://cn.vuejs.org/v2/api/?#v-on" target="_blank" rel="noopener">v-on：</a></p><blockquote><p>1、绑定事件监听器。用在普通元素上时，只能监听<a href="https://developer.mozilla.org/zh-CN/docs/Web/Events" target="_blank" rel="noopener"><strong>原生 DOM 事件</strong></a>（如：click、keyup/down、mouseenter/over/move/down/out 等）。也可以监听自定义事件即 methods 里面的事件。<br>2、在监听原生 DOM 事件时，方法以事件为唯一的参数。如果使用内联语句，语句可以访问一个 $event 属性：v-on:click=”handle(‘ok’, $event)”。</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">修饰符：</span><br><span class="line">.stop - 调用 event.stopPropagation()。阻止冒泡</span><br><span class="line">.prevent - 调用 event.preventDefault()。阻止默认事件</span><br><span class="line">.capture - 添加事件侦听器时使用 capture 模式。</span><br><span class="line">.self - 只当事件是从侦听器绑定的元素本身触发时才触发回调。</span><br><span class="line">.&#123;keyCode | keyAlias&#125; - 只当事件是从特定键触发时才触发回调。</span><br><span class="line">.native - 监听组件根元素的原生事件。</span><br><span class="line">.once - 只触发一次回调。</span><br><span class="line">.left - (2.2.0) 只当点击鼠标左键时触发。</span><br><span class="line">.right - (2.2.0) 只当点击鼠标右键时触发。</span><br><span class="line">.middle - (2.2.0) 只当点击鼠标中键时触发。</span><br><span class="line">.passive - (2.3.0) 以 &#123; passive: true &#125; 模式添加侦听器</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">用法：</span><br><span class="line">&lt;!-- 内联语句 --&gt;</span><br><span class="line">&lt;button v-on:click&#x3D;&quot;doThat(&#39;hello&#39;, $event)&quot;&gt;&lt;&#x2F;button&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 缩写 --&gt;</span><br><span class="line">&lt;button @click&#x3D;&quot;doThis&quot;&gt;&lt;&#x2F;button&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 停止冒泡 --&gt;</span><br><span class="line">&lt;button @click.stop&#x3D;&quot;doThis&quot;&gt;&lt;&#x2F;button&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 对象语法 (2.4.0+) --&gt;</span><br><span class="line">&lt;button v-on&#x3D;&quot;&#123; mousedown: doThis, mouseup: doThat &#125;&quot;&gt;&lt;&#x2F;button&gt;</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br></pre></td></tr></table></figure><ul><li>v-on 还提供了<a href="https://cn.vuejs.org/v2/guide/events.html#%E6%8C%89%E9%94%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6" target="_blank" rel="noopener">按键修饰符</a></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">键盘按钮的别名</span><br><span class="line">.enter</span><br><span class="line">.tab</span><br><span class="line">.delete (捕获“删除”和“退格”键)</span><br><span class="line">.esc</span><br><span class="line">.space</span><br><span class="line">.up</span><br><span class="line">.down</span><br><span class="line">.left</span><br><span class="line">.right</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 可以通过全局 &#96;config.keyCodes&#96; 对象自定义按键修饰符别名</span><br><span class="line">&#x2F;&#x2F; 使用 方式 &#96;v-on:keyup.f1&#96; ，f1 这个名字你可以任意取，你知道是什么意思就可以了</span><br><span class="line">Vue.config.keyCodes.f1 &#x3D; 112</span><br></pre></td></tr></table></figure><p><a href="https://cn.vuejs.org/v2/api/?#v-bind" target="_blank" rel="noopener">v-bind：</a></p><blockquote><p>动态地绑定一个或多个特性，或一个组件 prop 到表达式。</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 绑定一个属性 --&gt;</span><br><span class="line">&lt;img v-bind:src&#x3D;&quot;imageSrc&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 缩写 --&gt;</span><br><span class="line">&lt;img :src&#x3D;&quot;imageSrc&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 内联字符串拼接 --&gt;</span><br><span class="line">&lt;img :src&#x3D;&quot;&#39;&#x2F;path&#x2F;to&#x2F;images&#x2F;&#39; + fileName&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- class 绑定 --&gt;</span><br><span class="line">&lt;div :class&#x3D;&quot;&#123; red: isRed &#125;&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;div :class&#x3D;&quot;[classA, classB]&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;div :class&#x3D;&quot;[classA, &#123; classB: isB, classC: isC &#125;]&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- style 绑定 --&gt;</span><br><span class="line">&lt;div :style&#x3D;&quot;&#123; fontSize: size + &#39;px&#39; &#125;&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;div :style&#x3D;&quot;[styleObjectA, styleObjectB]&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 绑定一个有属性的对象 --&gt;</span><br><span class="line">&lt;div v-bind&#x3D;&quot;&#123; id: someProp, &#39;other-attr&#39;: otherProp &#125;&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- prop 绑定。“prop”必须在 my-component 中声明。--&gt;</span><br><span class="line">&lt;my-component :prop&#x3D;&quot;someThing&quot;&gt;&lt;&#x2F;my-component&gt;</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br></pre></td></tr></table></figure><h4 id="三、Vue-指令、自定义指令"><a href="#三、Vue-指令、自定义指令" class="headerlink" title="三、Vue 指令、自定义指令"></a>三、Vue 指令、自定义指令</h4><p><a href="https://cn.vuejs.org/v2/api/?#%E6%8C%87%E4%BB%A4" target="_blank" rel="noopener">Vue指令：</a></p><p>v-text：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;span v-text&#x3D;&quot;msg&quot;&gt;&lt;&#x2F;span&gt;</span><br><span class="line">&lt;!-- 和下面的一样 --&gt;</span><br><span class="line">&lt;span&gt;&#123;&#123;msg&#125;&#125;&lt;&#x2F;span&gt;</span><br></pre></td></tr></table></figure><p>v-html：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;输出真正的 HTML</span><br><span class="line">&lt;div v-html&#x3D;&quot;html&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">data&#123;</span><br><span class="line">  html:&#39;&lt;strong&gt;我是真正的html&lt;&#x2F;strong&gt;&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>v-show：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;根据表达式之真假值，切换元素的 display CSS 属性。</span><br><span class="line">&lt;h1 v-show&#x3D;&quot;ok&quot;&gt;Hello!&lt;&#x2F;h1&gt;</span><br></pre></td></tr></table></figure><p>v-if、v-if-else、v-else：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;v-if 是“真正”的条件渲染，如果条件为假，dom不会渲染在页面当中</span><br><span class="line">&#x2F;&#x2F;v-show 会一直渲染在dom当中</span><br><span class="line">&#x2F;&#x2F;当 v-if 与 v-for 一起使用时，v-for 具有比 v-if 更高的优先级。</span><br><span class="line">&lt;h1 v-if&#x3D;&quot;ok&quot;&gt;Yes&lt;&#x2F;h1&gt;</span><br><span class="line"></span><br><span class="line">&lt;h1 v-if&#x3D;&quot;ok&quot;&gt;Yes&lt;&#x2F;h1&gt;</span><br><span class="line">&lt;h1 v-else&gt;No&lt;&#x2F;h1&gt;</span><br><span class="line"></span><br><span class="line">&lt;div v-if&#x3D;&quot;type &#x3D;&#x3D;&#x3D; &#39;A&#39;&quot;&gt;A&lt;&#x2F;div&gt;</span><br><span class="line">&lt;div v-else-if&#x3D;&quot;type &#x3D;&#x3D;&#x3D; &#39;B&#39;&quot;&gt;B&lt;&#x2F;div&gt;</span><br><span class="line">&lt;div v-else-if&#x3D;&quot;type &#x3D;&#x3D;&#x3D; &#39;C&#39;&quot;&gt;C&lt;&#x2F;div&gt;</span><br><span class="line">&lt;div v-else&gt;Not A&#x2F;B&#x2F;C&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><p>v-for：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;基于源数据多次渲染元素或模板块。</span><br><span class="line">&lt;div v-for&#x3D;&quot;item in items&quot;&gt;</span><br><span class="line">  &#123;&#123; item.text &#125;&#125;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;另外也可以为数组索引指定别名 (或者用于对象的键)：val-&gt;对象的键值  key-&gt;对象的键  index-&gt;对象的下标</span><br><span class="line">&lt;div v-for&#x3D;&quot;(item, index) in items&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;div v-for&#x3D;&quot;(val, key) in object&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;div v-for&#x3D;&quot;(val, key, index) in object&quot;&gt;&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><p>v-model：作用于<input>、<select>、<textarea>，<br>当v-model作用于 <strong>多个复选框</strong>、<strong>当选择按钮</strong>、<strong>选择框</strong> 时，都是把这些标签的value值赋值给v-model的变量</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">修饰符：</span><br><span class="line">.lazy - 取代 &#96;input&#96; 监听 &#96;change&#96; 事件</span><br><span class="line">.number- 输入字符串转为数字</span><br><span class="line">.trim- 输入首尾空格过滤</span><br><span class="line"></span><br><span class="line">&lt;input v-model&#x3D;&quot;message&quot; placeholder&#x3D;&quot;edit me&quot;&gt;</span><br><span class="line">&lt;textarea v-model&#x3D;&quot;message&quot; placeholder&#x3D;&quot;add multiple lines&quot;&gt;&lt;&#x2F;textarea&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 选择框</span><br><span class="line">&lt;select v-model&#x3D;&quot;selected&quot;&gt;</span><br><span class="line">   &lt;option disabled value&#x3D;&quot;&quot;&gt;请选择&lt;&#x2F;option&gt;</span><br><span class="line">   &lt;option&gt;A&lt;&#x2F;option&gt;</span><br><span class="line">   &lt;option&gt;B&lt;&#x2F;option&gt;</span><br><span class="line">   &lt;option&gt;C&lt;&#x2F;option&gt;</span><br><span class="line">&lt;&#x2F;select&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 用 v-for 渲染的动态选项：</span><br><span class="line">&lt;select v-model&#x3D;&quot;selected&quot;&gt;</span><br><span class="line">  &lt;option v-for&#x3D;&quot;option in options&quot; v-bind:value&#x3D;&quot;option.value&quot;&gt;</span><br><span class="line">    &#123;&#123; option.text &#125;&#125;</span><br><span class="line">  &lt;&#x2F;option&gt;</span><br><span class="line">&lt;&#x2F;select&gt;</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br></pre></td></tr></table></figure><p>v-pre：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;跳过这个元素和它的子元素的编译过程。可以用来显示原始 Mustache 标签。跳过大量没有指令的节点会加快编译。</span><br><span class="line">&#x2F;&#x2F;Mustache 标签：&#123;&#123; &#125;&#125;</span><br><span class="line">&lt;span v-pre&gt;&#123;&#123; this will not be compiled &#125;&#125;&lt;&#x2F;span&gt;</span><br></pre></td></tr></table></figure><p>v-cloak：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;这个指令保持在元素上直到关联实例结束编译</span><br><span class="line">css:</span><br><span class="line">[v-cloak] &#123;</span><br><span class="line">  display: none;</span><br><span class="line">&#125;</span><br><span class="line">html:</span><br><span class="line">&lt;div v-cloak&gt;</span><br><span class="line">  &#123;&#123; message &#125;&#125;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><p>v-once：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">只渲染元素和组件一次。随后的重新渲染，元素&#x2F;组件及其所有的子节点将被视为静态内容并跳过。这可以用于优化更新性能。</span><br><span class="line"></span><br><span class="line">&lt;!-- 单个元素 --&gt;</span><br><span class="line">&lt;span v-once&gt;This will never change: &#123;&#123;msg&#125;&#125;&lt;&#x2F;span&gt;</span><br><span class="line">&lt;!-- 有子元素 --&gt;</span><br><span class="line">&lt;div v-once&gt;</span><br><span class="line">  &lt;h1&gt;comment&lt;&#x2F;h1&gt;</span><br><span class="line">  &lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;&#x2F;p&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;!-- 组件 --&gt;</span><br><span class="line">&lt;my-component v-once :comment&#x3D;&quot;msg&quot;&gt;&lt;&#x2F;my-component&gt;</span><br><span class="line">&lt;!-- &#96;v-for&#96; 指令--&gt;</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;li v-for&#x3D;&quot;i in list&quot; v-once&gt;&#123;&#123;i&#125;&#125;&lt;&#x2F;li&gt;</span><br><span class="line">&lt;&#x2F;ul&gt;</span><br></pre></td></tr></table></figure><p><a href="https://cn.vuejs.org/v2/guide/custom-directive.html" target="_blank" rel="noopener">Vue自定义指令：</a></p><p><a href="https://cn.vuejs.org/v2/guide/custom-directive.html#%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0" target="_blank" rel="noopener">指令的钩子函数：</a> 一个指令定义对象可以提供如下几个钩子函数 (均为可选)：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;bind&#96;：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。</span><br><span class="line"></span><br><span class="line">&#96;inserted&#96;：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。</span><br><span class="line"></span><br><span class="line">&#96;update&#96;：1、所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。</span><br><span class="line">          2、指令的值可能发生了改变，也可能没有。</span><br><span class="line">          3、你可以通过比较更新前后的值来忽略不必要的模板更新 (详细的钩子函数参数见下)。</span><br><span class="line"></span><br><span class="line">&#96;componentUpdated&#96;：指令所在组件的 VNode 及其子 VNode 全部更新后调用。</span><br><span class="line"></span><br><span class="line">&#96;unbind&#96;：只调用一次，指令与元素解绑时调用。</span><br></pre></td></tr></table></figure><p><a href="https://cn.vuejs.org/v2/guide/custom-directive.html#%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0" target="_blank" rel="noopener">钩子函数的参数</a> (即 el、binding、vnode 和 oldVnode)。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;el&#96;：指令所绑定的元素，可以用来直接操作 DOM 。</span><br><span class="line"></span><br><span class="line">&#96;binding&#96;：一个对象，包含以下属性：</span><br><span class="line">    &#96;name&#96;：指令名，不包括 &#96;v-&#96; 前缀。</span><br><span class="line">    &#96;value&#96;：指令的绑定值，例如：&#96;v-my-directive&#x3D;&quot;1 + 1&quot;&#96; 中，绑定值为 &#96;2&#96;。</span><br><span class="line">    &#96;oldValue&#96;：指令绑定的前一个值，仅在 &#96;update&#96; 和 &#96;componentUpdated&#96; 钩子中可用。无论值是否改变都可用。</span><br><span class="line">    &#96;expression&#96;：字符串形式的指令表达式。例如 &#96;v-my-directive&#x3D;&quot;1 + 1&quot;&#96; 中，表达式为 &#96;&quot;1 + 1&quot;&#96;。</span><br><span class="line">    &#96;arg&#96;：传给指令的参数，可选。例如 &#96;v-my-directive:foo&#96; 中，参数为 &#96;&quot;foo&quot;&#96;。</span><br><span class="line">    &#96;modifiers&#96;：一个包含修饰符的对象。例如：&#96;v-my-directive.foo.bar&#96; 中，修饰符对象为 &#96;&#123; foo: true, bar: true &#125;&#96;。</span><br><span class="line"></span><br><span class="line">&#96;vnode&#96;：Vue 编译生成的虚拟节点。移步(https:&#x2F;&#x2F;cn.vuejs.org&#x2F;v2&#x2F;api&#x2F;#VNode%E6%8E%A5%E5%8F%A3) 来了解更多详情。</span><br><span class="line"></span><br><span class="line">&#96;oldVnode&#96;：上一个虚拟节点，仅在 &#96;update&#96; 和 &#96;componentUpdated&#96; 钩子中可用。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 注册一个全局自定义指令 &#96;v-focus&#96;</span><br><span class="line">&#x2F;&#x2F; 在这里需要注意一下，给一个全局指令命名的时候不要加 &#96;v-&#96; 前缀，用在dom的时候再加上</span><br><span class="line">Vue.directive(&#39;focus&#39;, &#123;</span><br><span class="line">  &#x2F;&#x2F; 当被绑定的元素插入到 DOM 中时……</span><br><span class="line">  inserted: function (el,binding) &#123;</span><br><span class="line">    &#x2F;&#x2F; 聚焦元素</span><br><span class="line">    el.focus();</span><br><span class="line">    console.log(binding.value) &#x2F;&#x2F;&#x3D;&gt;666</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;如果想注册局部指令，组件中也接受一个 directives 的选项：</span><br><span class="line">directives: &#123;</span><br><span class="line">  focus: &#123;</span><br><span class="line">    &#x2F;&#x2F; 指令的定义</span><br><span class="line">    inserted: function (el,binding) &#123;</span><br><span class="line">      el.focus(); </span><br><span class="line">      console.log(binding.value) &#x2F;&#x2F;&#x3D;&gt;666</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;然后你可以在模板中任何元素上使用新的 v-focus 属性，如下：</span><br><span class="line">&lt;input v-focus&#x3D;&quot;6666&quot;&gt;  &#x2F;&#x2F; 6666 可用data 里面的变量替换，建议传简单数据类型</span><br></pre></td></tr></table></figure><blockquote><p>一个正常的业务不可能只有一个指令，如果把所有的指令都注册在main.js里面会不好管理，所以最好放在一个统一文件 directives.js<br>这里就产生了两个问题：<br>1、怎么把directives.js 这个文件引用到main.js<br>2、Vue.directives() 支不支持链式调用（因为老版本angular 支持，所以做一个假想）</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 第二个问题很好解决，经过测试，Vue.directives() 不支持链式调用 &#96;Vue.directives().directives()&#96;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 第一个问题：经过查阅相关资料之后可以以插件的形式引入</span><br><span class="line">&#x2F;&#x2F; 这种方式引入暂时还没有发现有其他的问题</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; main.js</span><br><span class="line">import directives from &#39;.&#x2F;directives.js&#39;</span><br><span class="line">Vue.use(directives);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; directives.js</span><br><span class="line">export default&#123;</span><br><span class="line">  &#x2F;&#x2F; install 方法会默认在main.js里面调用</span><br><span class="line">  install(Vue)&#123;</span><br><span class="line">    Vue.directive(&#39;focus&#39;,&#123;</span><br><span class="line">      inserted(el,binding)&#123;</span><br><span class="line">        el.focus();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    Vue.directive(&#39;data&#39;,&#123;</span><br><span class="line">      inserted(el)&#123;</span><br><span class="line">        console.log(el)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    &#x2F;&#x2F;有多个就继续往这里添加就好了</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="四、Vue-过滤器"><a href="#四、Vue-过滤器" class="headerlink" title="四、Vue 过滤器"></a>四、Vue 过滤器</h4><p><a href="https://cn.vuejs.org/v2/guide/filters.html" target="_blank" rel="noopener">Vue 过滤器的用法</a></p><blockquote><p>过滤器可以用在两个地方：双花括号插值和 v-bind 表达式 (后者从 2.1.0+ 开始支持)。<br>与指令的用法类似，但过滤器一定要有返回值，也不支持链式调用</p></blockquote><blockquote><p><strong>这里需要注意的地方是，vue 2.0 之后移除了自带的过滤器</strong></p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 在双花括号中</span><br><span class="line">&#123;&#123; message | capitalize &#125;&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 在 &#96;v-bind&#96; 中</span><br><span class="line">&lt;div v-bind:id&#x3D;&quot;rawId | formatId&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 局部注册过滤器</span><br><span class="line">filters: &#123;</span><br><span class="line">  &#x2F;&#x2F; 首字母大写</span><br><span class="line">  capitalize: function (value) &#123;</span><br><span class="line">    &#x2F;&#x2F; value 就是 ‘|’ 符号前面的值</span><br><span class="line">    if (!value) return &#39;&#39;;</span><br><span class="line">    value &#x3D; value.toString()</span><br><span class="line">    return value.charAt(0).toUpperCase() + value.slice(1)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 注册全局过滤器</span><br><span class="line">Vue.filter(&#39;capitalize&#39;, function (value) &#123;</span><br><span class="line">  if (!value) return &#39;&#39;;</span><br><span class="line">  value &#x3D; value.toString()</span><br><span class="line">  return value.charAt(0).toUpperCase() + value.slice(1)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 过滤器传值</span><br><span class="line">&#123;&#123; number | dual(2) &#125;&#125;</span><br><span class="line"></span><br><span class="line">Vue.filter(&#39;dual&#39;, function (value,type) &#123;</span><br><span class="line">  &#x2F;&#x2F; 回调函数里面默认有 value ,在页面上传过来的值会依次添加在后面</span><br><span class="line">  console.log(type)  &#x2F;&#x2F; &#x3D;&gt; 2</span><br><span class="line">  if (!value) return &#39;&#39;;</span><br><span class="line">  if (typeof value !&#x3D;&#x3D; &quot;number&quot;) return alert(value + &#39; 不是数字&#39;);</span><br><span class="line">  if( parseInt(type) &#x3D;&#x3D;&#x3D; 2 )&#123;</span><br><span class="line">    return value &#x3D; value &gt; 10 ? value : &#39;0&#39; + value</span><br><span class="line">  &#125;</span><br><span class="line">  return value</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 过滤器的插件用法，与 directives.js 一致</span><br><span class="line">&#x2F;&#x2F; main.js</span><br><span class="line">import directives from &#39;.&#x2F;filters.js&#39;</span><br><span class="line">Vue.use(filters);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; filters.js</span><br><span class="line">export default &#123;</span><br><span class="line">  install(Vue)&#123;</span><br><span class="line">    Vue.filter(&#39;dual&#39;, function (value,type) &#123;</span><br><span class="line">      if (!value) return &#39;&#39;;</span><br><span class="line">      if (typeof value !&#x3D;&#x3D; &quot;number&quot;) return alert(value + &#39; 不是数字&#39;);</span><br><span class="line">      if( parseInt(type) &#x3D;&#x3D;&#x3D; 2 )&#123;</span><br><span class="line">        return value &#x3D; value &gt; 10 ? value : &#39;0&#39; + value</span><br><span class="line">      &#125;</span><br><span class="line">      return value</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="五、Vue-数据监听"><a href="#五、Vue-数据监听" class="headerlink" title="五、Vue 数据监听"></a>五、Vue 数据监听</h4><p><a href="https://cn.vuejs.org/v2/api/#watch" target="_blank" rel="noopener">Vue 数据监听 watch</a></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; watch 基本用法与注意事项</span><br><span class="line">data: &#123;</span><br><span class="line">  a: 1,</span><br><span class="line">  e: &#123;</span><br><span class="line">    f: &#123;</span><br><span class="line">      g: 5</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  items: [</span><br><span class="line">    &#123; message: &#39;Foo&#39; &#125;,</span><br><span class="line">    &#123; message: &#39;Bar&#39; &#125;</span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br><span class="line">mounted: function()&#123;</span><br><span class="line">  this.a &#x3D; 2；</span><br><span class="line">  this.e.f.g &#x3D; 10;</span><br><span class="line">  this.$set(this.items, 0, &#123; message: &#39;AAA&#39; &#125;);  &#x2F;&#x2F; $set 赋值</span><br><span class="line">  this.items[0] &#x3D; &#123; message: &#39;AAA&#39; &#125;;  &#x2F;&#x2F; 直接赋值</span><br><span class="line">&#125;,</span><br><span class="line">watch: &#123;</span><br><span class="line">  &#x2F;&#x2F; 最简单最直接的监听方式，能监听简单的数据变化，这种方法默认就是执行 handler: function()&#123;&#125;</span><br><span class="line">  &#x2F;&#x2F; 注意：这种方式监听不到对象的变化</span><br><span class="line">  a: function(val, oldVal)&#123;</span><br><span class="line">    console.log(val);  &#x2F;&#x2F; &#x3D;&gt; 变化之后的数据</span><br><span class="line">    console.log(oldVal); &#x2F;&#x2F; &#x3D;&gt; 变化之前的数据</span><br><span class="line">  &#125;,</span><br><span class="line">  &#x2F;&#x2F; 深度监听，这里要注意一下，这样的方式打印出来两个值都是变化之后的值</span><br><span class="line">  &#x2F;&#x2F; deep 的值默认为false，如果不写或者deep: false 都不能监听到对象值的变化</span><br><span class="line">  e: &#123;</span><br><span class="line">    handler: function (val, oldVal) &#123;</span><br><span class="line">      console.log(val);  &#x2F;&#x2F; &#x3D;&gt; 变化之后的数据</span><br><span class="line">      console.log(oldVal);  &#x2F;&#x2F; &#x3D;&gt; 变化之后的数据</span><br><span class="line">    &#125;,</span><br><span class="line">    deep: true, </span><br><span class="line">  &#125;,</span><br><span class="line">  &#x2F;&#x2F; 如果要精准监听的对象值的变化，可以用这种方法</span><br><span class="line">  &#39;e.f.g&#39;: function (val, oldVal) &#123;</span><br><span class="line">    console.log(val);  &#x2F;&#x2F; &#x3D;&gt; 变化之后的数据</span><br><span class="line">    console.log(oldVal);  &#x2F;&#x2F; &#x3D;&gt; 变化之前的数据</span><br><span class="line">  &#125;,</span><br><span class="line">  &#x2F;&#x2F; 监听数组</span><br><span class="line">  &#x2F;&#x2F; 由于 JavaScript 的限制，Vue 不能检测 this.items[0] &#x3D; &#123; message: &#39;AAA&#39; &#125;; 这种方式赋值的变化</span><br><span class="line">  &#x2F;&#x2F; 所以你要用 $set、或者数组变异的方法赋值</span><br><span class="line">  items: function(val, oldVal)&#123;</span><br><span class="line">    console.log(val);  &#x2F;&#x2F; &#x3D;&gt; 变化之后的数据</span><br><span class="line">    console.log(oldVal);  &#x2F;&#x2F; &#x3D;&gt; 变化之后的数据</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://cn.vuejs.org/v2/guide/list.html#%E6%95%B0%E7%BB%84%E6%9B%B4%E6%96%B0%E6%A3%80%E6%B5%8B" target="_blank" rel="noopener">Vue 数组更新检测</a></p><p>官网的介绍：<strong>由于 JavaScript 的限制，Vue 不能检测以下变动的数组</strong><br>换句话来说：<strong>这样赋值不触发视图更新</strong></p><ul><li>1、当你利用索引直接设置一个项时，例如：</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">this.items[indexOfItem] &#x3D; newValue  &#x2F;&#x2F; indexOfItem 是指数组的index 下标</span><br></pre></td></tr></table></figure><ul><li>2、当你修改数组的长度时，例如：</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">this.items.length &#x3D; newLength</span><br></pre></td></tr></table></figure><p>要解决上面问题，你可以用以下方式解决：</p><h6 id="1、Vue-set-target-key-value-，set方法有下面3个参数"><a href="#1、Vue-set-target-key-value-，set方法有下面3个参数" class="headerlink" title="1、Vue.set( target, key, value) ，set方法有下面3个参数"></a>1、<a href="https://cn.vuejs.org/v2/api/#Vue-set" target="_blank" rel="noopener">Vue.set( target, key, value)</a> ，set方法有下面3个参数</h6><ul><li>{Object | Array} target  – 给谁设置值（对象，数组）都可以</li><li>{string | number} key – 给对象设值，key 就是对象的key，给数组设值，key 就是数组的下标 index</li><li>{any} value – 添加任何值都可以</li></ul><h6 id="2、数组变异的方式"><a href="#2、数组变异的方式" class="headerlink" title="2、数组变异的方式"></a>2、数组变异的方式</h6><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/push" target="_blank" rel="noopener">push()</a>：将一个或多个元素添加到数组的末尾，并返回新数组的长度。<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/pop" target="_blank" rel="noopener">pop()</a>：从数组中删除最后一个元素，并返回该元素的值。此方法更改数组的长度。<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/shift" target="_blank" rel="noopener">shift()</a>：从数组中删除第一个元素，并返回该元素的值。<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/unshift" target="_blank" rel="noopener">unshift()</a>：将一个或多个元素添加到数组的开头，并返回新数组的长度。<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/splice" target="_blank" rel="noopener">splice()</a>：通过删除现有元素和/或添加新元素来更改一个数组的内容。<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/sort" target="_blank" rel="noopener">sort()</a>：用<a href="https://en.wikipedia.org/wiki/Sorting_algorithm#Stability" target="_blank" rel="noopener">就地（ in-place ）的算法</a>对数组的元素进行排序，并返回数组。 sort 排序不一定是<a href="https://zh.wikipedia.org/wiki/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95#.E7.A9.A9.E5.AE.9A.E6.80.A7" target="_blank" rel="noopener">稳定的</a>。默认排序顺序是根据字符串Unicode码点。<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/reverse" target="_blank" rel="noopener">reverse()</a>：将数组中元素的位置颠倒。</p><h4 id="六、Vue-组件"><a href="#六、Vue-组件" class="headerlink" title="六、Vue 组件"></a>六、Vue 组件</h4><p><a href="https://cn.vuejs.org/v2/guide/components.html" target="_blank" rel="noopener">Vue 组件基础</a></p><blockquote><p>组件是可复用的 Vue 实例，所以它们与 new Vue 接收相同的选项，例如 data、computed、watch、methods 以及生命周期钩子等。<br>注意：<strong>组件没有 el 这样根实例特有的选项；而根实例没有 props 这个子组件特有的属性</strong></p></blockquote><ul><li>Vue.component( 组件名 ,{ 选项 }) 全局注册</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 全局注册组件的时候必须写在Vue实例创建之前</span><br><span class="line">&#x2F;&#x2F; 下面这几种方式是等价的</span><br><span class="line">import Vue from &#39;vue&#39;</span><br><span class="line">var MyComponent &#x3D; Vue.extend(&#123;</span><br><span class="line">  template:&quot;&lt;h1&gt;我是全局组件&lt;&#x2F;h1&gt;&quot;</span><br><span class="line">&#125;);</span><br><span class="line">Vue.component(&quot;my-component&quot;,MyComponent);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 注册组件，传入一个扩展过的构造器</span><br><span class="line">Vue.component(&#39;my-component&#39;, Vue.extend(&#123; &#x2F;* ... *&#x2F; &#125;))</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 注册组件，传入一个选项对象 (自动调用 Vue.extend)</span><br><span class="line">Vue.component(&#39;my-component&#39;, &#123; &#x2F;* ... *&#x2F; &#125;)</span><br></pre></td></tr></table></figure><ul><li>通常情况下一个组件肯定是由很多html标签组成的，如果全部写在template 里会非常难看且没有语法高亮提示，有没有其他解决办法？还真有</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 一个定义模板的方式是在一个 &lt;script&gt; 元素中，并为其带上 text&#x2F;x-template 的类型，然后通过一个 id 将模板引用过去。</span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;x-template&quot; id&#x3D;&quot;hello-world-template&quot;&gt;</span><br><span class="line">  &lt;p&gt;Hello hello hello&lt;&#x2F;p&gt;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 另一个定义模板的方式是在一个 &lt;template&gt; 元素中，通过一个 id 将模板引用过去；在单文件组件 .vue 当中，id可以省略；</span><br><span class="line">&lt;template id&#x3D;&quot;hello-world-template&quot;&gt;</span><br><span class="line">  &lt;p&gt;Hello hello hello&lt;&#x2F;p&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">Vue.component(&quot;my-component&quot;,&#123;</span><br><span class="line">    template:&quot;#hello-world-template&quot;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>引入外部单文件组件注册成全局组件</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; .vue </span><br><span class="line">&#x2F;&#x2F; 在单文件组件中 template 标签下只能有一个根元素</span><br><span class="line">&#x2F;&#x2F; 如果硬要有多个根元素，你只能在多个根元素中添加 v-if、v-else-if、v-else 来判断什么时候用哪个根元素</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;home&quot;&gt;</span><br><span class="line">    &lt;p&gt;&#123;&#123;getting&#125;&#125;&lt;&#x2F;p&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">  &lt;!-- &lt;p&gt;这样是不行的&lt;&#x2F;p&gt; --&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    name: &quot;home&quot;,  &#x2F;&#x2F; 便于在vue-devtools 调试中提供更加友好的警告信息</span><br><span class="line">    data: function () &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        getting: &#39;welcome&#39;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">&#x2F;&#x2F; 局部css样式</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; main.js</span><br><span class="line">import home from &#39;.&#x2F;components&#x2F;home&#x2F;home&#39;</span><br><span class="line">Vue.component(&#39;home&#39;,home);</span><br></pre></td></tr></table></figure><ul><li>局部注册组件</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 每个vue 实例都会有一个 components 的选项，而组件是可复用的 Vue 实例，所以每个组件都有components 选项</span><br><span class="line">&#x2F;&#x2F; 引入外部文件注册成局部组件</span><br><span class="line">import home from &#39;.&#x2F;components&#x2F;home&#x2F;home&#39;</span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el:&quot;#app&quot;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    home, &#x2F;&#x2F; 等价于home: home，ES6对象中属性的简洁表示，ES6(http:&#x2F;&#x2F;es6.ruanyifeng.com&#x2F;#docs&#x2F;object)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 直接在components 选项中写，(不推荐这种用法)</span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el:&quot;#app&quot;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    loading: &#123;</span><br><span class="line">      data: function () &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">          getting: &#39;welcome&#39;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      components:&#123;</span><br><span class="line">       &#x2F;&#x2F; 这里还可以嵌套局部组件... </span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li><h6 id="组件间的传值"><a href="#组件间的传值" class="headerlink" title="组件间的传值"></a>组件间的传值</h6></li></ul><p><a href="https://cn.vuejs.org/v2/guide/components-props.html" target="_blank" rel="noopener">通过 Prop 向子组件传递数据</a></p><ul><li>注意：这种传值方式是<a href="https://cn.vuejs.org/v2/guide/components-props.html#%E5%8D%95%E5%90%91%E6%95%B0%E6%8D%AE%E6%B5%81" target="_blank" rel="noopener">单向数据流</a>，不可逆。</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; HTML 中的特性名是大小写不敏感的，所以浏览器会把所有大写字符解释为小写字符。</span><br><span class="line">&#x2F;&#x2F; 这意味着当你使用 DOM 中的模板时，驼峰命名法的 prop 名需要使用其等价的 短横线分隔命名命名。</span><br><span class="line">&#x2F;&#x2F; 如果使用字符串模板，那么这个限制就不存在了。</span><br><span class="line">Vue.component(&#39;my-component&#39;, &#123;</span><br><span class="line">  props: [&#39;myTitle&#39;],</span><br><span class="line">  template: &#39;&lt;h3&gt;&#123;&#123; myTitle&#125;&#125;&lt;&#x2F;h3&gt;&#39;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; HTML</span><br><span class="line">&lt;my-component my-title&#x3D;&#39;hello world&#39;&gt;&lt;&#x2F;my-component&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 上述例子只是一个静态数据传输，如果你要动态传输数据，可以用 v-bind 绑定一个属性</span><br><span class="line">&#x2F;&#x2F; 也可以用v-bind 的缩写形式</span><br><span class="line">&lt;my-component v-bind:my-title&#x3D;&#39;hello world&#39;&gt;&lt;&#x2F;my-component&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 任何类型的值都可以传递给 prop，prop 允许很多个</span><br><span class="line">&#x2F;&#x2F; 如果你想要将一个对象的所有属性都作为 prop 传入，你可以使用不带参数的 v-bind，如：</span><br><span class="line">obj: &#123;</span><br><span class="line">  id: 1,</span><br><span class="line">  title: &#39;Hello World&#39;</span><br><span class="line">&#125;</span><br><span class="line">&lt;my-component v-bind&#x3D;&#39;obj&#39;&gt;&lt;&#x2F;my-component&gt;</span><br><span class="line">&#x2F;&#x2F; 等价于：</span><br><span class="line">&lt;my-component </span><br><span class="line">  v-bind:id&#x3D;&#39;obj.id&#39;</span><br><span class="line">  v-bind:title&#x3D;&#39;obj.title&#39;</span><br><span class="line">&gt;&lt;&#x2F;my-component&gt;</span><br></pre></td></tr></table></figure><p><a href="https://cn.vuejs.org/v2/guide/components-props.html#Prop-%E9%AA%8C%E8%AF%81" target="_blank" rel="noopener">Prop 还提供验证的方式指定传什么值</a></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Vue.component(&#39;my-component&#39;, &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    &#x2F;&#x2F; 基础的类型检查 (&#96;null&#96; 匹配任何类型)</span><br><span class="line">    propA: Number,</span><br><span class="line">    &#x2F;&#x2F; 多个可能的类型</span><br><span class="line">    propB: [String, Number],</span><br><span class="line">    &#x2F;&#x2F; 必填的字符串</span><br><span class="line">    propC: &#123;</span><br><span class="line">      type: String,</span><br><span class="line">      required: true</span><br><span class="line">    &#125;,</span><br><span class="line">    &#x2F;&#x2F; 带有默认值的数字</span><br><span class="line">    propD: &#123;</span><br><span class="line">      type: Number,</span><br><span class="line">      default: 100</span><br><span class="line">    &#125;,</span><br><span class="line">    &#x2F;&#x2F; 带有默认值的对象</span><br><span class="line">    propE: &#123;</span><br><span class="line">      type: Object,</span><br><span class="line">      &#x2F;&#x2F; 对象或数组且一定会从一个工厂函数返回默认值</span><br><span class="line">      default: function () &#123;</span><br><span class="line">        return &#123; message: &#39;hello&#39; &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#x2F;&#x2F; 自定义验证函数</span><br><span class="line">    propF: &#123;</span><br><span class="line">      validator: function (value) &#123;</span><br><span class="line">        &#x2F;&#x2F; 这个值必须匹配下列字符串中的一个</span><br><span class="line">        return [&#39;success&#39;, &#39;warning&#39;, &#39;danger&#39;].indexOf(value) !&#x3D;&#x3D; -1</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>既然 prop 的单向的，那如果子组件向父组件传值怎么办？</p><ul><li>子传父，使用 <a href="https://cn.vuejs.org/v2/guide/components-custom-events.html" target="_blank" rel="noopener">自定义事件</a> 的方式</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 子组件,子组件可以通过$emit() 广播一个事件给父组件</span><br><span class="line">&#x2F;&#x2F; 命名的这个事件名没有限制，子组件与父组件的名字保持一致就可以了</span><br><span class="line">&lt;button v-on:click&#x3D;&quot;$emit(&#39;broadcast&#39;)&quot;&gt;向父组件广播这个事件&lt;&#x2F;button&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; $emit() 这个方法也可以写在 子组件的 methods 里面</span><br><span class="line">&lt;button v-on:click&#x3D;&quot;broadcast&quot;&gt;向父组件广播这个事件&lt;&#x2F;button&gt;</span><br><span class="line">methods: &#123;</span><br><span class="line">  broadcast()&#123;</span><br><span class="line">    this.$emit(&#39;broadcast&#39;)</span><br><span class="line">    &#x2F;&#x2F; 如果要传值，就使用$emit(事件名, 值) 的第二个参数</span><br><span class="line">    this.$emit(&#39;broadcast&#39;, value)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 在父组件中，父组件可以用 v-on 监听子组件触发的 &#96;broadcast&#96; 事件，类似监听Dom 事件一样的用法</span><br><span class="line">&lt;my-component v-on:broadcast&#x3D;&#39;catchYou&#39;&gt;&lt;&#x2F;my-component&gt;</span><br><span class="line">methods: &#123;</span><br><span class="line">  catchYou(val)&#123;</span><br><span class="line">    &#x2F;&#x2F; 子组件传过来的值就会作为第一个参数传入这个方法 </span><br><span class="line">    console.log(val)</span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br><span class="line">&#x2F;&#x2F; 在组件的表达式里面，你可以通过$event 访问到子组件传递过来的值</span><br><span class="line">&lt;my-component v-on:broadcast&#x3D;&#39;$event&#39;&gt;&lt;&#x2F;my-component&gt;</span><br></pre></td></tr></table></figure><ul><li>组件的一些其他用法，感兴趣可以去了解 <a href="https://cn.vuejs.org/v2/guide/components-slots.html" target="_blank" rel="noopener">插槽</a>   <a href="https://cn.vuejs.org/v2/guide/components-dynamic-async.html" target="_blank" rel="noopener">动态组件 &amp; 异步组件</a></li><li><a href="https://cn.vuejs.org/v2/guide/transitions.html#%E5%8D%95%E5%85%83%E7%B4%A0-%E7%BB%84%E4%BB%B6%E7%9A%84%E8%BF%87%E6%B8%A1" target="_blank" rel="noopener">单元素/组件的过渡</a></li></ul><h4 id="七、vue-router"><a href="#七、vue-router" class="headerlink" title="七、vue-router"></a>七、vue-router</h4><ul><li>贴一段 app 构建的案例。官网API <a href="https://router.vuejs.org/zh-cn/essentials/getting-started.html" target="_blank" rel="noopener">点这里</a></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 这里我让 app.vue作为最大的渲染层，渲染tabs --&gt;</span><br><span class="line">&lt;!-- 这里我模拟的是一个商场app，下面几个tab；点击&#96;tab&#96;直接渲染在&#96;tabs&#96;的&lt;router-view&gt;&lt;&#x2F;router-view&gt;上 --&gt;</span><br><span class="line">&lt;!-- tabs 之外的页面直接渲染在app.vue 的&lt;router-view&gt;&lt;&#x2F;router-view&gt;上 --&gt;</span><br><span class="line">&lt;!--  app.vue --&gt;</span><br><span class="line">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">  &lt;router-view&gt;&lt;&#x2F;router-view&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tabs.vue --&gt;</span><br><span class="line">&lt;div class&#x3D;&quot;tabs&quot;&gt;</span><br><span class="line">  &lt;router-view&gt;&lt;&#x2F;router-view&gt;</span><br><span class="line">  &lt;nav class&#x3D;&quot;nav&quot;&gt;</span><br><span class="line">    &lt;router-link class&#x3D;&quot;nav-link&quot; to&#x3D;&quot;home&quot;&gt;</span><br><span class="line">      &lt;i&gt;&lt;&#x2F;i&gt;</span><br><span class="line">      &lt;p&gt;首页&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;&#x2F;router-link&gt;</span><br><span class="line">  &lt;nav&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 以下一些配置是简单要用到的，高级的用法请看官网</span><br><span class="line">&#x2F;&#x2F; router.js</span><br><span class="line">import tabs from &#39;.&#x2F;components&#x2F;tabs&#x2F;tabs&#39;</span><br><span class="line">import home from &#39;.&#x2F;components&#x2F;home&#x2F;home&#39;</span><br><span class="line">const router &#x3D;  new VueRouter(&#123;</span><br><span class="line">  mode: &#39;history&#39;,  &#x2F;&#x2F; 可选值: &quot;hash&quot; 、 &quot;history&quot; 、 &quot;abstract&quot; </span><br><span class="line">  linkActiveClass: &#39;active&#39;,  &#x2F;&#x2F; 默认值: &quot;router-link-active&quot; 全局配置 &lt;router-link&gt; 的默认『激活 class 类名』</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: &quot;&#x2F;tabs&quot;,    &#x2F;&#x2F; 指向的路径</span><br><span class="line">      name: &quot;tabs&quot;,   &#x2F;&#x2F; 命名路由，可以通过这个名称跳转到这个组件</span><br><span class="line">      component: tabs, &#x2F;&#x2F; 指向路径加载的组件</span><br><span class="line">      children: [  &#x2F;&#x2F; 嵌套路由也有跟父级一样的选项</span><br><span class="line">        &#123;</span><br><span class="line">          path:&quot;home&quot;,</span><br><span class="line">          name: &quot;home&quot;,</span><br><span class="line">          component: home, </span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      path: &#39;&#x2F;&#39;,</span><br><span class="line">      redirect: &#39;&#x2F;tabs&#x2F;home&#39;   &#x2F;&#x2F; 重定向，即无目标地址的时候转到这个路径</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;);</span><br><span class="line">export default router;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; main.js</span><br><span class="line">import router from &#39;.&#x2F;router.js&#39;</span><br><span class="line">new Vue(&#123;</span><br><span class="line">  router,</span><br><span class="line">  render: h &#x3D;&gt; h(App)</span><br><span class="line">&#125;).$mount(&#39;#app&#39;);</span><br></pre></td></tr></table></figure><ul><li><a href="https://router.vuejs.org/zh/api/#router-link" target="_blank" rel="noopener">router-link</a> 的几种跳转方式</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 字符串模式，可以说是静态模式，不用v-bind --&gt;</span><br><span class="line">&lt;router-link to&#x3D;&quot;home&quot;&gt;Home&lt;&#x2F;router-link&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 下面几种是动态模式 --&gt;</span><br><span class="line">&lt;!-- 使用 v-bind 的 JS 表达式 --&gt;</span><br><span class="line">&lt;router-link v-bind:to&#x3D;&quot;&#39;home&#39;&quot;&gt;Home&lt;&#x2F;router-link&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 不写 v-bind 也可以，就像绑定别的属性一样 --&gt;</span><br><span class="line">&lt;router-link :to&#x3D;&quot;&#39;home&#39;&quot;&gt;Home&lt;&#x2F;router-link&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 同上 --&gt;</span><br><span class="line">&lt;router-link :to&#x3D;&quot;&#123; path: &#39;home&#39; &#125;&quot;&gt;Home&lt;&#x2F;router-link&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 跳转到命名的路由 --&gt;</span><br><span class="line">&lt;!-- 这里有需要注意的地方是，如果路由有传值，那这里的params 就不能省略--&gt;</span><br><span class="line">&lt;router-link :to&#x3D;&quot;&#123; name: &#39;user&#39; , params: &#123; userId &#125;&#125;&quot;&gt;User&lt;&#x2F;router-link&gt;</span><br></pre></td></tr></table></figure><ul><li>router 传值的几种方式<br><strong>注意：如果提供了 path，params 会被忽略，取而代之的是提供路由的 name 或手写完整的带有参数的 path，同样的规则也适用于 router-link 组件的 to 属性</strong></li><li>另外的传参方式，有兴趣可以了解一下 <a href="https://router.vuejs.org/zh/guide/essentials/passing-props.html#%E5%B8%83%E5%B0%94%E6%A8%A1%E5%BC%8F" target="_blank" rel="noopener">props</a></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 在函数里面</span><br><span class="line">this.$router.push(&#123; name: &#39;user&#39;, params: &#123; userId &#125;&#125;)</span><br><span class="line">this.$router.push(&#123; path: &#96;&#x2F;user&#x2F;$&#123;userId&#125;&#96; &#125;)  &#x2F;&#x2F; &#96;$&#123; &#125;&#96; 是ES6 的模板字符串概念，标识符是 &#96; &#96;</span><br><span class="line">&#x2F;&#x2F; 这里的 params 不生效</span><br><span class="line">this.$router.push(&#123; path: &#39;&#x2F;user&#39;, params: &#123; userId &#125;&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; router-link 传值</span><br><span class="line">&lt;router-link :to&#x3D;&quot;&#123; name: &#39;user&#39;,params: &#123; userId &#125; &#125;&quot;&gt;User&lt;&#x2F;router-link&gt;</span><br><span class="line">&lt;router-link :to&#x3D;&quot;&#123; path: &#96;&#x2F;user&#x2F;$&#123;userId&#125;&#96; &#125;&quot;&gt;User&lt;&#x2F;router-link&gt;</span><br><span class="line">&#x2F;&#x2F; 这里的 params 不生效</span><br><span class="line">&lt;router-link :to&#x3D;&quot;&#123; path: &#39;&#x2F;user&#39;, params: &#123; userId &#125;&#125;&quot;&gt;User&lt;&#x2F;router-link&gt;</span><br></pre></td></tr></table></figure><ul><li>目标组件取值<br><strong>这里要很小心，是 this.$route，不是 this.$router，没有 r 的</strong></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 使用这种方式获取路由传过来的值</span><br><span class="line">this.$route.params.userId</span><br></pre></td></tr></table></figure><ul><li>路由的命名视图，这里贴的是官网的例子，官网API <a href="https://router.vuejs.org/zh/guide/essentials/named-views.html#%E5%B5%8C%E5%A5%97%E5%91%BD%E5%90%8D%E8%A7%86%E5%9B%BE" target="_blank" rel="noopener">点这里</a></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- html --&gt;</span><br><span class="line">&lt;router-view class&#x3D;&quot;view one&quot;&gt;&lt;&#x2F;router-view&gt;</span><br><span class="line">&lt;router-view class&#x3D;&quot;view two&quot; name&#x3D;&quot;a&quot;&gt;&lt;&#x2F;router-view&gt;</span><br><span class="line">&lt;router-view class&#x3D;&quot;view three&quot; name&#x3D;&quot;b&quot;&gt;&lt;&#x2F;router-view&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js</span><br><span class="line">const router &#x3D; new VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: &#39;&#x2F;&#39;,</span><br><span class="line">      components: &#123; &#x2F;&#x2F; 这里的 &#96;components&#96; 要跟上面的 &#96;component&#96; 区分一下，有多个视图渲染的时候有 &#96;s&#96;，别漏了</span><br><span class="line">        default: Foo,  &#x2F;&#x2F; 这是默认指定的 Foo 这个组件，也就是在没有命名的&lt;router-view&gt;上渲染</span><br><span class="line">        a: Bar,  &#x2F;&#x2F; 这里一一对应有 name 属性的&lt;router-view&gt;就可以了</span><br><span class="line">        b: Baz</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>几种导航的方法，官网 <a href="https://router.vuejs.org/zh/guide/essentials/navigation.html" target="_blank" rel="noopener">点这里</a><br>下面几种方法跟 window.history 的几种方法很像，其实就是仿照 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/History" target="_blank" rel="noopener">window.history</a></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 往路由历史新增一条记录，相关参数参考官网</span><br><span class="line">this.$router.push(location, onComplete?, onAbort?)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 替换掉当前的记录</span><br><span class="line">this.$router.replace(location, onComplete?, onAbort?)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 在浏览器记录中前进一步，等同于 this.$router.forward()</span><br><span class="line">this.$router.go(1)</span><br><span class="line">this.$router.forward()</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 后退一步记录，等同于 this.$router.back()</span><br><span class="line">this.$router.go(-1)</span><br><span class="line">this.$router.back()</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 前进 3 步记录</span><br><span class="line">this.$router.go(3)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 如果 history 记录不够用，那就默默地失败呗</span><br><span class="line">this.$router.go(-100)</span><br><span class="line">this.$router.go(100)</span><br></pre></td></tr></table></figure><ul><li>路由跳转的时候支持过度动效，感兴趣可以去玩一下，官网 <a href="https://router.vuejs.org/zh/guide/advanced/transitions.html#%E5%8D%95%E4%B8%AA%E8%B7%AF%E7%94%B1%E7%9A%84%E8%BF%87%E6%B8%A1" target="_blank" rel="noopener">点这里</a> （还有其他更加高级的用法要靠自己去<a href="https://router.vuejs.org/zh/guide/advanced/scroll-behavior.html" target="_blank" rel="noopener">查阅</a>了）</li></ul><h4 id="八、axios"><a href="#八、axios" class="headerlink" title="八、axios"></a>八、axios</h4><p><a href="https://www.npmjs.com/package/axios" target="_blank" rel="noopener">axios 英文文档</a><br><a href="https://www.kancloud.cn/yunye/axios/234845" target="_blank" rel="noopener">axios 中文文档 — 对英文文档的翻译</a><br><strong>axios 是基于 ES6 的 Promise 写的，具体可以看</strong> <a href="http://es6.ruanyifeng.com/#docs/promise" target="_blank" rel="noopener">Promise 相关说明</a></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; npm 安装</span><br><span class="line">npm i axiso  &#x2F;&#x2F; 等价于 npm install axios ，i 是 install 的简写</span><br></pre></td></tr></table></figure><p><strong>axios 的一些简单用法</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; GET 请求</span><br><span class="line">&#x2F;&#x2F; 为给定 ID 的 user 创建请求</span><br><span class="line">axios.get(&#39;&#x2F;user?ID&#x3D;12345&#39;)</span><br><span class="line">  .then(function (response) &#123;</span><br><span class="line">    console.log(response);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(function (error) &#123;</span><br><span class="line">    console.log(error);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 上面的请求可以这样做</span><br><span class="line">axios.get(&#39;&#x2F;user&#39;, &#123;</span><br><span class="line">  params: &#123;</span><br><span class="line">    ID: 12345</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">.then(function (response) &#123;</span><br><span class="line">  console.log(response);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(function (error) &#123;</span><br><span class="line">  console.log(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; POST 请求</span><br><span class="line">axios.post(&#39;&#x2F;user&#39;, &#123;</span><br><span class="line">    firstName: &#39;Fred&#39;,</span><br><span class="line">    lastName: &#39;Flintstone&#39;</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(function (response) &#123;</span><br><span class="line">    console.log(response);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(function (error) &#123;</span><br><span class="line">    console.log(error);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;  执行多个并发请求</span><br><span class="line">function getUserAccount() &#123;</span><br><span class="line">  return axios.get(&#39;&#x2F;user&#x2F;12345&#39;);</span><br><span class="line">&#125;</span><br><span class="line">function getUserPermissions() &#123;</span><br><span class="line">  return axios.get(&#39;&#x2F;user&#x2F;12345&#x2F;permissions&#39;);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 这两个方法返回的都是 Promise 对象，这两个请求方法都成功返回的时候，下面方法才返回成功。</span><br><span class="line">&#x2F;&#x2F; 这两个方法中有一个返回不成功就算返回失败 </span><br><span class="line">axios.all([getUserAccount(), getUserPermissions()])</span><br><span class="line">  .then(axios.spread(function (acct, perms) &#123;</span><br><span class="line">    &#x2F;&#x2F; 两个请求现在都执行完成</span><br><span class="line">  &#125;));</span><br></pre></td></tr></table></figure><p><strong>通过向 axios 传递相关配置来创建请求</strong></p><ul><li>axios(config)</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 发送 POST 请求</span><br><span class="line">axios(&#123;</span><br><span class="line">  method: &#39;post&#39;,</span><br><span class="line">  url: &#39;&#x2F;user&#x2F;12345&#39;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    firstName: &#39;Fred&#39;,</span><br><span class="line">    lastName: &#39;Flintstone&#39;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>axios(url[, config])</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 发送 GET 请求（默认的方法）</span><br><span class="line">axios(&#39;&#x2F;user&#x2F;12345&#39;);</span><br></pre></td></tr></table></figure><p><strong>为方便，axios 还为支持的请求方法提供了别名，如：</strong><br><em>注意：在使用别名方法时， url、method、data 这些属性都不必在配置中指定。</em></p><ul><li>axios.request(config)</li><li>axios.get(url[, config])</li><li>axios.delete(url[, config])</li><li>axios.head(url[, config])</li><li>axios.post(url[, data[, config]])</li><li>axios.put(url[, data[, config]])</li><li>axios.patch(url[, data[, config]])</li></ul><p><strong>处理并发请求的助手函数</strong></p><ul><li>axios.all(iterable)</li><li>axios.spread(callback)</li></ul><p><strong>还有其他高级用法，具体请查阅官网</strong> <a href="https://www.npmjs.com/package/axios" target="_blank" rel="noopener">axios 英文文档</a></p>]]></content>
    
    <summary type="html">
    
      前端体系、前后端分离
    
    </summary>
    
    
      <category term="Vue" scheme="https://SomunsTao.github.io/categories/Vue/"/>
    
    
      <category term="Vue" scheme="https://SomunsTao.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue 11：实战快速上手</title>
    <link href="https://somunstao.github.io/2020/04/21/Vue%2011%EF%BC%9A%E5%AE%9E%E6%88%98%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/"/>
    <id>https://somunstao.github.io/2020/04/21/Vue%2011%EF%BC%9A%E5%AE%9E%E6%88%98%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/</id>
    <published>2020-04-20T16:00:00.000Z</published>
    <updated>2020-08-01T15:19:27.256Z</updated>
    
    <content type="html"><![CDATA[<p>​    </p><h1 id="Vue：实战快速上手"><a href="#Vue：实战快速上手" class="headerlink" title="Vue：实战快速上手"></a>Vue：实战快速上手</h1><p>我们采用实战教学模式并结合 <code>ElementUI</code> 组件库，将所需知识点应用到实际中，以最快速度带领大家掌握 Vue 的使用;</p><h2 id="创建工程"><a href="#创建工程" class="headerlink" title="创建工程"></a>创建工程</h2><p>注意： 命令行都要使用管理员模式运行</p><p>1、创建一个名为 hello-vue 的工程 <code>vue init webpack hello-vue</code><br>2、安装依赖，我们需要安装 vue-router、element-ui、sass-loader 和 node-sass 四个插件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 进入工程目录</span><br><span class="line">cd hello-vue</span><br><span class="line"># 安装 vue-router</span><br><span class="line">npm install vue-router --save-dev</span><br><span class="line"># 安装 element-ui</span><br><span class="line">npm i element-ui -S</span><br><span class="line"># 安装依赖</span><br><span class="line">npm install</span><br><span class="line"># 安装 SASS 加载器</span><br><span class="line">cnpm install sass-loader node-sass --save-dev</span><br><span class="line"># 启动测试</span><br><span class="line">npm run dev</span><br></pre></td></tr></table></figure><p>3、Npm命令解释：</p><ul><li><code>npm install moduleName</code>：安装模块到项目目录下</li><li><code>npm install -g moduleName</code>：-g 的意思是将模块安装到全局，具体安装到磁盘哪个位置，要看 npm config prefix 的位置</li><li><code>npm install -save moduleName</code>：–save 的意思是将模块安装到项目目录下，并在 package 文件的 dependencies 节点写入依赖，-S 为该命令的缩写</li><li><code>npm install -save-dev moduleNam</code>e：–save-dev 的意思是将模块安装到项目目录下，并在 package 文件的 devDependencies 节点写入依赖，-D 为该命令的缩写</li></ul><h2 id="创建登录页面"><a href="#创建登录页面" class="headerlink" title="创建登录页面"></a>创建登录页面</h2><p>把没有用的初始化东西删掉！</p><p>在源码目录中创建如下结构：</p><ul><li>assets：用于存放资源文件</li><li>components：用于存放 Vue 功能组件</li><li>views：用于存放 Vue 视图组件</li><li>router：用于存放 vue-router 配置</li></ul><p><img src="https://blog.kuangstudy.com/usr/uploads/2019/10/1596391106.jpg" alt="QQ截图20191025101406.jpg"></p><p><strong>创建首页视图，在 views 目录下创建一个名为 Main.vue 的视图组件；</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      首页</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    export default &#123;</span><br><span class="line">        name: &quot;Main&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure><p><strong>创建登录页视图在 views 目录下创建一个名为 Login.vue 的视图组件，其中 el-* 的元素为 ElementUI 组件；</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;el-form ref&#x3D;&quot;loginForm&quot; :model&#x3D;&quot;form&quot; :rules&#x3D;&quot;rules&quot; label-width&#x3D;&quot;80px&quot; class&#x3D;&quot;login-box&quot;&gt;</span><br><span class="line">      &lt;h3 class&#x3D;&quot;login-title&quot;&gt;欢迎登录&lt;&#x2F;h3&gt;</span><br><span class="line">      &lt;el-form-item label&#x3D;&quot;账号&quot; prop&#x3D;&quot;username&quot;&gt;</span><br><span class="line">        &lt;el-input type&#x3D;&quot;text&quot; placeholder&#x3D;&quot;请输入账号&quot; v-model&#x3D;&quot;form.username&quot;&#x2F;&gt;</span><br><span class="line">      &lt;&#x2F;el-form-item&gt;</span><br><span class="line">      &lt;el-form-item label&#x3D;&quot;密码&quot; prop&#x3D;&quot;password&quot;&gt;</span><br><span class="line">        &lt;el-input type&#x3D;&quot;password&quot; placeholder&#x3D;&quot;请输入密码&quot; v-model&#x3D;&quot;form.password&quot;&#x2F;&gt;</span><br><span class="line">      &lt;&#x2F;el-form-item&gt;</span><br><span class="line">      &lt;el-form-item&gt;</span><br><span class="line">        &lt;el-button type&#x3D;&quot;primary&quot; v-on:click&#x3D;&quot;onSubmit(&#39;loginForm&#39;)&quot;&gt;登录&lt;&#x2F;el-button&gt;</span><br><span class="line">      &lt;&#x2F;el-form-item&gt;</span><br><span class="line">    &lt;&#x2F;el-form&gt;</span><br><span class="line"></span><br><span class="line">    &lt;el-dialog</span><br><span class="line">      title&#x3D;&quot;温馨提示&quot;</span><br><span class="line">      :visible.sync&#x3D;&quot;dialogVisible&quot;</span><br><span class="line">      width&#x3D;&quot;30%&quot;</span><br><span class="line">      :before-close&#x3D;&quot;handleClose&quot;&gt;</span><br><span class="line">      &lt;span&gt;请输入账号和密码&lt;&#x2F;span&gt;</span><br><span class="line">      &lt;span slot&#x3D;&quot;footer&quot; class&#x3D;&quot;dialog-footer&quot;&gt;</span><br><span class="line">        &lt;el-button type&#x3D;&quot;primary&quot; @click&#x3D;&quot;dialogVisible &#x3D; false&quot;&gt;确 定&lt;&#x2F;el-button&gt;</span><br><span class="line">      &lt;&#x2F;span&gt;</span><br><span class="line">    &lt;&#x2F;el-dialog&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    name: &quot;Login&quot;,</span><br><span class="line">    data() &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        form: &#123;</span><br><span class="line">          username: &#39;&#39;,</span><br><span class="line">          password: &#39;&#39;</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 表单验证，需要在 el-form-item 元素中增加 prop 属性</span><br><span class="line">        rules: &#123;</span><br><span class="line">          username: [</span><br><span class="line">            &#123;required: true, message: &#39;账号不可为空&#39;, trigger: &#39;blur&#39;&#125;</span><br><span class="line">          ],</span><br><span class="line">          password: [</span><br><span class="line">            &#123;required: true, message: &#39;密码不可为空&#39;, trigger: &#39;blur&#39;&#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 对话框显示和隐藏</span><br><span class="line">        dialogVisible: false</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      onSubmit(formName) &#123;</span><br><span class="line">        &#x2F;&#x2F; 为表单绑定验证功能</span><br><span class="line">        this.$refs[formName].validate((valid) &#x3D;&gt; &#123;</span><br><span class="line">          if (valid) &#123;</span><br><span class="line">            &#x2F;&#x2F; 使用 vue-router 路由到指定页面，该方式称之为编程式导航</span><br><span class="line">            this.$router.push(&quot;&#x2F;main&quot;);</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">            this.dialogVisible &#x3D; true;</span><br><span class="line">            return false;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style lang&#x3D;&quot;scss&quot; scoped&gt;</span><br><span class="line">  .login-box &#123;</span><br><span class="line">    border: 1px solid #DCDFE6;</span><br><span class="line">    width: 350px;</span><br><span class="line">    margin: 180px auto;</span><br><span class="line">    padding: 35px 35px 15px 35px;</span><br><span class="line">    border-radius: 5px;</span><br><span class="line">    -webkit-border-radius: 5px;</span><br><span class="line">    -moz-border-radius: 5px;</span><br><span class="line">    box-shadow: 0 0 25px #909399;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  .login-title &#123;</span><br><span class="line">    text-align: center;</span><br><span class="line">    margin: 0 auto 40px auto;</span><br><span class="line">    color: #303133;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure><p><strong>创建路由,在 router 目录下创建一个名为 index.js 的 vue-router 路由配置文件</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import Vue from &#39;vue&#39;</span><br><span class="line">import Router from &#39;vue-router&#39;</span><br><span class="line"></span><br><span class="line">import Login from &quot;..&#x2F;views&#x2F;Login&quot;</span><br><span class="line">import Main from &#39;..&#x2F;views&#x2F;Main&#39;</span><br><span class="line"></span><br><span class="line">Vue.use(Router);</span><br><span class="line"></span><br><span class="line">export default new Router(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      &#x2F;&#x2F; 登录页</span><br><span class="line">      path: &#39;&#x2F;login&#39;,</span><br><span class="line">      name: &#39;Login&#39;,</span><br><span class="line">      component: Login</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &#x2F;&#x2F; 首页</span><br><span class="line">      path: &#39;&#x2F;main&#39;,</span><br><span class="line">      name: &#39;Main&#39;,</span><br><span class="line">      component: Main</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>配置路由，修改入口代码，修改 main.js 入口代码</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import Vue from &#39;vue&#39;</span><br><span class="line">import VueRouter from &#39;vue-router&#39;</span><br><span class="line">import router from &#39;.&#x2F;router&#39;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 导入 ElementUI</span><br><span class="line">import ElementUI from &#39;element-ui&#39;</span><br><span class="line">import &#39;element-ui&#x2F;lib&#x2F;theme-chalk&#x2F;index.css&#39;</span><br><span class="line"></span><br><span class="line">import App from &#39;.&#x2F;App&#39;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 安装路由</span><br><span class="line">Vue.use(VueRouter);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 安装 ElementUI</span><br><span class="line">Vue.use(ElementUI);</span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: &#39;#app&#39;,</span><br><span class="line">  &#x2F;&#x2F; 启用路由</span><br><span class="line">  router,</span><br><span class="line">  &#x2F;&#x2F; 启用 ElementUI</span><br><span class="line">  render: h &#x3D;&gt; h(App)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>修改 App.vue 组件代码</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">    &lt;router-view&#x2F;&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    name: &#39;App&#39;,</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>测试 ： 在浏览器打开 <a href="http://localhost/" target="_blank" rel="noopener">http://localhost</a>:8080/#/login</p><p>如果出现错误: 可能是因为sass-loader的版本过高导致的编译错误，当前最高版本是8.x，需要退回到7.3.1 ；</p><p>去package.json文件里面的 “sass-loader”的版本更换成7.3.1，然后重新<code>cnpm install</code>就可以了；</p><p><img src="https://blog.kuangstudy.com/usr/uploads/2019/10/1972241333.jpg" alt="QQ截图20191025111608.jpg"></p><h2 id="路由嵌套"><a href="#路由嵌套" class="headerlink" title="路由嵌套"></a>路由嵌套</h2><p>嵌套路由又称子路由，在实际应用中，通常由多层嵌套的组件组合而成。同样地，URL 中各段动态路径也按某种结构对应嵌套的各层组件，例如：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;user&#x2F;foo&#x2F;profile                     &#x2F;user&#x2F;foo&#x2F;posts</span><br><span class="line">+------------------+                  +-----------------+</span><br><span class="line">| User             |                  | User            |</span><br><span class="line">| +--------------+ |                  | +-------------+ |</span><br><span class="line">| | Profile      | |  +------------&gt;  | | Posts       | |</span><br><span class="line">| |              | |                  | |             | |</span><br><span class="line">| +--------------+ |                  | +-------------+ |</span><br><span class="line">+------------------+                  +-----------------+</span><br></pre></td></tr></table></figure><p>1、用户信息组件，在 views/user 目录下创建一个名为 Profile.vue 的视图组件；</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      个人信息</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    export default &#123;</span><br><span class="line">        name: &quot;UserProfile&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure><p>2、用户列表组件在 views/user 目录下创建一个名为 List.vue 的视图组件；</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      用户列表</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    export default &#123;</span><br><span class="line">        name: &quot;UserList&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure><p>3、配置嵌套路由修改 router 目录下的 index.js 路由配置文件，代码如</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import Vue from &#39;vue&#39;</span><br><span class="line">import Router from &#39;vue-router&#39;</span><br><span class="line"></span><br><span class="line">import Login from &quot;..&#x2F;views&#x2F;Login&quot;</span><br><span class="line">import Main from &#39;..&#x2F;views&#x2F;Main&#39;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 用于嵌套的路由组件</span><br><span class="line">import UserProfile from &#39;..&#x2F;views&#x2F;user&#x2F;Profile&#39;</span><br><span class="line">import UserList from &#39;..&#x2F;views&#x2F;user&#x2F;List&#39;</span><br><span class="line"></span><br><span class="line">Vue.use(Router);</span><br><span class="line"></span><br><span class="line">export default new Router(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      &#x2F;&#x2F; 登录页</span><br><span class="line">      path: &#39;&#x2F;login&#39;,</span><br><span class="line">      name: &#39;Login&#39;,</span><br><span class="line">      component: Login</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &#x2F;&#x2F; 首页</span><br><span class="line">      path: &#39;&#x2F;main&#39;,</span><br><span class="line">      name: &#39;Main&#39;,</span><br><span class="line">      component: Main,</span><br><span class="line">      &#x2F;&#x2F; 配置嵌套路由</span><br><span class="line">      children: [</span><br><span class="line">        &#123;path: &#39;&#x2F;user&#x2F;profile&#39;, component: UserProfile&#125;,</span><br><span class="line">        &#123;path: &#39;&#x2F;user&#x2F;list&#39;, component: UserList&#125;,</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>说明：主要在路由配置中增加了 children 数组配置，用于在该组件下设置嵌套路由</p><p>4、修改首页视图，我们修改 Main.vue 视图组件，此处使用了 ElementUI 布局容器组件，代码如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;el-container&gt;</span><br><span class="line">        &lt;el-aside width&#x3D;&quot;200px&quot;&gt;</span><br><span class="line">          &lt;el-menu :default-openeds&#x3D;&quot;[&#39;1&#39;]&quot;&gt;</span><br><span class="line">            &lt;el-submenu index&#x3D;&quot;1&quot;&gt;</span><br><span class="line">              &lt;template slot&#x3D;&quot;title&quot;&gt;&lt;i class&#x3D;&quot;el-icon-caret-right&quot;&gt;&lt;&#x2F;i&gt;用户管理&lt;&#x2F;template&gt;</span><br><span class="line">              &lt;el-menu-item-group&gt;</span><br><span class="line">                &lt;el-menu-item index&#x3D;&quot;1-1&quot;&gt;</span><br><span class="line">                  &lt;router-link to&#x3D;&quot;&#x2F;user&#x2F;profile&quot;&gt;个人信息&lt;&#x2F;router-link&gt;</span><br><span class="line">                &lt;&#x2F;el-menu-item&gt;</span><br><span class="line">                &lt;el-menu-item index&#x3D;&quot;1-2&quot;&gt;</span><br><span class="line">                  &lt;router-link to&#x3D;&quot;&#x2F;user&#x2F;list&quot;&gt;用户列表&lt;&#x2F;router-link&gt;</span><br><span class="line">                &lt;&#x2F;el-menu-item&gt;</span><br><span class="line">              &lt;&#x2F;el-menu-item-group&gt;</span><br><span class="line">            &lt;&#x2F;el-submenu&gt;</span><br><span class="line">            &lt;el-submenu index&#x3D;&quot;2&quot;&gt;</span><br><span class="line">              &lt;template slot&#x3D;&quot;title&quot;&gt;&lt;i class&#x3D;&quot;el-icon-caret-right&quot;&gt;&lt;&#x2F;i&gt;内容管理&lt;&#x2F;template&gt;</span><br><span class="line">              &lt;el-menu-item-group&gt;</span><br><span class="line">                &lt;el-menu-item index&#x3D;&quot;2-1&quot;&gt;分类管理&lt;&#x2F;el-menu-item&gt;</span><br><span class="line">                &lt;el-menu-item index&#x3D;&quot;2-2&quot;&gt;内容列表&lt;&#x2F;el-menu-item&gt;</span><br><span class="line">              &lt;&#x2F;el-menu-item-group&gt;</span><br><span class="line">            &lt;&#x2F;el-submenu&gt;</span><br><span class="line">          &lt;&#x2F;el-menu&gt;</span><br><span class="line">        &lt;&#x2F;el-aside&gt;</span><br><span class="line"></span><br><span class="line">        &lt;el-container&gt;</span><br><span class="line">          &lt;el-header style&#x3D;&quot;text-align: right; font-size: 12px&quot;&gt;</span><br><span class="line">            &lt;el-dropdown&gt;</span><br><span class="line">              &lt;i class&#x3D;&quot;el-icon-setting&quot; style&#x3D;&quot;margin-right: 15px&quot;&gt;&lt;&#x2F;i&gt;</span><br><span class="line">              &lt;el-dropdown-menu slot&#x3D;&quot;dropdown&quot;&gt;</span><br><span class="line">                &lt;el-dropdown-item&gt;个人信息&lt;&#x2F;el-dropdown-item&gt;</span><br><span class="line">                &lt;el-dropdown-item&gt;退出登录&lt;&#x2F;el-dropdown-item&gt;</span><br><span class="line">              &lt;&#x2F;el-dropdown-menu&gt;</span><br><span class="line">            &lt;&#x2F;el-dropdown&gt;</span><br><span class="line">          &lt;&#x2F;el-header&gt;</span><br><span class="line"></span><br><span class="line">          &lt;el-main&gt;</span><br><span class="line">            &lt;router-view &#x2F;&gt;</span><br><span class="line">          &lt;&#x2F;el-main&gt;</span><br><span class="line">        &lt;&#x2F;el-container&gt;</span><br><span class="line">      &lt;&#x2F;el-container&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    export default &#123;</span><br><span class="line">        name: &quot;Main&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped lang&#x3D;&quot;scss&quot;&gt;</span><br><span class="line">  .el-header &#123;</span><br><span class="line">    background-color: #B3C0D1;</span><br><span class="line">    color: #333;</span><br><span class="line">    line-height: 60px;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  .el-aside &#123;</span><br><span class="line">    color: #333;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure><p>说明：</p><p>在 <el-main> 元素中配置了 <router-view /> 用于展示嵌套路由,主要使用 <router-link to="/user/profile">个人信息</router-link> 展示嵌套路由内容</p><h2 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h2><p>我们经常需要把某种模式匹配到的所有路由，全都映射到同个组件。例如，我们有一个 User 组件，对于所有 ID 各不相同的用户，都要使用这个组件来渲染。此时我们就需要传递参数了；</p><p>1、修改路由配置, 主要是在 path 属性中增加了 :id 这样的占位符</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;path: &#39;&#x2F;user&#x2F;profile&#x2F;:id&#39;, name:&#39;UserProfile&#39;, component: UserProfile&#125;</span><br></pre></td></tr></table></figure><p>2、传递参数</p><p>此时我们将 to 改为了 :to，是为了将这一属性当成对象使用，注意 router-link 中的 name 属性名称 一定要和 路由中的 name 属性名称 匹配，因为这样 Vue 才能找到对应的路由路径；</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;router-link :to&#x3D;&quot;&#123;name: &#39;UserProfile&#39;, params: &#123;id: 1&#125;&#125;&quot;&gt;个人信息&lt;&#x2F;router-link&gt;</span><br></pre></td></tr></table></figure><p>3、接收参数, 在目标组件中</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&#123; $route.params.id &#125;&#125;</span><br></pre></td></tr></table></figure><h3 id="使用-props-的方式"><a href="#使用-props-的方式" class="headerlink" title="使用 props 的方式"></a>使用 props 的方式</h3><p>1、修改路由配置 , 主要增加了 props: true 属性</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;path: &#39;&#x2F;user&#x2F;profile&#x2F;:id&#39;, name:&#39;UserProfile&#39;, component: UserProfile, props: true&#125;</span><br></pre></td></tr></table></figure><p>2、传递参数和之前一样<br>3、接收参数为目标组件增加 props 属性</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    个人信息</span><br><span class="line">    &#123;&#123; id &#125;&#125;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    export default &#123;</span><br><span class="line">      props: [&#39;id&#39;],</span><br><span class="line">      name: &quot;UserProfile&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure><h2 id="组件重定向"><a href="#组件重定向" class="headerlink" title="组件重定向"></a>组件重定向</h2><p>重定向的意思大家都明白，但 Vue 中的重定向是作用在路径不同但组件相同的情况下，比如：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  path: &#39;&#x2F;main&#39;,</span><br><span class="line">  name: &#39;Main&#39;,</span><br><span class="line">  component: Main</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">  path: &#39;&#x2F;goHome&#39;,</span><br><span class="line">  redirect: &#39;&#x2F;main&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：这里定义了两个路径，一个是 /main ，一个是 /goHome，其中 /goHome 重定向到了 /main 路径，由此可以看出重定向不需要定义组件；</p><p>使用的话，只需要设置对应路径即可；</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;el-menu-item index&#x3D;&quot;1-3&quot;&gt;</span><br><span class="line">    &lt;router-link to&#x3D;&quot;&#x2F;goHome&quot;&gt;回到首页&lt;&#x2F;router-link&gt;</span><br><span class="line">&lt;&#x2F;el-menu-item&gt;</span><br></pre></td></tr></table></figure><h2 id="路由模式与-404"><a href="#路由模式与-404" class="headerlink" title="路由模式与 404"></a>路由模式与 404</h2><p>路由模式有两种</p><ul><li>hash：路径带 # 符号，如 <a href="http://localhost/#/login" target="_blank" rel="noopener">http://localhost/#/login</a></li><li>history：路径不带 # 符号，如 <a href="http://localhost/login" target="_blank" rel="noopener">http://localhost/login</a></li></ul><p>修改路由配置，代码如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export default new Router(&#123;</span><br><span class="line">  mode: &#39;history&#39;,</span><br><span class="line">  routes: [</span><br><span class="line">  ]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>处理 404</strong> 创建一个名为 <code>NotFound.vue</code> 的视图组件，代码如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    页面不存在，请重试！</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    name: &quot;NotFount&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure><p>修改路由配置，代码如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import NotFound from &#39;..&#x2F;views&#x2F;NotFound&#39;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">   path: &#39;*&#39;,</span><br><span class="line">   component: NotFound</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="路由钩子与异步请求"><a href="#路由钩子与异步请求" class="headerlink" title="路由钩子与异步请求"></a>路由钩子与异步请求</h3><p><code>beforeRouteEnter</code>：在进入路由前执行<br><code>beforeRouteLeave</code>：在离开路由前执行</p><p>上代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">  props: [&#39;id&#39;],</span><br><span class="line">  name: &quot;UserProfile&quot;,</span><br><span class="line">  beforeRouteEnter: (to, from, next) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&quot;准备进入个人信息页&quot;);</span><br><span class="line">    next();</span><br><span class="line">  &#125;,</span><br><span class="line">  beforeRouteLeave: (to, from, next) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&quot;准备离开个人信息页&quot;);</span><br><span class="line">    next();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li>to：路由将要跳转的路径信息</li><li>from：路径跳转前的路径信息</li><li>next：路由的控制参数<ul><li>next() 跳入下一个页面</li><li>next(‘/path’) 改变路由的跳转方向，使其跳到另一个路由</li><li>next(false) 返回原来的页面</li><li>next((vm)=&gt;{}) 仅在 beforeRouteEnter 中可用，vm 是组件实例</li></ul></li></ul><p><strong>在钩子函数中使用异步请求</strong></p><p>1、安装 Axios <code>cnpm install axios -s</code><br>2、<code>main.js</code>引用 Axios</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import axios from &#39;axios&#39;</span><br><span class="line">Vue.prototype.axios &#x3D; axios;</span><br></pre></td></tr></table></figure><p>3、准备数据 ： 只有我们的 static 目录下的文件是可以被访问到的，所以我们就把静态文件放入该目录下。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 静态数据存放的位置</span><br><span class="line">static&#x2F;mock&#x2F;data.json</span><br></pre></td></tr></table></figure><p>4、在 beforeRouteEnter 中进行异步请求</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">   props: [&#39;id&#39;],</span><br><span class="line">   name: &quot;UserProfile&quot;,</span><br><span class="line">   beforeRouteEnter: (to, from, next) &#x3D;&gt; &#123;</span><br><span class="line">     console.log(&quot;准备进入个人信息页&quot;);</span><br><span class="line">     &#x2F;&#x2F; 注意，一定要在 next 中请求，因为该方法调用时 Vue 实例还没有创建，此时无法获取到 this 对象，在这里使用官方提供的回调函数拿到当前实例</span><br><span class="line">     next(vm &#x3D;&gt; &#123;</span><br><span class="line">       vm.getData();</span><br><span class="line">     &#125;);</span><br><span class="line">   &#125;,</span><br><span class="line">   beforeRouteLeave: (to, from, next) &#x3D;&gt; &#123;</span><br><span class="line">     console.log(&quot;准备离开个人信息页&quot;);</span><br><span class="line">     next();</span><br><span class="line">   &#125;,</span><br><span class="line">   methods: &#123;</span><br><span class="line">     getData: function () &#123;</span><br><span class="line">       this.axios(&#123;</span><br><span class="line">         method: &#39;get&#39;,</span><br><span class="line">         url: &#39;http:&#x2F;&#x2F;localhost:8080&#x2F;static&#x2F;mock&#x2F;data.json&#39;</span><br><span class="line">       &#125;).then(function (repos) &#123;</span><br><span class="line">         console.log(repos);</span><br><span class="line">       &#125;).catch(function (error) &#123;</span><br><span class="line">         console.log(error);</span><br><span class="line">       &#125;);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      前端体系、前后端分离
    
    </summary>
    
    
      <category term="Vue" scheme="https://SomunsTao.github.io/categories/Vue/"/>
    
    
      <category term="Vue" scheme="https://SomunsTao.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue 10：实战快速上手</title>
    <link href="https://somunstao.github.io/2020/04/20/Vue%2010%EF%BC%9A%E5%AE%9E%E6%88%98%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/"/>
    <id>https://somunstao.github.io/2020/04/20/Vue%2010%EF%BC%9A%E5%AE%9E%E6%88%98%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/</id>
    <published>2020-04-19T16:00:00.000Z</published>
    <updated>2020-08-01T15:19:07.123Z</updated>
    
    <content type="html"><![CDATA[<p>​    </p><h1 id="Vue：实战快速上手"><a href="#Vue：实战快速上手" class="headerlink" title="Vue：实战快速上手"></a>Vue：实战快速上手</h1><p>我们采用实战教学模式并结合 <code>ElementUI</code> 组件库，将所需知识点应用到实际中，以最快速度带领大家掌握 Vue 的使用;</p><h2 id="创建工程"><a href="#创建工程" class="headerlink" title="创建工程"></a>创建工程</h2><p>注意： 命令行都要使用管理员模式运行</p><p>1、创建一个名为 hello-vue 的工程 <code>vue init webpack hello-vue</code><br>2、安装依赖，我们需要安装 vue-router、element-ui、sass-loader 和 node-sass 四个插件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 进入工程目录</span><br><span class="line">cd hello-vue</span><br><span class="line"># 安装 vue-router</span><br><span class="line">npm install vue-router --save-dev</span><br><span class="line"># 安装 element-ui</span><br><span class="line">npm i element-ui -S</span><br><span class="line"># 安装依赖</span><br><span class="line">npm install</span><br><span class="line"># 安装 SASS 加载器</span><br><span class="line">cnpm install sass-loader node-sass --save-dev</span><br><span class="line"># 启动测试</span><br><span class="line">npm run dev</span><br></pre></td></tr></table></figure><p>3、Npm命令解释：</p><ul><li><code>npm install moduleName</code>：安装模块到项目目录下</li><li><code>npm install -g moduleName</code>：-g 的意思是将模块安装到全局，具体安装到磁盘哪个位置，要看 npm config prefix 的位置</li><li><code>npm install -save moduleName</code>：–save 的意思是将模块安装到项目目录下，并在 package 文件的 dependencies 节点写入依赖，-S 为该命令的缩写</li><li><code>npm install -save-dev moduleNam</code>e：–save-dev 的意思是将模块安装到项目目录下，并在 package 文件的 devDependencies 节点写入依赖，-D 为该命令的缩写</li></ul><h2 id="创建登录页面"><a href="#创建登录页面" class="headerlink" title="创建登录页面"></a>创建登录页面</h2><p>把没有用的初始化东西删掉！</p><p>在源码目录中创建如下结构：</p><ul><li>assets：用于存放资源文件</li><li>components：用于存放 Vue 功能组件</li><li>views：用于存放 Vue 视图组件</li><li>router：用于存放 vue-router 配置</li></ul><p><img src="https://blog.kuangstudy.com/usr/uploads/2019/10/1596391106.jpg" alt="QQ截图20191025101406.jpg"></p><p><strong>创建首页视图，在 views 目录下创建一个名为 Main.vue 的视图组件；</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      首页</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    export default &#123;</span><br><span class="line">        name: &quot;Main&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure><p><strong>创建登录页视图在 views 目录下创建一个名为 Login.vue 的视图组件，其中 el-* 的元素为 ElementUI 组件；</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;el-form ref&#x3D;&quot;loginForm&quot; :model&#x3D;&quot;form&quot; :rules&#x3D;&quot;rules&quot; label-width&#x3D;&quot;80px&quot; class&#x3D;&quot;login-box&quot;&gt;</span><br><span class="line">      &lt;h3 class&#x3D;&quot;login-title&quot;&gt;欢迎登录&lt;&#x2F;h3&gt;</span><br><span class="line">      &lt;el-form-item label&#x3D;&quot;账号&quot; prop&#x3D;&quot;username&quot;&gt;</span><br><span class="line">        &lt;el-input type&#x3D;&quot;text&quot; placeholder&#x3D;&quot;请输入账号&quot; v-model&#x3D;&quot;form.username&quot;&#x2F;&gt;</span><br><span class="line">      &lt;&#x2F;el-form-item&gt;</span><br><span class="line">      &lt;el-form-item label&#x3D;&quot;密码&quot; prop&#x3D;&quot;password&quot;&gt;</span><br><span class="line">        &lt;el-input type&#x3D;&quot;password&quot; placeholder&#x3D;&quot;请输入密码&quot; v-model&#x3D;&quot;form.password&quot;&#x2F;&gt;</span><br><span class="line">      &lt;&#x2F;el-form-item&gt;</span><br><span class="line">      &lt;el-form-item&gt;</span><br><span class="line">        &lt;el-button type&#x3D;&quot;primary&quot; v-on:click&#x3D;&quot;onSubmit(&#39;loginForm&#39;)&quot;&gt;登录&lt;&#x2F;el-button&gt;</span><br><span class="line">      &lt;&#x2F;el-form-item&gt;</span><br><span class="line">    &lt;&#x2F;el-form&gt;</span><br><span class="line"></span><br><span class="line">    &lt;el-dialog</span><br><span class="line">      title&#x3D;&quot;温馨提示&quot;</span><br><span class="line">      :visible.sync&#x3D;&quot;dialogVisible&quot;</span><br><span class="line">      width&#x3D;&quot;30%&quot;</span><br><span class="line">      :before-close&#x3D;&quot;handleClose&quot;&gt;</span><br><span class="line">      &lt;span&gt;请输入账号和密码&lt;&#x2F;span&gt;</span><br><span class="line">      &lt;span slot&#x3D;&quot;footer&quot; class&#x3D;&quot;dialog-footer&quot;&gt;</span><br><span class="line">        &lt;el-button type&#x3D;&quot;primary&quot; @click&#x3D;&quot;dialogVisible &#x3D; false&quot;&gt;确 定&lt;&#x2F;el-button&gt;</span><br><span class="line">      &lt;&#x2F;span&gt;</span><br><span class="line">    &lt;&#x2F;el-dialog&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    name: &quot;Login&quot;,</span><br><span class="line">    data() &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        form: &#123;</span><br><span class="line">          username: &#39;&#39;,</span><br><span class="line">          password: &#39;&#39;</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 表单验证，需要在 el-form-item 元素中增加 prop 属性</span><br><span class="line">        rules: &#123;</span><br><span class="line">          username: [</span><br><span class="line">            &#123;required: true, message: &#39;账号不可为空&#39;, trigger: &#39;blur&#39;&#125;</span><br><span class="line">          ],</span><br><span class="line">          password: [</span><br><span class="line">            &#123;required: true, message: &#39;密码不可为空&#39;, trigger: &#39;blur&#39;&#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 对话框显示和隐藏</span><br><span class="line">        dialogVisible: false</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      onSubmit(formName) &#123;</span><br><span class="line">        &#x2F;&#x2F; 为表单绑定验证功能</span><br><span class="line">        this.$refs[formName].validate((valid) &#x3D;&gt; &#123;</span><br><span class="line">          if (valid) &#123;</span><br><span class="line">            &#x2F;&#x2F; 使用 vue-router 路由到指定页面，该方式称之为编程式导航</span><br><span class="line">            this.$router.push(&quot;&#x2F;main&quot;);</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">            this.dialogVisible &#x3D; true;</span><br><span class="line">            return false;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style lang&#x3D;&quot;scss&quot; scoped&gt;</span><br><span class="line">  .login-box &#123;</span><br><span class="line">    border: 1px solid #DCDFE6;</span><br><span class="line">    width: 350px;</span><br><span class="line">    margin: 180px auto;</span><br><span class="line">    padding: 35px 35px 15px 35px;</span><br><span class="line">    border-radius: 5px;</span><br><span class="line">    -webkit-border-radius: 5px;</span><br><span class="line">    -moz-border-radius: 5px;</span><br><span class="line">    box-shadow: 0 0 25px #909399;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  .login-title &#123;</span><br><span class="line">    text-align: center;</span><br><span class="line">    margin: 0 auto 40px auto;</span><br><span class="line">    color: #303133;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure><p><strong>创建路由,在 router 目录下创建一个名为 index.js 的 vue-router 路由配置文件</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import Vue from &#39;vue&#39;</span><br><span class="line">import Router from &#39;vue-router&#39;</span><br><span class="line"></span><br><span class="line">import Login from &quot;..&#x2F;views&#x2F;Login&quot;</span><br><span class="line">import Main from &#39;..&#x2F;views&#x2F;Main&#39;</span><br><span class="line"></span><br><span class="line">Vue.use(Router);</span><br><span class="line"></span><br><span class="line">export default new Router(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      &#x2F;&#x2F; 登录页</span><br><span class="line">      path: &#39;&#x2F;login&#39;,</span><br><span class="line">      name: &#39;Login&#39;,</span><br><span class="line">      component: Login</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &#x2F;&#x2F; 首页</span><br><span class="line">      path: &#39;&#x2F;main&#39;,</span><br><span class="line">      name: &#39;Main&#39;,</span><br><span class="line">      component: Main</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>配置路由，修改入口代码，修改 main.js 入口代码</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import Vue from &#39;vue&#39;</span><br><span class="line">import VueRouter from &#39;vue-router&#39;</span><br><span class="line">import router from &#39;.&#x2F;router&#39;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 导入 ElementUI</span><br><span class="line">import ElementUI from &#39;element-ui&#39;</span><br><span class="line">import &#39;element-ui&#x2F;lib&#x2F;theme-chalk&#x2F;index.css&#39;</span><br><span class="line"></span><br><span class="line">import App from &#39;.&#x2F;App&#39;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 安装路由</span><br><span class="line">Vue.use(VueRouter);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 安装 ElementUI</span><br><span class="line">Vue.use(ElementUI);</span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: &#39;#app&#39;,</span><br><span class="line">  &#x2F;&#x2F; 启用路由</span><br><span class="line">  router,</span><br><span class="line">  &#x2F;&#x2F; 启用 ElementUI</span><br><span class="line">  render: h &#x3D;&gt; h(App)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>修改 App.vue 组件代码</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">    &lt;router-view&#x2F;&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    name: &#39;App&#39;,</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>测试 ： 在浏览器打开 <a href="http://localhost/" target="_blank" rel="noopener">http://localhost</a>:8080/#/login</p><p>如果出现错误: 可能是因为sass-loader的版本过高导致的编译错误，当前最高版本是8.x，需要退回到7.3.1 ；</p><p>去package.json文件里面的 “sass-loader”的版本更换成7.3.1，然后重新<code>cnpm install</code>就可以了；</p><p><img src="https://blog.kuangstudy.com/usr/uploads/2019/10/1972241333.jpg" alt="QQ截图20191025111608.jpg"></p><h2 id="路由嵌套"><a href="#路由嵌套" class="headerlink" title="路由嵌套"></a>路由嵌套</h2><p>嵌套路由又称子路由，在实际应用中，通常由多层嵌套的组件组合而成。同样地，URL 中各段动态路径也按某种结构对应嵌套的各层组件，例如：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;user&#x2F;foo&#x2F;profile                     &#x2F;user&#x2F;foo&#x2F;posts</span><br><span class="line">+------------------+                  +-----------------+</span><br><span class="line">| User             |                  | User            |</span><br><span class="line">| +--------------+ |                  | +-------------+ |</span><br><span class="line">| | Profile      | |  +------------&gt;  | | Posts       | |</span><br><span class="line">| |              | |                  | |             | |</span><br><span class="line">| +--------------+ |                  | +-------------+ |</span><br><span class="line">+------------------+                  +-----------------+</span><br></pre></td></tr></table></figure><p>1、用户信息组件，在 views/user 目录下创建一个名为 Profile.vue 的视图组件；</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      个人信息</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    export default &#123;</span><br><span class="line">        name: &quot;UserProfile&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure><p>2、用户列表组件在 views/user 目录下创建一个名为 List.vue 的视图组件；</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      用户列表</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    export default &#123;</span><br><span class="line">        name: &quot;UserList&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure><p>3、配置嵌套路由修改 router 目录下的 index.js 路由配置文件，代码如</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import Vue from &#39;vue&#39;</span><br><span class="line">import Router from &#39;vue-router&#39;</span><br><span class="line"></span><br><span class="line">import Login from &quot;..&#x2F;views&#x2F;Login&quot;</span><br><span class="line">import Main from &#39;..&#x2F;views&#x2F;Main&#39;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 用于嵌套的路由组件</span><br><span class="line">import UserProfile from &#39;..&#x2F;views&#x2F;user&#x2F;Profile&#39;</span><br><span class="line">import UserList from &#39;..&#x2F;views&#x2F;user&#x2F;List&#39;</span><br><span class="line"></span><br><span class="line">Vue.use(Router);</span><br><span class="line"></span><br><span class="line">export default new Router(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      &#x2F;&#x2F; 登录页</span><br><span class="line">      path: &#39;&#x2F;login&#39;,</span><br><span class="line">      name: &#39;Login&#39;,</span><br><span class="line">      component: Login</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &#x2F;&#x2F; 首页</span><br><span class="line">      path: &#39;&#x2F;main&#39;,</span><br><span class="line">      name: &#39;Main&#39;,</span><br><span class="line">      component: Main,</span><br><span class="line">      &#x2F;&#x2F; 配置嵌套路由</span><br><span class="line">      children: [</span><br><span class="line">        &#123;path: &#39;&#x2F;user&#x2F;profile&#39;, component: UserProfile&#125;,</span><br><span class="line">        &#123;path: &#39;&#x2F;user&#x2F;list&#39;, component: UserList&#125;,</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>说明：主要在路由配置中增加了 children 数组配置，用于在该组件下设置嵌套路由</p><p>4、修改首页视图，我们修改 Main.vue 视图组件，此处使用了 ElementUI 布局容器组件，代码如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;el-container&gt;</span><br><span class="line">        &lt;el-aside width&#x3D;&quot;200px&quot;&gt;</span><br><span class="line">          &lt;el-menu :default-openeds&#x3D;&quot;[&#39;1&#39;]&quot;&gt;</span><br><span class="line">            &lt;el-submenu index&#x3D;&quot;1&quot;&gt;</span><br><span class="line">              &lt;template slot&#x3D;&quot;title&quot;&gt;&lt;i class&#x3D;&quot;el-icon-caret-right&quot;&gt;&lt;&#x2F;i&gt;用户管理&lt;&#x2F;template&gt;</span><br><span class="line">              &lt;el-menu-item-group&gt;</span><br><span class="line">                &lt;el-menu-item index&#x3D;&quot;1-1&quot;&gt;</span><br><span class="line">                  &lt;router-link to&#x3D;&quot;&#x2F;user&#x2F;profile&quot;&gt;个人信息&lt;&#x2F;router-link&gt;</span><br><span class="line">                &lt;&#x2F;el-menu-item&gt;</span><br><span class="line">                &lt;el-menu-item index&#x3D;&quot;1-2&quot;&gt;</span><br><span class="line">                  &lt;router-link to&#x3D;&quot;&#x2F;user&#x2F;list&quot;&gt;用户列表&lt;&#x2F;router-link&gt;</span><br><span class="line">                &lt;&#x2F;el-menu-item&gt;</span><br><span class="line">              &lt;&#x2F;el-menu-item-group&gt;</span><br><span class="line">            &lt;&#x2F;el-submenu&gt;</span><br><span class="line">            &lt;el-submenu index&#x3D;&quot;2&quot;&gt;</span><br><span class="line">              &lt;template slot&#x3D;&quot;title&quot;&gt;&lt;i class&#x3D;&quot;el-icon-caret-right&quot;&gt;&lt;&#x2F;i&gt;内容管理&lt;&#x2F;template&gt;</span><br><span class="line">              &lt;el-menu-item-group&gt;</span><br><span class="line">                &lt;el-menu-item index&#x3D;&quot;2-1&quot;&gt;分类管理&lt;&#x2F;el-menu-item&gt;</span><br><span class="line">                &lt;el-menu-item index&#x3D;&quot;2-2&quot;&gt;内容列表&lt;&#x2F;el-menu-item&gt;</span><br><span class="line">              &lt;&#x2F;el-menu-item-group&gt;</span><br><span class="line">            &lt;&#x2F;el-submenu&gt;</span><br><span class="line">          &lt;&#x2F;el-menu&gt;</span><br><span class="line">        &lt;&#x2F;el-aside&gt;</span><br><span class="line"></span><br><span class="line">        &lt;el-container&gt;</span><br><span class="line">          &lt;el-header style&#x3D;&quot;text-align: right; font-size: 12px&quot;&gt;</span><br><span class="line">            &lt;el-dropdown&gt;</span><br><span class="line">              &lt;i class&#x3D;&quot;el-icon-setting&quot; style&#x3D;&quot;margin-right: 15px&quot;&gt;&lt;&#x2F;i&gt;</span><br><span class="line">              &lt;el-dropdown-menu slot&#x3D;&quot;dropdown&quot;&gt;</span><br><span class="line">                &lt;el-dropdown-item&gt;个人信息&lt;&#x2F;el-dropdown-item&gt;</span><br><span class="line">                &lt;el-dropdown-item&gt;退出登录&lt;&#x2F;el-dropdown-item&gt;</span><br><span class="line">              &lt;&#x2F;el-dropdown-menu&gt;</span><br><span class="line">            &lt;&#x2F;el-dropdown&gt;</span><br><span class="line">          &lt;&#x2F;el-header&gt;</span><br><span class="line"></span><br><span class="line">          &lt;el-main&gt;</span><br><span class="line">            &lt;router-view &#x2F;&gt;</span><br><span class="line">          &lt;&#x2F;el-main&gt;</span><br><span class="line">        &lt;&#x2F;el-container&gt;</span><br><span class="line">      &lt;&#x2F;el-container&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    export default &#123;</span><br><span class="line">        name: &quot;Main&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped lang&#x3D;&quot;scss&quot;&gt;</span><br><span class="line">  .el-header &#123;</span><br><span class="line">    background-color: #B3C0D1;</span><br><span class="line">    color: #333;</span><br><span class="line">    line-height: 60px;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  .el-aside &#123;</span><br><span class="line">    color: #333;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure><p>说明：</p><p>在 <el-main> 元素中配置了 <router-view /> 用于展示嵌套路由,主要使用 <router-link to="/user/profile">个人信息</router-link> 展示嵌套路由内容</p><h2 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h2><p>我们经常需要把某种模式匹配到的所有路由，全都映射到同个组件。例如，我们有一个 User 组件，对于所有 ID 各不相同的用户，都要使用这个组件来渲染。此时我们就需要传递参数了；</p><p>1、修改路由配置, 主要是在 path 属性中增加了 :id 这样的占位符</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;path: &#39;&#x2F;user&#x2F;profile&#x2F;:id&#39;, name:&#39;UserProfile&#39;, component: UserProfile&#125;</span><br></pre></td></tr></table></figure><p>2、传递参数</p><p>此时我们将 to 改为了 :to，是为了将这一属性当成对象使用，注意 router-link 中的 name 属性名称 一定要和 路由中的 name 属性名称 匹配，因为这样 Vue 才能找到对应的路由路径；</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;router-link :to&#x3D;&quot;&#123;name: &#39;UserProfile&#39;, params: &#123;id: 1&#125;&#125;&quot;&gt;个人信息&lt;&#x2F;router-link&gt;</span><br></pre></td></tr></table></figure><p>3、接收参数, 在目标组件中</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&#123; $route.params.id &#125;&#125;</span><br></pre></td></tr></table></figure><h3 id="使用-props-的方式"><a href="#使用-props-的方式" class="headerlink" title="使用 props 的方式"></a>使用 props 的方式</h3><p>1、修改路由配置 , 主要增加了 props: true 属性</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;path: &#39;&#x2F;user&#x2F;profile&#x2F;:id&#39;, name:&#39;UserProfile&#39;, component: UserProfile, props: true&#125;</span><br></pre></td></tr></table></figure><p>2、传递参数和之前一样<br>3、接收参数为目标组件增加 props 属性</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    个人信息</span><br><span class="line">    &#123;&#123; id &#125;&#125;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    export default &#123;</span><br><span class="line">      props: [&#39;id&#39;],</span><br><span class="line">      name: &quot;UserProfile&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure><h2 id="组件重定向"><a href="#组件重定向" class="headerlink" title="组件重定向"></a>组件重定向</h2><p>重定向的意思大家都明白，但 Vue 中的重定向是作用在路径不同但组件相同的情况下，比如：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  path: &#39;&#x2F;main&#39;,</span><br><span class="line">  name: &#39;Main&#39;,</span><br><span class="line">  component: Main</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">  path: &#39;&#x2F;goHome&#39;,</span><br><span class="line">  redirect: &#39;&#x2F;main&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：这里定义了两个路径，一个是 /main ，一个是 /goHome，其中 /goHome 重定向到了 /main 路径，由此可以看出重定向不需要定义组件；</p><p>使用的话，只需要设置对应路径即可；</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;el-menu-item index&#x3D;&quot;1-3&quot;&gt;</span><br><span class="line">    &lt;router-link to&#x3D;&quot;&#x2F;goHome&quot;&gt;回到首页&lt;&#x2F;router-link&gt;</span><br><span class="line">&lt;&#x2F;el-menu-item&gt;</span><br></pre></td></tr></table></figure><h2 id="路由模式与-404"><a href="#路由模式与-404" class="headerlink" title="路由模式与 404"></a>路由模式与 404</h2><p>路由模式有两种</p><ul><li>hash：路径带 # 符号，如 <a href="http://localhost/#/login" target="_blank" rel="noopener">http://localhost/#/login</a></li><li>history：路径不带 # 符号，如 <a href="http://localhost/login" target="_blank" rel="noopener">http://localhost/login</a></li></ul><p>修改路由配置，代码如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export default new Router(&#123;</span><br><span class="line">  mode: &#39;history&#39;,</span><br><span class="line">  routes: [</span><br><span class="line">  ]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>处理 404</strong> 创建一个名为 <code>NotFound.vue</code> 的视图组件，代码如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    页面不存在，请重试！</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    name: &quot;NotFount&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure><p>修改路由配置，代码如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import NotFound from &#39;..&#x2F;views&#x2F;NotFound&#39;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">   path: &#39;*&#39;,</span><br><span class="line">   component: NotFound</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="路由钩子与异步请求"><a href="#路由钩子与异步请求" class="headerlink" title="路由钩子与异步请求"></a>路由钩子与异步请求</h3><p><code>beforeRouteEnter</code>：在进入路由前执行<br><code>beforeRouteLeave</code>：在离开路由前执行</p><p>上代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">  props: [&#39;id&#39;],</span><br><span class="line">  name: &quot;UserProfile&quot;,</span><br><span class="line">  beforeRouteEnter: (to, from, next) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&quot;准备进入个人信息页&quot;);</span><br><span class="line">    next();</span><br><span class="line">  &#125;,</span><br><span class="line">  beforeRouteLeave: (to, from, next) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&quot;准备离开个人信息页&quot;);</span><br><span class="line">    next();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li>to：路由将要跳转的路径信息</li><li>from：路径跳转前的路径信息</li><li>next：路由的控制参数<ul><li>next() 跳入下一个页面</li><li>next(‘/path’) 改变路由的跳转方向，使其跳到另一个路由</li><li>next(false) 返回原来的页面</li><li>next((vm)=&gt;{}) 仅在 beforeRouteEnter 中可用，vm 是组件实例</li></ul></li></ul><p><strong>在钩子函数中使用异步请求</strong></p><p>1、安装 Axios <code>cnpm install axios -s</code><br>2、<code>main.js</code>引用 Axios</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import axios from &#39;axios&#39;</span><br><span class="line">Vue.prototype.axios &#x3D; axios;</span><br></pre></td></tr></table></figure><p>3、准备数据 ： 只有我们的 static 目录下的文件是可以被访问到的，所以我们就把静态文件放入该目录下。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 静态数据存放的位置</span><br><span class="line">static&#x2F;mock&#x2F;data.json</span><br></pre></td></tr></table></figure><p>4、在 beforeRouteEnter 中进行异步请求</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">   props: [&#39;id&#39;],</span><br><span class="line">   name: &quot;UserProfile&quot;,</span><br><span class="line">   beforeRouteEnter: (to, from, next) &#x3D;&gt; &#123;</span><br><span class="line">     console.log(&quot;准备进入个人信息页&quot;);</span><br><span class="line">     &#x2F;&#x2F; 注意，一定要在 next 中请求，因为该方法调用时 Vue 实例还没有创建，此时无法获取到 this 对象，在这里使用官方提供的回调函数拿到当前实例</span><br><span class="line">     next(vm &#x3D;&gt; &#123;</span><br><span class="line">       vm.getData();</span><br><span class="line">     &#125;);</span><br><span class="line">   &#125;,</span><br><span class="line">   beforeRouteLeave: (to, from, next) &#x3D;&gt; &#123;</span><br><span class="line">     console.log(&quot;准备离开个人信息页&quot;);</span><br><span class="line">     next();</span><br><span class="line">   &#125;,</span><br><span class="line">   methods: &#123;</span><br><span class="line">     getData: function () &#123;</span><br><span class="line">       this.axios(&#123;</span><br><span class="line">         method: &#39;get&#39;,</span><br><span class="line">         url: &#39;http:&#x2F;&#x2F;localhost:8080&#x2F;static&#x2F;mock&#x2F;data.json&#39;</span><br><span class="line">       &#125;).then(function (repos) &#123;</span><br><span class="line">         console.log(repos);</span><br><span class="line">       &#125;).catch(function (error) &#123;</span><br><span class="line">         console.log(error);</span><br><span class="line">       &#125;);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      前端体系、前后端分离
    
    </summary>
    
    
      <category term="Vue" scheme="https://SomunsTao.github.io/categories/Vue/"/>
    
    
      <category term="Vue" scheme="https://SomunsTao.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue 09：vue-router路由</title>
    <link href="https://somunstao.github.io/2020/04/19/Vue%2009%EF%BC%9Avue-router%E8%B7%AF%E7%94%B1/"/>
    <id>https://somunstao.github.io/2020/04/19/Vue%2009%EF%BC%9Avue-router%E8%B7%AF%E7%94%B1/</id>
    <published>2020-04-18T16:00:00.000Z</published>
    <updated>2020-08-01T15:18:48.746Z</updated>
    
    <content type="html"><![CDATA[<p>​    </p><h1 id="Vue：vue-router路由"><a href="#Vue：vue-router路由" class="headerlink" title="Vue：vue-router路由"></a>Vue：vue-router路由</h1><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>学习的时候，尽量的打开官方的文档</p><p>Vue Router 是 Vue.js 官方的路由管理器。它和 Vue.js 的核心深度集成，让构建单页面应用变得易如反掌。包含的功能有：</p><ul><li>嵌套的路由/视图表</li><li>模块化的、基于组件的路由配置</li><li>路由参数、查询、通配符</li><li>基于 Vue.js 过渡系统的视图过渡效果</li><li>细粒度的导航控制</li><li>带有自动激活的 CSS class 的链接</li><li>HTML5 历史模式或 hash 模式，在 IE9 中自动降级</li><li>自定义的滚动条行为</li></ul><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p><strong>基于第一个vue-cli进行测试学习;先查看node_modules中是否存在 vue-router</strong></p><p>vue-router 是一个插件包，所以我们还是需要用 npm/cnpm 来进行安装的。打开命令行工具，进入你的项目目录，输入下面命令。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install vue-router --save-dev</span><br></pre></td></tr></table></figure><p>如果在一个模块化工程中使用它，必须要通过 Vue.use() 明确地安装路由功能：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import Vue from &#39;vue&#39;</span><br><span class="line">import VueRouter from &#39;vue-router&#39;</span><br><span class="line"></span><br><span class="line">Vue.use(VueRouter);</span><br></pre></td></tr></table></figure><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>1、先删除没有用的东西<br>2、<code>components</code>目录下存放我们自己编写的组件<br>3、定义一个<code>Content.vue</code> 的组件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line"> &lt;h1&gt;内容页&lt;&#x2F;h1&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"> export default &#123;</span><br><span class="line">     name: &quot;Content&quot;</span><br><span class="line"> &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>4、 <strong>安装路由,在src目录下,新建一个文件夹 : router,专门存放路由</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import Vue from &#39;vue&#39;</span><br><span class="line">&#x2F;&#x2F; 导入路由插件</span><br><span class="line">import Router from &#39;vue-router&#39;</span><br><span class="line">&#x2F;&#x2F; 导入上面定义的组件</span><br><span class="line">import Content from &#39;..&#x2F;components&#x2F;Content&#39;</span><br><span class="line">import main from &#39;..&#x2F;components&#x2F;main&#39;</span><br><span class="line">&#x2F;&#x2F; 安装路由</span><br><span class="line">Vue.use(Router);</span><br><span class="line">&#x2F;&#x2F; 配置路由</span><br><span class="line">export default new Router(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      &#x2F;&#x2F; 路由路径</span><br><span class="line">      path: &#39;&#x2F;content&#39;,</span><br><span class="line">      &#x2F;&#x2F; 路由名称</span><br><span class="line">      name: &#39;Content&#39;,</span><br><span class="line">      &#x2F;&#x2F; 跳转到组件</span><br><span class="line">      component: Content</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">      &#x2F;&#x2F; 路由路径</span><br><span class="line">      path: &#39;&#x2F;main&#39;,</span><br><span class="line">      &#x2F;&#x2F; 路由名称</span><br><span class="line">      name: &#39;main&#39;,</span><br><span class="line">      &#x2F;&#x2F; 跳转到组件</span><br><span class="line">      component: main</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>5、在<code>main.js</code> 中配置路由</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import Vue from &#39;vue&#39;</span><br><span class="line">import App from &#39;.&#x2F;App&#39;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 导入上面创建的路由配置目录</span><br><span class="line">import router from &#39;.&#x2F;router&#39;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;来关闭生产模式下给出的提示</span><br><span class="line">Vue.config.productionTip &#x3D; false;</span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: &#39;#app&#39;,</span><br><span class="line">  &#x2F;&#x2F; 配置路由</span><br><span class="line">  router,</span><br><span class="line">  components: &#123; App &#125;,</span><br><span class="line">  template: &#39;&lt;App&#x2F;&gt;&#39;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>6、在<code>App.vue</code>中使用路由</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">    &lt;!--</span><br><span class="line">      router-link： 默认会被渲染成一个 &lt;a&gt; 标签，to 属性为指定链接</span><br><span class="line">      router-view： 用于渲染路由匹配到的组件</span><br><span class="line">    --&gt;</span><br><span class="line">    &lt;router-link to&#x3D;&quot;&#x2F;&quot;&gt;首页&lt;&#x2F;router-link&gt;</span><br><span class="line">    &lt;router-link to&#x3D;&quot;&#x2F;content&quot;&gt;内容&lt;&#x2F;router-link&gt;</span><br><span class="line">    &lt;router-view&gt;&lt;&#x2F;router-view&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#39;App&#39;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">  #app &#123;</span><br><span class="line">    font-family: &#39;Avenir&#39;, Helvetica, Arial, sans-serif;</span><br><span class="line">    -webkit-font-smoothing: antialiased;</span><br><span class="line">    -moz-osx-font-smoothing: grayscale;</span><br><span class="line">    text-align: center;</span><br><span class="line">    color: #2c3e50;</span><br><span class="line">    margin-top: 60px;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure><p>启动测试一下 ： <code>npm run dev</code></p><p><strong>练习： 在现有的基础上，在增加一个路由组件，优化一下！</strong></p>]]></content>
    
    <summary type="html">
    
      前端体系、前后端分离
    
    </summary>
    
    
      <category term="Vue" scheme="https://SomunsTao.github.io/categories/Vue/"/>
    
    
      <category term="Vue" scheme="https://SomunsTao.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue 08：Webpack学习</title>
    <link href="https://somunstao.github.io/2020/04/18/Vue%2008%EF%BC%9AWebpack%E5%AD%A6%E4%B9%A0/"/>
    <id>https://somunstao.github.io/2020/04/18/Vue%2008%EF%BC%9AWebpack%E5%AD%A6%E4%B9%A0/</id>
    <published>2020-04-17T16:00:00.000Z</published>
    <updated>2020-08-01T15:18:32.935Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Vue：Webpack学习"><a href="#Vue：Webpack学习" class="headerlink" title="Vue：Webpack学习"></a>Vue：Webpack学习</h1><h2 id="什么是Webpack"><a href="#什么是Webpack" class="headerlink" title="什么是Webpack"></a>什么是Webpack</h2><p>本质上，webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle.</p><p>Webpack 是当下最热门的前端资源模块化管理和打包工具，它可以将许多松散耦合的模块按照依赖和规则打包成符合生产环境部署的前端资源。还可以将按需加载的模块进行代码分离，等到实际需要时再异步加载。通过 loader 转换，任何形式的资源都可以当做模块，比如 CommonsJS、AMD、ES6、CSS、JSON、CoffeeScript、LESS 等；</p><p>伴随着移动互联网的大潮，当今越来越多的网站已经从网页模式进化到了 WebApp 模式。它们运行在现代浏览器里，使用 HTML5、CSS3、ES6 等新的技术来开发丰富的功能，网页已经不仅仅是完成浏览器的基本需求；WebApp 通常是一个 SPA （单页面应用），每一个视图通过异步的方式加载，这导致页面初始化和使用过程中会加载越来越多的 JS 代码，这给前端的开发流程和资源组织带来了巨大挑战。</p><p>前端开发和其他开发工作的主要区别，首先是前端基于多语言、多层次的编码和组织工作，其次前端产品的交付是基于浏览器的，这些资源是通过增量加载的方式运行到浏览器端，如何在开发环境组织好这些碎片化的代码和资源，并且保证他们在浏览器端快速、优雅的加载和更新，就需要一个模块化系统，这个理想中的模块化系统是前端工程师多年来一直探索的难题。</p><h3 id="模块化的演进"><a href="#模块化的演进" class="headerlink" title="模块化的演进"></a>模块化的演进</h3><h4 id="Script-标签"><a href="#Script-标签" class="headerlink" title="Script 标签"></a>Script 标签</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script src&#x3D;&quot;module1.js&quot;&gt;&lt;&#x2F;scirpt&gt;</span><br><span class="line">&lt;script src&#x3D;&quot;module2.js&quot;&gt;&lt;&#x2F;scirpt&gt;</span><br><span class="line">&lt;script src&#x3D;&quot;module3.js&quot;&gt;&lt;&#x2F;scirpt&gt;</span><br><span class="line">&lt;script src&#x3D;&quot;module4.js&quot;&gt;&lt;&#x2F;scirpt&gt;</span><br></pre></td></tr></table></figure><p>这是最原始的 JavaScript 文件加载方式，如果把每一个文件看做是一个模块，那么他们的接口通常是暴露在全局作用域下，也就是定义在 window 对象中，不同模块的调用都是一个作用域。</p><p>这种原始的加载方式暴露了一些显而易见的弊端：</p><ul><li>全局作用域下容易造成变量冲突</li><li>文件只能按照 <script> 的书写顺序进行加载</li><li>开发人员必须主观解决模块和代码库的依赖关系</li><li>在大型项目中各种资源难以管理，长期积累的问题导致代码库混乱不堪</li></ul><h4 id="CommonsJS"><a href="#CommonsJS" class="headerlink" title="CommonsJS"></a>CommonsJS</h4><p>服务器端的 NodeJS 遵循 CommonsJS 规范，该规范核心思想是允许模块通过 require 方法来同步加载所需依赖的其它模块，然后通过 exports 或 module.exports 来导出需要暴露的接口。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">require(&quot;module&quot;);</span><br><span class="line">require(&quot;..&#x2F;module.js&quot;);</span><br><span class="line">export.doStuff &#x3D; function() &#123;&#125;;</span><br><span class="line">module.exports &#x3D; someValue;</span><br></pre></td></tr></table></figure><p><strong>优点:</strong></p><ul><li>服务器端模块便于重用</li><li>NPM 中已经有超过 45 万个可以使用的模块包</li><li>简单易用</li></ul><p><strong>缺点:</strong></p><ul><li>同步的模块加载方式不适合在浏览器环境中，同步意味着阻塞加载，浏览器资源是异步加载的</li><li>不能非阻塞的并行加载多个模块</li></ul><p><strong>实现:</strong></p><ul><li>服务端的 NodeJS</li><li>Browserify，浏览器端的 CommonsJS 实现，可以使用 NPM 的模块，但是编译打包后的文件体积较大</li><li>modules-webmake，类似 Browserify，但不如 Browserify 灵活</li><li>wreq，Browserify 的前身</li></ul><h4 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h4><p>Asynchronous Module Definition 规范其实主要一个主要接口 define(id?, dependencies?, factory); 它要在声明模块的时候指定所有的依赖 dependencies，并且还要当做形参传到 factory 中，对于依赖的模块提前执行。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">define(&quot;module&quot;, [&quot;dep1&quot;, &quot;dep2&quot;], function(d1, d2) &#123;</span><br><span class="line">  return someExportedValue;</span><br><span class="line">&#125;);</span><br><span class="line">require([&quot;module&quot;, &quot;..&#x2F;file.js&quot;], function(module, file) &#123;&#125;);</span><br></pre></td></tr></table></figure><p><strong>优点</strong></p><ul><li>适合在浏览器环境中异步加载模块</li><li>可以并行加载多个模块</li></ul><p><strong>缺点</strong></p><ul><li>提高了开发成本，代码的阅读和书写比较困难，模块定义方式的语义不畅</li><li>不符合通用的模块化思维方式，是一种妥协的实现</li></ul><p><strong>实现</strong></p><ul><li>RequireJS</li><li>curl</li></ul><h4 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h4><p>Commons Module Definition 规范和 AMD 很相似，尽量保持简单，并与 CommonsJS 和 NodeJS 的 Modules 规范保持了很大的兼容性。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">define(function(require, exports, module) &#123;</span><br><span class="line">  var $ &#x3D; require(&quot;jquery&quot;);</span><br><span class="line">  var Spinning &#x3D; require(&quot;.&#x2F;spinning&quot;);</span><br><span class="line">  exports.doSomething &#x3D; ...;</span><br><span class="line">  module.exports &#x3D; ...;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>优点:</strong></p><ul><li>依赖就近，延迟执行</li><li>可以很容易在 NodeJS 中运行</li></ul><p><strong>缺点</strong></p><ul><li>依赖 SPM 打包，模块的加载逻辑偏重</li></ul><p><strong>实现</strong></p><ul><li>Sea.js</li><li>coolie</li></ul><h4 id="ES6-模块"><a href="#ES6-模块" class="headerlink" title="ES6 模块"></a>ES6 模块</h4><p>EcmaScript6 标准增加了 JavaScript 语言层面的模块体系定义。 ES6 模块的设计思想，是尽量静态化，使编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonsJS 和 AMD 模块，都只能在运行时确定这些东西。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &quot;jquery&quot;;</span><br><span class="line">export function doStuff() &#123;&#125;</span><br><span class="line">module &quot;localModule&quot; &#123;&#125;</span><br></pre></td></tr></table></figure><p><strong>优点</strong></p><ul><li>容易进行静态分析</li><li>面向未来的 EcmaScript 标准</li></ul><p><strong>缺点</strong></p><ul><li>原生浏览器端还没有实现该标准</li><li>全新的命令，新版的 NodeJS 才支持</li></ul><p><strong>实现</strong></p><ul><li>Babel</li></ul><p><strong>大家期望的模块系统</strong></p><p>可以兼容多种模块风格，尽量可以利用已有的代码，不仅仅只是 JavaScript 模块化，还有 CSS、图片、字体等资源也需要模块化。</p><h2 id="安装Webpack"><a href="#安装Webpack" class="headerlink" title="安装Webpack"></a>安装Webpack</h2><p>WebPack 是一款模块加载器兼打包工具，它能把各种资源，如 JS、JSX、ES6、SASS、LESS、图片等都作为模块来处理和使用。</p><p><strong>安装:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install webpack -g</span><br><span class="line">npm install webpack-cli -g</span><br></pre></td></tr></table></figure><p>测试安装成功:</p><ul><li><code>webpack -v</code></li><li><code>webpack-cli -v</code></li></ul><p><img src="https://blog.kuangstudy.com/usr/uploads/2019/10/2035564066.png" alt="QQ截图20191023173431.png"></p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>创建 <code>webpack.config.js</code> 配置文件</p><ul><li>entry：入口文件，指定 WebPack 用哪个文件作为项目的入口</li><li>output：输出，指定 WebPack 把处理完成的文件放置到指定路径</li><li>module：模块，用于处理各种类型的文件</li><li>plugins：插件，如：热更新、代码重用等</li><li>resolve：设置路径指向</li><li>watch：监听，用于设置文件改动后直接打包</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">    entry: &quot;&quot;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: &quot;&quot;,</span><br><span class="line">        filename: &quot;&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    module: &#123;</span><br><span class="line">        loaders: [</span><br><span class="line">            &#123;test: &#x2F;\.js$&#x2F;, loader: &quot;&quot;&#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: &#123;&#125;,</span><br><span class="line">    resolve: &#123;&#125;,</span><br><span class="line">    watch: true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接运行 <code>webpack</code> 命令打包</p><h2 id="使用webpack"><a href="#使用webpack" class="headerlink" title="使用webpack"></a>使用webpack</h2><ol><li><p>创建项目</p></li><li><p>创建一个名为 modules 的目录，用于放置 JS 模块等资源文件</p></li><li><p>在modules下创建模块文件，如 hello.js，用于编写 JS 模块相关代码</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;暴露一个方法:sayHi</span><br><span class="line">exports.sayHi &#x3D; function () &#123;</span><br><span class="line">  document.write(&quot;&lt;div&gt;Hello WebPack&lt;&#x2F;div&gt;&quot;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>在modules下创建一个名为 main.js 的入口文件，用于打包时设置 entry 属性</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;require 导入一个模块,就可以调用这个模块中的方法了</span><br><span class="line">var hello &#x3D; require(&quot;.&#x2F;hello&quot;);</span><br><span class="line">hello.sayHi();</span><br></pre></td></tr></table></figure></li><li><p>在项目目录下创建 webpack.config.js 配置文件，使用 webpack 命令打包</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">    entry: &quot;.&#x2F;modules&#x2F;main.js&quot;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: &quot;.&#x2F;js&#x2F;bundle.js&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>在项目目录下创建 HTML 页面，如 index.html，导入 WebPack 打包后的 JS 文件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!doctype html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line"> &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line"> &lt;title&gt;狂神说Java&lt;&#x2F;title&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;script src&#x3D;&quot;dist&#x2F;js&#x2F;bundle.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure></li><li><p>在IDEA控制台中直接执行webpack;如果失败的话,就使用管理员权限运行即可!</p></li><li><p>运行 HTML 看效果</p></li></ol><p><strong>说明:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 参数 --watch 用于监听变化</span><br><span class="line">webpack --watch</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      前端体系、前后端分离
    
    </summary>
    
    
      <category term="Vue" scheme="https://SomunsTao.github.io/categories/Vue/"/>
    
    
      <category term="Vue" scheme="https://SomunsTao.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue 07：第一个vue-cli项目</title>
    <link href="https://somunstao.github.io/2020/04/17/Vue%2007%EF%BC%9A%E7%AC%AC%E4%B8%80%E4%B8%AAvue-cli%E9%A1%B9%E7%9B%AE/"/>
    <id>https://somunstao.github.io/2020/04/17/Vue%2007%EF%BC%9A%E7%AC%AC%E4%B8%80%E4%B8%AAvue-cli%E9%A1%B9%E7%9B%AE/</id>
    <published>2020-04-16T16:00:00.000Z</published>
    <updated>2020-08-01T15:18:13.793Z</updated>
    
    <content type="html"><![CDATA[<p>​    </p><h1 id="Vue：第一个vue-cli项目"><a href="#Vue：第一个vue-cli项目" class="headerlink" title="Vue：第一个vue-cli项目"></a>Vue：第一个vue-cli项目</h1><h2 id="什么是vue-cli"><a href="#什么是vue-cli" class="headerlink" title="什么是vue-cli"></a>什么是vue-cli</h2><p>vue-cli 官方提供的一个脚手架,用于快速生成一个 vue 的项目模板;</p><p>预先定义好的目录结构及基础代码，就好比咱们在创建 Maven 项目时可以选择创建一个骨架项目，这个骨架项目就是脚手架,我们的开发更加的快速;</p><p><strong>主要的功能:</strong></p><ul><li>统一的目录结构</li><li>本地调试</li><li>热部署</li><li>单元测试</li><li>集成打包上线</li></ul><h2 id="需要的环境"><a href="#需要的环境" class="headerlink" title="需要的环境"></a>需要的环境</h2><ul><li>Node.js : <a href="http://nodejs.cn/download/" target="_blank" rel="noopener">http://nodejs.cn/download/</a><br>安装就无脑下一步就好,安装在自己的环境目录下</li><li>Git : <a href="https://git-scm.com/downloads" target="_blank" rel="noopener">https://git-scm.com/downloads</a><br>镜像:<a href="https://npm.taobao.org/mirrors/git-for-windows/" target="_blank" rel="noopener">https://npm.taobao.org/mirrors/git-for-windows/</a></li></ul><p><strong>确认nodejs安装成功:</strong></p><ul><li>cmd 下输入 <code>node -v</code>,查看是否能够正确打印出版本号即可!</li><li>cmd 下输入 <code>npm-v</code>,查看是否能够正确打印出版本号即可!</li></ul><p>这个npm,就是一个软件包管理工具,就和linux下的apt软件安装差不多!</p><p><strong>安装 Node.js 淘宝镜像加速器（cnpm）</strong></p><p>这样子的话,下载会快很多~</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># -g 就是全局安装</span><br><span class="line">npm install cnpm -g</span><br><span class="line"></span><br><span class="line"># 或使用如下语句解决 npm 速度慢的问题</span><br><span class="line">npm install --registry&#x3D;https:&#x2F;&#x2F;registry.npm.taobao.org</span><br></pre></td></tr></table></figure><p>安装过程可能有点慢~,耐心等待!虽然安装了cnpm,但是尽量少用!</p><p>安装的位置:<code>C:\Users\Administrator\AppData\Roaming\npm</code></p><p><img src="https://blog.kuangstudy.com/usr/uploads/2019/10/3274148234.png" alt="QQ截图20191023160802.png"></p><p><strong>安装 vue-cli</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cnpm install vue-cli -g</span><br><span class="line"></span><br><span class="line"># 测试是否安装成功</span><br><span class="line"># 查看可以基于哪些模板创建 vue 应用程序，通常我们选择 webpack</span><br><span class="line">vue list</span><br></pre></td></tr></table></figure><p><img src="https://blog.kuangstudy.com/usr/uploads/2019/10/1623428782.png" alt="QQ截图20191023161055.png"></p><h2 id="第一个-vue-cli-应用程序"><a href="#第一个-vue-cli-应用程序" class="headerlink" title="第一个 vue-cli 应用程序"></a>第一个 vue-cli 应用程序</h2><ol><li><p>创建一个Vue项目,我们随便建立一个空的文件夹在电脑上,我这里在D盘下新建一个目录<code>D:\Project\vue-study</code>;</p></li><li><p>创建一个基于 webpack 模板的 vue 应用程序</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 这里的 myvue 是项目名称，可以根据自己的需求起名</span><br><span class="line">vue init webpack myvue</span><br></pre></td></tr></table></figure><p>一路都选择no即可;</p></li></ol><p><strong>说明:</strong></p><ul><li>Project name：项目名称，默认 回车 即可</li><li>Project description：项目描述，默认 回车 即可</li><li>Author：项目作者，默认 回车 即可</li><li>Install vue-router：是否安装 vue-router，选择 n 不安装（后期需要再手动添加）</li><li>Use ESLint to lint your code：是否使用 ESLint 做代码检查，选择 n 不安装（后期需要再手动添加）</li><li>Set up unit tests：单元测试相关，选择 n 不安装（后期需要再手动添加）</li><li>Setup e2e tests with Nightwatch：单元测试相关，选择 n 不安装（后期需要再手动添加）</li><li>Should we run npm install for you after the project has been created：创建完成后直接初始化，选择 n，我们手动执行;运行结果!<br><img src="https://blog.kuangstudy.com/usr/uploads/2019/10/1192113224.png" alt="QQ截图20191023161857.png"></li></ul><h3 id="初始化并运行"><a href="#初始化并运行" class="headerlink" title="初始化并运行"></a>初始化并运行</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd myvue</span><br><span class="line">npm install</span><br><span class="line">npm run dev</span><br></pre></td></tr></table></figure><p>执行完成后,目录多了很多依赖</p><p><img src="https://blog.kuangstudy.com/usr/uploads/2019/10/1102095439.png" alt="QQ截图20191023162254.png"></p><p>安装并运行成功后在浏览器输入：<a href="http://localhost/" target="_blank" rel="noopener">http://localhost</a>:8080</p><p><img src="https://blog.kuangstudy.com/usr/uploads/2019/10/2731297978.png" alt="QQ截图20191023162439.png"></p><p><strong>效果:</strong></p><p><img src="https://blog.kuangstudy.com/usr/uploads/2019/10/3761367777.png" alt="QQ截图20191023162508.png"></p><h2 id="Vue-cli目录结构"><a href="#Vue-cli目录结构" class="headerlink" title="Vue-cli目录结构"></a>Vue-cli目录结构</h2><p>我们用IDEA,open刚才的项目!</p><p><img src="https://blog.kuangstudy.com/usr/uploads/2019/10/3943650778.png" alt="QQ截图20191023162755.png"></p><ul><li>build 和 config：WebPack 配置文件</li><li>node_modules：用于存放 npm install 安装的依赖文件</li><li>src： 项目源码目录</li><li>static：静态资源文件</li><li>.babelrc：Babel 配置文件，主要作用是将 ES6 转换为 ES5</li><li>.editorconfig：编辑器配置</li><li>eslintignore：需要忽略的语法检查配置文件</li><li>.gitignore：git 忽略的配置文件</li><li>.postcssrc.js：css 相关配置文件，其中内部的 module.exports 是 NodeJS 模块化语法</li><li>index.html：首页，仅作为模板页，实际开发时不使用</li><li>package.json：项目的配置文件<ul><li>name：项目名称</li><li>version：项目版本</li><li>description：项目描述</li><li>author：项目作者</li><li>scripts：封装常用命令</li><li>dependencies：生产环境依赖</li><li>devDependencies：开发环境依赖</li></ul></li></ul><h2 id="src-目录"><a href="#src-目录" class="headerlink" title="src 目录"></a>src 目录</h2><p><code>src</code> 目录是项目的源码目录，所有代码都会写在这里</p><p><img src="https://blog.kuangstudy.com/usr/uploads/2019/10/1887353409.png" alt="QQ截图20191023164841.png"></p><h3 id="main-js"><a href="#main-js" class="headerlink" title="main.js"></a>main.js</h3><p>项目的入口文件，我们知道所有的程序都会有一个入口</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; The Vue build version to load with the &#96;import&#96; command</span><br><span class="line">&#x2F;&#x2F; (runtime-only or standalone) has been set in webpack.base.conf with an alias.</span><br><span class="line">import Vue from &#39;vue&#39;</span><br><span class="line">import App from &#39;.&#x2F;App&#39;</span><br><span class="line"></span><br><span class="line">Vue.config.productionTip &#x3D; false;</span><br><span class="line"></span><br><span class="line">&#x2F;* eslint-disable no-new *&#x2F;</span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: &#39;#app&#39;,</span><br><span class="line">  components: &#123; App &#125;,</span><br><span class="line">  template: &#39;&lt;App&#x2F;&gt;&#39;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li><code>import Vue from &#39;vue&#39;</code>：ES6 写法，会被转换成 require(“vue”); （require 是 NodeJS 提供的模块加载器）</li><li><code>import App from &#39;./App&#39;</code>：意思同上，但是指定了查找路径，./ 为当前目录</li><li><code>Vue.config.productionTip = false</code>：关闭浏览器控制台关于环境的相关提示</li><li><code>new Vue({...})</code>：实例化 Vue<ul><li><code>el: &#39;#app&#39;</code>：查找 index.html 中 id 为 app 的元素</li><li><code>template: &#39;&lt;App/&gt;&#39;</code>：模板，会将 index.html 中 <div id="app"></div> 替换为 <App /></li><li><code>components: { App }</code>：引入组件，使用的是 import App from ‘./App’ 定义的 App 组件;</li></ul></li></ul><h3 id="App-vue"><a href="#App-vue" class="headerlink" title="App.vue"></a>App.vue</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">    &lt;img src&#x3D;&quot;.&#x2F;assets&#x2F;logo.png&quot;&gt;</span><br><span class="line">    &lt;HelloWorld&#x2F;&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import HelloWorld from &#39;.&#x2F;components&#x2F;HelloWorld&#39;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#39;App&#39;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    HelloWorld</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">#app &#123;</span><br><span class="line">  font-family: &#39;Avenir&#39;, Helvetica, Arial, sans-serif;</span><br><span class="line">  -webkit-font-smoothing: antialiased;</span><br><span class="line">  -moz-osx-font-smoothing: grayscale;</span><br><span class="line">  text-align: center;</span><br><span class="line">  color: #2c3e50;</span><br><span class="line">  margin-top: 60px;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure><ul><li>template：HTML 代码模板，会替换 <App /> 中的内容</li><li>import HelloWorld from ‘./components/HelloWorld’：引入 HelloWorld 组件，用于替换 template 中的 <HelloWorld/></li><li>export default{…}：导出 NodeJS 对象，作用是可以通过 import 关键字导入<ul><li>name: ‘App’：定义组件的名称</li><li>components: { HelloWorld }：定义子组件</li></ul></li></ul><p>在hello,Vue中,关于 <style scoped> 的说明：CSS 样式仅在当前组件有效，声明了样式的作用域,是当前的界面私有的!</p>]]></content>
    
    <summary type="html">
    
      前端体系、前后端分离
    
    </summary>
    
    
      <category term="Vue" scheme="https://SomunsTao.github.io/categories/Vue/"/>
    
    
      <category term="Vue" scheme="https://SomunsTao.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Spring Cloud Alibaba学习笔记:6、Nacos - 配置中心</title>
    <link href="https://somunstao.github.io/2020/04/16/Spring%20Cloud%20Alibaba%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B06%E3%80%81Nacos%20-%20%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/"/>
    <id>https://somunstao.github.io/2020/04/16/Spring%20Cloud%20Alibaba%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B06%E3%80%81Nacos%20-%20%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/</id>
    <published>2020-04-15T16:00:00.000Z</published>
    <updated>2020-08-02T03:05:23.358Z</updated>
    
    <content type="html"><![CDATA[<ul><li><h1 id="Spring-Cloud-Alibaba学习笔记-6、Nacos-配置中心"><a href="#Spring-Cloud-Alibaba学习笔记-6、Nacos-配置中心" class="headerlink" title="Spring Cloud Alibaba学习笔记:6、Nacos - 配置中心"></a>Spring Cloud Alibaba学习笔记:6、Nacos - 配置中心</h1><h3 id="文章目录"><a href="#文章目录" class="headerlink" title="文章目录"></a>文章目录</h3><ul><li><ul><li><ul><li><p><a href="https://blog.csdn.net/fxbin123/article/details/95041107#_3" target="_blank" rel="noopener">引</a></p></li><li><p><a href="https://blog.csdn.net/fxbin123/article/details/95041107#_6" target="_blank" rel="noopener">分布式配置中心</a></p></li><li><p><a href="https://blog.csdn.net/fxbin123/article/details/95041107#Spring_Cloud_Alibaba_Nacos_Config_9" target="_blank" rel="noopener">Spring Cloud Alibaba Nacos Config</a></p></li><li><p><a href="https://blog.csdn.net/fxbin123/article/details/95041107#_14" target="_blank" rel="noopener">创建配置文件</a></p></li><li><p><a href="https://blog.csdn.net/fxbin123/article/details/95041107#Nacos_Config__25" target="_blank" rel="noopener">创建Nacos Config 客户端</a></p></li><li><ul><li><a href="https://blog.csdn.net/fxbin123/article/details/95041107#1_maven_module__scanacosconfigclient_26" target="_blank" rel="noopener">1、 创建一个maven module 项目 <code>sca-nacos-config-client</code></a></li><li><a href="https://blog.csdn.net/fxbin123/article/details/95041107#2_pom_27" target="_blank" rel="noopener">2、 pom</a></li><li><a href="https://blog.csdn.net/fxbin123/article/details/95041107#3_ScaNacosConfigApplicationHTTP_72" target="_blank" rel="noopener">3、创建应用主类 <code>ScaNacosConfigApplication</code>，并实现一个HTTP接口</a></li><li><a href="https://blog.csdn.net/fxbin123/article/details/95041107#4_bootstrapyml_Nacos_111" target="_blank" rel="noopener">4、 <code>bootstrap.yml</code> 配置端口，配置服务名称和Nacos地址</a></li><li><a href="https://blog.csdn.net/fxbin123/article/details/95041107#5_132" target="_blank" rel="noopener">5、启动应用程序</a></li><li><a href="https://blog.csdn.net/fxbin123/article/details/95041107#6_136" target="_blank" rel="noopener">6、测试验证配置获取和验证动态刷新</a></li></ul></li></ul></li></ul></li></ul></li></ul><h3 id="引"><a href="#引" class="headerlink" title="引"></a>引</h3><p>  Nacos除了实现了服务的注册发现之外，还将配置中心功能整合在了一起，通过Nacos的配置管理功能，我们可以将整个架构体系内的所有配置都集中在Nacos中存储</p><h3 id="分布式配置中心"><a href="#分布式配置中心" class="headerlink" title="分布式配置中心"></a>分布式配置中心</h3><p>  在分布式系统中，由于服务数量巨多，为了实现更灵活的管理权限、安全性，实时更新以及一次打包，多处运行，所以需要分布式配置中心组件。</p><h3 id="Spring-Cloud-Alibaba-Nacos-Config"><a href="#Spring-Cloud-Alibaba-Nacos-Config" class="headerlink" title="Spring Cloud Alibaba Nacos Config"></a>Spring Cloud Alibaba Nacos Config</h3><blockquote><p>Nacos 提供用于存储配置和其他元数据的 key/value 存储，为分布式系统中的外部化配置提供服务器端和客户端支持。使用 Spring Cloud Alibaba Nacos Config，您可以在 Nacos Server 集中管理你 Spring Cloud 应用的外部属性配置。</p></blockquote><blockquote><p>Spring Cloud Alibaba Nacos Config 是 Config Server 和 Client 的替代方案，客户端和服务器上的概念与 Spring Environment 和 PropertySource 有着一致的抽象，在特殊的 bootstrap 阶段，配置被加载到 Spring 环境中。当应用程序通过部署管道从开发到测试再到生产时，您可以管理这些环境之间的配置，并确保应用程序具有迁移时需要运行的所有内容。</p></blockquote><h3 id="创建配置文件"><a href="#创建配置文件" class="headerlink" title="创建配置文件"></a>创建配置文件</h3><p>  第一步： 进入Nacos的控制页面，在配置列表功能页面中，点击右上角的“+”按钮<br>  <img src="https://img-blog.csdnimg.cn/2019070723335029.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z4YmluMTIz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>  第二步：进入“新建配置”页面，如下图填写内容：<br>  <img src="https://img-blog.csdnimg.cn/20190707235513599.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z4YmluMTIz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">注意&#96;：Data ID 的默认扩展名为 &#96;.properties&#96; ，希望使用 YAML 配置，此处必须指明是 &#96;.yaml</span><br></pre></td></tr></table></figure><p>  第三步： 发布，发布成功后在 “配置列表” 一栏即可看到刚才创建的配置项<br>  <img src="https://img-blog.csdnimg.cn/20190707234109505.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z4YmluMTIz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="创建Nacos-Config-客户端"><a href="#创建Nacos-Config-客户端" class="headerlink" title="创建Nacos Config 客户端"></a>创建Nacos Config 客户端</h3><h4 id="1、-创建一个maven-module-项目-sca-nacos-config-client"><a href="#1、-创建一个maven-module-项目-sca-nacos-config-client" class="headerlink" title="1、 创建一个maven module 项目 sca-nacos-config-client"></a>1、 创建一个maven module 项目 <code>sca-nacos-config-client</code></h4><h4 id="2、-pom"><a href="#2、-pom" class="headerlink" title="2、 pom"></a>2、 pom</h4>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot;</span><br><span class="line">         xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">         xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;</span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;groupId&gt;cn.fxbin.learn&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;sca&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;version&gt;1.0&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;&#x2F;parent&gt;</span><br><span class="line"></span><br><span class="line">    &lt;artifactId&gt;sca-nacos-config-client&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.0&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;name&gt;sca-nacos-config-client&lt;&#x2F;name&gt;</span><br><span class="line">    &lt;description&gt;Spring Cloud Alibaba Nacos Config Client Service Project&lt;&#x2F;description&gt;</span><br><span class="line"></span><br><span class="line">    &lt;properties&gt;</span><br><span class="line">        &lt;java.version&gt;1.8&lt;&#x2F;java.version&gt;</span><br><span class="line">    &lt;&#x2F;properties&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;&#x2F;dependencies&gt;</span><br><span class="line"></span><br><span class="line">    &lt;build&gt;</span><br><span class="line">        &lt;plugins&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;spring-boot-maven-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;&#x2F;plugin&gt;</span><br><span class="line">        &lt;&#x2F;plugins&gt;</span><br><span class="line">    &lt;&#x2F;build&gt;</span><br><span class="line">&lt;&#x2F;project&gt;</span><br><span class="line">123456789101112131415161718192021222324252627282930313233343536373839404142</span><br></pre></td></tr></table></figure><h4 id="3、创建应用主类-ScaNacosConfigApplication，并实现一个HTTP接口"><a href="#3、创建应用主类-ScaNacosConfigApplication，并实现一个HTTP接口" class="headerlink" title="3、创建应用主类 ScaNacosConfigApplication，并实现一个HTTP接口"></a>3、创建应用主类 <code>ScaNacosConfigApplication</code>，并实现一个HTTP接口</h4>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package cn.fxbin.learn.sca.nacos.provider;</span><br><span class="line"></span><br><span class="line">import org.springframework.beans.factory.annotation.Value;</span><br><span class="line">import org.springframework.boot.SpringApplication;</span><br><span class="line">import org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line">import org.springframework.cloud.client.discovery.EnableDiscoveryClient;</span><br><span class="line">import org.springframework.cloud.context.config.annotation.RefreshScope;</span><br><span class="line">import org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class ScaNacosConfigApplication &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(ScaNacosConfigApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @RefreshScope</span><br><span class="line">    @RestController</span><br><span class="line">    public class ConfigController &#123;</span><br><span class="line"></span><br><span class="line">        @Value(&quot;$&#123;config.test&#125;&quot;)</span><br><span class="line">        private String configTest;</span><br><span class="line"></span><br><span class="line">        @GetMapping(&quot;&#x2F;config&quot;)</span><br><span class="line">        public String configTest() &#123;</span><br><span class="line">            return configTest;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">12345678910111213141516171819202122232425262728293031</span><br></pre></td></tr></table></figure><blockquote><p>这里要敲黑板，划重点 哈哈，<code>@RefreshScope</code>，主要用来让这个类下的配置内容支持动态刷新，也就是当我们的应用启动之后，修改了Nacos中的配置内容之后，这里也会马上生效。</p></blockquote><blockquote><p><strong>注意</strong>：你可以使用 <code>spring.cloud.nacos.config.refresh.enabled=false</code> 来关闭动态刷新</p></blockquote><h4 id="4、-bootstrap-yml-配置端口，配置服务名称和Nacos地址"><a href="#4、-bootstrap-yml-配置端口，配置服务名称和Nacos地址" class="headerlink" title="4、 bootstrap.yml 配置端口，配置服务名称和Nacos地址"></a>4、 <code>bootstrap.yml</code> 配置端口，配置服务名称和Nacos地址</h4>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 9034</span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    # 这里的应用名对应 Nacos Config 中的 Data ID，实际应用名称以配置中心的配置为准</span><br><span class="line">    name: sca-nacos-config-client</span><br><span class="line">  cloud:</span><br><span class="line">    nacos:</span><br><span class="line">      config:</span><br><span class="line">        # 指定查找名为 sca-nacos-config-client.yaml 的配置文件</span><br><span class="line">        file-extension: yaml</span><br><span class="line">        # Nacos Server 的地址</span><br><span class="line">        server-addr: 127.0.0.1:8848</span><br><span class="line">1234567891011121314</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>：Spring Boot 配置文件的加载顺序，依次为 <code>bootstrap.properties</code> -&gt; <code>bootstrap.yml</code> -&gt; <code>application.properties</code> -&gt; <code>application.yml</code> ，其中 <code>bootstrap.properties</code> 配置为最高优先级</p></blockquote><h4 id="5、启动应用程序"><a href="#5、启动应用程序" class="headerlink" title="5、启动应用程序"></a>5、启动应用程序</h4><p>  启动应用后我们可以通过日志看到，已经成功加载到了配置文件<br>  <img src="https://img-blog.csdnimg.cn/20190708000531764.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z4YmluMTIz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="6、测试验证配置获取和验证动态刷新"><a href="#6、测试验证配置获取和验证动态刷新" class="headerlink" title="6、测试验证配置获取和验证动态刷新"></a>6、测试验证配置获取和验证动态刷新</h4><blockquote><p>配置获取</p></blockquote><p>  通过<code>postman</code> 请求 <a href="http://localhost:9034/config" target="_blank" rel="noopener">http://localhost:9034/config</a> API<br>  <img src="https://img-blog.csdnimg.cn/20190708000838677.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z4YmluMTIz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><blockquote><p>配置动态刷新</p></blockquote><p>  在 Nacos 控制台 修改 <code>config.test</code> 值<br>  <img src="https://img-blog.csdnimg.cn/20190708001017274.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z4YmluMTIz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>  配置修改发布后，应用程序打印如下日志<br>  <img src="https://img-blog.csdnimg.cn/20190708001115623.png" alt="在这里插入图片描述"><br>  通过<code>postman</code> 请求 <a href="http://localhost:9034/config" target="_blank" rel="noopener">http://localhost:9034/config</a> API， 如下：<br>  <img src="https://img-blog.csdnimg.cn/20190708001141437.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z4YmluMTIz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>  参考资料：<br>  <a href="https://github.com/alibaba/spring-cloud-alibaba/wiki/Nacos-config" target="_blank" rel="noopener">https://github.com/alibaba/spring-cloud-alibaba/wiki/Nacos-config</a></p>]]></content>
    
    <summary type="html">
    
      面向服务
    
    </summary>
    
    
      <category term="Spring Cloud Alibaba" scheme="https://SomunsTao.github.io/categories/Spring-Cloud-Alibaba/"/>
    
    
      <category term="Spring Cloud Alibaba" scheme="https://SomunsTao.github.io/tags/Spring-Cloud-Alibaba/"/>
    
  </entry>
  
  <entry>
    <title>Vue 06：计算属性、内容分发、自定义事件</title>
    <link href="https://somunstao.github.io/2020/04/16/Vue%2006%EF%BC%9A%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E3%80%81%E5%86%85%E5%AE%B9%E5%88%86%E5%8F%91%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BA%8B%E4%BB%B6/"/>
    <id>https://somunstao.github.io/2020/04/16/Vue%2006%EF%BC%9A%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E3%80%81%E5%86%85%E5%AE%B9%E5%88%86%E5%8F%91%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BA%8B%E4%BB%B6/</id>
    <published>2020-04-15T16:00:00.000Z</published>
    <updated>2020-08-01T15:17:52.691Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Vue：计算属性、内容分发、自定义事件"><a href="#Vue：计算属性、内容分发、自定义事件" class="headerlink" title="Vue：计算属性、内容分发、自定义事件"></a>Vue：计算属性、内容分发、自定义事件</h1><h2 id="什么是计算属性"><a href="#什么是计算属性" class="headerlink" title="什么是计算属性"></a>什么是计算属性</h2><p>计算属性的重点突出在 <code>属性</code> 两个字上（属性是名词），首先它是个 <code>属性</code> 其次这个属性有 <code>计算</code> 的能力（计算是动词），这里的 <code>计算</code> 就是个函数；简单点说，它就是一个能够将计算结果缓存起来的属性（将行为转化成了静态的属性），仅此而已；可以想象为缓存！</p><p><strong>上代码：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;狂神说Java&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;vue@2.5.21&#x2F;dist&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;div id&#x3D;&quot;vue&quot;&gt;</span><br><span class="line">    &lt;!--注意，一个是方法，一个是属性--&gt;</span><br><span class="line">    &lt;p&gt;调用当前时间的方法：&#123;&#123;currentTime1()&#125;&#125;&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;p&gt;当前时间的计算属性：&#123;&#123;currentTime2&#125;&#125;&lt;&#x2F;p&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">    var vm &#x3D; new Vue(&#123;</span><br><span class="line">        el: &#39;#vue&#39;,</span><br><span class="line">        data: &#123;</span><br><span class="line">            message: &#39;Hello Vue&#39;</span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line">            currentTime1: function () &#123;</span><br><span class="line">                return Date.now();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        computed: &#123;</span><br><span class="line">            &#x2F;&#x2F;currentTime2 ，这是一个属性！不是方法</span><br><span class="line">            currentTime2: function () &#123;</span><br><span class="line">                this.message;</span><br><span class="line">                return Date.now();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p><strong>注意：methods 和 computed 里的东西不能重名</strong></p><p><strong>说明：</strong></p><ul><li>methods：定义方法，调用方法使用 currentTime1()，需要带括号</li><li>computed：定义计算属性，调用属性使用 currentTime2，不需要带括号；this.message 是为了能够让 currentTime2 观察到数据变化而变化</li><li>如何在方法中的值发生了变化，则缓存就会刷新！可以在控制台使用 <code>vm.message=&quot;qinjiang&quot;</code>,改变下数据的值，再次测试观察效果！</li></ul><p><strong>结论：</strong></p><p>调用方法时，每次都需要进行计算，既然有计算过程则必定产生系统开销，那如果这个结果是不经常变化的呢？此时就可以考虑将这个结果缓存起来，采用计算属性可以很方便的做到这一点,<strong>计算属性的主要特性就是为了将不经常变化的计算结果进行缓存，以节约我们的系统开销;</strong></p><h2 id="内容分发"><a href="#内容分发" class="headerlink" title="内容分发"></a>内容分发</h2><p>在 <code>Vue.js</code> 中我们使用 <code>&lt;slot&gt;</code> 元素作为承载分发内容的出口，作者称其为 插槽，可以应用在组合组件的场景中;</p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>比如准备制作一个待办事项组件（todo），该组件由待办标题（todo-title）和待办内容（todo-items）组成，但这三个组件又是相互独立的，该如何操作呢？</p><p><strong>第一步: 定义一个待办事项的组件</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;vue&quot;&gt;</span><br><span class="line">    &lt;todo&gt;&lt;&#x2F;todo&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">    Vue.component(&#39;todo&#39;, &#123;</span><br><span class="line">        template: &#39;&lt;div&gt;\</span><br><span class="line">                    &lt;div&gt;待办事项&lt;&#x2F;div&gt;\</span><br><span class="line">                    &lt;ul&gt;\</span><br><span class="line">                        &lt;li&gt;学习狂神说Java&lt;&#x2F;li&gt;\</span><br><span class="line">                    &lt;&#x2F;ul&gt;\</span><br><span class="line">               &lt;&#x2F;div&gt;&#39;</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p><strong>第二步: 我们需要让,待办事项的标题和值实现动态绑定,怎么做呢? 我们可以留出一个插槽!</strong></p><p>1-将上面的代码留出一个插槽,即 slot</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Vue.component(&#39;todo&#39;, &#123;</span><br><span class="line">    template: &#39;&lt;div&gt;\</span><br><span class="line">                    &lt;slot name&#x3D;&quot;todo-title&quot;&gt;&lt;&#x2F;slot&gt;\</span><br><span class="line">                    &lt;ul&gt;\</span><br><span class="line">                        &lt;slot name&#x3D;&quot;todo-items&quot;&gt;&lt;&#x2F;slot&gt;\</span><br><span class="line">                    &lt;&#x2F;ul&gt;\</span><br><span class="line">               &lt;&#x2F;div&gt;&#39;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>2-定义一个名为 todo-title 的待办标题组件 和 todo-items 的待办内容组件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Vue.component(&#39;todo-title&#39;, &#123;</span><br><span class="line">    props: [&#39;title&#39;],</span><br><span class="line">    template: &#39;&lt;div&gt;&#123;&#123;title&#125;&#125;&lt;&#x2F;div&gt;&#39;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;这里的index,就是数组的下标,使用for循环遍历的时候,可以循环出来!</span><br><span class="line">Vue.component(&#39;todo-items&#39;, &#123;</span><br><span class="line">    props: [&#39;item&#39;, &#39;index&#39;],</span><br><span class="line">    template: &#39;&lt;li&gt;&#123;&#123;index + 1&#125;&#125;. &#123;&#123;item&#125;&#125;&lt;&#x2F;li&gt;&#39;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>3-实例化 Vue 并初始化数据</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var vm &#x3D; new Vue(&#123;</span><br><span class="line">    el: &#39;#vue&#39;,</span><br><span class="line">    data: &#123;</span><br><span class="line">        todoItems: [&#39;狂神说Java&#39;, &#39;狂神说运维&#39;, &#39;狂神说前端&#39;]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>4-将这些值,通过插槽插入</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;vue&quot;&gt;</span><br><span class="line">    &lt;todo&gt;</span><br><span class="line">        &lt;todo-title slot&#x3D;&quot;todo-title&quot; title&#x3D;&quot;秦老师系列课程&quot;&gt;&lt;&#x2F;todo-title&gt;</span><br><span class="line">        &lt;todo-items slot&#x3D;&quot;todo-items&quot; v-for&#x3D;&quot;(item, index) in todoItems&quot; v-bind:item&#x3D;&quot;item&quot; v-bind:index&#x3D;&quot;index&quot; :key&#x3D;&quot;index&quot;&gt;&lt;&#x2F;todo-items&gt;</span><br><span class="line">    &lt;&#x2F;todo&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><p>说明:我们的 todo-title 和 todo-items 组件分别被分发到了 todo 组件的 todo-title 和 todo-items 插槽中</p><h2 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a>自定义事件</h2><p>通过以上代码不难发现，数据项在 Vue 的实例中，但删除操作要在组件中完成，那么组件如何才能删除 Vue 实例中的数据呢？此时就涉及到参数传递与事件分发了，Vue 为我们提供了自定义事件的功能很好的帮助我们解决了这个问题；使用 this.$emit(‘自定义事件名’, 参数)，操作过程如下:</p><p>1-在vue的实例中,增加了 methods 对象并定义了一个名为 removeTodoItems 的方法</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var vm &#x3D; new Vue(&#123;</span><br><span class="line">    el: &#39;#vue&#39;,</span><br><span class="line">    data: &#123;</span><br><span class="line">        title: &quot;秦老师系列课程1&quot;,</span><br><span class="line">        todoItems: [&#39;狂神说Java&#39;, &#39;狂神说运维&#39;, &#39;狂神说前端&#39;]</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        &#x2F;&#x2F; 该方法可以被模板中自定义事件触发</span><br><span class="line">        removeTodoItems: function (index) &#123;</span><br><span class="line">            console.log(&quot;删除 &quot; + this.todoItems[index] + &quot; 成功&quot;);</span><br><span class="line">            &#x2F;&#x2F; splice() 方法向&#x2F;从数组中添加&#x2F;删除项目，然后返回被删除的项目，其中 index 为添加&#x2F;删除项目的位置，1 表示删除的数量</span><br><span class="line">            this.todoItems.splice(index, 1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>2-修改 todo-items 待办内容组件的代码,增加一个删除按钮,并且绑定事件!</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Vue.component(&#39;todo-items&#39;, &#123;</span><br><span class="line">    props: [&#39;item&#39;, &#39;index&#39;],</span><br><span class="line">    template: &#39;&lt;li&gt;&#123;&#123;index + 1&#125;&#125;. &#123;&#123;item&#125;&#125;  &lt;button @click&#x3D;&quot;remove_component&quot;&gt;删除&lt;&#x2F;button&gt;&lt;&#x2F;li&gt;&#39;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        remove_component: function (index) &#123;</span><br><span class="line">            &#x2F;&#x2F; 这里的 remove 是自定义事件的名称，需要在 HTML 中使用 v-on:remove 的方式指派</span><br><span class="line">            this.$emit(&#39;remove&#39;, index);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>3-修改 todo-items 待办内容组件的 HTML 代码,增加一个自定义事件,比如叫 remove,可以和组件的方法绑定,然后绑定到vue的方法中!</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--增加了 v-on:remove&#x3D;&quot;removeTodoItems(index)&quot; 自定义事件，该事件会调用 Vue 实例中定义的名为 removeTodoItems 的方法--&gt;</span><br><span class="line">&lt;todo-items slot&#x3D;&quot;todo-items&quot; v-for&#x3D;&quot;(item, index) in todoItems&quot;</span><br><span class="line">            v-bind:item&#x3D;&quot;item&quot; v-bind:index&#x3D;&quot;index&quot; :key&#x3D;&quot;index&quot;</span><br><span class="line">            v-on:remove&#x3D;&quot;removeTodoItems(index)&quot;&gt;&lt;&#x2F;todo-items&gt;</span><br></pre></td></tr></table></figure><h3 id="逻辑理解"><a href="#逻辑理解" class="headerlink" title="逻辑理解"></a>逻辑理解</h3><p><img src="https://blog.kuangstudy.com/usr/uploads/2019/10/2041589231.png" alt="20191023150103.png"></p><h2 id="Vue-入门小结"><a href="#Vue-入门小结" class="headerlink" title="Vue 入门小结"></a>Vue 入门小结</h2><p>核心 : 数据驱动 , 组件化<br>优点 : 借鉴了 AngulaJS 的模块化开发 和 React 的虚拟Dom , 虚拟Dom就是把Dom操作放到内存中执行;</p><p>常用的属性:</p><ul><li>v-if</li><li>v-else-if</li><li>v-else</li><li>v-for</li><li>v-on 绑定事件 , 简写<code>@</code></li><li>v-model 数据双向绑定</li><li>v-bind 给组件绑定参数,简写 <code>:</code></li></ul><p>组件化:</p><ul><li>组合组件 slot 插槽</li><li>组件内部绑定事件需要使用到 <code>this.$emit(&quot;事件名&quot;,参数)</code>;</li><li>计算属性的特色,缓存计算数据</li></ul><p>遵循SoC 关注度分离原则,Vue是纯粹的视图框架,并不包含,比如Ajax之类的通信功能,为了解决通信问题,我们需要使用Axios 框架做异步通信;</p><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>Vue的开发都是要基于NodeJS, 实际开发采用 vue-cli脚手架开发,vue-router 路由,vuex做状态管理; Vue UI,界面我们一般使用 ElementUI(饿了么出品),或者ICE(阿里巴巴出品!)来快速搭建前端项目~</p><p>官网:</p><ul><li><a href="https://element.eleme.cn/#/zh-CN" target="_blank" rel="noopener">https://element.eleme.cn/#/zh-CN</a></li><li><a href="https://ice.work/" target="_blank" rel="noopener">https://ice.work/</a></li></ul>]]></content>
    
    <summary type="html">
    
      前端体系、前后端分离
    
    </summary>
    
    
      <category term="Vue" scheme="https://SomunsTao.github.io/categories/Vue/"/>
    
    
      <category term="Vue" scheme="https://SomunsTao.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Spring Cloud Alibaba学习笔记:5、创建服务消费者（Feign）</title>
    <link href="https://somunstao.github.io/2020/04/15/Spring%20Cloud%20Alibaba%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B05%E3%80%81%E5%88%9B%E5%BB%BA%E6%9C%8D%E5%8A%A1%E6%B6%88%E8%B4%B9%E8%80%85%EF%BC%88Feign%EF%BC%89/"/>
    <id>https://somunstao.github.io/2020/04/15/Spring%20Cloud%20Alibaba%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B05%E3%80%81%E5%88%9B%E5%BB%BA%E6%9C%8D%E5%8A%A1%E6%B6%88%E8%B4%B9%E8%80%85%EF%BC%88Feign%EF%BC%89/</id>
    <published>2020-04-14T16:00:00.000Z</published>
    <updated>2020-08-02T03:05:07.867Z</updated>
    
    <content type="html"><![CDATA[<ul><li><h1 id="Spring-Cloud-Alibaba学习笔记-5、创建服务消费者（Feign）"><a href="#Spring-Cloud-Alibaba学习笔记-5、创建服务消费者（Feign）" class="headerlink" title="Spring Cloud Alibaba学习笔记:5、创建服务消费者（Feign）"></a>Spring Cloud Alibaba学习笔记:5、创建服务消费者（Feign）</h1></li><li><h3 id="文章目录"><a href="#文章目录" class="headerlink" title="文章目录"></a>文章目录</h3><ul><li><ul><li><ul><li><ul><li><p><a href="https://blog.csdn.net/fxbin123/article/details/95029632#_3" target="_blank" rel="noopener">前言</a></p></li><li><p><a href="https://blog.csdn.net/fxbin123/article/details/95029632#Feign__8" target="_blank" rel="noopener">Feign 概述</a></p></li><li><p><a href="https://blog.csdn.net/fxbin123/article/details/95029632#feign__15" target="_blank" rel="noopener">创建feign 服务消费者</a></p></li><li><ul><li><p><a href="https://blog.csdn.net/fxbin123/article/details/95029632#1_maven_module__scanacosdiscoveryconsumerfeign_17" target="_blank" rel="noopener">1、 创建一个maven module 项目 <code>sca-nacos-discovery-consumer-feign</code></a></p></li><li><p><a href="https://blog.csdn.net/fxbin123/article/details/95029632#2_pom_18" target="_blank" rel="noopener">2、 pom</a></p></li><li><p><a href="https://blog.csdn.net/fxbin123/article/details/95029632#3_ScaNacosFeignApplication_69" target="_blank" rel="noopener">3、创建应用主类别 <code>ScaNacosFeignApplication</code></a></p></li><li><p><a href="https://blog.csdn.net/fxbin123/article/details/95029632#4_feign__92" target="_blank" rel="noopener">4、创建 feign 客户端</a></p></li><li><p><a href="https://blog.csdn.net/fxbin123/article/details/95029632#5_ConsumerController_118" target="_blank" rel="noopener">5、创建 <code>ConsumerController</code></a></p></li><li><p><a href="https://blog.csdn.net/fxbin123/article/details/95029632#6Nacos_153" target="_blank" rel="noopener">6、配置服务端口、名称、服务端点检查和Nacos地址</a></p></li><li><p><a href="https://blog.csdn.net/fxbin123/article/details/95029632#7Feign_176" target="_blank" rel="noopener">7、启动Feign服务消费者</a></p></li><li><p><a href="https://blog.csdn.net/fxbin123/article/details/95029632#8nacos__178" target="_blank" rel="noopener">8、检查nacos 控制台</a></p></li><li><p><a href="https://blog.csdn.net/fxbin123/article/details/95029632#9_180" target="_blank" rel="noopener">9、测试消费者</a></p></li><li><ul><li><a href="https://blog.csdn.net/fxbin123/article/details/95029632#_API_181" target="_blank" rel="noopener">&gt; 测试服务消费API</a></li><li><a href="https://blog.csdn.net/fxbin123/article/details/95029632#__188" target="_blank" rel="noopener">&gt; 测试服务负载</a></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>  上篇文章， <a href="https://blog.csdn.net/fxbin123/article/details/95025897" target="_blank" rel="noopener">Spring Cloud Alibaba学习笔记:4、创建服务消费者（RestTemplate + LoadBalancerClient）</a>，<br>  我们一起学习了 使用 RestTemplate + LoadBalancerClient 的方式 去创建服务消费者，但是依旧显得繁琐，本文，我们将结合使用 spring-cloud-openfeign 来创建服务消费者，简化消费调用…<br>  一起开始吧</p><h4 id="Feign-概述"><a href="#Feign-概述" class="headerlink" title="Feign 概述"></a>Feign 概述</h4><blockquote><p>Feign 是一个声明式的伪 Http 客户端，它使得写 Http 客户端变得更简单。使用 Feign，只需要创建一个接口并注解。它具有可插拔的注解特性，可使用 Feign 注解和 JAX-RS 注解。Feign 支持可插拔的编码器和解码器。Feign 默认集成了 Ribbon，Nacos 也很好的兼容了 Feign，默认实现了负载均衡的效果</p></blockquote><ul><li><p>Feign 采用的是基于接口的注解</p></li><li><p>Feign 整合了 ribbon</p><h4 id="创建feign-服务消费者"><a href="#创建feign-服务消费者" class="headerlink" title="创建feign 服务消费者"></a>创建feign 服务消费者</h4><h5 id="1、-创建一个maven-module-项目-sca-nacos-discovery-consumer-feign"><a href="#1、-创建一个maven-module-项目-sca-nacos-discovery-consumer-feign" class="headerlink" title="1、 创建一个maven module 项目 sca-nacos-discovery-consumer-feign"></a>1、 创建一个maven module 项目 <code>sca-nacos-discovery-consumer-feign</code></h5><h5 id="2、-pom"><a href="#2、-pom" class="headerlink" title="2、 pom"></a>2、 pom</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot;</span><br><span class="line">         xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">         xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;</span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;groupId&gt;cn.fxbin.learn&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;sca&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;version&gt;1.0&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;&#x2F;parent&gt;</span><br><span class="line"></span><br><span class="line">    &lt;artifactId&gt;sca-nacos-discovery-consumer-feign&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.0&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;name&gt;sca-nacos-discovery-consumer-feign&lt;&#x2F;name&gt;</span><br><span class="line">    &lt;description&gt;Spring Cloud Alibaba Nacos Discovery Consumer Feign Service Project&lt;&#x2F;description&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;!-- spring-boot web --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- nacos-discovery --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- openfeign --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;&#x2F;dependencies&gt;</span><br><span class="line"></span><br><span class="line">    &lt;build&gt;</span><br><span class="line">        &lt;plugins&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;spring-boot-maven-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;&#x2F;plugin&gt;</span><br><span class="line">        &lt;&#x2F;plugins&gt;</span><br><span class="line">    &lt;&#x2F;build&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;project&gt;</span><br><span class="line">12345678910111213141516171819202122232425262728293031323334353637383940414243444546</span><br></pre></td></tr></table></figure><h5 id="3、创建应用主类别-ScaNacosFeignApplication"><a href="#3、创建应用主类别-ScaNacosFeignApplication" class="headerlink" title="3、创建应用主类别 ScaNacosFeignApplication"></a>3、创建应用主类别 <code>ScaNacosFeignApplication</code></h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package cn.fxbin.learn.sca.nacos.consumer;</span><br><span class="line"></span><br><span class="line">import org.springframework.boot.SpringApplication;</span><br><span class="line">import org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line">import org.springframework.cloud.client.discovery.EnableDiscoveryClient;</span><br><span class="line">import org.springframework.cloud.openfeign.EnableFeignClients;</span><br><span class="line"></span><br><span class="line">@EnableFeignClients</span><br><span class="line">@EnableDiscoveryClient</span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class ScaNacosFeignApplication &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(ScaNacosFeignApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">123456789101112131415161718</span><br></pre></td></tr></table></figure><h5 id="4、创建-feign-客户端"><a href="#4、创建-feign-客户端" class="headerlink" title="4、创建 feign 客户端"></a>4、创建 feign 客户端</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package cn.fxbin.learn.sca.nacos.consumer.client;</span><br><span class="line"></span><br><span class="line">import org.springframework.cloud.openfeign.FeignClient;</span><br><span class="line">import org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * DiscoveryClient</span><br><span class="line"> *</span><br><span class="line"> * @author fxbin</span><br><span class="line"> * @version v1.0</span><br><span class="line"> * @since 2019&#x2F;7&#x2F;7 22:47</span><br><span class="line"> *&#x2F;</span><br><span class="line">@FeignClient(&quot;sca-nacos-discovery-provider&quot;)</span><br><span class="line">public interface DiscoveryClient &#123;</span><br><span class="line"></span><br><span class="line">    @GetMapping(value &#x3D; &quot;&#x2F;echo&#x2F;&#123;message&#125;&quot;)</span><br><span class="line">    String echo(@PathVariable String message);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">123456789101112131415161718192021</span><br></pre></td></tr></table></figure><h5 id="5、创建-ConsumerController"><a href="#5、创建-ConsumerController" class="headerlink" title="5、创建 ConsumerController"></a>5、创建 <code>ConsumerController</code></h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package cn.fxbin.learn.sca.nacos.consumer.controller;</span><br><span class="line"></span><br><span class="line">import cn.fxbin.learn.sca.nacos.consumer.client.DiscoveryClient;</span><br><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line">import org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line">import javax.annotation.Resource;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * ConsumerController</span><br><span class="line"> *</span><br><span class="line"> * @author fxbin</span><br><span class="line"> * @version v1.0</span><br><span class="line"> * @since 2019&#x2F;7&#x2F;7 20:36</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Slf4j</span><br><span class="line">@RestController</span><br><span class="line">public class ConsumerController &#123;</span><br><span class="line"></span><br><span class="line">    @Resource</span><br><span class="line">    private DiscoveryClient discoveryClient;</span><br><span class="line"></span><br><span class="line">    @GetMapping(value &#x3D; &quot;&#x2F;test&quot;)</span><br><span class="line">    public String test() &#123;</span><br><span class="line">        return discoveryClient.echo(&quot; !^@^! &quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">123456789101112131415161718192021222324252627282930</span><br></pre></td></tr></table></figure><h5 id="6、配置服务端口、名称、服务端点检查和Nacos地址"><a href="#6、配置服务端口、名称、服务端点检查和Nacos地址" class="headerlink" title="6、配置服务端口、名称、服务端点检查和Nacos地址"></a>6、配置服务端口、名称、服务端点检查和Nacos地址</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 9033</span><br><span class="line"></span><br><span class="line">management:</span><br><span class="line">  endpoints:</span><br><span class="line">    web:</span><br><span class="line">      exposure:</span><br><span class="line">        include: &quot;*&quot;</span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: sca-nacos-discovery-consumer-feign</span><br><span class="line">  cloud:</span><br><span class="line">    nacos:</span><br><span class="line">      discovery:</span><br><span class="line">        server-addr: 127.0.0.1:8848</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">123456789101112131415161718</span><br></pre></td></tr></table></figure><h5 id="7、启动Feign服务消费者"><a href="#7、启动Feign服务消费者" class="headerlink" title="7、启动Feign服务消费者"></a>7、启动Feign服务消费者</h5><p><img src="https://img-blog.csdnimg.cn/20190707225616949.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z4YmluMTIz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h5 id="8、检查nacos-控制台"><a href="#8、检查nacos-控制台" class="headerlink" title="8、检查nacos 控制台"></a>8、检查nacos 控制台</h5><p><img src="https://img-blog.csdnimg.cn/20190707225715357.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z4YmluMTIz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h5 id="9、测试消费者"><a href="#9、测试消费者" class="headerlink" title="9、测试消费者"></a>9、测试消费者</h5><h6 id="gt-测试服务消费API"><a href="#gt-测试服务消费API" class="headerlink" title="&gt; 测试服务消费API"></a>&gt; 测试服务消费API</h6><p>postman 调用 api: <a href="http://localhost:9033/test" target="_blank" rel="noopener">http://localhost:9033/test</a></p><p><img src="https://img-blog.csdnimg.cn/20190707225905774.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z4YmluMTIz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190707225945330.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z4YmluMTIz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h6 id="gt-测试服务负载"><a href="#gt-测试服务负载" class="headerlink" title="&gt; 测试服务负载"></a>&gt; 测试服务负载</h6></li><li><p>修改<code>sca-nacos-discovery-provider</code> 服务 api, 打印当前服务端口</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  @RestController</span><br><span class="line">  public class EchoController &#123;</span><br><span class="line"></span><br><span class="line">       @Value(&quot;$&#123;server.port&#125;&quot;)</span><br><span class="line">       private String port;</span><br><span class="line"> </span><br><span class="line">      @GetMapping(value &#x3D; &quot;&#x2F;echo&#x2F;&#123;message&#125;&quot;)</span><br><span class="line">      public String echo(@PathVariable String message) &#123;</span><br><span class="line">          return &quot;Hello Nacos Discovery Provider : &quot; + message + &quot;, port :&quot; + port;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">1234567891011</span><br></pre></td></tr></table></figure></li><li><p>接下来重新启动原有实例，并再启动一个 <code>sca-nacos-discovery-provide</code> 的实例， 如下所示：<br><img src="https://img-blog.csdnimg.cn/20190707230622801.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z4YmluMTIz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li><li><p>再次请求 <a href="http://localhost:9033/test" target="_blank" rel="noopener">http://localhost:9033/test</a> , 会交替显示如下信息：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Hello Nacos Discovery Provider :  !^@^! , port :8081</span><br><span class="line">Hello Nacos Discovery Provider :  !^@^! , port :9030</span><br><span class="line">12</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20190707231059323.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z4YmluMTIz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190707231114625.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z4YmluMTIz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li></ul>]]></content>
    
    <summary type="html">
    
      面向服务
    
    </summary>
    
    
      <category term="Spring Cloud Alibaba" scheme="https://SomunsTao.github.io/categories/Spring-Cloud-Alibaba/"/>
    
    
      <category term="Spring Cloud Alibaba" scheme="https://SomunsTao.github.io/tags/Spring-Cloud-Alibaba/"/>
    
  </entry>
  
  <entry>
    <title>Vue 05：表单双绑、组件</title>
    <link href="https://somunstao.github.io/2020/04/15/Vue%2005%EF%BC%9A%E8%A1%A8%E5%8D%95%E5%8F%8C%E7%BB%91%E3%80%81%E7%BB%84%E4%BB%B6/"/>
    <id>https://somunstao.github.io/2020/04/15/Vue%2005%EF%BC%9A%E8%A1%A8%E5%8D%95%E5%8F%8C%E7%BB%91%E3%80%81%E7%BB%84%E4%BB%B6/</id>
    <published>2020-04-14T16:00:00.000Z</published>
    <updated>2020-08-01T15:17:33.652Z</updated>
    
    <content type="html"><![CDATA[<p>​    </p><h1 id="Vue：表单双绑、组件"><a href="#Vue：表单双绑、组件" class="headerlink" title="Vue：表单双绑、组件"></a>Vue：表单双绑、组件</h1><h2 id="什么是双向数据绑定"><a href="#什么是双向数据绑定" class="headerlink" title="什么是双向数据绑定"></a>什么是双向数据绑定</h2><p>Vue.js 是一个 MVVM 框架，即数据双向绑定，即当数据发生变化的时候，视图也就发生变化，当视图发生变化的时候，数据也会跟着同步变化。这也算是 Vue.js 的精髓之处了。</p><p>值得注意的是，我们所说的数据双向绑定，一定是对于 UI 控件来说的，非 UI 控件不会涉及到数据双向绑定。单向数据绑定是使用状态管理工具的前提。如果我们使用 <code>vuex</code>，那么数据流也是单项的，这时就会和双向数据绑定有冲突。</p><h3 id="为什么要实现数据的双向绑定"><a href="#为什么要实现数据的双向绑定" class="headerlink" title="为什么要实现数据的双向绑定"></a>为什么要实现数据的双向绑定</h3><p>在 <code>Vue.js</code> 中，如果使用 <code>vuex</code>，实际上数据还是单向的，之所以说是数据双向绑定，这是用的 UI 控件来说，对于我们处理表单，Vue.js 的双向数据绑定用起来就特别舒服了。即两者并不互斥，在全局性数据流使用单项，方便跟踪；局部性数据流使用双向，简单易操作。</p><h2 id="在表单中使用双向数据绑定"><a href="#在表单中使用双向数据绑定" class="headerlink" title="在表单中使用双向数据绑定"></a>在表单中使用双向数据绑定</h2><p>你可以用 <code>v-model</code> 指令在表单 <code>&lt;input&gt;</code>、<code>&lt;textarea&gt;</code> 及 <code>&lt;select&gt;</code> 元素上创建双向数据绑定。它会根据控件类型自动选取正确的方法来更新元素。尽管有些神奇，但 v-model 本质上不过是语法糖。它负责监听用户的输入事件以更新数据，并对一些极端场景进行一些特殊处理。</p><p><strong>注意：v-model 会忽略所有表单元素的 value、checked、selected 特性的初始值而总是将 Vue 实例的数据作为数据来源。你应该通过 JavaScript 在组件的 data 选项中声明初始值!</strong></p><h3 id="单行文本"><a href="#单行文本" class="headerlink" title="单行文本"></a>单行文本</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;狂神说Java&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;vue@2.5.21&#x2F;dist&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--我们这里希望，输入框的值和&#123;&#125;取值动态绑定，实时相同，我们就使用v-model绑定message--&gt;</span><br><span class="line">&lt;div id&#x3D;&quot;vue&quot;&gt;</span><br><span class="line">    单行文本：&lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;message&quot; value&#x3D;&quot;hello&quot; &#x2F;&gt;&amp;nbsp;&amp;nbsp;单行文本是：&#123;&#123;message&#125;&#125;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">    var vm &#x3D; new Vue(&#123;</span><br><span class="line">        el: &#39;#vue&#39;,</span><br><span class="line">        data: &#123;</span><br><span class="line">            message: &quot;Hello Vue&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><h3 id="多行文本"><a href="#多行文本" class="headerlink" title="多行文本"></a>多行文本</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;vue&quot;&gt;</span><br><span class="line">    多行文本：&lt;textarea v-model&#x3D;&quot;message&quot;&gt;&lt;&#x2F;textarea&gt;&amp;nbsp;&amp;nbsp;多行文本是：&#123;&#123;message&#125;&#125;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">    var vm &#x3D; new Vue(&#123;</span><br><span class="line">        el: &#39;#vue&#39;,</span><br><span class="line">        data: &#123;</span><br><span class="line">            message: &quot;Hello Textarea&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h3 id="单复选框"><a href="#单复选框" class="headerlink" title="单复选框"></a>单复选框</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;vue&quot;&gt;</span><br><span class="line">    单复选框：</span><br><span class="line">    &lt;input type&#x3D;&quot;checkbox&quot; id&#x3D;&quot;checkbox&quot; v-model&#x3D;&quot;checked&quot;&gt;</span><br><span class="line">    &amp;nbsp;&amp;nbsp;</span><br><span class="line">    &lt;label for&#x3D;&quot;checkbox&quot;&gt;&#123;&#123; checked &#125;&#125;&lt;&#x2F;label&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">    var vm &#x3D; new Vue(&#123;</span><br><span class="line">        el: &#39;#vue&#39;,</span><br><span class="line">        data: &#123;</span><br><span class="line">            checked: false</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h3 id="多复选框"><a href="#多复选框" class="headerlink" title="多复选框"></a>多复选框</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;vue&quot;&gt;</span><br><span class="line">    多复选框：</span><br><span class="line">    &lt;input type&#x3D;&quot;checkbox&quot; id&#x3D;&quot;jack&quot; value&#x3D;&quot;Jack&quot; v-model&#x3D;&quot;checkedNames&quot;&gt;</span><br><span class="line">    &lt;label for&#x3D;&quot;jack&quot;&gt;Jack&lt;&#x2F;label&gt;</span><br><span class="line">    &lt;input type&#x3D;&quot;checkbox&quot; id&#x3D;&quot;john&quot; value&#x3D;&quot;John&quot; v-model&#x3D;&quot;checkedNames&quot;&gt;</span><br><span class="line">    &lt;label for&#x3D;&quot;john&quot;&gt;John&lt;&#x2F;label&gt;</span><br><span class="line">    &lt;input type&#x3D;&quot;checkbox&quot; id&#x3D;&quot;mike&quot; value&#x3D;&quot;Mike&quot; v-model&#x3D;&quot;checkedNames&quot;&gt;</span><br><span class="line">    &lt;label for&#x3D;&quot;mike&quot;&gt;Mike&lt;&#x2F;label&gt;</span><br><span class="line">    &lt;span&gt;选中的值: &#123;&#123; checkedNames &#125;&#125;&lt;&#x2F;span&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">    var vm &#x3D; new Vue(&#123;</span><br><span class="line">        el: &#39;#vue&#39;,</span><br><span class="line">        data: &#123;</span><br><span class="line">            checkedNames: []</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h3 id="单选按钮"><a href="#单选按钮" class="headerlink" title="单选按钮"></a>单选按钮</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;vue&quot;&gt;</span><br><span class="line">    单选按钮：</span><br><span class="line">    &lt;input type&#x3D;&quot;radio&quot; id&#x3D;&quot;one&quot; value&#x3D;&quot;One&quot; v-model&#x3D;&quot;picked&quot;&gt;</span><br><span class="line">    &lt;label for&#x3D;&quot;one&quot;&gt;One&lt;&#x2F;label&gt;</span><br><span class="line">    &lt;input type&#x3D;&quot;radio&quot; id&#x3D;&quot;two&quot; value&#x3D;&quot;Two&quot; v-model&#x3D;&quot;picked&quot;&gt;</span><br><span class="line">    &lt;label for&#x3D;&quot;two&quot;&gt;Two&lt;&#x2F;label&gt;</span><br><span class="line">    &lt;span&gt;选中的值: &#123;&#123; picked &#125;&#125;&lt;&#x2F;span&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">    var vm &#x3D; new Vue(&#123;</span><br><span class="line">        el: &#39;#vue&#39;,</span><br><span class="line">        data: &#123;</span><br><span class="line">            picked: &#39;&#39;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h3 id="下拉框"><a href="#下拉框" class="headerlink" title="下拉框"></a>下拉框</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;vue&quot;&gt;</span><br><span class="line">    下拉框：</span><br><span class="line">    &lt;select v-model&#x3D;&quot;selected&quot;&gt;</span><br><span class="line">        &lt;option disabled value&#x3D;&quot;&quot;&gt;请选择&lt;&#x2F;option&gt;</span><br><span class="line">        &lt;option&gt;A&lt;&#x2F;option&gt;</span><br><span class="line">        &lt;option&gt;B&lt;&#x2F;option&gt;</span><br><span class="line">        &lt;option&gt;C&lt;&#x2F;option&gt;</span><br><span class="line">    &lt;&#x2F;select&gt;</span><br><span class="line">    &lt;span&gt;选中的值: &#123;&#123; selected &#125;&#125;&lt;&#x2F;span&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">    var vm &#x3D; new Vue(&#123;</span><br><span class="line">        el: &#39;#vue&#39;,</span><br><span class="line">        data: &#123;</span><br><span class="line">            selected: &#39;&#39;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：如果 <code>v-model</code> 表达式的初始值未能匹配任何选项，<select> 元素将被渲染为“未选中”状态。在 iOS 中，这会使用户无法选择第一个选项。因为这样的情况下，iOS 不会触发 change 事件。因此，更推荐像上面这样提供一个值为空的禁用选项。</p><h2 id="什么是组件"><a href="#什么是组件" class="headerlink" title="什么是组件"></a>什么是组件</h2><p>组件是可复用的 <code>Vue</code> 实例，说白了就是一组可以重复使用的模板，跟 JSTL 的自定义标签、Thymeleaf 的 <code>th:fragment</code>等框架有着异曲同工之妙。通常一个应用会以一棵嵌套的组件树的形式来组织：</p><p><img src="https://blog.kuangstudy.com/usr/uploads/2019/10/1384909422.png" alt="vue-component.png"></p><p>例如，你可能会有页头、侧边栏、内容区等组件，每个组件又包含了其它的像导航链接、博文之类的组件。</p><h3 id="第一个-Vue-组件"><a href="#第一个-Vue-组件" class="headerlink" title="第一个 Vue 组件"></a>第一个 Vue 组件</h3><p>注意：在实际开发中，我们并不会用以下方式开发组件，而是采用 vue-cli 创建 .vue 模板文件的方式开发，以下方法只是为了让大家理解什么是组件。</p><p><strong>使用 Vue.component() 方法注册组件,格式如下：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">    &#x2F;&#x2F; 先注册组件</span><br><span class="line">    Vue.component(&#39;my-component-li&#39;, &#123;</span><br><span class="line">        template: &#39;&lt;li&gt;Hello li&lt;&#x2F;li&gt;&#39;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 再实例化 Vue</span><br><span class="line">    var vm &#x3D; new Vue(&#123;</span><br><span class="line">        el: &#39;#vue&#39;</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;div id&#x3D;&quot;vue&quot;&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">        &lt;my-component-li&gt;&lt;&#x2F;my-component-li&gt;</span><br><span class="line">    &lt;&#x2F;ul&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li>Vue.component()：注册组件</li><li>my-component-li：自定义组件的名字</li><li>template：组件的模板</li></ul><h3 id="使用-props-属性传递参数"><a href="#使用-props-属性传递参数" class="headerlink" title="使用 props 属性传递参数"></a>使用 <code>props</code> 属性传递参数</h3><p>像上面那样用组件没有任何意义，所以我们是需要传递参数到组件的，此时就需要使用 <code>props</code> 属性了！</p><p><strong>注意：默认规则下 props 属性里的值不能为大写；</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">    &#x2F;&#x2F; 先注册组件</span><br><span class="line">    Vue.component(&#39;my-component-li&#39;, &#123;</span><br><span class="line">        props: [&#39;item&#39;],</span><br><span class="line">        template: &#39;&lt;li&gt;Hello &#123;&#123;item&#125;&#125;&lt;&#x2F;li&gt;&#39;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 再实例化 Vue</span><br><span class="line">    var vm &#x3D; new Vue(&#123;</span><br><span class="line">        el: &#39;#vue&#39;,</span><br><span class="line">        data: &#123;</span><br><span class="line">            items: [&quot;张三&quot;, &quot;李四&quot;, &quot;王五&quot;]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;div id&#x3D;&quot;vue&quot;&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">        &lt;my-component-li v-for&#x3D;&quot;item in items&quot; v-bind:item&#x3D;&quot;item&quot;&gt;&lt;&#x2F;my-component-li&gt;</span><br><span class="line">    &lt;&#x2F;ul&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li><code>v-for=&quot;item in items&quot;</code>：遍历 <code>Vue</code> 实例中定义的名为 <code>items</code> 的数组，并创建同等数量的组件</li><li><code>v-bind:item=&quot;item&quot;</code>：将遍历的 <code>item</code> 项绑定到组件中 <code>props</code> 定义的名为 <code>item</code> 属性上；= 号左边的 item 为 props 定义的属性名，右边的为 <code>item in items</code> 中遍历的 item 项的值</li></ul>]]></content>
    
    <summary type="html">
    
      前端体系、前后端分离
    
    </summary>
    
    
      <category term="Vue" scheme="https://SomunsTao.github.io/categories/Vue/"/>
    
    
      <category term="Vue" scheme="https://SomunsTao.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Spring Cloud Alibaba学习笔记:1、简介</title>
    <link href="https://somunstao.github.io/2020/04/14/Spring%20Cloud%20Alibaba%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%201%E3%80%81%E7%AE%80%E4%BB%8B/"/>
    <id>https://somunstao.github.io/2020/04/14/Spring%20Cloud%20Alibaba%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%201%E3%80%81%E7%AE%80%E4%BB%8B/</id>
    <published>2020-04-13T16:00:00.000Z</published>
    <updated>2020-08-02T03:38:55.861Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring-Cloud-Alibaba学习笔记-1、简介"><a href="#Spring-Cloud-Alibaba学习笔记-1、简介" class="headerlink" title="Spring Cloud Alibaba学习笔记: 1、简介"></a>Spring Cloud Alibaba学习笔记: 1、简介</h1><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>2018 年 10 月 31 日的凌晨，Spring Cloud Alibaba 正式入驻了 Spring Cloud 官方孵化器，并在 Maven 中央库发布了第一个版本。</p><p>Spring Cloud Alibaba 致力于提供微服务开发的一站式解决方案。此项目包含开发分布式应用服务的必需组件，方便开发者通过 Spring Cloud 编程模型轻松使用这些组件来开发分布式应用服务。</p><p>依托 Spring Cloud Alibaba，您只需要添加一些注解和少量配置，就可以将 Spring Cloud 应用接入阿里分布式应用解决方案，通过阿里中间件来迅速搭建分布式应用系统。</p><p><a href="https://github.com/alibaba/spring-cloud-alibaba/blob/master/README-zh.md" target="_blank" rel="noopener">Spring Cloud Alibaba Github</a></p><p><a href="https://mp.weixin.qq.com/s/4jMRBCJ0jQslOIrO5d5drg" target="_blank" rel="noopener">Spring Cloud 加盟重量级成员Spring Cloud Alibaba，打造更符合中国国情的微服务体系</a></p><h3 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h3><ul><li>服务限流降级：默认支持 Servlet、Feign、RestTemplate、Dubbo 和 RocketMQ 限流降级功能的接入，可以在运行时通过控制台实时修改限流降级规则，还支持查看限流降级 Metrics 监控。</li><li>服务注册与发现：适配 Spring Cloud 服务注册与发现标准，默认集成了 Ribbon 的支持。</li><li>分布式配置管理：支持分布式系统中的外部化配置，配置更改时自动刷新。</li><li>消息驱动能力：基于 Spring Cloud Stream 为微服务应用构建消息驱动能力。<br>分布式事务：使用 @GlobalTransactional 注解， 高效并且对业务零侵入地解决分布式事务问题。。</li><li>阿里云对象存储：阿里云提供的海量、安全、低成本、高可靠的云存储服务。支持在任何应用、任何时间、任何地点存储和访问任意类型的数据。</li><li>分布式任务调度：提供秒级、精准、高可靠、高可用的定时（基于 Cron 表达式）任务调度服务。同时提供分布式的任务执行模型，如网格任务。网格任务支持海量子任务均匀分配到所有 Worker（schedulerx-client）上执行。</li><li>阿里云短信服务：覆盖全球的短信服务，友好、高效、智能的互联化通讯能力，帮助企业迅速搭建客户触达通道。</li></ul><h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><ul><li><a href="https://github.com/alibaba/Sentinel" target="_blank" rel="noopener">Sentinel</a>：把流量作为切入点，从流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性。</li><li><a href="https://github.com/alibaba/Nacos" target="_blank" rel="noopener">Nacos</a>：一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台。</li><li><a href="https://rocketmq.apache.org/" target="_blank" rel="noopener">RocketMQ</a>：一款开源的分布式消息系统，基于高可用分布式集群技术，提供低延时的、高可靠的消息发布与订阅服务。</li><li><a href="https://github.com/apache/dubbo" target="_blank" rel="noopener">Dubbo</a>：Apache Dubbo™ 是一款高性能 Java RPC 框架。</li><li><a href="https://github.com/seata/seata" target="_blank" rel="noopener">Seata</a>：阿里巴巴开源产品，一个易于使用的高性能微服务分布式事务解决方案。</li><li><a href="https://www.aliyun.com/product/acm" target="_blank" rel="noopener">Alibaba Cloud ACM</a>：一款在分布式架构环境中对应用配置进行集中管理和推送的应用配置中心产品。</li><li><a href="https://www.aliyun.com/product/oss" target="_blank" rel="noopener">Alibaba Cloud OSS</a>: 阿里云对象存储服务（Object Storage Service，简称 OSS），是阿里云提供的海量、安全、低成本、高可靠的云存储服务。您可以在任何应用、任何时间、任何地点存储和访问任意类型的数据。</li><li><a href="https://help.aliyun.com/document_detail/43136.html" target="_blank" rel="noopener">Alibaba Cloud SchedulerX</a>: 阿里中间件团队开发的一款分布式任务调度产品，提供秒级、精准、高可靠、高可用的定时（基于 Cron 表达式）任务调度服务。</li><li><a href="https://www.aliyun.com/product/sms" target="_blank" rel="noopener">Alibaba Cloud SMS</a>: 覆盖全球的短信服务，友好、高效、智能的互联化通讯能力，帮助企业迅速搭建客户触达通道</li></ul>]]></content>
    
    <summary type="html">
    
      面向服务
    
    </summary>
    
    
      <category term="Spring Cloud Alibaba" scheme="https://SomunsTao.github.io/categories/Spring-Cloud-Alibaba/"/>
    
    
      <category term="Spring Cloud Alibaba" scheme="https://SomunsTao.github.io/tags/Spring-Cloud-Alibaba/"/>
    
  </entry>
  
  <entry>
    <title>Spring Cloud Alibaba学习笔记:2、版本说明与统一依赖管理项目创建</title>
    <link href="https://somunstao.github.io/2020/04/14/Spring%20Cloud%20Alibaba%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%202%E3%80%81%E7%89%88%E6%9C%AC%E8%AF%B4%E6%98%8E%E4%B8%8E%E7%BB%9F%E4%B8%80%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE%E5%88%9B%E5%BB%BA/"/>
    <id>https://somunstao.github.io/2020/04/14/Spring%20Cloud%20Alibaba%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%202%E3%80%81%E7%89%88%E6%9C%AC%E8%AF%B4%E6%98%8E%E4%B8%8E%E7%BB%9F%E4%B8%80%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE%E5%88%9B%E5%BB%BA/</id>
    <published>2020-04-13T16:00:00.000Z</published>
    <updated>2020-08-02T03:39:09.255Z</updated>
    
    <content type="html"><![CDATA[<ul><li><h1 id="Spring-Cloud-Alibaba学习笔记-2、版本说明与统一依赖管理项目创建"><a href="#Spring-Cloud-Alibaba学习笔记-2、版本说明与统一依赖管理项目创建" class="headerlink" title="Spring Cloud Alibaba学习笔记: 2、版本说明与统一依赖管理项目创建"></a>Spring Cloud Alibaba学习笔记: 2、版本说明与统一依赖管理项目创建</h1></li></ul><h3 id="文章目录"><a href="#文章目录" class="headerlink" title="文章目录"></a>文章目录</h3><ul><li><ul><li><a href="https://blog.csdn.net/fxbin123/article/details/94918049#_3" target="_blank" rel="noopener">版本使用列表</a></li><li><a href="https://blog.csdn.net/fxbin123/article/details/94918049#Spring_BootSpring_CloudSpring_Cloud_Alibaba_15" target="_blank" rel="noopener">Spring Boot、Spring Cloud、Spring Cloud Alibaba三者间关系</a></li><li><a href="https://blog.csdn.net/fxbin123/article/details/94918049#_25" target="_blank" rel="noopener">项目结构图</a></li><li><a href="https://blog.csdn.net/fxbin123/article/details/94918049#_28" target="_blank" rel="noopener">创建依赖管理项目</a></li></ul></li></ul><h2 id="版本使用列表"><a href="#版本使用列表" class="headerlink" title="版本使用列表"></a>版本使用列表</h2><p>  Spring Cloud Alibaba 项目都是基于 Spring Cloud，而 Spring Cloud 项目又是基于 Spring Boot 进行开发，并且都是使用 Maven 做项目管理工具，以下为我们使用的版本列表：</p><table><thead><tr><th>名称</th><th>版本</th></tr></thead><tbody><tr><td>JAVA JDK</td><td>1.8.0_211</td></tr><tr><td>Spring Boot</td><td>2.1.6.RELEASE</td></tr><tr><td>Spring Boot Admin</td><td>2.1.5</td></tr><tr><td>Spring Cloud</td><td>Greenwich.SR2</td></tr><tr><td>Spring Cloud Alibaba</td><td>0.9.0.RELEASE</td></tr></tbody></table><h2 id="Spring-Boot、Spring-Cloud、Spring-Cloud-Alibaba三者间关系"><a href="#Spring-Boot、Spring-Cloud、Spring-Cloud-Alibaba三者间关系" class="headerlink" title="Spring Boot、Spring Cloud、Spring Cloud Alibaba三者间关系"></a>Spring Boot、Spring Cloud、Spring Cloud Alibaba三者间关系</h2><table><thead><tr><th>Spring Boot</th><th>Spring Cloud</th><th>Spring Cloud Alibaba</th></tr></thead><tbody><tr><td>2.1.x</td><td>Greenwich</td><td>0.9.x</td></tr><tr><td>2.0.x</td><td>Finchley</td><td>0.2.x</td></tr><tr><td>1.5.x</td><td>Edgware</td><td>0.1.x</td></tr><tr><td>1.5.x</td><td>Dalston</td><td>0.1.x</td></tr></tbody></table><p>  参考：</p><h2 id="项目结构图"><a href="#项目结构图" class="headerlink" title="项目结构图"></a>项目结构图</h2><p>  <img src="https://img-blog.csdnimg.cn/20190707000245484.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z4YmluMTIz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="创建依赖管理项目"><a href="#创建依赖管理项目" class="headerlink" title="创建依赖管理项目"></a>创建依赖管理项目</h2><p>  创建一个 <code>sca</code> （Spring Cloud Alibaba 首字母缩写） 的项目， 以下为 <code>pom.xml</code> 依赖文件内容：</p>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">         xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;</span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-parent&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;version&gt;2.1.6.RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;relativePath&#x2F;&gt; &lt;!-- lookup parent from repository --&gt;</span><br><span class="line">    &lt;&#x2F;parent&gt;</span><br><span class="line"></span><br><span class="line">    &lt;groupId&gt;cn.fxbin.learn&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;sca&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.0&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;packaging&gt;pom&lt;&#x2F;packaging&gt;</span><br><span class="line"></span><br><span class="line">    &lt;name&gt;sca-build&lt;&#x2F;name&gt;</span><br><span class="line">    &lt;description&gt;Spring Cloud Alibaba Learn Build Project&lt;&#x2F;description&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;properties&gt;</span><br><span class="line">        &lt;!-- Environment Settings --&gt;</span><br><span class="line">        &lt;java.version&gt;1.8&lt;&#x2F;java.version&gt;</span><br><span class="line">        &lt;project.build.sourceEncoding&gt;UTF-8&lt;&#x2F;project.build.sourceEncoding&gt;</span><br><span class="line">        &lt;project.reporting.outputEncoding&gt;UTF-8&lt;&#x2F;project.reporting.outputEncoding&gt;</span><br><span class="line">        </span><br><span class="line">        &lt;!-- Spring Settings --&gt;</span><br><span class="line">        &lt;spring-boot-admin.version&gt;2.1.5&lt;&#x2F;spring-boot-admin.version&gt;</span><br><span class="line">        &lt;spring-cloud.version&gt;Greenwich.SR2&lt;&#x2F;spring-cloud.version&gt;</span><br><span class="line">        &lt;spring-cloud-alibaba.version&gt;0.9.0.RELEASE&lt;&#x2F;spring-cloud-alibaba.version&gt;</span><br><span class="line">    &lt;&#x2F;properties&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- actuator --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-actuator&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- lombok --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.projectlombok&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;lombok&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;optional&gt;true&lt;&#x2F;optional&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- test --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;&#x2F;scope&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;&#x2F;dependencies&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencyManagement&gt;</span><br><span class="line">        &lt;dependencies&gt;</span><br><span class="line">            &lt;!-- spring-boot-admin --&gt;</span><br><span class="line">            &lt;dependency&gt;</span><br><span class="line">                &lt;groupId&gt;de.codecentric&lt;&#x2F;groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;spring-boot-admin-dependencies&lt;&#x2F;artifactId&gt;</span><br><span class="line">                &lt;version&gt;$&#123;spring-boot-admin.version&#125;&lt;&#x2F;version&gt;</span><br><span class="line">                &lt;type&gt;pom&lt;&#x2F;type&gt;</span><br><span class="line">                &lt;scope&gt;import&lt;&#x2F;scope&gt;</span><br><span class="line">            &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">            &lt;!-- spring cloud --&gt;</span><br><span class="line">            &lt;dependency&gt;</span><br><span class="line">                &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;spring-cloud-dependencies&lt;&#x2F;artifactId&gt;</span><br><span class="line">                &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;&#x2F;version&gt;</span><br><span class="line">                &lt;type&gt;pom&lt;&#x2F;type&gt;</span><br><span class="line">                &lt;scope&gt;import&lt;&#x2F;scope&gt;</span><br><span class="line">            &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">            &lt;!-- spring cloud alibaba --&gt;</span><br><span class="line">            &lt;dependency&gt;</span><br><span class="line">                &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;&#x2F;artifactId&gt;</span><br><span class="line">                &lt;version&gt;$&#123;spring-cloud-alibaba.version&#125;&lt;&#x2F;version&gt;</span><br><span class="line">                &lt;type&gt;pom&lt;&#x2F;type&gt;</span><br><span class="line">                &lt;scope&gt;import&lt;&#x2F;scope&gt;</span><br><span class="line">            &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;&#x2F;dependencies&gt;</span><br><span class="line">    &lt;&#x2F;dependencyManagement&gt;</span><br><span class="line"></span><br><span class="line">    &lt;build&gt;</span><br><span class="line">        &lt;plugins&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;spring-boot-maven-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;&#x2F;plugin&gt;</span><br><span class="line">        &lt;&#x2F;plugins&gt;</span><br><span class="line"></span><br><span class="line">    &lt;&#x2F;build&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;&#x2F;project&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      面向服务
    
    </summary>
    
    
      <category term="Spring Cloud Alibaba" scheme="https://SomunsTao.github.io/categories/Spring-Cloud-Alibaba/"/>
    
    
      <category term="Spring Cloud Alibaba" scheme="https://SomunsTao.github.io/tags/Spring-Cloud-Alibaba/"/>
    
  </entry>
  
  <entry>
    <title>Spring Cloud Alibaba学习笔记:3、Nacos - 服务注册与发现</title>
    <link href="https://somunstao.github.io/2020/04/14/Spring%20Cloud%20Alibaba%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%203%E3%80%81Nacos%20-%20%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%8E%E5%8F%91%E7%8E%B0/"/>
    <id>https://somunstao.github.io/2020/04/14/Spring%20Cloud%20Alibaba%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%203%E3%80%81Nacos%20-%20%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%8E%E5%8F%91%E7%8E%B0/</id>
    <published>2020-04-13T16:00:00.000Z</published>
    <updated>2020-08-02T03:39:18.927Z</updated>
    
    <content type="html"><![CDATA[<ul><li><h1 id="Spring-Cloud-Alibaba学习笔记-3、Nacos-服务注册与发现"><a href="#Spring-Cloud-Alibaba学习笔记-3、Nacos-服务注册与发现" class="headerlink" title="Spring Cloud Alibaba学习笔记: 3、Nacos - 服务注册与发现"></a>Spring Cloud Alibaba学习笔记: 3、Nacos - 服务注册与发现</h1></li></ul><h3 id="文章目录"><a href="#文章目录" class="headerlink" title="文章目录"></a>文章目录</h3><ul><li><ul><li><ul><li><p><a href="https://blog.csdn.net/fxbin123/article/details/94918724#Nacos_1" target="_blank" rel="noopener">Nacos概览</a></p></li><li><p><a href="https://blog.csdn.net/fxbin123/article/details/94918724#_Nacos_8" target="_blank" rel="noopener">什么是 Nacos？</a></p></li><li><p><a href="https://blog.csdn.net/fxbin123/article/details/94918724#Nacos__11" target="_blank" rel="noopener">Nacos 概念</a></p></li><li><p><a href="https://blog.csdn.net/fxbin123/article/details/94918724#Nacos__16" target="_blank" rel="noopener">Nacos 架构</a></p></li><li><ul><li><p><a href="https://blog.csdn.net/fxbin123/article/details/94918724#_17" target="_blank" rel="noopener">基本架构及概念</a></p></li><li><ul><li><a href="https://blog.csdn.net/fxbin123/article/details/94918724#_Service_20" target="_blank" rel="noopener">服务 (Service)</a></li><li><a href="https://blog.csdn.net/fxbin123/article/details/94918724#_Service_Registry_23" target="_blank" rel="noopener">服务注册中心 (Service Registry)</a></li><li><a href="https://blog.csdn.net/fxbin123/article/details/94918724#_Service_Metadata_26" target="_blank" rel="noopener">服务元数据 (Service Metadata)</a></li><li><a href="https://blog.csdn.net/fxbin123/article/details/94918724#_Service_Provider_29" target="_blank" rel="noopener">服务提供方 (Service Provider)</a></li><li><a href="https://blog.csdn.net/fxbin123/article/details/94918724#_Service_Consumer_32" target="_blank" rel="noopener">服务消费方 (Service Consumer)</a></li><li><a href="https://blog.csdn.net/fxbin123/article/details/94918724#_Configuration_35" target="_blank" rel="noopener">配置 (Configuration)</a></li><li><a href="https://blog.csdn.net/fxbin123/article/details/94918724#_Configuration_Management_38" target="_blank" rel="noopener">配置管理 (Configuration Management)</a></li><li><a href="https://blog.csdn.net/fxbin123/article/details/94918724#_Naming_Service_41" target="_blank" rel="noopener">名字服务 (Naming Service)</a></li><li><a href="https://blog.csdn.net/fxbin123/article/details/94918724#_Configuration_Service_44" target="_blank" rel="noopener">配置服务 (Configuration Service)</a></li></ul></li></ul></li><li><p><a href="https://blog.csdn.net/fxbin123/article/details/94918724#Nacos_49" target="_blank" rel="noopener">安装Nacos</a></p></li><li><ul><li><ul><li><a href="https://blog.csdn.net/fxbin123/article/details/94918724#1_52" target="_blank" rel="noopener">1、下载服务</a></li><li><a href="https://blog.csdn.net/fxbin123/article/details/94918724#2_54" target="_blank" rel="noopener">2、启动服务器</a></li><li><a href="https://blog.csdn.net/fxbin123/article/details/94918724#3_81" target="_blank" rel="noopener">3、访问服务</a></li></ul></li></ul></li><li><p><a href="https://blog.csdn.net/fxbin123/article/details/94918724#_Nacos__87" target="_blank" rel="noopener">接入 Nacos 注册中心</a></p></li><li><ul><li><a href="https://blog.csdn.net/fxbin123/article/details/94918724#_88" target="_blank" rel="noopener">服务提供者</a></li><li><a href="https://blog.csdn.net/fxbin123/article/details/94918724#_206" target="_blank" rel="noopener">服务消费者</a></li></ul></li></ul></li></ul></li></ul><h3 id="Nacos概览"><a href="#Nacos概览" class="headerlink" title="Nacos概览"></a>Nacos概览</h3><p>  Nacos 官网地址： <a href="https://nacos.io" target="_blank" rel="noopener">https://nacos.io</a></p><p>  Nacos 致力于帮助您发现、配置和管理微服务。Nacos 提供了一组简单易用的特性集，帮助您快速实现动态服务发现、服务配置、服务元数据及流量管理。</p><p>  Nacos 帮助您更敏捷和容易地构建、交付和管理微服务平台。 Nacos 是构建以“服务”为中心的现代应用架构 (例如微服务范式、云原生范式) 的服务基础设施。</p><h3 id="什么是-Nacos？"><a href="#什么是-Nacos？" class="headerlink" title="什么是 Nacos？"></a>什么是 Nacos？</h3><p>  <a href="https://nacos.io/zh-cn/docs/what-is-nacos.html" target="_blank" rel="noopener">https://nacos.io/zh-cn/docs/what-is-nacos.html</a></p><h3 id="Nacos-概念"><a href="#Nacos-概念" class="headerlink" title="Nacos 概念"></a>Nacos 概念</h3><p>  <a href="https://nacos.io/zh-cn/docs/concepts.html" target="_blank" rel="noopener">https://nacos.io/zh-cn/docs/concepts.html</a></p><blockquote><p>NOTE: Nacos 引入了一些基本的概念，系统性的了解一下这些概念可以帮助您更好的理解和正确的使用 Nacos 产品。</p></blockquote><h3 id="Nacos-架构"><a href="#Nacos-架构" class="headerlink" title="Nacos 架构"></a>Nacos 架构</h3><h4 id="基本架构及概念"><a href="#基本架构及概念" class="headerlink" title="基本架构及概念"></a>基本架构及概念</h4><p>  <img src="https://img-blog.csdnimg.cn/20190707004012333.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z4YmluMTIz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h5 id="服务-Service"><a href="#服务-Service" class="headerlink" title="服务 (Service)"></a>服务 (Service)</h5><p>  服务是指一个或一组软件功能（例如特定信息的检索或一组操作的执行），其目的是不同的客户端可以为不同的目的重用（例如通过跨进程的网络调用）。Nacos 支持主流的服务生态，如 Kubernetes Service、gRPC|Dubbo RPC Service 或者 Spring Cloud RESTful Service.</p><h5 id="服务注册中心-Service-Registry"><a href="#服务注册中心-Service-Registry" class="headerlink" title="服务注册中心 (Service Registry)"></a>服务注册中心 (Service Registry)</h5><p>  服务注册中心，它是服务，其实例及元数据的数据库。服务实例在启动时注册到服务注册表，并在关闭时注销。服务和路由器的客户端查询服务注册表以查找服务的可用实例。服务注册中心可能会调用服务实例的健康检查 API 来验证它是否能够处理请求。</p><h5 id="服务元数据-Service-Metadata"><a href="#服务元数据-Service-Metadata" class="headerlink" title="服务元数据 (Service Metadata)"></a>服务元数据 (Service Metadata)</h5><p>  服务元数据是指包括服务端点(endpoints)、服务标签、服务版本号、服务实例权重、路由规则、安全策略等描述服务的数据</p><h5 id="服务提供方-Service-Provider"><a href="#服务提供方-Service-Provider" class="headerlink" title="服务提供方 (Service Provider)"></a>服务提供方 (Service Provider)</h5><p>  是指提供可复用和可调用服务的应用方</p><h5 id="服务消费方-Service-Consumer"><a href="#服务消费方-Service-Consumer" class="headerlink" title="服务消费方 (Service Consumer)"></a>服务消费方 (Service Consumer)</h5><p>  是指会发起对某个服务调用的应用方</p><h5 id="配置-Configuration"><a href="#配置-Configuration" class="headerlink" title="配置 (Configuration)"></a>配置 (Configuration)</h5><p>  在系统开发过程中通常会将一些需要变更的参数、变量等从代码中分离出来独立管理，以独立的配置文件的形式存在。目的是让静态的系统工件或者交付物（如 WAR，JAR 包等）更好地和实际的物理运行环境进行适配。配置管理一般包含在系统部署的过程中，由系统管理员或者运维人员完成这个步骤。配置变更是调整系统运行时的行为的有效手段之一。</p><h5 id="配置管理-Configuration-Management"><a href="#配置管理-Configuration-Management" class="headerlink" title="配置管理 (Configuration Management)"></a>配置管理 (Configuration Management)</h5><p>  在数据中心中，系统中所有配置的编辑、存储、分发、变更管理、历史版本管理、变更审计等所有与配置相关的活动统称为配置管理。</p><h5 id="名字服务-Naming-Service"><a href="#名字服务-Naming-Service" class="headerlink" title="名字服务 (Naming Service)"></a>名字服务 (Naming Service)</h5><p>  提供分布式系统中所有对象(Object)、实体(Entity)的“名字”到关联的元数据之间的映射管理服务，例如 ServiceName -&gt; Endpoints Info, Distributed Lock Name -&gt; Lock Owner/Status Info, DNS Domain Name -&gt; IP List, 服务发现和 DNS 就是名字服务的2大场景。</p><h5 id="配置服务-Configuration-Service"><a href="#配置服务-Configuration-Service" class="headerlink" title="配置服务 (Configuration Service)"></a>配置服务 (Configuration Service)</h5><p>  在服务或者应用运行过程中，提供动态配置或者元数据以及配置管理的服务提供者。</p><p>  <a href="https://nacos.io/zh-cn/docs/architecture.html" target="_blank" rel="noopener">更多…</a></p><h3 id="安装Nacos"><a href="#安装Nacos" class="headerlink" title="安装Nacos"></a>安装Nacos</h3>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">注： 本文采用 Nacos Docker 方式启动</span><br></pre></td></tr></table></figure><h5 id="1、下载服务"><a href="#1、下载服务" class="headerlink" title="1、下载服务"></a>1、下载服务</h5>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 下载地址：https:&#x2F;&#x2F;github.com&#x2F;alibaba&#x2F;nacos&#x2F;releases</span><br><span class="line">1</span><br></pre></td></tr></table></figure><h5 id="2、启动服务器"><a href="#2、启动服务器" class="headerlink" title="2、启动服务器"></a>2、启动服务器</h5><ul><li><p>Linux/Unix/Mac<br>启动命令(standalone代表着单机模式运行，非集群模式):</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">   sh startup.sh -m standalone</span><br><span class="line">1</span><br></pre></td></tr></table></figure></li><li><p>Windows<br>启动命令：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">   cmd startup.cmd</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>或者双击startup.cmd运行文件</p></li><li><p>Docker</p><blockquote><p>1 、Clone 项目</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;nacos-group&#x2F;nacos-docker.git</span><br><span class="line">    cd nacos-docker</span><br><span class="line">12</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20190707005455624.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z4YmluMTIz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><blockquote><p>2、单机模式</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker-compose -f example&#x2F;standalone.yaml up</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20190707005753882.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z4YmluMTIz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h5 id="3、访问服务"><a href="#3、访问服务" class="headerlink" title="3、访问服务"></a>3、访问服务</h5><p>启动完成之后，访问：<a href="http://127.0.0.1:8848/nacos/" target="_blank" rel="noopener">http://127.0.0.1:8848/nacos/</a><br>可以进入Nacos的服务管理页面，</p></li></ul><p>  <strong><code>注</code></strong>：从 0.8.0 版本开始，需要登录才可访问，nacos 默认用户名密码 <code>nacos/nacos</code><br>  <img src="https://img-blog.csdnimg.cn/20190707010038347.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z4YmluMTIz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="接入-Nacos-注册中心"><a href="#接入-Nacos-注册中心" class="headerlink" title="接入 Nacos 注册中心"></a>接入 Nacos 注册中心</h3><h4 id="服务提供者"><a href="#服务提供者" class="headerlink" title="服务提供者"></a>服务提供者</h4><p>  1、 创建一个maven module 项目 <code>sca-nacos-discovery-provider</code></p><p>  2、 pom.xml 配置如下：</p>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">         xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;</span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;groupId&gt;cn.fxbin.learn&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;sca&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;version&gt;1.0&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;&#x2F;parent&gt;</span><br><span class="line"></span><br><span class="line">    &lt;artifactId&gt;sca-nacos-discovery-provider&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;0.0.1-SNAPSHOT&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;name&gt;sca-nacos-discovery-provider&lt;&#x2F;name&gt;</span><br><span class="line">    &lt;description&gt;Spring Cloud Alibaba Nacos Discovery Provider Service Project&lt;&#x2F;description&gt;</span><br><span class="line"></span><br><span class="line">    &lt;properties&gt;</span><br><span class="line">        &lt;java.version&gt;1.8&lt;&#x2F;java.version&gt;</span><br><span class="line">    &lt;&#x2F;properties&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;&#x2F;dependencies&gt;</span><br><span class="line"></span><br><span class="line">    &lt;build&gt;</span><br><span class="line">        &lt;plugins&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;spring-boot-maven-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;&#x2F;plugin&gt;</span><br><span class="line">        &lt;&#x2F;plugins&gt;</span><br><span class="line">    &lt;&#x2F;build&gt;</span><br><span class="line">&lt;&#x2F;project&gt;</span><br><span class="line">1234567891011121314151617181920212223242526272829303132333435363738394041</span><br></pre></td></tr></table></figure><p>  3、创建应用主类别 <code>ScaNacosDiscoveryProviderApplication.java</code></p>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package cn.fxbin.learn.sca.nacos.provider;</span><br><span class="line"></span><br><span class="line">import org.springframework.boot.SpringApplication;</span><br><span class="line">import org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line">import org.springframework.cloud.client.discovery.EnableDiscoveryClient;</span><br><span class="line">import org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line">@EnableDiscoveryClient</span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class ScaNacosDiscoveryProviderApplication &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(ScaNacosDiscoveryProviderApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @RestController</span><br><span class="line">    public class EchoController &#123;</span><br><span class="line">        @GetMapping(value &#x3D; &quot;&#x2F;echo&#x2F;&#123;message&#125;&quot;)</span><br><span class="line">        public String echo(@PathVariable String message) &#123;</span><br><span class="line">            return &quot;Hello Nacos Discovery Provider : &quot; + message;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">12345678910111213141516171819202122232425</span><br></pre></td></tr></table></figure><p>  4、 配置服务端口、名称、服务端点检查和Nacos地址</p>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 9090</span><br><span class="line"></span><br><span class="line">management:</span><br><span class="line">  endpoints:</span><br><span class="line">    web:</span><br><span class="line">      exposure:</span><br><span class="line">        include: &quot;*&quot;</span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: sca-nacos-discovery-provider</span><br><span class="line">  cloud:</span><br><span class="line">    nacos:</span><br><span class="line">      discovery:</span><br><span class="line">        server-addr: 127.0.0.1:8848</span><br><span class="line">12345678910111213141516</span><br></pre></td></tr></table></figure><p>  5、启动服务提供者</p><blockquote><p>验证服务端点检查 ：</p></blockquote><p>  spring-cloud-starter-alibaba-nacos-discovery 在实现的时候提供了一个 EndPoint, EndPoint 的访问地址为 <a href="http://ip:port/actuator/nacos-discovery。">http://ip:port/actuator/nacos-discovery。</a> EndPoint 的信息主要提供了两类:</p><p>  1、subscribe: 显示了当前有哪些服务订阅者<br>  2、NacosDiscoveryProperties: 显示了当前服务实例关于 Nacos 的基础配置</p><p>  如下图所示：<br>  <img src="https://img-blog.csdnimg.cn/20190707013051112.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z4YmluMTIz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><blockquote><p>验证注册列表：</p></blockquote><p>  启动完成之后，在 Nacos Server 控制台可以看到如下内容 ：</p><p>  <img src="https://img-blog.csdnimg.cn/20190707012900808.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z4YmluMTIz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>  <img src="https://img-blog.csdnimg.cn/2019070701291733.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z4YmluMTIz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="服务消费者"><a href="#服务消费者" class="headerlink" title="服务消费者"></a>服务消费者</h4><p>  1、 创建一个maven module 项目 <code>sca-nacos-discovery-consumer</code></p><p>  2、 pom.xml 配置如下：</p>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot;</span><br><span class="line">         xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">         xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;artifactId&gt;sca&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;groupId&gt;cn.fxbin.learn&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;version&gt;1.0&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;&#x2F;parent&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;</span><br><span class="line"></span><br><span class="line">    &lt;artifactId&gt;sca-nacos-discovery-consumer&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;0.0.1-SNAPSHOT&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;name&gt;sca-nacos-discovery-provider&lt;&#x2F;name&gt;</span><br><span class="line">    &lt;description&gt;Spring Cloud Alibaba Nacos Discovery Consumer Service Project&lt;&#x2F;description&gt;</span><br><span class="line"></span><br><span class="line">    &lt;properties&gt;</span><br><span class="line">        &lt;java.version&gt;1.8&lt;&#x2F;java.version&gt;</span><br><span class="line">    &lt;&#x2F;properties&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;&#x2F;dependencies&gt;</span><br><span class="line"></span><br><span class="line">    &lt;build&gt;</span><br><span class="line">        &lt;plugins&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;spring-boot-maven-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;&#x2F;plugin&gt;</span><br><span class="line">        &lt;&#x2F;plugins&gt;</span><br><span class="line">    &lt;&#x2F;build&gt;</span><br><span class="line">&lt;&#x2F;project&gt;</span><br><span class="line">123456789101112131415161718192021222324252627282930313233343536373839404142</span><br></pre></td></tr></table></figure><p>  3、创建应用主类别 <code>ScaNacosDiscoveryConsumerApplication.java</code></p>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package cn.fxbin.learn.sca.nacos.consumer;</span><br><span class="line"></span><br><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line">import org.springframework.boot.SpringApplication;</span><br><span class="line">import org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line">import org.springframework.cloud.client.ServiceInstance;</span><br><span class="line">import org.springframework.cloud.client.discovery.EnableDiscoveryClient;</span><br><span class="line">import org.springframework.cloud.client.loadbalancer.LoadBalancerClient;</span><br><span class="line">import org.springframework.context.annotation.Bean;</span><br><span class="line">import org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line">import org.springframework.web.client.RestTemplate;</span><br><span class="line"></span><br><span class="line">import javax.annotation.Resource;</span><br><span class="line"></span><br><span class="line">@Slf4j</span><br><span class="line">@EnableDiscoveryClient</span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class ScaNacosDiscoveryConsumerApplication &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(ScaNacosDiscoveryConsumerApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public RestTemplate restTemplate()&#123;</span><br><span class="line">        return new RestTemplate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @RestController</span><br><span class="line">    public class ConsumerController &#123;</span><br><span class="line"></span><br><span class="line">        @Resource</span><br><span class="line">        LoadBalancerClient loadBalancerClient;</span><br><span class="line"></span><br><span class="line">        @Resource</span><br><span class="line">        private RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        @GetMapping(value &#x3D; &quot;&#x2F;echo&#x2F;&#123;message&#125;&quot;)</span><br><span class="line">        public String echo(@PathVariable String message) &#123;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 通过spring cloud common中的负载均衡接口选取服务提供节点实现接口调用</span><br><span class="line">            ServiceInstance serviceInstance &#x3D; loadBalancerClient.choose(&quot;sca-nacos-discovery-provider&quot;);</span><br><span class="line">            String url &#x3D; String.format(&quot;http:&#x2F;&#x2F;%s:%s&#x2F;echo&#x2F;%s&quot;, serviceInstance.getHost(), serviceInstance.getPort(), &quot; !^@^! &quot;);</span><br><span class="line">            log.info(&quot;请求路径为：&#123;&#125;&quot;, url);</span><br><span class="line">            return restTemplate.getForObject(url, String.class);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051</span><br></pre></td></tr></table></figure><p>  4、 配置服务端口、名称、服务端点检查和Nacos地址</p>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 9031</span><br><span class="line"></span><br><span class="line">management:</span><br><span class="line">  endpoints:</span><br><span class="line">    web:</span><br><span class="line">      exposure:</span><br><span class="line">        include: &quot;*&quot;</span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: sca-nacos-discovery-consumer</span><br><span class="line">  cloud:</span><br><span class="line">    nacos:</span><br><span class="line">      discovery:</span><br><span class="line">        server-addr: 127.0.0.1:8848</span><br><span class="line">12345678910111213141516</span><br></pre></td></tr></table></figure><p>  5、启动服务消费者， postman 验证接口：</p><p>  <img src="https://img-blog.csdnimg.cn/2019070701552939.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z4YmluMTIz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>  <img src="https://img-blog.csdnimg.cn/20190707015544275.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z4YmluMTIz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
    
    <summary type="html">
    
      面向服务
    
    </summary>
    
    
      <category term="Spring Cloud Alibaba" scheme="https://SomunsTao.github.io/categories/Spring-Cloud-Alibaba/"/>
    
    
      <category term="Spring Cloud Alibaba" scheme="https://SomunsTao.github.io/tags/Spring-Cloud-Alibaba/"/>
    
  </entry>
  
  <entry>
    <title>Spring Cloud Alibaba学习笔记:4、创建服务消费者</title>
    <link href="https://somunstao.github.io/2020/04/14/Spring%20Cloud%20Alibaba%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B04%E3%80%81%E5%88%9B%E5%BB%BA%E6%9C%8D%E5%8A%A1%E6%B6%88%E8%B4%B9%E8%80%85/"/>
    <id>https://somunstao.github.io/2020/04/14/Spring%20Cloud%20Alibaba%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B04%E3%80%81%E5%88%9B%E5%BB%BA%E6%9C%8D%E5%8A%A1%E6%B6%88%E8%B4%B9%E8%80%85/</id>
    <published>2020-04-13T16:00:00.000Z</published>
    <updated>2020-08-02T03:04:54.065Z</updated>
    
    <content type="html"><![CDATA[<ul><li><h1 id="Spring-Cloud-Alibaba学习笔记-4、创建服务消费者（RestTemplate-LoadBalancerClient）"><a href="#Spring-Cloud-Alibaba学习笔记-4、创建服务消费者（RestTemplate-LoadBalancerClient）" class="headerlink" title="Spring Cloud Alibaba学习笔记:4、创建服务消费者（RestTemplate + LoadBalancerClient）"></a>Spring Cloud Alibaba学习笔记:4、创建服务消费者（RestTemplate + LoadBalancerClient）</h1><h3 id="文章目录"><a href="#文章目录" class="headerlink" title="文章目录"></a>文章目录</h3><ul><li><ul><li><ul><li><p><a href="https://blog.csdn.net/fxbin123/article/details/95025897#_2" target="_blank" rel="noopener">前言</a></p></li><li><p><a href="https://blog.csdn.net/fxbin123/article/details/95025897#_Nacos__RestTemplate__5" target="_blank" rel="noopener">创建 Nacos RestTemplate 消费者</a></p></li><li><ul><li><a href="https://blog.csdn.net/fxbin123/article/details/95025897#1_maven_module__scanacosdiscoveryconsumerresttemplate_7" target="_blank" rel="noopener">1、 创建一个maven module 项目 <code>sca-nacos-discovery-consumer-resttemplate</code></a></li><li><a href="https://blog.csdn.net/fxbin123/article/details/95025897#2_pomxml__8" target="_blank" rel="noopener">2、 pom.xml 配置</a></li><li><a href="https://blog.csdn.net/fxbin123/article/details/95025897#3_ScaNacosConsumerApplication_52" target="_blank" rel="noopener">3、创建应用主类别 <code>ScaNacosConsumerApplication</code></a></li><li><a href="https://blog.csdn.net/fxbin123/article/details/95025897#4_RestTemplateConfig_71" target="_blank" rel="noopener">4、创建 <code>RestTemplateConfig</code></a></li><li><a href="https://blog.csdn.net/fxbin123/article/details/95025897#5_ConsumerController_99" target="_blank" rel="noopener">5、创建 <code>ConsumerController</code></a></li><li><a href="https://blog.csdn.net/fxbin123/article/details/95025897#6Nacos_136" target="_blank" rel="noopener">6、配置服务端口、名称、服务端点检查和Nacos地址</a></li><li><a href="https://blog.csdn.net/fxbin123/article/details/95025897#7_157" target="_blank" rel="noopener">7、启动服务消费者</a></li><li><a href="https://blog.csdn.net/fxbin123/article/details/95025897#8nacos__161" target="_blank" rel="noopener">8、检查nacos 控制台</a></li><li><a href="https://blog.csdn.net/fxbin123/article/details/95025897#9_165" target="_blank" rel="noopener">9、测试消费者</a></li><li><ul><li><ul><li><a href="https://blog.csdn.net/fxbin123/article/details/95025897#___167" target="_blank" rel="noopener">&gt; 服务端点检查</a></li><li><a href="https://blog.csdn.net/fxbin123/article/details/95025897#__API_172" target="_blank" rel="noopener">&gt; 测试服务消费API</a></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>  上篇文章 <a href="https://blog.csdn.net/fxbin123/article/details/94918724" target="_blank" rel="noopener">Spring Cloud Alibaba学习笔记: 3、Nacos - 服务注册与发现</a> 中，我们创建了实现了通过 Nacos 的服务提供者与发现者，也通过使用 <code>LoadBalancerClient</code> 来获取某个服务实例，并消费服务接口，但是异常繁琐，不是很友好，本片文正是对上文 服务消费者有优化实现， 絮絮叨叨了半天，接下来开启新的探索吧…</p><h3 id="创建-Nacos-RestTemplate-消费者"><a href="#创建-Nacos-RestTemplate-消费者" class="headerlink" title="创建 Nacos RestTemplate 消费者"></a>创建 Nacos RestTemplate 消费者</h3><h4 id="1、-创建一个maven-module-项目-sca-nacos-discovery-consumer-resttemplate"><a href="#1、-创建一个maven-module-项目-sca-nacos-discovery-consumer-resttemplate" class="headerlink" title="1、 创建一个maven module 项目 sca-nacos-discovery-consumer-resttemplate"></a>1、 创建一个maven module 项目 <code>sca-nacos-discovery-consumer-resttemplate</code></h4><h4 id="2、-pom-xml-配置"><a href="#2、-pom-xml-配置" class="headerlink" title="2、 pom.xml 配置"></a>2、 pom.xml 配置</h4>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot;</span><br><span class="line">         xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">         xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;artifactId&gt;sca&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;groupId&gt;cn.fxbin.learn&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;version&gt;1.0&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;&#x2F;parent&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;</span><br><span class="line"></span><br><span class="line">    &lt;artifactId&gt;sca-nacos-discovery-consumer-resttemplate&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.0&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;name&gt;sca-nacos-discovery-consumer-resttemplate&lt;&#x2F;name&gt;</span><br><span class="line">    &lt;description&gt;Spring Cloud Alibaba Nacos Discovery Consumer RestTemplate Service Project&lt;&#x2F;description&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;&#x2F;dependencies&gt;</span><br><span class="line"></span><br><span class="line">    &lt;build&gt;</span><br><span class="line">        &lt;plugins&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;spring-boot-maven-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;&#x2F;plugin&gt;</span><br><span class="line">        &lt;&#x2F;plugins&gt;</span><br><span class="line">    &lt;&#x2F;build&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;project&gt;</span><br><span class="line">123456789101112131415161718192021222324252627282930313233343536373839</span><br></pre></td></tr></table></figure><h4 id="3、创建应用主类别-ScaNacosConsumerApplication"><a href="#3、创建应用主类别-ScaNacosConsumerApplication" class="headerlink" title="3、创建应用主类别 ScaNacosConsumerApplication"></a>3、创建应用主类别 <code>ScaNacosConsumerApplication</code></h4>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package cn.fxbin.learn.sca.nacos.consumer;</span><br><span class="line"></span><br><span class="line">import org.springframework.boot.SpringApplication;</span><br><span class="line">import org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line">import org.springframework.cloud.client.discovery.EnableDiscoveryClient;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@EnableDiscoveryClient</span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class ScaNacosConsumerApplication &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(ScaNacosConsumerApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">123456789101112131415</span><br></pre></td></tr></table></figure><h4 id="4、创建-RestTemplateConfig"><a href="#4、创建-RestTemplateConfig" class="headerlink" title="4、创建 RestTemplateConfig"></a>4、创建 <code>RestTemplateConfig</code></h4>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package cn.fxbin.learn.sca.nacos.consumer.config;</span><br><span class="line"></span><br><span class="line">import org.springframework.cloud.client.loadbalancer.LoadBalanced;</span><br><span class="line">import org.springframework.context.annotation.Bean;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line">import org.springframework.web.client.RestTemplate;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * RestTemplateConfig</span><br><span class="line"> *</span><br><span class="line"> * @author fxbin</span><br><span class="line"> * @version v1.0</span><br><span class="line"> * @since 2019&#x2F;7&#x2F;7 20:37</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Configuration</span><br><span class="line">public class RestTemplateConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    @LoadBalanced</span><br><span class="line">    public RestTemplate restTemplate()&#123;</span><br><span class="line">        return new RestTemplate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">123456789101112131415161718192021222324</span><br></pre></td></tr></table></figure><h4 id="5、创建-ConsumerController"><a href="#5、创建-ConsumerController" class="headerlink" title="5、创建 ConsumerController"></a>5、创建 <code>ConsumerController</code></h4>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package cn.fxbin.learn.sca.nacos.consumer.controller;</span><br><span class="line"></span><br><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line">import org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line">import org.springframework.web.client.RestTemplate;</span><br><span class="line"></span><br><span class="line">import javax.annotation.Resource;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * ConsumerController</span><br><span class="line"> *</span><br><span class="line"> * @author fxbin</span><br><span class="line"> * @version v1.0</span><br><span class="line"> * @since 2019&#x2F;7&#x2F;7 20:36</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Slf4j</span><br><span class="line">@RestController</span><br><span class="line">public class ConsumerController &#123;</span><br><span class="line"></span><br><span class="line">    @Resource</span><br><span class="line">    private RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    @GetMapping(value &#x3D; &quot;&#x2F;test&quot;)</span><br><span class="line">    public String test() &#123;</span><br><span class="line"></span><br><span class="line">        String url &#x3D; String.format(&quot;http:&#x2F;&#x2F;%s&#x2F;echo&#x2F;%s&quot;, &quot;sca-nacos-discovery-provider&quot;, &quot; !^@^! &quot;);</span><br><span class="line">        log.info(&quot;请求路径为：&#123;&#125;&quot;, url);</span><br><span class="line">        return restTemplate.getForObject(url, String.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">1234567891011121314151617181920212223242526272829303132</span><br></pre></td></tr></table></figure><h4 id="6、配置服务端口、名称、服务端点检查和Nacos地址"><a href="#6、配置服务端口、名称、服务端点检查和Nacos地址" class="headerlink" title="6、配置服务端口、名称、服务端点检查和Nacos地址"></a>6、配置服务端口、名称、服务端点检查和Nacos地址</h4>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 9032</span><br><span class="line"></span><br><span class="line">management:</span><br><span class="line">  endpoints:</span><br><span class="line">    web:</span><br><span class="line">      exposure:</span><br><span class="line">        include: &quot;*&quot;</span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: sca-nacos-discovery-consumer-resttemplate</span><br><span class="line">  cloud:</span><br><span class="line">    nacos:</span><br><span class="line">      discovery:</span><br><span class="line">        server-addr: 127.0.0.1:8848</span><br><span class="line">12345678910111213141516</span><br></pre></td></tr></table></figure><h4 id="7、启动服务消费者"><a href="#7、启动服务消费者" class="headerlink" title="7、启动服务消费者"></a>7、启动服务消费者</h4><p>  <img src="https://img-blog.csdnimg.cn/20190707205229289.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z4YmluMTIz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="8、检查nacos-控制台"><a href="#8、检查nacos-控制台" class="headerlink" title="8、检查nacos 控制台"></a>8、检查nacos 控制台</h4><p>  <img src="https://img-blog.csdnimg.cn/20190707205317980.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z4YmluMTIz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="9、测试消费者"><a href="#9、测试消费者" class="headerlink" title="9、测试消费者"></a>9、测试消费者</h4><h6 id="gt-服务端点检查"><a href="#gt-服务端点检查" class="headerlink" title="&gt; 服务端点检查"></a>&gt; 服务端点检查</h6><p>  访问 <a href="http://127.0.0.1:9032/actuator/nacos-discovery" target="_blank" rel="noopener">http://127.0.0.1:9032/actuator/nacos-discovery</a><br>  <img src="https://img-blog.csdnimg.cn/20190707205541433.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z4YmluMTIz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h6 id="gt-测试服务消费API"><a href="#gt-测试服务消费API" class="headerlink" title="&gt; 测试服务消费API"></a>&gt; 测试服务消费API</h6><p>  访问 <a href="http://localhost:9032/test" target="_blank" rel="noopener">http://localhost:9032/test</a></p><p>  <img src="https://img-blog.csdnimg.cn/2019070720570810.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z4YmluMTIz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>  <img src="https://img-blog.csdnimg.cn/20190707205742156.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z4YmluMTIz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
    
    <summary type="html">
    
      面向服务
    
    </summary>
    
    
      <category term="Spring Cloud Alibaba" scheme="https://SomunsTao.github.io/categories/Spring-Cloud-Alibaba/"/>
    
    
      <category term="Spring Cloud Alibaba" scheme="https://SomunsTao.github.io/tags/Spring-Cloud-Alibaba/"/>
    
  </entry>
  
  <entry>
    <title>Vue 04：Axios异步通信</title>
    <link href="https://somunstao.github.io/2020/04/14/Vue%2004%EF%BC%9AAxios%E5%BC%82%E6%AD%A5%E9%80%9A%E4%BF%A1/"/>
    <id>https://somunstao.github.io/2020/04/14/Vue%2004%EF%BC%9AAxios%E5%BC%82%E6%AD%A5%E9%80%9A%E4%BF%A1/</id>
    <published>2020-04-13T16:00:00.000Z</published>
    <updated>2020-08-01T15:17:11.703Z</updated>
    
    <content type="html"><![CDATA[<p>​    </p><h1 id="Vue：Axios异步通信"><a href="#Vue：Axios异步通信" class="headerlink" title="Vue：Axios异步通信"></a>Vue：Axios异步通信</h1><h2 id="什么是Axios"><a href="#什么是Axios" class="headerlink" title="什么是Axios"></a>什么是Axios</h2><p>Axios 是一个开源的可以用在浏览器端和 <code>NodeJS</code> 的异步通信框架，她的主要作用就是实现 AJAX 异步通信，其功能特点如下：</p><ul><li>从浏览器中创建 <code>XMLHttpRequests</code></li><li>从 node.js 创建 http 请求</li><li>支持 Promise API [JS中链式编程]</li><li>拦截请求和响应</li><li>转换请求数据和响应数据</li><li>取消请求</li><li>自动转换 JSON 数据</li><li>客户端支持防御 XSRF（跨站请求伪造）</li></ul><p>GitHub：<a href="https://github.com/axios/axios" target="_blank" rel="noopener">https://github.com/axios/axios</a></p><p>中文文档：<a href="http://www.axios-js.com/" target="_blank" rel="noopener">http://www.axios-js.com/</a></p><h3 id="为什么要使用-Axios"><a href="#为什么要使用-Axios" class="headerlink" title="为什么要使用 Axios"></a>为什么要使用 Axios</h3><p>由于 <code>Vue.js</code> 是一个 视图层框架 并且作者（尤雨溪）严格准守 SoC （关注度分离原则），所以 <code>Vue.js</code> 并不包含 AJAX 的通信功能，为了解决通信问题，作者单独开发了一个名为 <code>vue-resource</code> 的插件，不过在进入 2.0 版本以后停止了对该插件的维护并推荐了 <code>Axios</code> 框架。少用jQuery，因为它操作Dom太频繁！</p><h2 id="第一个-Axios-应用程序"><a href="#第一个-Axios-应用程序" class="headerlink" title="第一个 Axios 应用程序"></a>第一个 Axios 应用程序</h2><p>咱们开发的接口大部分都是采用 JSON 格式，可以先在项目里模拟一段 JSON 数据，数据内容如下：创建一个名为 data.json 的文件并填入上面的内容，放在项目的根目录下</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;狂神说Java&quot;,</span><br><span class="line">  &quot;url&quot;: &quot;https:&#x2F;&#x2F;blog.kuangstudy.com&quot;,</span><br><span class="line">  &quot;page&quot;: 1,</span><br><span class="line">  &quot;isNonProfit&quot;: true,</span><br><span class="line">  &quot;address&quot;: &#123;</span><br><span class="line">    &quot;street&quot;: &quot;含光门&quot;,</span><br><span class="line">    &quot;city&quot;: &quot;陕西西安&quot;,</span><br><span class="line">    &quot;country&quot;: &quot;中国&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;links&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;name&quot;: &quot;bilibili&quot;,</span><br><span class="line">      &quot;url&quot;: &quot;https:&#x2F;&#x2F;space.bilibili.com&#x2F;95256449&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;name&quot;: &quot;狂伸说java&quot;,</span><br><span class="line">      &quot;url&quot;: &quot;https:&#x2F;&#x2F;blog.kuangstudy.com&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;name&quot;: &quot;百度&quot;,</span><br><span class="line">      &quot;url&quot;: &quot;https:&#x2F;&#x2F;www.baidu.com&#x2F;&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试代码</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot; xmlns:v-bind&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;1999&#x2F;xhtml&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;狂神说Java&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;!--v-cloak 解决闪烁问题--&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        [v-cloak] &#123;</span><br><span class="line">            display: none;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;&#x2F;style&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;div id&#x3D;&quot;vue&quot; v-cloak&gt;</span><br><span class="line">    &lt;div&gt;名称：&#123;&#123;info.name&#125;&#125;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;div&gt;地址：&#123;&#123;info.address.country&#125;&#125;-&#123;&#123;info.address.city&#125;&#125;-&#123;&#123;info.address.street&#125;&#125;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;div&gt;链接：&lt;a v-bind:href&#x3D;&quot;info.url&quot; target&#x3D;&quot;_blank&quot;&gt;&#123;&#123;info.url&#125;&#125;&lt;&#x2F;a&gt; &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--引入 JS 文件--&gt;</span><br><span class="line">&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;vue@2.5.21&#x2F;dist&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;unpkg.com&#x2F;axios&#x2F;dist&#x2F;axios.min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">    var vm &#x3D; new Vue(&#123;</span><br><span class="line">        el: &#39;#vue&#39;,</span><br><span class="line">        data() &#123;</span><br><span class="line">            return &#123;</span><br><span class="line">                info: &#123;</span><br><span class="line">                    name: null,</span><br><span class="line">                    address: &#123;</span><br><span class="line">                        country: null,</span><br><span class="line">                        city: null,</span><br><span class="line">                        street: null</span><br><span class="line">                    &#125;,</span><br><span class="line">                    url: null</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        mounted() &#123; &#x2F;&#x2F;钩子函数</span><br><span class="line">            axios</span><br><span class="line">                .get(&#39;data.json&#39;)</span><br><span class="line">                .then(response &#x3D;&gt; (this.info &#x3D; response.data));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p>说明:</p><ol><li>在这里使用了 v-bind 将 a:href 的属性值与 Vue 实例中的数据进行绑定</li><li>使用 axios 框架的 get 方法请求 AJAX 并自动将数据封装进了 Vue 实例的数据对象中</li><li>我们在data中的数据结构必须要和<code>Ajax</code>响应回来的数据格式匹配！</li></ol><h2 id="Vue的生命周期"><a href="#Vue的生命周期" class="headerlink" title="Vue的生命周期"></a>Vue的生命周期</h2><p>官方文档：<a href="https://cn.vuejs.org/v2/guide/instance.html#生命周期图示" target="_blank" rel="noopener">https://cn.vuejs.org/v2/guide/instance.html#生命周期图示</a></p><p>Vue 实例有一个完整的生命周期，也就是从开始创建、初始化数据、编译模板、挂载 DOM、渲染→更新→渲染、卸载等一系列过程，我们称这是 Vue 的生命周期。通俗说就是 Vue 实例从创建到销毁的过程，就是生命周期。</p><p>在 Vue 的整个生命周期中，它提供了一系列的事件，可以让我们在事件触发时注册 JS 方法，可以让我们用自己注册的 JS 方法控制整个大局，在这些事件响应方法中的 this 直接指向的是 Vue 的实例。</p><p><img src="https://blog.kuangstudy.com/usr/uploads/2019/10/1579484219.jpg" alt="vue-life.jpg"></p>]]></content>
    
    <summary type="html">
    
      前端体系、前后端分离
    
    </summary>
    
    
      <category term="Vue" scheme="https://SomunsTao.github.io/categories/Vue/"/>
    
    
      <category term="Vue" scheme="https://SomunsTao.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue 03：基础语法</title>
    <link href="https://somunstao.github.io/2020/04/13/Vue%2003%EF%BC%9A%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    <id>https://somunstao.github.io/2020/04/13/Vue%2003%EF%BC%9A%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</id>
    <published>2020-04-12T16:00:00.000Z</published>
    <updated>2020-08-01T15:16:45.568Z</updated>
    
    <content type="html"><![CDATA[<p>​    </p><h1 id="Vue：基础语法"><a href="#Vue：基础语法" class="headerlink" title="Vue：基础语法"></a>Vue：基础语法</h1><h2 id="v-bind"><a href="#v-bind" class="headerlink" title="v-bind"></a>v-bind</h2><p>我们已经成功创建了第一个 Vue 应用！看起来这跟渲染一个字符串模板非常类似，但是 Vue 在背后做了大量工作。现在数据和 DOM 已经被建立了关联，所有东西都是响应式的。我们在控制台操作对象属性，界面可以实时更新！</p><p>我们还可以使用<code>v-bind</code>来绑定元素特性!</p><p><strong>上代码：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html xmlns:v-bind&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;1999&#x2F;xhtml&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;狂神说Java&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;vue@2.5.21&#x2F;dist&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">  &lt;span v-bind:title&#x3D;&quot;message&quot;&gt;</span><br><span class="line">    鼠标悬停几秒钟查看此处动态绑定的提示信息！</span><br><span class="line">  &lt;&#x2F;span&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">    var app &#x3D; new Vue(&#123;</span><br><span class="line">        el: &#39;#app&#39;,</span><br><span class="line">        data: &#123;</span><br><span class="line">            message: &#39;页面加载于 &#39; + new Date().toLocaleString()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p>你看到的 v-bind 等被称为指令。指令带有前缀 v-，以表示它们是 Vue 提供的特殊特性。可能你已经猜到了，它们会在渲染的 DOM 上应用特殊的响应式行为。在这里，该指令的意思是：“将这个元素节点的 title 特性和 Vue 实例的 message 属性保持一致”。</p><p>如果你再次打开浏览器的 JavaScript 控制台，输入 app.message = ‘新消息’，就会再一次看到这个绑定了 title 特性的 HTML 已经进行了更新。</p><h2 id="v-if-v-else"><a href="#v-if-v-else" class="headerlink" title="v-if,v-else"></a>v-if,v-else</h2><p>什么是条件判断语句，就不需要我说明了吧（￣▽￣）,以下两个属性！</p><ul><li><code>v-if</code></li><li><code>v-else</code></li></ul><p><strong>上代码：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;狂神说Java&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;vue@2.5.21&#x2F;dist&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;div id&#x3D;&quot;vue&quot;&gt;</span><br><span class="line">    &lt;h1 v-if&#x3D;&quot;ok&quot;&gt;YES&lt;&#x2F;h1&gt;</span><br><span class="line">    &lt;h1 v-else&gt;NO&lt;&#x2F;h1&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">    var vm &#x3D; new Vue(&#123;</span><br><span class="line">        el: &#39;#vue&#39;,</span><br><span class="line">        data: &#123;</span><br><span class="line">            ok: true</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p>测试：</p><ol><li>在浏览器上运行，打开控制台！</li><li>在控制台输入 <code>vm.ok = false</code> ，然后 回车，你会发现浏览器中显示的内容会直接变成 NO</li></ol><p>注：使用 <code>v-*</code> 属性绑定数据是不需要 <code>双花括号</code> 包裹的</p><h2 id="v-else-if"><a href="#v-else-if" class="headerlink" title="v-else-if"></a>v-else-if</h2><ul><li>v-if</li><li>v-else-if</li><li>v-else</li></ul><p>注：<code>===</code> 三个等号在 JS 中表示绝对等于（就是数据与类型都要相等）</p><p><strong>上代码：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;狂神说Java&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;vue@2.5.21&#x2F;dist&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;div id&#x3D;&quot;vue&quot;&gt;</span><br><span class="line">    &lt;h1 v-if&#x3D;&quot;type &#x3D;&#x3D;&#x3D; &#39;A&#39;&quot;&gt;A&lt;&#x2F;h1&gt;</span><br><span class="line">    &lt;h1 v-else-if&#x3D;&quot;type &#x3D;&#x3D;&#x3D; &#39;B&#39;&quot;&gt;B&lt;&#x2F;h1&gt;</span><br><span class="line">    &lt;h1 v-else-if&#x3D;&quot;type &#x3D;&#x3D;&#x3D; &#39;C&#39;&quot;&gt;C&lt;&#x2F;h1&gt;</span><br><span class="line">    &lt;h1 v-else&gt;who&lt;&#x2F;h1&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">    var vm &#x3D; new Vue(&#123;</span><br><span class="line">        el: &#39;#vue&#39;,</span><br><span class="line">        data: &#123;</span><br><span class="line">            type: &#39;A&#39;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p>测试：观察在控制台输入 vm.type = ‘B’、’C’、’D’ 的变化</p><h2 id="v-for"><a href="#v-for" class="headerlink" title="v-for"></a>v-for</h2><ul><li>v-for</li></ul><p>格式说明：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;vue&quot;&gt;</span><br><span class="line">    &lt;li v-for&#x3D;&quot;item in items&quot;&gt;</span><br><span class="line">        &#123;&#123; item.message &#125;&#125;</span><br><span class="line">    &lt;&#x2F;li&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><p>注：<code>items</code> 是数组，<code>item</code>是数组元素迭代的别名。我们之后学习的Thymeleaf模板引擎的语法和这个十分的相似！</p><p><strong>上代码：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;狂神说Java&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;vue@2.5.21&#x2F;dist&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;div id&#x3D;&quot;vue&quot;&gt;</span><br><span class="line">    &lt;li v-for&#x3D;&quot;item in items&quot;&gt;</span><br><span class="line">        &#123;&#123; item.message &#125;&#125;</span><br><span class="line">    &lt;&#x2F;li&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">    var vm &#x3D; new Vue(&#123;</span><br><span class="line">        el: &#39;#vue&#39;,</span><br><span class="line">        data: &#123;</span><br><span class="line">            &#x2F;&#x2F;items数组</span><br><span class="line">            items: [</span><br><span class="line">                &#123;message: &#39;狂神说Java&#39;&#125;,</span><br><span class="line">                &#123;message: &#39;狂神说前端&#39;&#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p>测试 ：在控制台输入 <code>vm.items.push({message: &#39;狂神说运维&#39;})</code> ，尝试追加一条数据，你会发现浏览器中显示的内容会增加一条 <code>狂神说运维</code>.</p><h2 id="v-on"><a href="#v-on" class="headerlink" title="v-on"></a>v-on</h2><p><code>v-on</code> 监听事件</p><p>事件有Vue的事件、和前端页面本身的一些事件！我们这里的<code>click</code>是vue的事件，可以绑定到Vue中的<code>methods</code>中的方法事件！</p><p><strong>上代码：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html xmlns:v-on&#x3D;&quot;&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;狂神说Java&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;vue@2.5.21&#x2F;dist&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;div id&#x3D;&quot;vue&quot;&gt;</span><br><span class="line">    &lt;!--在这里我们使用了 v-on 绑定了 click 事件，并指定了名为 sayHi 的方法--&gt;</span><br><span class="line">    &lt;button v-on:click&#x3D;&quot;sayHi&quot;&gt;点我&lt;&#x2F;button&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">    var vm &#x3D; new Vue(&#123;</span><br><span class="line">        el: &#39;#vue&#39;,</span><br><span class="line">        data: &#123;</span><br><span class="line">            message: &#39;Hello World&#39;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#x2F;&#x2F; 方法必须定义在 Vue 实例的 methods 对象中</span><br><span class="line">        methods: &#123;</span><br><span class="line">            sayHi: function (event) &#123;</span><br><span class="line">                &#x2F;&#x2F; &#96;this&#96; 在方法里指向当前 Vue 实例</span><br><span class="line">                alert(this.message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p>点击测试</p><p>Vue还有一些基本的使用方式，大家有需要的可以再跟着官方文档看看，因为这些基本的指令几乎我们都见过了，一通百通！掌握学习的方式！</p><p><a href="https://blog.kuangstudy.com/index.php/tag/Vue/" target="_blank" rel="noopener">VUE</a></p>]]></content>
    
    <summary type="html">
    
      前端体系、前后端分离
    
    </summary>
    
    
      <category term="Vue" scheme="https://SomunsTao.github.io/categories/Vue/"/>
    
    
      <category term="Vue" scheme="https://SomunsTao.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue 02：MVVM模式和第一个Vue程序</title>
    <link href="https://somunstao.github.io/2020/04/12/Vue%2002%EF%BC%9AMVVM%E6%A8%A1%E5%BC%8F%E5%92%8C%E7%AC%AC%E4%B8%80%E4%B8%AAVue%E7%A8%8B%E5%BA%8F/"/>
    <id>https://somunstao.github.io/2020/04/12/Vue%2002%EF%BC%9AMVVM%E6%A8%A1%E5%BC%8F%E5%92%8C%E7%AC%AC%E4%B8%80%E4%B8%AAVue%E7%A8%8B%E5%BA%8F/</id>
    <published>2020-04-11T16:00:00.000Z</published>
    <updated>2020-08-01T15:16:10.772Z</updated>
    
    <content type="html"><![CDATA[<p>​    </p><h1 id="Vue：MVVM模式和第一个Vue程序"><a href="#Vue：MVVM模式和第一个Vue程序" class="headerlink" title="Vue：MVVM模式和第一个Vue程序"></a>Vue：MVVM模式和第一个Vue程序</h1><h2 id="什么是-MVVM"><a href="#什么是-MVVM" class="headerlink" title="什么是 MVVM"></a>什么是 MVVM</h2><p>MVVM（Model-View-ViewModel）是一种软件架构设计模式，由微软 WPF（用于替代 WinForm，以前就是用这个技术开发桌面应用程序的）和 Silverlight（类似于 Java Applet，简单点说就是在浏览器上运行的 WPF） 的架构师 Ken Cooper 和 Ted Peters 开发，是一种简化用户界面的<strong>事件驱动编程方式</strong>。由 John Gossman（同样也是 WPF 和 Silverlight 的架构师）于 2005 年在他的博客上发表。</p><p>MVVM 源自于经典的 MVC（Model-View-Controller）模式。MVVM 的核心是 ViewModel 层，负责转换 Model 中的数据对象来让数据变得更容易管理和使用，其作用如下：</p><ul><li>该层向上与视图层进行双向数据绑定</li><li>向下与 Model 层通过接口请求进行数据交互<br><img src="https://blog.kuangstudy.com/usr/uploads/2019/10/1897504213.png" alt="20191017111649.png"></li></ul><p>MVVM 已经相当成熟了，主要运用但不仅仅在网络应用程序开发中。当下流行的 MVVM 框架有 <code>Vue.js</code>，<code>AngularJS</code> 等。</p><h2 id="为什么要使用-MVVM"><a href="#为什么要使用-MVVM" class="headerlink" title="为什么要使用 MVVM"></a>为什么要使用 MVVM</h2><p>MVVM 模式和 MVC 模式一样，主要目的是分离视图（View）和模型（Model），有几大好处</p><ul><li><strong>低耦合</strong>： 视图（View）可以独立于 Model 变化和修改，一个 ViewModel 可以绑定到不同的 View 上，当 View 变化的时候 Model 可以不变，当 Model 变化的时候 View 也可以不变。</li><li><strong>可复用</strong>： 你可以把一些视图逻辑放在一个 ViewModel 里面，让很多 View 重用这段视图逻辑。</li><li><strong>独立开发</strong>： 开发人员可以专注于业务逻辑和数据的开发（ViewModel），设计人员可以专注于页面设计。</li><li><strong>可测试</strong>： 界面素来是比较难于测试的，而现在测试可以针对 ViewModel 来写。</li></ul><h2 id="MVVM-的组成部分"><a href="#MVVM-的组成部分" class="headerlink" title="MVVM 的组成部分"></a>MVVM 的组成部分</h2><p><img src="https://blog.kuangstudy.com/usr/uploads/2019/10/1552878682.png" alt="20191017111955.png"></p><h3 id="View"><a href="#View" class="headerlink" title="View"></a>View</h3><p>View 是视图层，也就是用户界面。前端主要由 <code>HTML</code> 和 <code>CSS</code> 来构建，为了更方便地展现 <code>ViewModel</code> 或者 <code>Model</code> 层的数据，已经产生了各种各样的前后端模板语言，比如 FreeMarker、Thymeleaf 等等，各大 MVVM 框架如 Vue.js，AngularJS，EJS 等也都有自己用来构建用户界面的内置模板语言。</p><h3 id="Model"><a href="#Model" class="headerlink" title="Model"></a>Model</h3><p>Model 是指数据模型，泛指后端进行的各种业务逻辑处理和数据操控，主要围绕数据库系统展开。这里的难点主要在于需要和前端约定统一的 <code>接口规则</code></p><h3 id="ViewModel"><a href="#ViewModel" class="headerlink" title="ViewModel"></a>ViewModel</h3><p>ViewModel 是由前端开发人员组织生成和维护的视图数据层。在这一层，前端开发者对从后端获取的 Model 数据进行转换处理，做二次封装，以生成符合 View 层使用预期的视图数据模型。</p><p>需要注意的是 ViewModel 所封装出来的数据模型包括视图的状态和行为两部分，而 Model 层的数据模型是只包含状态的</p><ul><li>比如页面的这一块展示什么，那一块展示什么这些都属于视图状态（展示）</li><li>页面加载进来时发生什么，点击这一块发生什么，这一块滚动时发生什么这些都属于视图行为（交互）</li></ul><p>视图状态和行为都封装在了 ViewModel 里。这样的封装使得 ViewModel 可以完整地去描述 View 层`。由于实现了双向绑定，ViewModel 的内容会实时展现在 View 层，这是激动人心的，因为前端开发者再也不必低效又麻烦地通过操纵 DOM 去更新视图。</p><p>MVVM 框架已经把最脏最累的一块做好了，我们开发者只需要处理和维护 ViewModel，更新数据视图就会自动得到相应更新，真正实现 <code>事件驱动编程</code>。</p><p>View 层展现的不是 <code>Model</code> 层的数据，而是 <code>ViewModel</code> 的数据，由 <code>ViewModel</code> 负责与 <code>Model</code> 层交互，这就<strong>完全解耦了 View 层和 Model 层，这个解耦是至关重要的，它是前后端分离方案实施的重要一环。</strong></p><h2 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h2><p>Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式框架，发布于 2014 年 2 月。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库（如：vue-router，vue-resource，vuex）或既有项目整合。</p><h3 id="MVVM-模式的实现者"><a href="#MVVM-模式的实现者" class="headerlink" title="MVVM 模式的实现者"></a>MVVM 模式的实现者</h3><ul><li>Model：模型层，在这里表示 JavaScript 对象</li><li>View：视图层，在这里表示 DOM（HTML 操作的元素）</li><li>ViewModel：连接视图和数据的中间件，Vue.js 就是 MVVM 中的 ViewModel 层的实现者</li></ul><p>在 MVVM 架构中，是不允许 数据 和 视图 直接通信的，只能通过 ViewModel 来通信，而 ViewModel 就是定义了一个 Observer 观察者</p><ul><li>ViewModel 能够观察到数据的变化，并对视图对应的内容进行更新</li><li>ViewModel 能够监听到视图的变化，并能够通知数据发生改变</li></ul><p>至此，我们就明白了，Vue.js 就是一个 MVVM 的实现者，他的核心就是实现了 DOM 监听 与 数据绑定</p><h3 id="为什么要使用-Vue-js"><a href="#为什么要使用-Vue-js" class="headerlink" title="为什么要使用 Vue.js"></a>为什么要使用 Vue.js</h3><ul><li>轻量级，体积小是一个重要指标。Vue.js 压缩后有只有 20多kb （Angular 压缩后 56kb+，React 压缩后 44kb+）</li><li>移动优先。更适合移动端，比如移动端的 Touch 事件</li><li>易上手，学习曲线平稳，文档齐全</li><li>吸取了 Angular（模块化）和 React（虚拟 DOM）的长处，并拥有自己独特的功能，如：计算属性</li><li>开源，社区活跃度高</li><li>……</li></ul><h2 id="第一个Vue程序"><a href="#第一个Vue程序" class="headerlink" title="第一个Vue程序"></a>第一个Vue程序</h2><p>【说明】IDEA 可以安装 Vue 的插件！</p><p>注意：Vue 不支持 IE8 及以下版本，因为 Vue 使用了 IE8 无法模拟的 ECMAScript 5 特性。但它支持所有兼容 ECMAScript 5 的浏览器。</p><h3 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h3><ul><li>开发版本<ul><li>包含完整的警告和调试模式：<a href="https://vuejs.org/js/vue.js" target="_blank" rel="noopener">https://vuejs.org/js/vue.js</a></li><li>删除了警告，30.96KB min + gzip：<a href="https://vuejs.org/js/vue.min.js" target="_blank" rel="noopener">https://vuejs.org/js/vue.min.js</a></li></ul></li><li>CDN<ul><li><code>&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.js&quot;&gt;&lt;/script&gt;</code></li><li><code>&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.min.js&quot;&gt;&lt;/script&gt;</code></li></ul></li></ul><h3 id="代码编写"><a href="#代码编写" class="headerlink" title="代码编写"></a>代码编写</h3><p>Vue.js 的核心是实现了 MVVM 模式，她扮演的角色就是 ViewModel 层，那么所谓的第一个应用程序就是展示她的 数据绑定 功能，操作流程如下：</p><p><strong>1、创建一个 HTML 文件</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;狂神说&lt;&#x2F;title&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p><strong>2、引入 Vue.js</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;vue@2.5.21&#x2F;dist&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p><strong>3、创建一个 Vue 的实例</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">    var vm &#x3D; new Vue(&#123;</span><br><span class="line">        el: &#39;#vue&#39;,</span><br><span class="line">        data: &#123;</span><br><span class="line">            message: &#39;Hello Vue!&#39;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>说明:</p><ul><li><code>el:&#39;#vue&#39;</code>：绑定元素的 ID</li><li><code>data:{message:&#39;Hello Vue!&#39;}</code>：数据对象中有一个名为 message 的属性，并设置了初始值 Hello Vue!</li></ul><p><strong>4、将数据绑定到页面元素</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;vue&quot;&gt;</span><br><span class="line">    &#123;&#123;message&#125;&#125;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><p>说明：只需要在绑定的元素中使用 双花括号 将 Vue 创建的名为 message 属性包裹起来，即可实现数据绑定功能，也就实现了 ViewModel 层所需的效果，是不是和 EL 表达式非常像？</p><h3 id="完整的-HTML"><a href="#完整的-HTML" class="headerlink" title="完整的 HTML"></a>完整的 HTML</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;第一个 Vue 应用程序&lt;&#x2F;title&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--View--&gt;</span><br><span class="line">&lt;div id&#x3D;&quot;vue&quot;&gt;</span><br><span class="line">     &#123;&#123;message&#125;&#125;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;vue@2.5.21&#x2F;dist&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">    &#x2F;&#x2F; var vm &#x3D; new Vue(&#123;&#125;); &#x2F;&#x2F;ViewModel</span><br><span class="line">    var vm &#x3D; new Vue(&#123;</span><br><span class="line">        el: &#39;#vue&#39;,</span><br><span class="line">        data: &#123; &#x2F;&#x2F;Model</span><br><span class="line">            message: &#39;Hello Vue!&#39;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>为了能够更直观的体验 Vue 带来的数据绑定功能，我们需要在浏览器测试一番，操作流程如下：</p><p>1、在浏览器上运行第一个 Vue 应用程序，进入 开发者工具</p><p>2、在控制台输入 vm.message = ‘Hello World’ ，然后 回车，你会发现浏览器中显示的内容会直接变成 Hello World</p><p>此时就可以在控制台直接输入 vm.message 来修改值，中间是可以省略 data 的，在这个操作中，我并没有主动操作 DOM，就让页面的内容发生了变化，这就是借助了 Vue 的 数据绑定 功能实现的；MVVM 模式中要求 ViewModel 层就是使用 观察者模式 来实现数据的监听与绑定，以做到数据与视图的快速响应。</p>]]></content>
    
    <summary type="html">
    
      前端体系、前后端分离MVVM
    
    </summary>
    
    
      <category term="Vue" scheme="https://SomunsTao.github.io/categories/Vue/"/>
    
    
      <category term="Vue" scheme="https://SomunsTao.github.io/tags/Vue/"/>
    
  </entry>
  
</feed>
