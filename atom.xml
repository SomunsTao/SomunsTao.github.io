<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Somuns ` Tao</title>
  
  <subtitle>Java Blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://somunstao.github.io/"/>
  <updated>2020-05-01T02:17:04.419Z</updated>
  <id>https://somunstao.github.io/</id>
  
  <author>
    <name>陈涛</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SpringBoot：自动配置解析</title>
    <link href="https://somunstao.github.io/2020/05/03/SpringBoot21%EF%BC%9A%20%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE/"/>
    <id>https://somunstao.github.io/2020/05/03/SpringBoot21%EF%BC%9A%20%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE/</id>
    <published>2020-05-02T16:00:00.000Z</published>
    <updated>2020-05-01T02:17:04.419Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://p99.pstatp.com/large/pgc-image/15367619528862cca2a0df9" alt="img"></p><p>原文链接：<a href="https://www.cnblogs.com/leihuazhe/p/7743479.html" target="_blank" rel="noopener">https://www.cnblogs.com/leihuazhe/p/7743479.html</a></p><hr><hr><blockquote><p>SpringBoot 自动配置主要通过 <code>@EnableAutoConfiguration</code>, <code>@Conditional</code>, <code>@EnableConfigurationProperties</code> 或者 <code>@ConfigurationProperties</code> 等几个注解来进行自动配置完成的。</p><p><code>@EnableAutoConfiguration</code> 开启自动配置，主要作用就是调用 <code>Spring-Core</code> 包里的 <code>loadFactoryNames()</code>，将 <code>autoconfig</code> 包里的已经写好的自动配置加载进来。</p><p><code>@Conditional</code> 条件注解，通过判断类路径下有没有相应配置的 <code>jar</code> 包来确定是否加载和自动配置这个类。</p><p><code>@EnableConfigurationProperties</code> 的作用就是，给自动配置提供具体的配置参数，只需要写在 <code>application.properties</code> 中，就可以通过映射写入配置类的 <code>POJO</code> 属性中。</p></blockquote><h3 id="EnableAutoConfiguration"><a href="#EnableAutoConfiguration" class="headerlink" title="@EnableAutoConfiguration"></a>@EnableAutoConfiguration</h3><p>@Enable*注释并不是<code>SpringBoot</code>新发明的注释，Spring 3框架就引入了这些注释，用这些注释替代XML配置文件。比如：<br><code>@EnableTransactionManagement</code>注释，它能够声明事务管理<br><code>@EnableWebMvc</code>注释，它能启用Spring MVC<br><code>@EnableScheduling</code>注释，它可以初始化一个调度器。</p><h4 id="这些注释事实上都是简单的配置，通过-Import注释导入。"><a href="#这些注释事实上都是简单的配置，通过-Import注释导入。" class="headerlink" title="这些注释事实上都是简单的配置，通过@Import注释导入。"></a><strong>这些注释事实上都是简单的配置，通过<code>@Import</code>注释导入</strong>。</h4><h5 id="从启动类的-SpringBootApplication进入，在里面找到了-EnableAutoConfiguration"><a href="#从启动类的-SpringBootApplication进入，在里面找到了-EnableAutoConfiguration" class="headerlink" title="从启动类的@SpringBootApplication进入，在里面找到了@EnableAutoConfiguration,"></a>从启动类的@SpringBootApplication进入，在里面找到了@EnableAutoConfiguration,</h5><p><img src="http://pic.hzways.com/1.png" alt="1.png"></p><p><img src="http://pic.hzways.com/2.png" alt="2.png"></p><h5 id="EnableAutoConfiguration里通过-Import导入了EnableAutoConfigurationImportSelector"><a href="#EnableAutoConfiguration里通过-Import导入了EnableAutoConfigurationImportSelector" class="headerlink" title="@EnableAutoConfiguration里通过@Import导入了EnableAutoConfigurationImportSelector,"></a>@EnableAutoConfiguration里通过@Import导入了<code>EnableAutoConfigurationImportSelector</code>,</h5><p><img src="http://pic.hzways.com/3.png" alt="3.png"></p><h5 id="进入他的父类AutoConfigurationImportSelector"><a href="#进入他的父类AutoConfigurationImportSelector" class="headerlink" title="进入他的父类AutoConfigurationImportSelector"></a>进入他的父类<code>AutoConfigurationImportSelector</code></h5><p><img src="http://pic.hzways.com/4.png" alt="4.png"></p><h5 id="找到selectImports-方法，他调用了getCandidateConfigurations-方法，在这里，这个方法又调用了Spring-Core包中的loadFactoryNames-方法。这个方法的作用是，会查询META-INF-spring-factories文件中包含的JAR文件。"><a href="#找到selectImports-方法，他调用了getCandidateConfigurations-方法，在这里，这个方法又调用了Spring-Core包中的loadFactoryNames-方法。这个方法的作用是，会查询META-INF-spring-factories文件中包含的JAR文件。" class="headerlink" title="找到selectImports()方法，他调用了getCandidateConfigurations()方法，在这里，这个方法又调用了Spring Core包中的loadFactoryNames()方法。这个方法的作用是，会查询META-INF/spring.factories文件中包含的JAR文件。"></a>找到<code>selectImports()</code>方法，他调用了<code>getCandidateConfigurations()</code>方法，在这里，这个方法又调用了Spring Core包中的<code>loadFactoryNames()</code>方法。这个方法的作用是，会查询<code>META-INF/spring.factories</code>文件中包含的<code>JAR</code>文件。</h5><p><img src="http://pic.hzways.com/5.png" alt="5.png"></p><h5 id="当找到spring-factories文件后，SpringFactoriesLoader将查询配置文件命名的属性。"><a href="#当找到spring-factories文件后，SpringFactoriesLoader将查询配置文件命名的属性。" class="headerlink" title="当找到spring.factories文件后，SpringFactoriesLoader将查询配置文件命名的属性。"></a>当找到spring.factories文件后，SpringFactoriesLoader将查询配置文件命名的属性。</h5><p><img src="http://pic.hzways.com/6.png" alt="6.png"></p><p><img src="http://pic.hzways.com/7.png" alt="7.png"></p><h5 id="Jar文件在org-springframework-boot-autoconfigure的spring-factories"><a href="#Jar文件在org-springframework-boot-autoconfigure的spring-factories" class="headerlink" title="Jar文件在org.springframework.boot.autoconfigure的spring.factories"></a><code>Jar</code>文件在<code>org.springframework.boot.autoconfigure的spring.factories</code></h5><p><img src="http://pic.hzways.com/8.png" alt="8.png"></p><h5 id="spring-factories内容如下-截取部分-在这个文件中，可以看到一系列Spring-Boot自动配置的列表"><a href="#spring-factories内容如下-截取部分-在这个文件中，可以看到一系列Spring-Boot自动配置的列表" class="headerlink" title="spring.factories内容如下(截取部分),在这个文件中，可以看到一系列Spring Boot自动配置的列表"></a><code>spring.factories</code>内容如下(截取部分),在这个文件中，可以看到一系列Spring Boot自动配置的列表</h5><figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="meta">org.springframework.boot.autoconfigure.EnableAutoConfiguration</span>=<span class="string">\</span></span><br><span class="line">org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.cloud.CloudAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.context.MessageSourceAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.couchbase.CouchbaseAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.dao.PersistenceExceptionTranslationAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.cassandra.CassandraDataAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.cassandra.CassandraRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.couchbase.CouchbaseDataAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.couchbase.CouchbaseRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchDataAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.jpa.JpaRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.ldap.LdapDataAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.ldap.LdapRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.mongo.MongoDataAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.mongo.MongoRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.neo4j.Neo4jDataAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.neo4j.Neo4jRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.solr.SolrRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.redis.RedisRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.rest.RepositoryRestMvcAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.web.SpringDataWebAutoConfiguration,\</span><br></pre></td></tr></table></figure><h3 id="下面我们来看自动配置redis的细节，RedisAutoConfiguration："><a href="#下面我们来看自动配置redis的细节，RedisAutoConfiguration：" class="headerlink" title="下面我们来看自动配置redis的细节，RedisAutoConfiguration："></a>下面我们来看自动配置redis的细节，RedisAutoConfiguration：</h3><h3 id="RedisAutoConfiguration"><a href="#RedisAutoConfiguration" class="headerlink" title="RedisAutoConfiguration"></a>RedisAutoConfiguration</h3><p><img src="http://pic.hzways.com/redis.png" alt="redis.png"></p><p>这个类进行了简单的Spring配置，声明了Redis所需典型Bean，和其它很多类一样，重度依赖于Spring Boot注释：<br>1）@ConditionOnClass激活一个配置，当类路径中存在这个类时才会配置该类<br>2）@EnableConfigurationProperties自动映射一个POJO到Spring Boot配置文件（默认是application.properties文件）的属性集。<br>3）@ConditionalOnMissingBean启用一个Bean定义，但必须是这个Bean之前未定义过才有效。<br>还可以使用@ AutoConfigureBefore注释、@AutoConfigureAfter注释来定义这些配置类的载入顺序。</p><h4 id="着重了解-Conditional注释，Spring-4框架的新特性"><a href="#着重了解-Conditional注释，Spring-4框架的新特性" class="headerlink" title="着重了解@Conditional注释，Spring 4框架的新特性"></a>着重了解@Conditional注释，Spring 4框架的新特性</h4><p>此注释使得只有在特定条件满足时才启用一些配置。SrpingBoot的AutoConfig大量使用了@Conditional，它会根据运行环境来动态注入Bean。这里介绍一些@Conditional的使用和原理，并自定义@Conditional来自定义功能。</p><ul><li>@Conditional是SpringFramework的功能，SpringBoot在它的基础上定义了</li><li>@ConditionalOnClass，@ConditionalOnProperty等一系列的注解来实现更丰富的内容。</li></ul><h4 id="具体几个-Conditon-注解的含义"><a href="#具体几个-Conditon-注解的含义" class="headerlink" title="具体几个@Conditon*注解的含义"></a>具体几个@Conditon*注解的含义</h4><h6 id="ConditionalOnBean"><a href="#ConditionalOnBean" class="headerlink" title="@ConditionalOnBean"></a>@ConditionalOnBean</h6><p>仅仅在当前上下文中存在某个对象时，才会实例化一个Bean</p><h6 id="ConditionalOnClass"><a href="#ConditionalOnClass" class="headerlink" title="@ConditionalOnClass"></a>@ConditionalOnClass</h6><p>某个class位于类路径上，才会实例化一个Bean)，该注解的参数对应的类必须存在，否则不解析该注解修饰的配置类</p><h6 id="ConditionalOnExpression"><a href="#ConditionalOnExpression" class="headerlink" title="@ConditionalOnExpression"></a>@ConditionalOnExpression</h6><p>当表达式为true的时候，才会实例化一个Bean</p><h6 id="ConditionalOnMissingBean"><a href="#ConditionalOnMissingBean" class="headerlink" title="@ConditionalOnMissingBean"></a>@ConditionalOnMissingBean</h6><p>仅仅在当前上下文中不存在某个对象时，才会实例化一个Bean，该注解表示，如果存在它修饰的类的bean，则不需要再创建这个bean，可以给该注解传入参数例如@ConditionOnMissingBean(name = “example”)，这个表示如果name为“example”的bean存在，这该注解修饰的代码块不执行</p><h6 id="ConditionalOnMissingClass"><a href="#ConditionalOnMissingClass" class="headerlink" title="@ConditionalOnMissingClass"></a>@ConditionalOnMissingClass</h6><p>某个class类路径上不存在的时候，才会实例化一个Bean</p><h6 id="ConditionalOnNotWebApplication"><a href="#ConditionalOnNotWebApplication" class="headerlink" title="@ConditionalOnNotWebApplication"></a>@ConditionalOnNotWebApplication</h6><p>不是web应用时，才会执行</p><hr><h3 id="2-Properties系列注释"><a href="#2-Properties系列注释" class="headerlink" title="2.Properties系列注释"></a>2.Properties系列注释</h3><p>@EnableConfigurationProperties<br>@ConfigurationProperties(prefix = “may”)</p><p>在需要注入配置的类上加上这个注解，prefix的意思是，以该前缀打头的配置，以下是例子</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"may"</span>)  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> String name;  </span><br><span class="line">    <span class="keyword">private</span> String gender;  </span><br><span class="line">    </span><br><span class="line">   <span class="comment">//省略setter,getter方法</span></span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>application.yml中的配置</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">may</span><br><span class="line">   name: youjie</span><br><span class="line">   gender: man</span><br></pre></td></tr></table></figure><p>如果不用系统初始的application.yml配置类，而是使用自己的如youjie.yml，可以如下配置</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"may"</span>,locations = <span class="string">"classpath:youjie.yml"</span>)  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User2</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> String name;  </span><br><span class="line">    <span class="keyword">private</span> String gender;  </span><br><span class="line">    </span><br><span class="line">   <span class="comment">//省略setter,getter方法</span></span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>过时：由于Spring-boot 1.5.2版本移除了，locations这个属性,因此上述这种方式在最新的版本中过时。<br>@PropertySource</p><p>Spring-boot 1.5.2版本之后，采用下面这种方式</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="comment">//@PropertySource只能加载.properties文件，需要将上面的yml文件，改为.properties文件</span></span><br><span class="line"><span class="meta">@PropertySource</span>(<span class="string">"classpath:may.properties"</span>)</span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix=<span class="string">"may"</span>) </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User2</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">private</span> String name;  </span><br><span class="line">        <span class="keyword">private</span> String gender;  </span><br><span class="line">        </span><br><span class="line">       <span class="comment">//省略setter,getter方法</span></span><br><span class="line">      </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>@EnableConfigurationProperties</p><p>最后注意在spring Boot入口类加上@EnableConfigurationProperties</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span>  </span><br><span class="line"><span class="meta">@EnableConfigurationProperties</span>(&#123;User<span class="class">.<span class="keyword">class</span>,<span class="title">User2</span>.<span class="title">class</span>&#125;)  </span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">DemoApplication</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        SpringApplication.run(DemoApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实这里@EnableConfigurationProperties({User.class,User2.class}) 可以省略</p><p><img src="http://pic.hzways.com/config.png" alt="config.png"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>SpringBoot 的 自动配置得益于 SpringFramework 强大的支撑，框架早已有很多工具和注解可以自动装配 Bean 。SpringBoot 通过 一个封装，将市面上通用的组件直接写好了配置类。当我们程序去依赖了这些组件的 jar 包后，启动 SpringBoot应用，于是自动加载开始了。</p><p>我们也可以定义自己的自动装配组件，依赖之后，Spring直接可以加载我们定义的 starter 。笔者将在后续文章中进行编码和解读。</p>]]></content>
    
    <summary type="html">
    
      you can &quot;just run&quot;
    
    </summary>
    
    
      <category term="SpringBoot" scheme="https://SomunsTao.github.io/categories/SpringBoot/"/>
    
    
      <category term="SpringBoot" scheme="https://SomunsTao.github.io/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot：启动原理解析</title>
    <link href="https://somunstao.github.io/2020/05/03/SpringBoot21%EF%BC%9A%E5%90%AF%E5%8A%A8%E5%8E%9F%E7%90%86/"/>
    <id>https://somunstao.github.io/2020/05/03/SpringBoot21%EF%BC%9A%E5%90%AF%E5%8A%A8%E5%8E%9F%E7%90%86/</id>
    <published>2020-05-02T16:00:00.000Z</published>
    <updated>2020-05-01T05:05:32.289Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://p99.pstatp.com/large/pgc-image/15367619528862cca2a0df9" alt="img"></p><p>原文链接：<a href="https://www.cnblogs.com/xiaoxi/p/7999885.html" target="_blank" rel="noopener">https://www.cnblogs.com/xiaoxi/p/7999885.html</a></p><p>原作者：平凡希</p><hr><hr><h1 id="spring-boot：启动原理解析"><a href="#spring-boot：启动原理解析" class="headerlink" title="spring boot：启动原理解析"></a><a href="https://www.cnblogs.com/xiaoxi/p/7999885.html" target="_blank" rel="noopener">spring boot：启动原理解析</a></h1><p>我们开发任何一个Spring Boot项目，都会用到如下的启动类</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 @SpringBootApplication</span><br><span class="line">2 public class Application &#123;</span><br><span class="line">3     public static void main(String[] args) &#123;</span><br><span class="line">4         SpringApplication.run(Application.class, args);</span><br><span class="line">5     &#125;</span><br><span class="line">6 &#125;</span><br></pre></td></tr></table></figure><p>从上面代码可以看出，Annotation定义（@SpringBootApplication）和类定义（SpringApplication.run）最为耀眼，所以要揭开SpringBoot的神秘面纱，我们要从这两位开始就可以了。</p><p><strong>一、SpringBootApplication背后的秘密</strong></p><p>@SpringBootApplication注解是Spring Boot的核心注解，它其实是一个组合注解：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 1 @Target(ElementType.TYPE)</span><br><span class="line"> 2 @Retention(RetentionPolicy.RUNTIME)</span><br><span class="line"> 3 @Documented</span><br><span class="line"> 4 @Inherited</span><br><span class="line"> 5 @SpringBootConfiguration</span><br><span class="line"> 6 @EnableAutoConfiguration</span><br><span class="line"> 7 @ComponentScan(excludeFilters &#x3D; &#123;</span><br><span class="line"> 8         @Filter(type &#x3D; FilterType.CUSTOM, classes &#x3D; TypeExcludeFilter.class),</span><br><span class="line"> 9         @Filter(type &#x3D; FilterType.CUSTOM, classes &#x3D; AutoConfigurationExcludeFilter.class) &#125;)</span><br><span class="line">10 public @interface SpringBootApplication &#123;</span><br><span class="line">11 ...</span><br><span class="line">12 &#125;</span><br></pre></td></tr></table></figure><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>虽然定义使用了多个Annotation进行了原信息标注，但实际上重要的只有三个Annotation：</p><ul><li>@Configuration（@SpringBootConfiguration点开查看发现里面还是应用了@Configuration）</li><li>@EnableAutoConfiguration</li><li>@ComponentScan</li></ul><p>即 @SpringBootApplication = (默认属性)@Configuration + @EnableAutoConfiguration + @ComponentScan。</p><p>所以，如果我们使用如下的SpringBoot启动类，整个SpringBoot应用依然可以与之前的启动类功能对等：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 @Configuration</span><br><span class="line">2 @EnableAutoConfiguration</span><br><span class="line">3 @ComponentScan</span><br><span class="line">4 public class Application &#123;</span><br><span class="line">5     public static void main(String[] args) &#123;</span><br><span class="line">6         SpringApplication.run(Application.class, args);</span><br><span class="line">7     &#125;</span><br><span class="line">8 &#125;</span><br></pre></td></tr></table></figure><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>每次写这3个比较累，所以写一个@SpringBootApplication方便点。接下来分别介绍这3个Annotation。</p><p><strong>1、@Configuration</strong></p><p>   这里的@Configuration对我们来说不陌生，它就是JavaConfig形式的Spring Ioc容器的配置类使用的那个@Configuration，SpringBoot社区推荐使用基于JavaConfig的配置形式，所以，这里的启动类标注了@Configuration之后，本身其实也是一个IoC容器的配置类。</p><p>举几个简单例子回顾下，XML跟config配置方式的区别：</p><p><strong>（1）表达形式层面</strong></p><p>基于XML配置的方式是这样：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 &lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">2 &lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">3        xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">4        xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans-3.0.xsd&quot;</span><br><span class="line">5        default-lazy-init&#x3D;&quot;true&quot;&gt;</span><br><span class="line">6     &lt;!--bean定义--&gt;</span><br><span class="line">7 &lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>而基于JavaConfig的配置方式是这样：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 @Configuration</span><br><span class="line">2 public class MockConfiguration&#123;</span><br><span class="line">3     &#x2F;&#x2F;bean定义</span><br><span class="line">4 &#125;</span><br></pre></td></tr></table></figure><p>任何一个标注了@Configuration的Java类定义都是一个JavaConfig配置类。</p><p><strong>（2）注册bean定义层面</strong></p><p>基于XML的配置形式是这样：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 &lt;bean id&#x3D;&quot;mockService&quot; class&#x3D;&quot;..MockServiceImpl&quot;&gt;</span><br><span class="line">2     ...</span><br><span class="line">3 &lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure><p>而基于JavaConfig的配置形式是这样的：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 @Configuration</span><br><span class="line">2 public class MockConfiguration&#123;</span><br><span class="line">3     @Bean</span><br><span class="line">4     public MockService mockService()&#123;</span><br><span class="line">5         return new MockServiceImpl();</span><br><span class="line">6     &#125;</span><br><span class="line">7 &#125;</span><br></pre></td></tr></table></figure><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>任何一个标注了@Bean的方法，其返回值将作为一个bean定义注册到Spring的IoC容器，方法名将默认成该bean定义的id。</p><p><strong>（3）表达依赖注入关系层面</strong></p><p>为了表达bean与bean之间的依赖关系，在XML形式中一般是这样：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 &lt;bean id&#x3D;&quot;mockService&quot; class&#x3D;&quot;..MockServiceImpl&quot;&gt;</span><br><span class="line">2     &lt;propery name &#x3D;&quot;dependencyService&quot; ref&#x3D;&quot;dependencyService&quot; &#x2F;&gt;</span><br><span class="line">3 &lt;&#x2F;bean&gt;</span><br><span class="line">4 </span><br><span class="line">5 &lt;bean id&#x3D;&quot;dependencyService&quot; class&#x3D;&quot;DependencyServiceImpl&quot;&gt;&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure><p>而基于JavaConfig的配置形式是这样的：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 1 @Configuration</span><br><span class="line"> 2 public class MockConfiguration&#123;</span><br><span class="line"> 3     @Bean</span><br><span class="line"> 4     public MockService mockService()&#123;</span><br><span class="line"> 5         return new MockServiceImpl(dependencyService());</span><br><span class="line"> 6     &#125;</span><br><span class="line"> 7     </span><br><span class="line"> 8     @Bean</span><br><span class="line"> 9     public DependencyService dependencyService()&#123;</span><br><span class="line">10         return new DependencyServiceImpl();</span><br><span class="line">11     &#125;</span><br><span class="line">12 &#125;</span><br></pre></td></tr></table></figure><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>如果一个bean的定义依赖其他bean，则直接调用对应的JavaConfig类中依赖bean的创建方法就可以了。</p><hr><p>@Configuration：提到@Configuration就要提到他的搭档@Bean。使用这两个注解就可以创建一个简单的spring配置类，可以用来替代相应的xml配置文件。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 &lt;beans&gt; </span><br><span class="line">2     &lt;bean id &#x3D; &quot;car&quot; class&#x3D;&quot;com.test.Car&quot;&gt; </span><br><span class="line">3         &lt;property name&#x3D;&quot;wheel&quot; ref &#x3D; &quot;wheel&quot;&gt;&lt;&#x2F;property&gt; </span><br><span class="line">4     &lt;&#x2F;bean&gt; </span><br><span class="line">5     &lt;bean id &#x3D; &quot;wheel&quot; class&#x3D;&quot;com.test.Wheel&quot;&gt;&lt;&#x2F;bean&gt; </span><br><span class="line">6 &lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure><p>相当于：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 1 @Configuration </span><br><span class="line"> 2 public class Conf &#123; </span><br><span class="line"> 3     @Bean </span><br><span class="line"> 4     public Car car() &#123; </span><br><span class="line"> 5         Car car &#x3D; new Car(); </span><br><span class="line"> 6         car.setWheel(wheel()); </span><br><span class="line"> 7         return car; </span><br><span class="line"> 8     &#125;</span><br><span class="line"> 9     </span><br><span class="line">10     @Bean </span><br><span class="line">11     public Wheel wheel() &#123; </span><br><span class="line">12         return new Wheel(); </span><br><span class="line">13     &#125; </span><br><span class="line">14 &#125;</span><br></pre></td></tr></table></figure><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>@Configuration的注解类标识这个类可以使用Spring IoC容器作为bean定义的来源。</p><p>@Bean注解告诉Spring，一个带有@Bean的注解方法将返回一个对象，该对象应该被注册为在Spring应用程序上下文中的bean。</p><p><strong>2、@ComponentScan</strong></p><p>   @ComponentScan这个注解在Spring中很重要，它对应XML配置中的元素，@ComponentScan的功能其实就是自动扫描并加载符合条件的组件（比如@Component和@Repository等）或者bean定义，最终将这些bean定义加载到IoC容器中。</p><p>   我们可以通过basePackages等属性来细粒度的定制@ComponentScan自动扫描的范围，如果不指定，则默认Spring框架实现会从声明@ComponentScan所在类的package进行扫描。</p><p>注：所以SpringBoot的启动类最好是放在root package下，因为默认不指定basePackages。</p><p><strong>3、@EnableAutoConfiguration</strong></p><p>  个人感觉@EnableAutoConfiguration这个Annotation最为重要，所以放在最后来解读，大家是否还记得Spring框架提供的各种名字为@Enable开头的Annotation定义？比如@EnableScheduling、@EnableCaching、@EnableMBeanExport等，@EnableAutoConfiguration的理念和做事方式其实一脉相承，简单概括一下就是，<strong>借助@Import的支持，收集和注册特定场景相关的bean定义。</strong></p><ul><li>@EnableScheduling是通过@Import将Spring调度框架相关的bean定义都加载到IoC容器。</li><li>@EnableMBeanExport是通过@Import将JMX相关的bean定义加载到IoC容器。</li></ul><p>而@EnableAutoConfiguration也是借助@Import的帮助，将所有符合自动配置条件的bean定义加载到IoC容器，仅此而已！</p><p>  @EnableAutoConfiguration会根据类路径中的jar依赖为项目进行自动配置，如：添加了spring-boot-starter-web依赖，会自动添加Tomcat和Spring MVC的依赖，Spring Boot会对Tomcat和Spring MVC进行自动配置。</p><p><img src="https://images2017.cnblogs.com/blog/249993/201712/249993-20171207162607144-677920507.png" alt="img"></p><p> @EnableAutoConfiguration作为一个复合Annotation，其自身定义关键信息如下：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 1 @SuppressWarnings(&quot;deprecation&quot;)</span><br><span class="line"> 2 @Target(ElementType.TYPE)</span><br><span class="line"> 3 @Retention(RetentionPolicy.RUNTIME)</span><br><span class="line"> 4 @Documented</span><br><span class="line"> 5 @Inherited</span><br><span class="line"> 6 @AutoConfigurationPackage</span><br><span class="line"> 7 @Import(EnableAutoConfigurationImportSelector.class)</span><br><span class="line"> 8 public @interface EnableAutoConfiguration &#123;</span><br><span class="line"> 9     ...</span><br><span class="line">10 &#125;</span><br></pre></td></tr></table></figure><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>  其中，最关键的要属@Import(EnableAutoConfigurationImportSelector.class)，借助EnableAutoConfigurationImportSelector，@EnableAutoConfiguration可以帮助SpringBoot应用将所有符合条件的@Configuration配置都加载到当前SpringBoot创建并使用的IoC容器。就像一只“八爪鱼”一样，借助于Spring框架原有的一个工具类：SpringFactoriesLoader的支持，@EnableAutoConfiguration可以智能的自动配置功效才得以大功告成！</p><p><img src="https://images2017.cnblogs.com/blog/249993/201712/249993-20171207163759488-1739516792.png" alt="img"></p><p><strong>自动配置幕后英雄：SpringFactoriesLoader详解</strong></p><p>SpringFactoriesLoader属于Spring框架私有的一种扩展方案，其主要功能就是从指定的配置文件META-INF/spring.factories加载配置。</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 1 public abstract class SpringFactoriesLoader &#123;</span><br><span class="line"> 2     &#x2F;&#x2F;...</span><br><span class="line"> 3     public static &lt;T&gt; List&lt;T&gt; loadFactories(Class&lt;T&gt; factoryClass, ClassLoader classLoader) &#123;</span><br><span class="line"> 4         ...</span><br><span class="line"> 5     &#125;</span><br><span class="line"> 6 </span><br><span class="line"> 7 </span><br><span class="line"> 8     public static List&lt;String&gt; loadFactoryNames(Class&lt;?&gt; factoryClass, ClassLoader classLoader) &#123;</span><br><span class="line"> 9         ....</span><br><span class="line">10     &#125;</span><br><span class="line">11 &#125;</span><br></pre></td></tr></table></figure><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>配合@EnableAutoConfiguration使用的话，它更多是提供一种配置查找的功能支持，即根据@EnableAutoConfiguration的完整类名org.springframework.boot.autoconfigure.EnableAutoConfiguration作为查找的Key，获取对应的一组@Configuration类。</p><p><img src="https://images2017.cnblogs.com/blog/249993/201712/249993-20171208161556484-1145877030.jpg" alt="img"></p><p>上图就是从SpringBoot的autoconfigure依赖包中的META-INF/spring.factories配置文件中摘录的一段内容，可以很好地说明问题。</p><p>所以，@EnableAutoConfiguration自动配置的魔法骑士就变成了：<strong>从classpath中搜寻所有的META-INF/spring.factories配置文件，并将其中org.springframework.boot.autoconfigure.EnableutoConfiguration对应的配置项通过反射（Java Refletion）实例化为对应的标注了@Configuration的JavaConfig形式的IoC容器配置类，然后汇总为一个并加载到IoC容器。</strong></p><p><strong>二、深入探索SpringApplication执行流程</strong></p><p>SpringApplication的run方法的实现是我们本次旅程的主要线路，该方法的主要流程大体可以归纳如下：</p><p>1） 如果我们使用的是SpringApplication的静态run方法，那么，这个方法里面首先要创建一个SpringApplication对象实例，然后调用这个创建好的SpringApplication的实例方法。在SpringApplication实例初始化的时候，它会提前做几件事情：</p><ul><li>根据classpath里面是否存在某个特征类（org.springframework.web.context.ConfigurableWebApplicationContext）来决定是否应该创建一个为Web应用使用的ApplicationContext类型。</li><li>使用SpringFactoriesLoader在应用的classpath中查找并加载所有可用的ApplicationContextInitializer。</li><li>使用SpringFactoriesLoader在应用的classpath中查找并加载所有可用的ApplicationListener。</li><li>推断并设置main方法的定义类。</li></ul><p>2） SpringApplication实例初始化完成并且完成设置后，就开始执行run方法的逻辑了，方法执行伊始，首先遍历执行所有通过SpringFactoriesLoader可以查找到并加载的SpringApplicationRunListener。调用它们的started()方法，告诉这些SpringApplicationRunListener，“嘿，SpringBoot应用要开始执行咯！”。</p><p>3） 创建并配置当前Spring Boot应用将要使用的Environment（包括配置要使用的PropertySource以及Profile）。</p><p>4） 遍历调用所有SpringApplicationRunListener的environmentPrepared()的方法，告诉他们：“当前SpringBoot应用使用的Environment准备好了咯！”。</p><p>5） 如果SpringApplication的showBanner属性被设置为true，则打印banner。</p><p>6） 根据用户是否明确设置了applicationContextClass类型以及初始化阶段的推断结果，决定该为当前SpringBoot应用创建什么类型的ApplicationContext并创建完成，然后根据条件决定是否添加ShutdownHook，决定是否使用自定义的BeanNameGenerator，决定是否使用自定义的ResourceLoader，当然，最重要的，将之前准备好的Environment设置给创建好的ApplicationContext使用。</p><p>7） ApplicationContext创建好之后，SpringApplication会再次借助Spring-FactoriesLoader，查找并加载classpath中所有可用的ApplicationContext-Initializer，然后遍历调用这些ApplicationContextInitializer的initialize（applicationContext）方法来对已经创建好的ApplicationContext进行进一步的处理。</p><p>8） 遍历调用所有SpringApplicationRunListener的contextPrepared()方法。</p><p>9） 最核心的一步，将之前通过@EnableAutoConfiguration获取的所有配置以及其他形式的IoC容器配置加载到已经准备完毕的ApplicationContext。</p><p>10） 遍历调用所有SpringApplicationRunListener的contextLoaded()方法。</p><p>11） 调用ApplicationContext的refresh()方法，完成IoC容器可用的最后一道工序。</p><p>12） 查找当前ApplicationContext中是否注册有CommandLineRunner，如果有，则遍历执行它们。</p><p>13） 正常情况下，遍历执行SpringApplicationRunListener的finished()方法、（如果整个过程出现异常，则依然调用所有SpringApplicationRunListener的finished()方法，只不过这种情况下会将异常信息一并传入处理）</p><p>去除事件通知点后，整个流程如下：</p><p><img src="https://images2017.cnblogs.com/blog/249993/201712/249993-20171212151321051-993064506.jpg" alt="img"></p><hr><p>本文以调试一个实际的SpringBoot启动程序为例，参考流程中主要类类图，来分析其启动逻辑和自动化配置原理。</p><p><img src="https://images2017.cnblogs.com/blog/249993/201712/249993-20171213142128051-351399772.png" alt="img"></p><p><strong>总览：</strong>   </p><p>  上图为SpringBoot启动结构图，我们发现启动流程主要分为三个部分，第一部分进行SpringApplication的初始化模块，配置一些基本的环境变量、资源、构造器、监听器，第二部分实现了应用具体的启动方案，包括启动流程的监听模块、加载配置环境模块、及核心的创建上下文环境模块，第三部分是自动化配置模块，该模块作为springboot自动配置核心，在后面的分析中会详细讨论。在下面的启动程序中我们会串联起结构中的主要功能。</p><p><strong>启动：</strong></p><p>   每个SpringBoot程序都有一个主入口，也就是main方法，main里面调用SpringApplication.run()启动整个spring-boot程序，该方法所在类需要使用@SpringBootApplication注解，以及@ImportResource注解(if need)，@SpringBootApplication包括三个注解，功能如下：</p><p>@EnableAutoConfiguration：SpringBoot根据应用所声明的依赖来对Spring框架进行自动配置。</p><p>@SpringBootConfiguration(内部为@Configuration)：被标注的类等于在spring的XML配置文件中(applicationContext.xml)，装配所有bean事务，提供了一个spring的上下文环境。</p><p>@ComponentScan：组件扫描，可自动发现和装配Bean，默认扫描SpringApplication的run方法里的Booter.class所在的包路径下文件，所以最好将该启动类放到根包路径下。</p><p><img src="https://images2017.cnblogs.com/blog/249993/201712/249993-20171213143558363-1466265945.png" alt="img"></p><p><strong>SpringBoot启动类</strong></p><p>首先进入run方法</p><p><img src="https://images2017.cnblogs.com/blog/249993/201712/249993-20171213144051754-1827098906.png" alt="img"></p><p>run方法中去创建了一个SpringApplication实例，在该构造方法内，我们可以发现其调用了一个初始化的initialize方法</p><p><img src="https://images2017.cnblogs.com/blog/249993/201712/249993-20171213144232926-834887500.png" alt="img"></p><p><img src="https://images2017.cnblogs.com/blog/249993/201712/249993-20171213144259160-129693850.png" alt="img"></p><p>这里主要是为SpringApplication对象赋一些初值。构造函数执行完毕后，我们回到run方法</p><p><img src="https://images2017.cnblogs.com/blog/249993/201712/249993-20171213144447066-1033381024.png" alt="img"></p><p>该方法中实现了如下几个关键步骤：</p><p>1.创建了应用的监听器SpringApplicationRunListeners并开始监听</p><p>2.加载SpringBoot配置环境(ConfigurableEnvironment)，如果是通过web容器发布，会加载StandardEnvironment，其最终也是继承了ConfigurableEnvironment，类图如下</p><p><img src="https://images2017.cnblogs.com/blog/249993/201712/249993-20171213144808707-1335729370.png" alt="img"></p><p>可以看出，*Environment最终都实现了PropertyResolver接口，我们平时通过environment对象获取配置文件中指定Key对应的value方法时，就是调用了propertyResolver接口的getProperty方法</p><p>3.配置环境(Environment)加入到监听器对象中(SpringApplicationRunListeners)</p><p>4.创建run方法的返回对象：ConfigurableApplicationContext(应用配置上下文)，我们可以看一下创建方法：</p><p><img src="https://images2017.cnblogs.com/blog/249993/201712/249993-20171213145353394-1416082242.png" alt="img"></p><p>方法会先获取显式设置的应用上下文(applicationContextClass)，如果不存在，再加载默认的环境配置（通过是否是web environment判断），默认选择AnnotationConfigApplicationContext注解上下文（通过扫描所有注解类来加载bean），最后通过BeanUtils实例化上下文对象，并返回。</p><p>ConfigurableApplicationContext类图如下：</p><p><img src="https://images2017.cnblogs.com/blog/249993/201712/249993-20171213154313488-1411301156.png" alt="img"></p><p>主要看其继承的两个方向：</p><p>LifeCycle：生命周期类，定义了start启动、stop结束、isRunning是否运行中等生命周期空值方法</p><p>ApplicationContext：应用上下文类，其主要继承了beanFactory(bean的工厂类)</p><p>5.回到run方法内，prepareContext方法将listeners、environment、applicationArguments、banner等重要组件与上下文对象关联</p><p>6.接下来的refreshContext(context)方法(初始化方法如下)将是实现spring-boot-starter-*(mybatis、redis等)自动化配置的关键，包括spring.factories的加载，bean的实例化等核心工作。</p><p><img src="https://images2017.cnblogs.com/blog/249993/201712/249993-20171213154943754-336827902.png" alt="img"></p><p>   配置结束后，Springboot做了一些基本的收尾工作，返回了应用环境上下文。回顾整体流程，Springboot的启动，主要创建了配置环境(environment)、事件监听(listeners)、应用上下文(applicationContext)，并基于以上条件，在容器中开始实例化我们需要的Bean，至此，通过SpringBoot启动的程序已经构造完成，接下来我们来探讨自动化配置是如何实现。</p><hr><p><strong>自动化配置：</strong></p><p>之前的启动结构图中，我们注意到无论是应用初始化还是具体的执行过程，都调用了SpringBoot自动配置模块。</p><p><img src="https://images2017.cnblogs.com/blog/249993/201712/249993-20171219161544990-1859845219.png" alt="img"></p><p>SpringBoot自动配置模块</p><p>  该配置模块的主要使用到了SpringFactoriesLoader，即Spring工厂加载器，该对象提供了loadFactoryNames方法，入参为factoryClass和classLoader，即需要传入上图中的工厂类名称和对应的类加载器，方法会根据指定的classLoader，加载该类加器搜索路径下的指定文件，即spring.factories文件，传入的工厂类为接口，而文件中对应的类则是接口的实现类，或最终作为实现类，所以文件中一般为如下图这种一对多的类名集合，获取到这些实现类的类名后，loadFactoryNames方法返回类名集合，方法调用方得到这些集合后，再通过反射获取这些类的类对象、构造方法，最终生成实例。</p><p><img src="https://images2017.cnblogs.com/blog/249993/201712/249993-20171219162725615-751500087.png" alt="img"></p><p>工厂接口与其若干实现类接口名称</p><p>下图有助于我们形象理解自动配置流程。</p><p><img src="https://images2017.cnblogs.com/blog/249993/201712/249993-20171219162844787-1104034109.png" alt="img"></p><p>SpringBoot自动化配置关键组件关系图 </p><p>  mybatis-spring-boot-starter、spring-boot-starter-web等组件的META-INF文件下均含有spring.factories文件，自动配置模块中，SpringFactoriesLoader收集到文件中的类全名并返回一个类全名的数组，返回的类全名通过反射被实例化，就形成了具体的工厂实例，工厂实例来生成组件具体需要的bean。</p><p>之前我们提到了EnableAutoConfiguration注解，其类图如下：</p><p><img src="https://images2017.cnblogs.com/blog/249993/201712/249993-20171219163356100-1697141132.png" alt="img"></p><p>可以发现其最终实现了ImportSelector(选择器)和BeanClassLoaderAware(bean类加载器中间件)，重点关注一下AutoConfigurationImportSelector的selectImports方法。</p><p><img src="https://images2017.cnblogs.com/blog/249993/201712/249993-20171219163452318-1362759499.png" alt="img"></p><p>  该方法在springboot启动流程——bean实例化前被执行，返回要实例化的类信息列表。我们知道，如果获取到类信息，spring自然可以通过类加载器将类加载到jvm中，现在我们已经通过spring-boot的starter依赖方式依赖了我们需要的组件，那么这些组建的类信息在select方法中也是可以被获取到的，不要急我们继续向下分析。</p><p><img src="https://images2017.cnblogs.com/blog/249993/201712/249993-20171219164025334-1624354890.png" alt="img"></p><p>该方法中的getCandidateConfigurations方法，通过方法注释了解到，其返回一个自动配置类的类名列表，方法调用了loadFactoryNames方法，查看该方法</p><p><img src="https://images2017.cnblogs.com/blog/249993/201712/249993-20171219164224912-643901744.png" alt="img"></p><p>  在上面的代码可以看到自动配置器会根据传入的factoryClass.getName()到项目系统路径下所有的spring.factories文件中找到相应的key，从而加载里面的类。我们就选取这个mybatis-spring-boot-autoconfigure下的spring.factories文件</p><p><img src="https://images2017.cnblogs.com/blog/249993/201712/249993-20171219164557240-1466961312.png" alt="img"></p><p>进入org.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration中，主要看一下类头：</p><p><img src="https://images2017.cnblogs.com/blog/249993/201712/249993-20171219164818162-646159475.png" alt="img"></p><p>发现Spring的@Configuration，俨然是一个通过注解标注的springBean，继续向下看，</p><p>@ConditionalOnClass({ SqlSessionFactory.class, SqlSessionFactoryBean.class})这个注解的意思是：当存在SqlSessionFactory.class, SqlSessionFactoryBean.class这两个类时才解析MybatisAutoConfiguration配置类，否则不解析这一个配置类，make sence，我们需要mybatis为我们返回会话对象，就必须有会话工厂相关类。</p><p>@CondtionalOnBean(DataSource.class)：只有处理已经被声明为bean的dataSource。</p><p>@ConditionalOnMissingBean(MapperFactoryBean.class)这个注解的意思是如果容器中不存在name指定的bean则创建bean注入，否则不执行（该类源码较长，篇幅限制不全粘贴）</p><p>   以上配置可以保证sqlSessionFactory、sqlSessionTemplate、dataSource等mybatis所需的组件均可被自动配置，@Configuration注解已经提供了Spring的上下文环境，所以以上组件的配置方式与Spring启动时通过mybatis.xml文件进行配置起到一个效果。通过分析我们可以发现，只要一个基于SpringBoot项目的类路径下存在SqlSessionFactory.class, SqlSessionFactoryBean.class，并且容器中已经注册了dataSourceBean，就可以触发自动化配置，意思说我们只要在maven的项目中加入了mybatis所需要的若干依赖，就可以触发自动配置，但引入mybatis原生依赖的话，每集成一个功能都要去修改其自动化配置类，那就得不到开箱即用的效果了。所以Spring-boot为我们提供了统一的starter可以直接配置好相关的类，触发自动配置所需的依赖(mybatis)如下：</p><p><img src="https://images2017.cnblogs.com/blog/249993/201712/249993-20171220160748068-2010633643.png" alt="img"></p><p>这里是截取的mybatis-spring-boot-starter的源码中pom.xml文件中所有依赖：</p><p><img src="https://images2017.cnblogs.com/blog/249993/201712/249993-20171220160934240-319846263.png" alt="img"></p><p> 因为maven依赖的传递性，我们只要依赖starter就可以依赖到所有需要自动配置的类，实现开箱即用的功能。也体现出Springboot简化了Spring框架带来的大量XML配置以及复杂的依赖管理，让开发人员可以更加关注业务逻辑的开发。</p>]]></content>
    
    <summary type="html">
    
      you can &quot;just run&quot;
    
    </summary>
    
    
      <category term="SpringBoot" scheme="https://SomunsTao.github.io/categories/SpringBoot/"/>
    
    
      <category term="SpringBoot" scheme="https://SomunsTao.github.io/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>Vue 13： VUE复习</title>
    <link href="https://somunstao.github.io/2020/04/23/Vue%2013%EF%BC%9A%20VUE%E5%A4%8D%E4%B9%A0/"/>
    <id>https://somunstao.github.io/2020/04/23/Vue%2013%EF%BC%9A%20VUE%E5%A4%8D%E4%B9%A0/</id>
    <published>2020-04-22T16:00:00.000Z</published>
    <updated>2020-08-01T15:19:56.696Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Vue实战"><a href="#Vue实战" class="headerlink" title="Vue实战"></a>Vue实战</h1><h2 id="1-Vue-引言"><a href="#1-Vue-引言" class="headerlink" title="1. Vue 引言"></a>1. Vue 引言</h2><blockquote><p><code>渐进式</code> JavaScript 框架   –摘自官网</p></blockquote><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 渐进式</span></span><br><span class="line"><span class="bullet">   1. </span>易用  html css javascript</span><br><span class="line"><span class="bullet">   2. </span>高效  开发前端页面 非常高效 </span><br><span class="line"><span class="bullet">   3. </span>灵活  开发灵活 多样性</span><br><span class="line"></span><br><span class="line"><span class="section"># 总结</span></span><br><span class="line"><span class="code">Vue 是一个javascript 框架</span></span><br><span class="line"></span><br><span class="line"><span class="section"># 后端服务端开发人员: </span></span><br><span class="line"><span class="code">Vue 渐进式javascript框架: 让我们通过操作很少的DOM,甚至不需要操作页面中任何DOM元素,就很容易的完成数据和视图绑定  双向绑定 MVVM  </span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">注意: 日后在使用Vue过程中页面中不要在引入Jquery框架</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">htmlcss---&gt;javascript -----&gt;jquery----&gt;angularjs -----&gt; Vue</span></span><br><span class="line"> </span><br><span class="line"> # Vue 作者</span><br><span class="line">  尤雨溪   国内的</span><br></pre></td></tr></table></figure><hr><h2 id="2-Vue入门"><a href="#2-Vue入门" class="headerlink" title="2. Vue入门"></a>2. Vue入门</h2><h3 id="2-1-下载Vuejs"><a href="#2-1-下载Vuejs" class="headerlink" title="2.1    下载Vuejs"></a>2.1    下载Vuejs</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//开发版本:</span></span><br><span class="line">&lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt;</span><br><span class="line">&lt;script src=<span class="string">"https://cdn.jsdelivr.net/npm/vue/dist/vue.js"</span>&gt;&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/生产版本:</span></span><br><span class="line"><span class="regexp">&lt;!-- 生产环境版本，优化了尺寸和速度 --&gt;</span></span><br><span class="line"><span class="regexp">&lt;script src="https:/</span><span class="regexp">/cdn.jsdelivr.net/</span>npm/vue<span class="string">"&gt;&lt;/script&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-2-Vue第一个入门应用"><a href="#2-2-Vue第一个入门应用" class="headerlink" title="2.2 Vue第一个入门应用"></a>2.2 Vue第一个入门应用</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">       &#123;&#123; msg &#125;&#125;  &#123;&#123;username&#125;&#125; &#123;&#123;pwd&#125;&#125;</span><br><span class="line"></span><br><span class="line">       <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">span</span>&gt;</span></span><br><span class="line">           &#123;&#123; username &#125;&#125;</span><br><span class="line">           <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123; msg &#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!--引入vue.js--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/vue/dist/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">       <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">           el:<span class="string">"#app"</span>,  <span class="comment">//element 用来给Vue实例定义一个作用范围</span></span></span><br><span class="line"><span class="actionscript">           data:&#123;      <span class="comment">//用来给Vue实例定义一些相关数据</span></span></span><br><span class="line"><span class="actionscript">               msg:<span class="string">"百知欢迎你,期待你的加入!"</span>,</span></span><br><span class="line"><span class="actionscript">               username:<span class="string">"hello Vue!"</span>,</span></span><br><span class="line"><span class="actionscript">               pwd :<span class="string">"12345"</span>,</span></span><br><span class="line">           &#125;,</span><br><span class="line">       &#125;);</span><br><span class="line">   <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 总结:</span></span><br><span class="line"><span class="code">1.vue实例(对象)中el属性: 代表Vue的作用范围  日后在Vue的作用范围内都可以使用Vue的语法</span></span><br><span class="line"><span class="code">2.vue实例(对象)中data属性: 用来给Vue实例绑定一些相关数据, 绑定的数据可以通过&#123;&#123;变量名&#125;&#125;在Vue作用范围内取出</span></span><br><span class="line"><span class="code">3.在使用&#123;&#123;&#125;&#125;进行获取data中数据时,可以在&#123;&#123;&#125;&#125;中书写表达式,运算符,调用相关方法,以及逻辑运算等</span></span><br><span class="line"><span class="code">4.el属性中可以书写任意的CSS选择器[jquery选择器],但是在使用Vue开发是推荐使用 id选择器</span></span><br></pre></td></tr></table></figure><hr><h2 id="3-v-text和v-html"><a href="#3-v-text和v-html" class="headerlink" title="3. v-text和v-html"></a>3. v-text和v-html</h2><h3 id="3-1-v-text"><a href="#3-1-v-text" class="headerlink" title="3.1 v-text"></a>3.1 v-text</h3><blockquote><p><code>v-text</code>:用来获取data中数据将数据以文本的形式渲染到指定标签内部             类似于javascript 中 innerText</p></blockquote><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span> <span class="attr">class</span>=<span class="string">"aa"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span> &gt;</span>&#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-text</span>=<span class="string">"message"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--引入vue.js--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/vue/dist/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">      <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">          el:<span class="string">"#app"</span>,</span></span><br><span class="line">          data:&#123;</span><br><span class="line"><span class="actionscript">              message:<span class="string">"百知欢迎您"</span></span></span><br><span class="line">          &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 总结</span></span><br><span class="line"><span class="code">1.&#123;&#123;&#125;&#125;(插值表达式)和v-text获取数据的区别在于 </span></span><br><span class="line"><span class="code">a.使用v-text取值会将标签中原有的数据覆盖 使用插值表达式的形式不会覆盖标签原有的数据</span></span><br><span class="line"><span class="code">b.使用v-text可以避免在网络环境较差的情况下出现插值闪烁</span></span><br></pre></td></tr></table></figure><h3 id="3-2-v-html"><a href="#3-2-v-html" class="headerlink" title="3.2 v-html"></a>3.2 v-html</h3><blockquote><p><code>v-html</code>:用来获取data中数据将数据中含有的html标签先解析在渲染到指定标签的内部  类似于javascript中 innerHTML</p></blockquote><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span> <span class="attr">class</span>=<span class="string">"aa"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-text</span>=<span class="string">"message"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-html</span>=<span class="string">"message"</span>&gt;</span>xxxxxx<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--引入vue.js--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/vue/dist/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">            el:<span class="string">"#app"</span>,</span></span><br><span class="line">            data:&#123;</span><br><span class="line"><span class="handlebars"><span class="xml">                message:"<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">''</span>&gt;</span>百知欢迎您<span class="tag">&lt;/<span class="name">a</span>&gt;</span>"</span></span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h2 id="4-vue中事件绑定-v-on"><a href="#4-vue中事件绑定-v-on" class="headerlink" title="4.vue中事件绑定(v-on)"></a>4.vue中事件绑定(v-on)</h2><h3 id="4-1-绑定事件基本语法"><a href="#4-1-绑定事件基本语法" class="headerlink" title="4.1 绑定事件基本语法"></a>4.1 绑定事件基本语法</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h2</span> <span class="attr">v-text</span>=<span class="string">"message"</span>&gt;</span><span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h2</span>&gt;</span>年龄:&#123;&#123; age &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"点我改变年龄"</span> <span class="attr">v-on:click</span>=<span class="string">"changeage"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--引入vue.js--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/vue/dist/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">      <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">          el:<span class="string">"#app"</span>,</span></span><br><span class="line">          data:&#123;</span><br><span class="line"><span class="actionscript">              message:<span class="string">"hello 欢迎来到百知课堂!"</span>,</span></span><br><span class="line">              age:23,</span><br><span class="line">          &#125;,</span><br><span class="line"><span class="actionscript">          methods:&#123;  <span class="comment">//methods 用来定义vue中时间</span></span></span><br><span class="line"><span class="actionscript">              changeage:<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="actionscript">                  alert(<span class="string">'点击触发'</span>);</span></span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 总结:</span></span><br><span class="line"><span class="code">事件  事件源:发生事件dom元素  事件: 发生特定的动作  click....  监听器  发生特定动作之后的事件处理程序 通常是js中函数</span></span><br><span class="line"><span class="code">1.在vue中绑定事件是通过v-on指令来完成的 v-on:事件名 如  v-on:click</span></span><br><span class="line"><span class="code">2.在v-on:事件名的赋值语句中是当前时间触发调用的函数名</span></span><br><span class="line"><span class="code">3.在vue中事件的函数统一定义在Vue实例的methods属性中</span></span><br><span class="line"><span class="code">4.在vue定义的事件中this指的就是当前的Vue实例,日后可以在事件中通过使用this获取Vue实例中相关数据</span></span><br></pre></td></tr></table></figure><h3 id="4-2-Vue中事件的简化语法"><a href="#4-2-Vue中事件的简化语法" class="headerlink" title="4.2 Vue中事件的简化语法"></a>4.2 Vue中事件的简化语法</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123; age &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"通过v-on事件修改年龄每次+1"</span> <span class="attr">v-on:click</span>=<span class="string">"changeage"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"通过@绑定时间修改年龄每次-1"</span> @<span class="attr">click</span>=<span class="string">"editage"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--引入vue.js--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/vue/dist/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">      <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">         el:<span class="string">"#app"</span>,  <span class="comment">//element: 用来指定vue作用范围</span></span></span><br><span class="line">         data:&#123;</span><br><span class="line">             age:23,</span><br><span class="line"><span class="actionscript">         &#125;,    <span class="comment">//data   : 用来定义vue实例中相关数据</span></span></span><br><span class="line">         methods:&#123;</span><br><span class="line"><span class="actionscript">             changeage:<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="actionscript">                 <span class="keyword">this</span>.age++;</span></span><br><span class="line">             &#125;,</span><br><span class="line"><span class="actionscript">             editage:<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="actionscript">                 <span class="keyword">this</span>.age--;</span></span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line"><span class="actionscript">         &#125;  <span class="comment">//methods: 用来定义事件的处理函数</span></span></span><br><span class="line">      &#125;);</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 总结:</span></span><br><span class="line"><span class="code">1.日后在vue中绑定事件时可以通过@符号形式 简化  v-on 的事件绑定</span></span><br></pre></td></tr></table></figure><h3 id="4-3-Vue事件函数两种写法"><a href="#4-3-Vue事件函数两种写法" class="headerlink" title="4.3 Vue事件函数两种写法"></a>4.3 Vue事件函数两种写法</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123;count&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"改变count的值"</span> @<span class="attr">click</span>=<span class="string">"changecount"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--引入vue.js--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/vue/dist/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">      <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">         el:<span class="string">"#app"</span>,</span></span><br><span class="line">         data:&#123;</span><br><span class="line">             count:1,</span><br><span class="line">         &#125;,</span><br><span class="line">         methods:&#123;</span><br><span class="line">             /*changecount:function()&#123;</span><br><span class="line"><span class="actionscript">                 <span class="keyword">this</span>.count++;</span></span><br><span class="line">             &#125;*/</span><br><span class="line">             changecount()&#123;</span><br><span class="line"><span class="actionscript">                 <span class="keyword">this</span>.count++;</span></span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 总结:</span></span><br><span class="line"><span class="code">1.在Vue中事件定义存在两种写法  一种是 函数名:function()&#123;&#125;  推荐    一种是  函数名()&#123;&#125; 推荐</span></span><br></pre></td></tr></table></figure><h3 id="4-4-Vue事件参数传递"><a href="#4-4-Vue事件参数传递" class="headerlink" title="4.4 Vue事件参数传递"></a>4.4 Vue事件参数传递</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123;count&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"改变count为指定的值"</span> @<span class="attr">click</span>=<span class="string">"changecount(23,'xiaohei')"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--引入vue.js--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/vue/dist/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">      <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">         el:<span class="string">"#app"</span>,</span></span><br><span class="line">         data:&#123;</span><br><span class="line">             count:1,</span><br><span class="line">         &#125;,</span><br><span class="line">         methods:&#123;</span><br><span class="line"><span class="actionscript">             <span class="comment">//定义changecount</span></span></span><br><span class="line">             changecount(count,name)&#123;</span><br><span class="line"><span class="actionscript">                 <span class="keyword">this</span>.count = count;</span></span><br><span class="line">                 alert(name);</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">         &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 总结:</span></span><br><span class="line"><span class="code">1.在使用事件时,可以直接在事件调用出给事件进行参数传递,在事件定义出通过定义对应变量接收传递的参数</span></span><br></pre></td></tr></table></figure><hr><h2 id="5-v-show-v-if-v-bind"><a href="#5-v-show-v-if-v-bind" class="headerlink" title="5.v-show v-if v-bind"></a>5.v-show v-if v-bind</h2><h3 id="5-1-v-show"><a href="#5-1-v-show" class="headerlink" title="5.1 v-show"></a>5.1 v-show</h3><blockquote><p><code>v-show</code>:用来控制页面中某个标签元素是否展示        底层使用控制是 display 属性</p></blockquote><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        v-show: 用来控制标签展示还是隐藏的</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span> <span class="attr">v-show</span>=<span class="string">"false"</span>&gt;</span>百知教育欢迎你的加入!<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span> <span class="attr">v-show</span>=<span class="string">"show"</span>&gt;</span>百知教育欢迎你的加入这是vue中定义变量true!<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"展示隐藏标签"</span> @<span class="attr">click</span>=<span class="string">"showmsg"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--引入vue.js--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/vue/dist/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">        el:<span class="string">"#app"</span>,</span></span><br><span class="line">        data:&#123;</span><br><span class="line"><span class="actionscript">            show:<span class="literal">false</span>,</span></span><br><span class="line">        &#125;,</span><br><span class="line">        methods:&#123;</span><br><span class="line"><span class="actionscript">            <span class="comment">//定义时间</span></span></span><br><span class="line">            showmsg()&#123;</span><br><span class="line"><span class="actionscript">               <span class="keyword">this</span>.show =  !<span class="keyword">this</span>.show;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 总结</span></span><br><span class="line"><span class="code">1.在使用v-show时可以直接书写boolean值控制元素展示,也可以通过变量控制标签展示和隐藏</span></span><br><span class="line"><span class="code">2.在v-show中可以通过boolean表达式控制标签的展示课隐藏</span></span><br></pre></td></tr></table></figure><h3 id="5-2-v-if"><a href="#5-2-v-if" class="headerlink" title="5.2 v-if"></a>5.2 v-if</h3><blockquote><p><code>v-if</code>: 用来控制页面元素是否展示                底层控制是DOM元素    操作DOM</p></blockquote><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span> <span class="attr">v-if</span>=<span class="string">"false"</span>&gt;</span>百知教育<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span> <span class="attr">v-if</span>=<span class="string">"show"</span>&gt;</span>百知教育欢迎你的加入<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--引入vue.js--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/vue/dist/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">        el:<span class="string">"#app"</span>,</span></span><br><span class="line">        data:&#123;</span><br><span class="line"><span class="actionscript">            show:<span class="literal">false</span></span></span><br><span class="line">        &#125;,</span><br><span class="line">        methods:&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="5-3-v-bind"><a href="#5-3-v-bind" class="headerlink" title="5.3 v-bind"></a>5.3 v-bind</h3><blockquote><p><code>v-bind</code>: 用来绑定标签的属性从而通过vue动态修改标签的属性</p></blockquote><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">width</span>=<span class="string">"300"</span> <span class="attr">v-bind:title</span>=<span class="string">"msg"</span> <span class="attr">v-bind:class</span>=<span class="string">"&#123;aa:showCss&#125;"</span>  <span class="attr">src</span>=<span class="string">"baizhilogo.jpg"</span> <span class="attr">alt</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--引入vue.js--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/vue/dist/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">        el:<span class="string">"#app"</span>,</span></span><br><span class="line">        data:&#123;</span><br><span class="line"><span class="actionscript">            msg:<span class="string">"百知教育官方logo!!!!"</span>,</span></span><br><span class="line"><span class="actionscript">            showCss:<span class="literal">true</span>,</span></span><br><span class="line">        &#125;,</span><br><span class="line">        methods:&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="5-4-v-bind-简化写法"><a href="#5-4-v-bind-简化写法" class="headerlink" title="5.4 v-bind 简化写法"></a>5.4 v-bind 简化写法</h3><blockquote><p>​    vue为了方便我们日后绑定标签的属性提供了对属性绑定的简化写法如 <code>v-bind:属性名</code> 简化之后 <code>:属性名</code></p></blockquote><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">width</span>=<span class="string">"300"</span> <span class="attr">:title</span>=<span class="string">"msg"</span> <span class="attr">:class</span>=<span class="string">"&#123;aa:showCss&#125;"</span>  <span class="attr">:src</span>=<span class="string">"src"</span> <span class="attr">alt</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"动态控制加入样式"</span> @<span class="attr">click</span>=<span class="string">"addCss"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"改变图片"</span> @<span class="attr">click</span>=<span class="string">"changeSrc"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--引入vue.js--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/vue/dist/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">        el:<span class="string">"#app"</span>,</span></span><br><span class="line">        data:&#123;</span><br><span class="line"><span class="actionscript">            msg:<span class="string">"百知教育官方logo!!!!"</span>,</span></span><br><span class="line"><span class="actionscript">            showCss:<span class="literal">true</span>,</span></span><br><span class="line"><span class="actionscript">            src:<span class="string">"https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1583490365568&amp;di=52a82bd614cd4030f97ada9441bb2d0e&amp;imgtype=0&amp;src=http%3A%2F%2Fimg.kanzhun.com%2Fimages%2Flogo%2F20160714%2F820a68f65b4e4a3634085055779c000c.jpg"</span></span></span><br><span class="line">        &#125;,</span><br><span class="line">        methods:&#123;</span><br><span class="line">            addCss()&#123;</span><br><span class="line"><span class="actionscript">                <span class="keyword">this</span>.showCss= !<span class="keyword">this</span>.showCss;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            changeSrc()&#123;</span><br><span class="line"><span class="actionscript">                <span class="keyword">this</span>.src = <span class="string">"https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=1925088662,1336364220&amp;fm=26&amp;gp=0.jpg"</span>;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h2 id="6-v-for的使用"><a href="#6-v-for的使用" class="headerlink" title="6.v-for的使用"></a>6.v-for的使用</h2><blockquote><p><code>v-for</code>: 作用就是用来对对象进行遍历的(数组也是对象的一种)</p></blockquote><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123; user.name &#125;&#125; &#123;&#123; user.age &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">       通过v-for遍历对象</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-for</span>=<span class="string">"(value,key,index) in user"</span>&gt;</span></span><br><span class="line">        &#123;&#123;index&#125;&#125; : &#123;&#123;key&#125;&#125; : &#123;&#123;value&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        通过v-for遍历数组</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"a,index in arr"</span> &gt;</span></span><br><span class="line">            &#123;&#123;index&#125;&#125; &#123;&#123;a&#125;&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        通过v-for遍历数组中对象</span></span><br><span class="line"><span class="comment">        :key 便于vue内部做重用和排序</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"user,index in users"</span> <span class="attr">:key</span>=<span class="string">"user.id"</span>&gt;</span></span><br><span class="line">            &#123;&#123;index+1&#125;&#125; &#123;&#123; user.name &#125;&#125;  === &#123;&#123; user.age &#125;&#125; ==== &#123;&#123; user.content &#125;&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--引入vue--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/vue/dist/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">        el: <span class="string">"#app"</span>,</span></span><br><span class="line">        data: &#123;</span><br><span class="line"><span class="actionscript">            user:&#123;name:<span class="string">"小陈"</span>,age:<span class="number">23</span>&#125;,</span></span><br><span class="line"><span class="actionscript">            arr:[<span class="string">"北京校区"</span>, <span class="string">"天津校区"</span>, <span class="string">"河南校区"</span>],</span></span><br><span class="line">            users:[</span><br><span class="line"><span class="actionscript">                &#123;id:<span class="string">"1"</span>,name:<span class="string">"xiaochen"</span>,age:<span class="number">23</span>,content:<span class="string">"我曾经也是一个单纯的少年!"</span>&#125;,</span></span><br><span class="line"><span class="actionscript">                &#123;id:<span class="string">"2"</span>,name:<span class="string">"小白"</span>,age:<span class="number">23</span>,content:<span class="string">"我曾经是一个邪恶的少年!"</span>&#125;,</span></span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;&#125;</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 总结</span></span><br><span class="line"><span class="code">1.在使用v-for的时候一定要注意加入:key 用来给vue内部提供重用和排序的唯一key</span></span><br></pre></td></tr></table></figure><hr><h2 id="7-v-model-双向绑定"><a href="#7-v-model-双向绑定" class="headerlink" title="7 .v-model 双向绑定"></a>7 .v-model 双向绑定</h2><blockquote><p><code>v-model</code>: 作用用来绑定标签元素的值与vue实例对象中data数据保持一致,从而实现双向的数据绑定机制</p></blockquote><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model</span>=<span class="string">"message"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"改变Data中值"</span> @<span class="attr">click</span>=<span class="string">"changeValue"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--引入vue--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/vue/dist/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">        el: <span class="string">"#app"</span>,</span></span><br><span class="line">        data: &#123;</span><br><span class="line"><span class="actionscript">            message:<span class="string">""</span></span></span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line">            changeValue()&#123;</span><br><span class="line"><span class="actionscript">                <span class="keyword">this</span>.message=<span class="string">'百知教育!'</span>;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 总结</span></span><br><span class="line"><span class="code">1.使用v-model指令可以实现数据的双向绑定 </span></span><br><span class="line"><span class="code">2.所谓双向绑定 表单中数据变化导致vue实例data数据变化   vue实例中data数据的变化导致表单中数据变化 称之为双向绑定</span></span><br><span class="line"></span><br><span class="line"><span class="section"># MVVM架构  双向绑定机制</span></span><br><span class="line"><span class="code">Model: 数据  Vue实例中绑定数据</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">VM:   ViewModel  监听器</span></span><br><span class="line"></span><br><span class="line"><span class="code">View:  页面  页面展示的数据</span></span><br></pre></td></tr></table></figure><hr><h2 id="8-事件修饰符"><a href="#8-事件修饰符" class="headerlink" title="8. 事件修饰符"></a>8. 事件修饰符</h2><blockquote><p><code>修饰符</code>: 作用用来和事件连用,用来决定事件触发条件或者是阻止事件的触发机制</p></blockquote><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.常用的事件修饰符</span></span><br><span class="line"><span class="code">.stop</span></span><br><span class="line"><span class="code">.prevent</span></span><br><span class="line"><span class="code">.capture</span></span><br><span class="line"><span class="code">.self</span></span><br><span class="line"><span class="code">.once</span></span><br><span class="line"><span class="code">.passive</span></span><br></pre></td></tr></table></figure><h3 id="8-1-stop事件修饰符"><a href="#8-1-stop事件修饰符" class="headerlink" title="8.1 stop事件修饰符"></a>8.1 stop事件修饰符</h3><blockquote><p>用来阻止事件冒泡</p></blockquote><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"aa"</span> @<span class="attr">click</span>=<span class="string">"divClick"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--用来阻止事件冒泡--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"按钮"</span> @<span class="attr">click.stop</span>=<span class="string">"btnClick"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--引入vue--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/vue/dist/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">        el: <span class="string">"#app"</span>,</span></span><br><span class="line">        data: &#123;&#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line">            btnClick()&#123;</span><br><span class="line"><span class="actionscript">                alert(<span class="string">'button被点击了'</span>);</span></span><br><span class="line">            &#125;,</span><br><span class="line">            divClick()&#123;</span><br><span class="line"><span class="actionscript">                alert(<span class="string">'div被点击了'</span>);</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="8-2-prevent-事件修饰符"><a href="#8-2-prevent-事件修饰符" class="headerlink" title="8.2 prevent 事件修饰符"></a>8.2 prevent 事件修饰符</h3><blockquote><p>用来阻止标签的默认行为</p></blockquote><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--用来阻止事件的默认行为--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://www.baizhibest.com/"</span> @<span class="attr">click.prevent</span>=<span class="string">"aClick"</span>&gt;</span>百知教育<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="8-3-self-事件修饰符"><a href="#8-3-self-事件修饰符" class="headerlink" title="8.3 self 事件修饰符"></a>8.3 self 事件修饰符</h3><blockquote><p>用来针对于当前标签的事件触发     ===========&gt; 只触发自己标签的上特定动作的事件     只关心自己标签上触发的事件 不监听事件冒泡</p></blockquote><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--只触发标签自身的事件--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"aa"</span> @<span class="attr">click.self</span>=<span class="string">"divClick"</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--用来阻止事件冒泡--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"按钮"</span> @<span class="attr">click.stop</span>=<span class="string">"btnClick"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"按钮1"</span> @<span class="attr">click</span>=<span class="string">"btnClick1"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="8-4-once-事件修饰符"><a href="#8-4-once-事件修饰符" class="headerlink" title="8.4 once 事件修饰符"></a>8.4 once 事件修饰符</h3><blockquote><p>once 一次 作用:  就是让指定事件只触发一次</p></blockquote><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">.prevent : 用来阻止事件的默认行为</span></span><br><span class="line"><span class="comment">.once    : 用来只执行一次特定的事件</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://www.baizhibest.com/"</span> @<span class="attr">click.prevent.once</span>=<span class="string">"aClick"</span>&gt;</span>百知教育<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h2 id="9-按键修饰符"><a href="#9-按键修饰符" class="headerlink" title="9. 按键修饰符"></a>9. 按键修饰符</h2><blockquote><p>作用: 用来与键盘中按键事件绑定在一起,用来修饰特定的按键事件的修饰符</p></blockquote><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 按键修饰符</span></span><br><span class="line"><span class="code">.enter</span></span><br><span class="line"><span class="code">.tab</span></span><br><span class="line"><span class="code">.delete (捕获“删除”和“退格”键)</span></span><br><span class="line"><span class="code">.esc</span></span><br><span class="line"><span class="code">.space</span></span><br><span class="line"><span class="code">.up</span></span><br><span class="line"><span class="code">.down</span></span><br><span class="line"><span class="code">.left</span></span><br><span class="line"><span class="code">.right</span></span><br></pre></td></tr></table></figure><h3 id="9-1-enter-回车键"><a href="#9-1-enter-回车键" class="headerlink" title="9.1 enter 回车键"></a>9.1 enter 回车键</h3><blockquote><p>用来在触发回车按键之后触发的事件</p></blockquote><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model</span>=<span class="string">"msg"</span> @<span class="attr">keyup.enter</span>=<span class="string">"keyups"</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="9-2-tab-键"><a href="#9-2-tab-键" class="headerlink" title="9.2 tab 键"></a>9.2 tab 键</h3><blockquote><p>用来捕获到tab键执行到当前标签是才会触发</p></blockquote><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> @<span class="attr">keyup.tab</span>=<span class="string">"keytabs"</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h2 id="10-Axios-基本使用"><a href="#10-Axios-基本使用" class="headerlink" title="10. Axios 基本使用"></a>10. Axios 基本使用</h2><h3 id="10-1-引言"><a href="#10-1-引言" class="headerlink" title="10.1 引言"></a>10.1 引言</h3><blockquote><p><code>Axios</code> 是一个异步请求技术,核心作用就是用来在页面中发送异步请求,并获取对应数据在页面中渲染       页面局部更新技术  Ajax</p></blockquote><h3 id="10-2-Axios-第一个程序"><a href="#10-2-Axios-第一个程序" class="headerlink" title="10.2 Axios 第一个程序"></a>10.2 Axios 第一个程序</h3><p>中文网站:<a href="https://www.kancloud.cn/yunye/axios/234845" target="_blank" rel="noopener">https://www.kancloud.cn/yunye/axios/234845</a></p><p>安装: <a href="https://unpkg.com/axios/dist/axios.min.js" target="_blank" rel="noopener">https://unpkg.com/axios/dist/axios.min.js</a></p><h4 id="10-2-1-GET方式的请求"><a href="#10-2-1-GET方式的请求" class="headerlink" title="10.2.1 GET方式的请求"></a>10.2.1 GET方式的请求</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//发送GET方式请求</span></span><br><span class="line"> axios.get(<span class="string">"http://localhost:8989/user/findAll?name=xiaochen"</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>)</span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(response.data);</span><br><span class="line"> &#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(err);</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure><h4 id="10-2-2-POST方式请求"><a href="#10-2-2-POST方式请求" class="headerlink" title="10.2.2 POST方式请求"></a>10.2.2 POST方式请求</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//发送POST方式请求</span></span><br><span class="line">  axios.post(<span class="string">"http://localhost:8989/user/save"</span>,&#123;</span><br><span class="line">      username:<span class="string">"xiaochen"</span>,</span><br><span class="line">      age:<span class="number">23</span>,</span><br><span class="line">      email:<span class="string">"xiaochen@zparkhr.com"</span>,</span><br><span class="line">      phone:<span class="number">13260426185</span></span><br><span class="line">  &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>)</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(response.data);</span><br><span class="line">  &#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><h4 id="10-2-3-axios并发请求"><a href="#10-2-3-axios并发请求" class="headerlink" title="10.2.3 axios并发请求"></a>10.2.3 axios并发请求</h4><blockquote><p><code>并发请求</code>:  将多个请求在同一时刻发送到后端服务接口,最后在集中处理每个请求的响应结果</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.创建一个查询所有请求</span></span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">findAll</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> axios.get(<span class="string">"http://localhost:8989/user/findAll?name=xiaochen"</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//2.创建一个保存的请求</span></span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">save</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> axios.post(<span class="string">"http://localhost:8989/user/save"</span>,&#123;</span><br><span class="line">           username:<span class="string">"xiaochen"</span>,</span><br><span class="line">           age:<span class="number">23</span>,</span><br><span class="line">           email:<span class="string">"xiaochen@zparkhr.com"</span>,</span><br><span class="line">           phone:<span class="number">13260426185</span></span><br><span class="line">       &#125;);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//3.并发执行</span></span><br><span class="line">   axios.all([findAll(),save()]).then(</span><br><span class="line">       axios.spread(<span class="function"><span class="keyword">function</span>(<span class="params">res1,res2</span>)</span>&#123;  <span class="comment">//用来将一组函数的响应结果汇总处理</span></span><br><span class="line">           <span class="built_in">console</span>.log(res1.data);</span><br><span class="line">           <span class="built_in">console</span>.log(res2.data);</span><br><span class="line">       &#125;)</span><br><span class="line">   );<span class="comment">//用来发送一组并发请求</span></span><br></pre></td></tr></table></figure><hr><h2 id="11-Vue-生命周期"><a href="#11-Vue-生命周期" class="headerlink" title="11. Vue 生命周期"></a>11. Vue 生命周期</h2><blockquote><p><code>生命周期钩子</code>   ====&gt;  <code>生命周期函数</code></p></blockquote><p>![img](C:/Users/ASUS/Desktop/ vue资料/Vue实战笔记完整版/Vue实战.assets/lifecycle.png)</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># Vue生命周期总结</span></span><br><span class="line"><span class="code">1.初始化阶段</span></span><br><span class="line"><span class="code">beforeCreate()&#123; //1.生命周期中第一个函数,该函数在执行时Vue实例仅仅完成了自身事件的绑定和生命周期函数的初始化工作,Vue实例中还没有 Data el methods相关属性</span></span><br><span class="line"><span class="code">            console.log("beforeCreate: "+this.msg);</span></span><br><span class="line"><span class="code">        &#125;,</span></span><br><span class="line"><span class="code">        created()&#123; //2.生命周期中第二个函数,该函数在执行时Vue实例已经初始化了data属性和methods中相关方法</span></span><br><span class="line"><span class="code">            console.log("created: "+this.msg);</span></span><br><span class="line"><span class="code">        &#125;,</span></span><br><span class="line"><span class="code">        beforeMount()&#123;//3.生命周期中第三个函数,该函数在执行时Vue将El中指定作用范围作为模板编译</span></span><br><span class="line"><span class="code">            console.log("beforeMount: "+document.getElementById("sp").innerText);</span></span><br><span class="line"><span class="code">        &#125;,</span></span><br><span class="line"><span class="code">        mounted()&#123;//4.生命周期中第四个函数,该函数在执行过程中,已经将数据渲染到界面中并且已经更新页面</span></span><br><span class="line"><span class="code">            console.log("Mounted: "+document.getElementById("sp").innerText);</span></span><br><span class="line"><span class="code">        &#125;</span></span><br><span class="line"><span class="code">        </span></span><br><span class="line"><span class="code">2.运行阶段</span></span><br><span class="line"><span class="code"> beforeUpdate()&#123;//5.生命周期中第五个函数,该函数是data中数据发生变化时执行 这个事件执行时仅仅是Vue实例中data数据变化页面显示的依然是原始数据</span></span><br><span class="line"><span class="code">            console.log("beforeUpdate:"+this.msg);</span></span><br><span class="line"><span class="code">            console.log("beforeUpdate:"+document.getElementById("sp").innerText);</span></span><br><span class="line"><span class="code">        &#125;,</span></span><br><span class="line"><span class="code">        updated()&#123;    //6.生命周期中第六个函数,该函数执行时data中数据发生变化,页面中数据也发生了变化  页面中数据已经和data中数据一致</span></span><br><span class="line"><span class="code">            console.log("updated:"+this.msg);</span></span><br><span class="line"><span class="code">            console.log("updated:"+document.getElementById("sp").innerText);</span></span><br><span class="line"><span class="code">        &#125;,</span></span><br><span class="line"><span class="code">        </span></span><br><span class="line"><span class="code">3.销毁阶段</span></span><br><span class="line"><span class="code"> beforeDestory()&#123;//7.生命周期第七个函数,该函数执行时,Vue中所有数据 methods componet 都没销毁</span></span><br><span class="line"></span><br><span class="line"><span class="code">        &#125;,</span></span><br><span class="line"><span class="code">        destoryed()&#123; //8.生命周期的第八个函数,该函数执行时,Vue实例彻底销毁</span></span><br><span class="line"></span><br><span class="line"><span class="code">        &#125;</span></span><br></pre></td></tr></table></figure><hr><h2 id="12-Vue中组件-Component"><a href="#12-Vue中组件-Component" class="headerlink" title="12. Vue中组件(Component)"></a>12. Vue中组件(Component)</h2><h3 id="12-1-组件作用"><a href="#12-1-组件作用" class="headerlink" title="12.1 组件作用"></a>12.1 组件作用</h3><p>组件作用: 用来减少Vue实例对象中代码量,日后在使用Vue开发过程中,可以根据 不能业务功能将页面中划分不同的多个组件,然后由多个组件去完成整个页面的布局,便于日后使用Vue进行开发时页面管理,方便开发人员维护。</p><h3 id="12-2-组件使用"><a href="#12-2-组件使用" class="headerlink" title="12.2 组件使用"></a>12.2 组件使用</h3><h4 id="12-2-1-全局组件注册"><a href="#12-2-1-全局组件注册" class="headerlink" title="12.2.1 全局组件注册"></a>12.2.1 全局组件注册</h4><p><code>说明:全局组件注册给Vue实例,日后可以在任意Vue实例的范围内使用该组件</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.开发全局组件</span></span><br><span class="line">Vue.component(<span class="string">'login'</span>,&#123;</span><br><span class="line">        template:<span class="string">'&lt;div&gt;&lt;h1&gt;用户登录&lt;/h1&gt;&lt;/div&gt;'</span></span><br><span class="line">    &#125;);</span><br><span class="line"><span class="comment">//2.使用全局组件  在Vue实例范围内</span></span><br><span class="line">&lt;login&gt;&lt;<span class="regexp">/login&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 注意:</span></span><br><span class="line"><span class="code">1.Vue.component用来开发全局组件 参数1: 组件的名称  参数2: 组件配置&#123;&#125;  template:''用来书写组件的html代码  template中必须有且只有一个root元素</span></span><br><span class="line"><span class="code">2.使用时需要在Vue的作用范围内根据组件名使用全局组件</span></span><br><span class="line"><span class="code">3.如果在注册组件过程中使用 驼峰命名组件的方式 在使用组件时 必须将驼峰的所有单词小写加入-线进行使用</span></span><br></pre></td></tr></table></figure><h4 id="12-2-2-局部组件注册"><a href="#12-2-2-局部组件注册" class="headerlink" title="12.2.2 局部组件注册"></a>12.2.2 局部组件注册</h4><p><code>说明:通过将组件注册给对应Vue实例中一个components属性来完成组件注册,这种方式不会对Vue实例造成累加</code></p><ul><li>第一种开发方式</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//局部组件登录模板声明</span></span><br><span class="line">  <span class="keyword">let</span> login =&#123;   <span class="comment">//具体局部组件名称</span></span><br><span class="line">      template:<span class="string">'&lt;div&gt;&lt;h2&gt;用户登录&lt;/h2&gt;&lt;/div&gt;'</span></span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">      el: <span class="string">"#app"</span>,</span><br><span class="line">      data: &#123;&#125;,</span><br><span class="line">      methods: &#123;&#125;,</span><br><span class="line">      components:&#123;  <span class="comment">//用来注册局部组件</span></span><br><span class="line">          login:login  <span class="comment">//注册局部组件</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//局部组件使用 在Vue实例范围内</span></span><br><span class="line">&lt;login&gt;&lt;<span class="regexp">/login&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>第二种开发方式</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.声明局部组件模板  template 标签 注意:在Vue实例作用范围外声明</span></span><br><span class="line">  &lt;template id=<span class="string">"loginTemplate"</span>&gt;</span><br><span class="line">      &lt;h1&gt;用户登录&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>template&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.定义变量用来保存模板配置对象</span></span><br><span class="line">    <span class="keyword">let</span> login =&#123;   <span class="comment">//具体局部组件名称</span></span><br><span class="line">        template:<span class="string">'#loginTemplate'</span>  <span class="comment">//使用自定义template标签选择器即可</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.注册组件</span></span><br><span class="line">    <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">        el: <span class="string">"#app"</span>,</span><br><span class="line">        data: &#123;&#125;,</span><br><span class="line">        methods: &#123;&#125;,</span><br><span class="line">        components:&#123;  <span class="comment">//用来注册局部组件</span></span><br><span class="line">            login:login  <span class="comment">//注册局部组件</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"> <span class="comment">//4.局部组件使用 在Vue实例范围内</span></span><br><span class="line"> &lt;login&gt;&lt;<span class="regexp">/login&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="12-3-Prop的使用"><a href="#12-3-Prop的使用" class="headerlink" title="12.3 Prop的使用"></a>12.3 Prop的使用</h3><p><code>作用:props用来给组件传递相应静态数据或者是动态数据的</code></p><h4 id="12-3-1-通过在组件上声明静态数据传递给组件内部"><a href="#12-3-1-通过在组件上声明静态数据传递给组件内部" class="headerlink" title="12.3.1 通过在组件上声明静态数据传递给组件内部"></a>12.3.1 通过在组件上声明静态数据传递给组件内部</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.声明组件模板配置对象</span></span><br><span class="line">    <span class="keyword">let</span> login = &#123;</span><br><span class="line">        template:<span class="string">"&lt;div&gt;&lt;h1&gt;欢迎:&#123;&#123; userName &#125;&#125; 年龄:&#123;&#123; age &#125;&#125;&lt;/h1&gt;&lt;/div&gt;"</span>,</span><br><span class="line">        props:[<span class="string">'userName'</span>,<span class="string">'age'</span>]  <span class="comment">//props作用 用来接收使用组件时通过组件标签传递的数据</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.注册组件</span></span><br><span class="line">    <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">        el: <span class="string">"#app"</span>,</span><br><span class="line">        data: &#123;&#125;,</span><br><span class="line">        methods: &#123;&#125;,</span><br><span class="line">        components:&#123;</span><br><span class="line">            login <span class="comment">//组件注册</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.通过组件完成数据传递</span></span><br><span class="line">&lt;login user-name=<span class="string">"小陈"</span> age=<span class="string">"23"</span>&gt;&lt;<span class="regexp">/login&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 总结:</span></span><br><span class="line"><span class="code">1.使用组件时可以在组件上定义多个属性以及对应数据</span></span><br><span class="line"><span class="code">2.在组件内部可以使用props数组生命多个定义在组件上的属性名 日后可以在组件中通过&#123;&#123; 属性名 &#125;&#125; 方式获取组件中属性值</span></span><br></pre></td></tr></table></figure><h4 id="12-3-2-通过在组件上声明动态数据传递给组件内部"><a href="#12-3-2-通过在组件上声明动态数据传递给组件内部" class="headerlink" title="12.3.2 通过在组件上声明动态数据传递给组件内部"></a>12.3.2 通过在组件上声明动态数据传递给组件内部</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.声明组件模板对象</span></span><br><span class="line">    <span class="keyword">const</span> login = &#123;</span><br><span class="line">        template:<span class="string">'&lt;div&gt;&lt;h2&gt;欢迎: &#123;&#123; name &#125;&#125; 年龄:&#123;&#123; age &#125;&#125;&lt;/h2&gt;&lt;/div&gt;'</span>,</span><br><span class="line">        props:[<span class="string">'name'</span>,<span class="string">'age'</span>]</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//2.注册局部组件</span></span><br><span class="line">    <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">        el: <span class="string">"#app"</span>,</span><br><span class="line">        data: &#123;</span><br><span class="line">            username:<span class="string">"小陈陈"</span>,</span><br><span class="line">            age:<span class="number">23</span></span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;&#125;,</span><br><span class="line">        components:&#123;</span><br><span class="line">            login <span class="comment">//注册组件</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.使用组件</span></span><br><span class="line"> &lt;login :name=<span class="string">"username"</span> :age=<span class="string">"age"</span>&gt;&lt;<span class="regexp">/login&gt;  /</span><span class="regexp">/使用v-bind形式将数据绑定Vue实例中data属性,日后data属性发生变化,组件内部数据跟着变化</span></span><br></pre></td></tr></table></figure><h4 id="12-3-3-prop的单向数据流"><a href="#12-3-3-prop的单向数据流" class="headerlink" title="12.3.3 prop的单向数据流"></a>12.3.3 prop的单向数据流</h4><p><code>单向数据流:所有的 prop 都使得其父子 prop 之间形成了一个**单向下行绑定**：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。</code></p><blockquote><p>所有的 prop 都使得其父子 prop 之间形成了一个<strong>单向下行绑定</strong>：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流向难以理解。</p><p>额外的，每次父级组件发生更新时，子组件中所有的 prop 都将会刷新为最新的值。这意味着你<strong>不</strong>应该在一个子组件内部改变 prop。如果你这样做了，Vue 会在浏览器的控制台中发出警告。—摘自官网</p></blockquote><h3 id="12-4-组件中定义数据和事件使用"><a href="#12-4-组件中定义数据和事件使用" class="headerlink" title="12.4 组件中定义数据和事件使用"></a>12.4 组件中定义数据和事件使用</h3><h5 id="1-组件中定义属于组件的数据"><a href="#1-组件中定义属于组件的数据" class="headerlink" title="1. 组件中定义属于组件的数据"></a>1. 组件中定义属于组件的数据</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//组件声明的配置对象</span></span><br><span class="line">    <span class="keyword">const</span> login = &#123;</span><br><span class="line">        template:<span class="string">'&lt;div&gt;&lt;h1&gt;&#123;&#123; msg &#125;&#125; 百知教育&lt;/h1&gt;&lt;ul&gt;&lt;li v-for="item,index in lists"&gt;&#123;&#123; index &#125;&#125;&#123;&#123; item &#125;&#125;&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;'</span>,</span><br><span class="line">        data()&#123;   <span class="comment">//使用data函数方式定义组件的数据   在templatehtml代码中通过插值表达式直接获取</span></span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                msg:<span class="string">"hello"</span>,</span><br><span class="line">                lists:[<span class="string">'java'</span>,<span class="string">'spring'</span>,<span class="string">'springboot'</span>]</span><br><span class="line">            &#125;<span class="comment">//组件自己内部数据</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="2-组件中事件定义"><a href="#2-组件中事件定义" class="headerlink" title="2.组件中事件定义"></a>2.组件中事件定义</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> login=&#123;</span><br><span class="line">       template:<span class="string">'&lt;div&gt;&lt;input type="button" value="点我触发组件中事件" @click="change"&gt;&lt;/div&gt;'</span>,</span><br><span class="line">       data()&#123;</span><br><span class="line">           <span class="keyword">return</span> &#123;</span><br><span class="line">               name:<span class="string">'小陈'</span></span><br><span class="line">           &#125;;</span><br><span class="line">       &#125;,</span><br><span class="line">       methods:&#123;</span><br><span class="line">           change()&#123;</span><br><span class="line">               alert(<span class="keyword">this</span>.name)</span><br><span class="line">               alert(<span class="string">'触发事件'</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 总结</span></span><br><span class="line"><span class="code">1.组件中定义事件和直接在Vue中定义事件基本一致 直接在组件内部对应的html代码上加入@事件名=函数名方式即可</span></span><br><span class="line"><span class="code">2.在组件内部使用methods属性用来定义对应的事件函数即可,事件函数中this 指向的是当前组件的实例</span></span><br></pre></td></tr></table></figure><h3 id="12-5-向子组件中传递事件并在子组件中调用改事件"><a href="#12-5-向子组件中传递事件并在子组件中调用改事件" class="headerlink" title="12.5 向子组件中传递事件并在子组件中调用改事件"></a>12.5 向子组件中传递事件并在子组件中调用改事件</h3><p><code>在子组件中调用传递过来的相关事件必须使用 this.$emit(&#39;函数名&#39;) 方式调用</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.声明组件</span></span><br><span class="line">    <span class="keyword">const</span> login = &#123;</span><br><span class="line">        template:<span class="string">"&lt;div&gt;&lt;h1&gt;百知教育 &#123;&#123; uname &#125;&#125;&lt;/h1&gt; &lt;input type='button' value='点我' @click='change'&gt;&lt;/div&gt;"</span>,</span><br><span class="line">        data()&#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                uname:<span class="keyword">this</span>.name</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        props:[<span class="string">'name'</span>],</span><br><span class="line">        methods:&#123;</span><br><span class="line">            change()&#123;</span><br><span class="line">                <span class="comment">//调用vue实例中函数</span></span><br><span class="line">                <span class="keyword">this</span>.$emit(<span class="string">'aaa'</span>);  <span class="comment">//调用组件传递过来的其他函数时需要使用 this.$emit('函数名调用')</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"> <span class="comment">//2.注册组件</span></span><br><span class="line">    <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">        el: <span class="string">"#app"</span>,</span><br><span class="line">        data: &#123;</span><br><span class="line">            username:<span class="string">"小陈"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line">            findAll()&#123;  <span class="comment">//一个事件函数  将这个函数传递给子组件</span></span><br><span class="line">                alert(<span class="string">'Vue 实例中定义函数'</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        components:&#123;</span><br><span class="line">            login,<span class="comment">//组件的注册</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.使用组件</span></span><br><span class="line">&lt;login  @find=<span class="string">"findAll"</span>&gt;&lt;<span class="regexp">/login&gt;    /</span><span class="regexp">/=====&gt; 在组件内部使用  this.$emit('find')</span></span><br></pre></td></tr></table></figure><hr><h2 id="13-Vue中路由-VueRouter"><a href="#13-Vue中路由-VueRouter" class="headerlink" title="13.Vue中路由(VueRouter)"></a>13.Vue中路由(VueRouter)</h2><h4 id="13-1-路由"><a href="#13-1-路由" class="headerlink" title="13.1 路由"></a>13.1 路由</h4><p><code>路由:根据请求的路径按照一定的路由规则进行请求的转发从而帮助我们实现统一请求的管理</code></p><h4 id="13-2-作用"><a href="#13-2-作用" class="headerlink" title="13.2 作用"></a>13.2 作用</h4><p><code>用来在vue中实现组件之间的动态切换</code></p><h4 id="13-3-使用路由"><a href="#13-3-使用路由" class="headerlink" title="13.3 使用路由"></a>13.3 使用路由</h4><ol><li><h5 id="引入路由"><a href="#引入路由" class="headerlink" title="引入路由"></a>引入路由</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script src=<span class="string">"https://cdn.jsdelivr.net/npm/vue/dist/vue.js"</span>&gt;&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;script src="https:/</span><span class="regexp">/unpkg.com/</span>vue-router/dist/vue-router.js<span class="string">"&gt;&lt;/script&gt;  //vue 路由js</span></span><br></pre></td></tr></table></figure></li><li><h5 id="创建组件对象"><a href="#创建组件对象" class="headerlink" title="创建组件对象"></a>创建组件对象</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//声明组件模板</span></span><br><span class="line"><span class="keyword">const</span> login = &#123;</span><br><span class="line">  template:<span class="string">'&lt;h1&gt;登录&lt;/h1&gt;'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> register = &#123;</span><br><span class="line">  template:<span class="string">'&lt;h1&gt;注册&lt;/h1&gt;'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><h5 id="定义路由对象的规则"><a href="#定义路由对象的规则" class="headerlink" title="定义路由对象的规则"></a>定义路由对象的规则</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> <span class="comment">//创建路由对象</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes:[</span><br><span class="line">    &#123;<span class="attr">path</span>:<span class="string">'/login'</span>,<span class="attr">component</span>:login&#125;,   <span class="comment">//path: 路由的路径  component:路径对应的组件</span></span><br><span class="line">    &#123;<span class="attr">path</span>:<span class="string">'/register'</span>,<span class="attr">component</span>:register&#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ol><ol start="4"><li><h5 id="将路由对象注册到vue实例"><a href="#将路由对象注册到vue实例" class="headerlink" title="将路由对象注册到vue实例"></a>将路由对象注册到vue实例</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">"#app"</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    username:<span class="string">"小陈"</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;&#125;,</span><br><span class="line">  router:router   <span class="comment">//设置路由对象</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ol><ol start="5"><li><h5 id="在页面中显示路由的组件"><a href="#在页面中显示路由的组件" class="headerlink" title="在页面中显示路由的组件"></a>在页面中显示路由的组件</h5><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--显示路由的组件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><h5 id="根据连接切换路由"><a href="#根据连接切换路由" class="headerlink" title="根据连接切换路由"></a>根据连接切换路由</h5><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#/login"</span>&gt;</span>点我登录<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#/register"</span>&gt;</span>点我注册<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="13-4-router-link使用"><a href="#13-4-router-link使用" class="headerlink" title="13.4 router-link使用"></a>13.4 router-link使用</h3><p><code>作用:用来替换我们在切换路由时使用a标签切换路由</code></p><p><code>好处:就是可以自动给路由路径加入#不需要手动加入</code></p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/login"</span> <span class="attr">tag</span>=<span class="string">"button"</span>&gt;</span>我要登录<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/register"</span> <span class="attr">tag</span>=<span class="string">"button"</span>&gt;</span>点我注册<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 总结:</span></span><br><span class="line"><span class="code">1.router-link 用来替换使用a标签实现路由切换 好处是不需要书写#号直接书写路由路径</span></span><br><span class="line"><span class="code">2.router-link to属性用来书写路由路径   tag属性:用来将router-link渲染成指定的标签</span></span><br></pre></td></tr></table></figure><h3 id="13-5-默认路由"><a href="#13-5-默认路由" class="headerlink" title="13.5 默认路由"></a>13.5 默认路由</h3><p><code>作用:用来在第一次进入界面是显示一个默认的组件</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes:[</span><br><span class="line">    <span class="comment">//&#123; path:'/',component:login&#125;,</span></span><br><span class="line">    &#123; <span class="attr">path</span>:<span class="string">'/'</span>,<span class="attr">redirect</span>:<span class="string">'/login'</span>&#125;,  <span class="comment">//redirect: 用来当访问的是默认路由 "/" 时 跳转到指定的路由展示  推荐使用</span></span><br><span class="line">    &#123; <span class="attr">path</span>:<span class="string">'/login'</span>, <span class="attr">component</span>:login&#125;,</span><br><span class="line">    &#123; <span class="attr">path</span>:<span class="string">'/register'</span>, <span class="attr">component</span>:register&#125;,</span><br><span class="line">  ]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="13-6-路由中参数传递"><a href="#13-6-路由中参数传递" class="headerlink" title="13.6 路由中参数传递"></a>13.6 路由中参数传递</h3><ul><li>第一种方式传递参数 传统方式</li></ul><ol><li><p>通过?号形式拼接参数</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/login?id=21&amp;name=zhangsan"</span>&gt;</span>我要登录<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>组件中获取参数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> login = &#123;</span><br><span class="line">  template:<span class="string">'&lt;h1&gt;用户登录&lt;/h1&gt;'</span>,</span><br><span class="line">  data()&#123;<span class="keyword">return</span> &#123;&#125;&#125;,</span><br><span class="line">  methods:&#123;&#125;,</span><br><span class="line">  created()&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"=============&gt;"</span>+<span class="keyword">this</span>.$route.query.id+<span class="string">"======&gt;"</span>+<span class="keyword">this</span>.$route.query.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><ul><li>第二种方式传递参数 restful</li></ul><ol><li><p>通过使用路径方式传递参数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;router-link to=<span class="string">"/register/24/张三"</span>&gt;我要注册&lt;<span class="regexp">/router-link&gt;</span></span><br><span class="line"><span class="regexp">var router = new VueRouter(&#123;</span></span><br><span class="line"><span class="regexp">  routes:[</span></span><br><span class="line"><span class="regexp">    &#123;path:'/register/:id/:name',component:register&#125;   //定义路径中获取对应参数</span></span><br><span class="line"><span class="regexp">  ]</span></span><br><span class="line"><span class="regexp">&#125;);</span></span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><p>组件中获取参数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> register = &#123;</span><br><span class="line">  template:<span class="string">'&lt;h1&gt;用户注册&#123;&#123; $route.params.name &#125;&#125;&lt;/h1&gt;'</span>,</span><br><span class="line">  created()&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"注册组件中id:   "</span>+<span class="keyword">this</span>.$route.params.id+<span class="keyword">this</span>.$route.params.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><h3 id="13-7-嵌套路由"><a href="#13-7-嵌套路由" class="headerlink" title="13.7 嵌套路由"></a>13.7 嵌套路由</h3><ol><li><h5 id="声明最外层和内层路由"><a href="#声明最外层和内层路由" class="headerlink" title="声明最外层和内层路由"></a>声明最外层和内层路由</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template id=<span class="string">"product"</span>&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line"></span><br><span class="line">        &lt;h1&gt;商品管理&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">        &lt;router-link to="/</span>product/add<span class="string">"&gt;商品添加&lt;/router-link&gt;</span></span><br><span class="line"><span class="string">        &lt;router-link to="</span>/product/edit<span class="string">"&gt;商品编辑&lt;/router-link&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        &lt;router-view&gt;&lt;/router-view&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">&lt;/template&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">//声明组件模板</span></span><br><span class="line"><span class="string">const product=&#123;</span></span><br><span class="line"><span class="string">  template:'#product'</span></span><br><span class="line"><span class="string">&#125;;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">const add = &#123;</span></span><br><span class="line"><span class="string">  template:'&lt;h4&gt;商品添加&lt;/h4&gt;'</span></span><br><span class="line"><span class="string">&#125;;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">const edit = &#123;</span></span><br><span class="line"><span class="string">  template:'&lt;h4&gt;商品编辑&lt;/h4&gt;'</span></span><br><span class="line"><span class="string">&#125;;</span></span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><h5 id="创建路由对象含有嵌套路由"><a href="#创建路由对象含有嵌套路由" class="headerlink" title="创建路由对象含有嵌套路由"></a>创建路由对象含有嵌套路由</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">        routes:[</span><br><span class="line">            &#123;</span><br><span class="line">                path:<span class="string">'/product'</span>,</span><br><span class="line">                component:product,</span><br><span class="line">                children:[</span><br><span class="line">                    &#123;<span class="attr">path</span>:<span class="string">'add'</span>,<span class="attr">component</span>: add&#125;,</span><br><span class="line">                    &#123;<span class="attr">path</span>:<span class="string">'edit'</span>,<span class="attr">component</span>: edit&#125;,</span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">        ]</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure></li></ol><ol start="3"><li><h5 id="注册路由对象"><a href="#注册路由对象" class="headerlink" title="注册路由对象"></a>注册路由对象</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">"#app"</span>,</span><br><span class="line">    data: &#123;&#125;,</span><br><span class="line">    methods: &#123;&#125;,</span><br><span class="line">    router,<span class="comment">//定义路由对象</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>测试路由</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/product"</span>&gt;</span>商品管理<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br></pre></td></tr></table></figure><hr></li></ol><h2 id="14-Vue-CLI-脚手架"><a href="#14-Vue-CLI-脚手架" class="headerlink" title="14. Vue CLI 脚手架"></a>14. Vue CLI 脚手架</h2><h3 id="14-1-什么是CLI"><a href="#14-1-什么是CLI" class="headerlink" title="14.1 什么是CLI"></a>14.1 什么是CLI</h3><p>命令行界面（英语：command-line interface，缩写：<em>CLI</em>）是在图形用户界面得到普及之前使用最为广泛的用户界面，它通常不支持鼠标，用户通过键盘输入指令，计算机接收到指令后，予以执行。也有人称之为字符用户界面（CUI）</p><h3 id="14-2-什么是Vue-CLI"><a href="#14-2-什么是Vue-CLI" class="headerlink" title="14.2 什么是Vue CLI"></a>14.2 什么是Vue CLI</h3><p>Vue CLI 是一个基于 Vue.js 进行快速开发的完整系统。使用Vue 脚手架之后我们开发的页面将是一个完整系统(项目)。</p><h3 id="14-3-Vue-CLI优势"><a href="#14-3-Vue-CLI优势" class="headerlink" title="14.3 Vue CLI优势"></a>14.3 Vue CLI优势</h3><ul><li>通过 <code>vue-cli</code> 搭建交互式的项目脚手架。bootstrap css js jquery js     通过执行命令方式下载相关依赖</li><li>通过 <code>@vue/cli</code> + <code>@vue/cli-service-global</code> 快速开始零配置原型开发    vue页面 vuejs  vuerouter        axios(一条命令)</li><li>一个运行时依赖 (<code>@vue/cli-service</code>)，该依赖：<ul><li>可升级；  一条命令</li><li>基于 webpack 构建，并带有合理的默认配置；  webpack  项目打包方式     编译好的项目源码===&gt;部署到服务器上直接使用</li><li>可以通过项目内的配置文件进行配置；               默认配置文件,通过修改默认配置文件达到自己想要的项目环境            </li><li>可以通过插件进行扩展。                                       vue v-charts  elementui </li></ul></li><li>一个丰富的官方插件集合，集成了前端生态中最好的工具。Nodejs(tomcat)  Vue VueRouter webpack yarn</li><li>一套完全图形化的创建和管理 Vue.js 项目的用户界面</li></ul><h3 id="14-4-Vue-CLI安装"><a href="#14-4-Vue-CLI安装" class="headerlink" title="14.4 Vue CLI安装"></a>14.4 Vue CLI安装</h3><h5 id="1-环境准备"><a href="#1-环境准备" class="headerlink" title="1. 环境准备"></a>1. 环境准备</h5><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section">#1.下载nodejs</span></span><br><span class="line"><span class="code">http://nodejs.cn/download/</span></span><br><span class="line"><span class="code">windows系统:   .msi  安装包(exe)指定安装位置   .zip(压缩包)直接解压缩指定目录</span></span><br><span class="line"><span class="code">  mac os 系统:   .pkg  安装包格式自动配置环境变量  .tar.gz(压缩包)解压缩安装到指定名</span></span><br><span class="line"></span><br><span class="line"><span class="section">#2.配置nodejs环境变量</span></span><br><span class="line"><span class="code">windows系统:</span></span><br><span class="line"><span class="code">1.计算上右键属性----&gt;  高级属性 ----&gt;环境变量 添加如下配置:</span></span><br><span class="line"><span class="code">NODE_HOME=  nodejs安装目录</span></span><br><span class="line"><span class="code">        PATH    = xxxx;%NODE_HOME%</span></span><br><span class="line"><span class="code">    2.macos 系统</span></span><br><span class="line"><span class="code">    推荐使用.pkg安装直接配置node环境</span></span><br><span class="line"> </span><br><span class="line"><span class="section">#3.验证nodejs环境是否成功</span></span><br><span class="line"><span class="code">node -v </span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section">#4.npm介绍</span></span><br><span class="line"><span class="code">node package mangager    nodejs包管理工具       前端主流技术  npm 进行统一管理</span></span><br><span class="line"><span class="code">maven 管理java后端依赖   远程仓库(中心仓库)      阿里云镜像</span></span><br><span class="line"><span class="code">npm   管理前端系统依赖    远程仓库(中心仓库)      配置淘宝镜像</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section">#5.配置淘宝镜像</span></span><br><span class="line"><span class="code">  npm config set registry https://registry.npm.taobao.org</span></span><br><span class="line"><span class="code">  npm config get registry</span></span><br><span class="line"></span><br><span class="line"><span class="section">#6.配置npm下载依赖位置</span></span><br><span class="line"><span class="code"> windows:</span></span><br><span class="line"><span class="code">npm config set cache "D:\nodereps\npm-cache"</span></span><br><span class="line"><span class="code">npm config set prefix "D:\nodereps\npm_global"</span></span><br><span class="line"><span class="code"> mac os:</span></span><br><span class="line"><span class="code"> npm config set cache "/Users/chenyannan/dev/nodereps"</span></span><br><span class="line"><span class="code">npm config set prefix "/Users/chenyannan/dev/nodereps"</span></span><br><span class="line"></span><br><span class="line"><span class="section">#7.验证nodejs环境配置</span></span><br><span class="line"><span class="code">npm config ls</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">    ; userconfig /Users/chenyannan/.npmrc</span></span><br><span class="line"><span class="code">    cache = "/Users/chenyannan/dev/nodereps"</span></span><br><span class="line"><span class="code">    prefix = "/Users/chenyannan/dev/nodereps"</span></span><br><span class="line"><span class="code">    registry = "https://registry.npm.taobao.org/"</span></span><br></pre></td></tr></table></figure><h5 id="2-安装脚手架"><a href="#2-安装脚手架" class="headerlink" title="2.安装脚手架"></a>2.安装脚手架</h5><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section">#0.卸载脚手架</span></span><br><span class="line"><span class="code">npm uninstall -g @vue/cli  //卸载3.x版本脚手架</span></span><br><span class="line"><span class="code">npm uninstall -g vue-cli  //卸载2.x版本脚手架</span></span><br><span class="line"></span><br><span class="line"><span class="section">#1.Vue Cli官方网站</span></span><br><span class="line"><span class="code">https://cli.vuejs.org/zh/guide/</span></span><br><span class="line"></span><br><span class="line"><span class="section">#2.安装vue Cli</span></span><br><span class="line"><span class="code">npm install -g vue-cli</span></span><br></pre></td></tr></table></figure><h5 id="3-第一个vue脚手架项目"><a href="#3-第一个vue脚手架项目" class="headerlink" title="3.第一个vue脚手架项目"></a>3.第一个vue脚手架项目</h5><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.创建vue脚手架第一个项目</span></span><br><span class="line"><span class="code">vue init webpack 项目名</span></span><br><span class="line"><span class="section"># 2.创建第一个项目</span></span><br><span class="line"><span class="code">hello     -------------&gt;项目名</span></span><br><span class="line"><span class="code">    -build  -------------&gt;用来使用webpack打包使用build依赖</span></span><br><span class="line"><span class="code">    -config -------------&gt;用来做整个项目配置目录</span></span><br><span class="line"><span class="code">    -node_modules  ------&gt;用来管理项目中使用依赖</span></span><br><span class="line"><span class="code">    -src ------&gt;用来书写vue的源代码[重点]</span></span><br><span class="line"><span class="code">    +assets      ------&gt;用来存放静态资源 [重点]</span></span><br><span class="line"><span class="code">      components   ------&gt;用来书写Vue组件 [重点]</span></span><br><span class="line"><span class="code">      router ------&gt;用来配置项目中路由[重点]</span></span><br><span class="line"><span class="code">      App.vue      ------&gt;项目中根组件[重点]</span></span><br><span class="line"><span class="code">      main.js      ------&gt;项目中主入口[重点]</span></span><br><span class="line"><span class="code">    -static        ------&gt;其它静态</span></span><br><span class="line"><span class="code">    -.babelrc      ------&gt; 将es6语法转为es5运行</span></span><br><span class="line"><span class="code">    -.editorconfig ------&gt; 项目编辑配置</span></span><br><span class="line"><span class="code">    -.gitignore    ------&gt; git版本控制忽略文件</span></span><br><span class="line"><span class="code">    -.postcssrc.js ------&gt; 源码相关js</span></span><br><span class="line"><span class="code">    -index.html    ------&gt; 项目主页</span></span><br><span class="line"><span class="code">    -package.json  ------&gt; 类似与pom.xml 依赖管理  jquery 不建议手动修改</span></span><br><span class="line"><span class="code">    -package-lock.json ----&gt; 对package.json加锁</span></span><br><span class="line"><span class="code">    -README.md         ----&gt; 项目说明文件</span></span><br><span class="line"></span><br><span class="line"><span class="section"># 3.如何运行在项目的根目录中执行</span></span><br><span class="line"><span class="code">npm start 运行前端系统</span></span><br><span class="line"></span><br><span class="line"><span class="section"># 4.如何访问项目</span></span><br><span class="line"><span class="code">http://localhost:8081    </span></span><br><span class="line"></span><br><span class="line"><span class="section"># 5.Vue Cli中项目开发方式</span></span><br><span class="line"><span class="code"> 注意: 一切皆组件   一个组件中   js代码  html代码  css样式</span></span><br><span class="line"><span class="code"> </span></span><br><span class="line"><span class="bullet"> 1. </span>VueCli开发方式是在项目中开发一个一个组件对应一个业务功能模块,日后可以将多个组件组合到一起形成一个前端系统</span><br><span class="line"><span class="bullet"> 2. </span>日后在使用vue Cli进行开发时不再书写html,编写的是一个个组件(组件后缀.vue结尾的文件),日后打包时vue cli会将组件编译成运行的html文件</span><br></pre></td></tr></table></figure><h5 id="4-如何开发Vue脚手架"><a href="#4-如何开发Vue脚手架" class="headerlink" title="4.如何开发Vue脚手架"></a>4.如何开发Vue脚手架</h5><p><code>注意:在Vue cli 中一切皆组件</code></p><hr><h2 id="15-在脚手架中使用axios"><a href="#15-在脚手架中使用axios" class="headerlink" title="15.在脚手架中使用axios"></a>15.在脚手架中使用axios</h2><h3 id="15-1-安装axios"><a href="#15-1-安装axios" class="headerlink" title="15.1 安装axios"></a>15.1 安装axios</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.安装axios</span></span><br><span class="line"><span class="code">npm install axios --save-dev</span></span><br><span class="line"></span><br><span class="line"><span class="section"># 2.配置main.js中引入axios</span></span><br><span class="line"><span class="code">import axios from 'axios';</span></span><br><span class="line"></span><br><span class="line"><span class="code">Vue.prototype.$http=axios;</span></span><br><span class="line"></span><br><span class="line"><span class="section"># 3.使用axios</span></span><br><span class="line"><span class="code">在需要发送异步请求的位置:this.$http.get("url").then((res)=&gt;&#123;&#125;) this.$http.post("url").then((res)=&gt;&#123;&#125;)</span></span><br></pre></td></tr></table></figure><hr><h2 id="16-Vue-Cli脚手架项目打包和部署"><a href="#16-Vue-Cli脚手架项目打包和部署" class="headerlink" title="16.Vue Cli脚手架项目打包和部署"></a>16.Vue Cli脚手架项目打包和部署</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.在项目根目录中执行如下命令:</span></span><br><span class="line"><span class="code">  vue run build</span></span><br><span class="line"></span><br><span class="line"><span class="code">注意:vue脚手架打包的项目必须在服务器上运行不能直接双击运行</span></span><br><span class="line"></span><br><span class="line"><span class="section"># 2.打包之后当前项目中变化</span></span><br><span class="line"><span class="code"> 在打包之后项目中出现dist目录,dist目录就是vue脚手架项目生产目录或者说是直接部署目录</span></span><br><span class="line"></span><br><span class="line"><span class="section"># 3.</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      前端体系、前后端分离
    
    </summary>
    
    
      <category term="Vue" scheme="https://SomunsTao.github.io/categories/Vue/"/>
    
    
      <category term="Vue" scheme="https://SomunsTao.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue 12： 知识总结</title>
    <link href="https://somunstao.github.io/2020/04/22/Vue%2012%EF%BC%9A%E6%80%BB%E7%BB%93/"/>
    <id>https://somunstao.github.io/2020/04/22/Vue%2012%EF%BC%9A%E6%80%BB%E7%BB%93/</id>
    <published>2020-04-21T16:00:00.000Z</published>
    <updated>2020-08-01T15:19:42.152Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Vue-知识总结"><a href="#Vue-知识总结" class="headerlink" title="Vue 知识总结"></a>Vue 知识总结</h1><h5 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h5><blockquote><p>基于vue 2+ 写一份知识总结，可以说是学习笔记</p></blockquote><h5 id="目录："><a href="#目录：" class="headerlink" title="目录："></a>目录：</h5><blockquote><p>一、vue实例的基本结构<br>二、vue事件处理、绑定属性<br>三、vue指令、自定义指令<br>四、vue过滤器<br>五、vue数据监听<br>六、vue组件<br>七、vue-router<br>八、axios</p></blockquote><h5 id="一、Vue-实例的基本结构"><a href="#一、Vue-实例的基本结构" class="headerlink" title="一、Vue 实例的基本结构"></a>一、Vue 实例的基本结构</h5><p><a href="https://cn.vuejs.org/v2/api/" target="_blank" rel="noopener">Vue官网API</a></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">  &lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;p&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Welcome</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var vm &#x3D; new Vue(&#123;</span><br><span class="line">  el: &#39;#app&#39;, &#x2F;&#x2F;等价于后面的 .$mount(&#39;#app&#39;) 用其中之一就可以了</span><br><span class="line">  render: h &#x3D;&gt; h(App), &#x2F;&#x2F;理解不够深入，参考（https:&#x2F;&#x2F;cn.vuejs.org&#x2F;v2&#x2F;api&#x2F;?#render）</span><br><span class="line">  data: &#123; </span><br><span class="line">    &#x2F;&#x2F;页面响应的数据都放在这里如上（组件只接受 function 且必须返回一个对象），zhicvm.$data 访问这里面的data</span><br><span class="line">    msg: &#39;Welcome&#39;,</span><br><span class="line">  &#125;,</span><br><span class="line">  props:&#123;</span><br><span class="line">    &#x2F;&#x2F;props 可以是数组或对象，接收任何值</span><br><span class="line">  &#125;,</span><br><span class="line">  methods:  &#123;</span><br><span class="line">    &#x2F;&#x2F;页面或组件定义的方法的集合，可通过 vm.reset() 直接调用</span><br><span class="line">    reset: function()&#123;</span><br><span class="line">      this.msg &#x3D; &#39;这是重新设置之后的数据&#39;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    &#x2F;&#x2F;计算属性(computed)与方法(methods) 类似，如果计算数据量比较大，建议放到这里</span><br><span class="line">    &#x2F;&#x2F;计算属性的结果会被缓存，除非依赖的响应式属性变化才会重新计算。</span><br><span class="line">    &#x2F;&#x2F;参考（https:&#x2F;&#x2F;cn.vuejs.org&#x2F;v2&#x2F;api&#x2F;?#computed）</span><br><span class="line">  &#125;,</span><br><span class="line">  components：&#123;</span><br><span class="line">    &#x2F;&#x2F; 局部组件注册的地方</span><br><span class="line">    &#39;component-a&#39;: ComponentA,</span><br><span class="line">    &#39;component-b&#39;: ComponentB</span><br><span class="line">  &#125;,</span><br><span class="line">  directives: &#123;</span><br><span class="line">    &#x2F;&#x2F; 局部指令注册的地方</span><br><span class="line">    focus: &#123;</span><br><span class="line">      &#x2F;&#x2F; 指令的定义</span><br><span class="line">      inserted: function (el,binding) &#123;</span><br><span class="line">        el.focus(); </span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  filters:&#123;</span><br><span class="line">    &#x2F;&#x2F; 局部过滤器注册的地方</span><br><span class="line">  &#125;,</span><br><span class="line">  &#x2F;&#x2F;生命周期钩子</span><br><span class="line">  beforeCreate: function ()&#123;&#125;, &#x2F;&#x2F;在实例初始化之后，数据观测 (data observer) 和 event&#x2F;watcher 事件配置之前被调用。</span><br><span class="line">  created: function ()&#123;&#125;,&#x2F;&#x2F;在实例创建完成后被立即调用。</span><br><span class="line">  beforeMount: function ()&#123;&#125;,&#x2F;&#x2F;在挂载开始之前被调用：相关的 render 函数首次被调用。</span><br><span class="line">  mounted: function ()&#123;&#125;,&#x2F;&#x2F;el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子。</span><br><span class="line">  beforeUpdate: function ()&#123;&#125;,&#x2F;&#x2F;数据更新时调用，发生在虚拟 DOM 打补丁之前。</span><br><span class="line">  updated: function ()&#123;&#125;,&#x2F;&#x2F;由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。</span><br><span class="line">  beforeDestroy: function ()&#123;&#125;,&#x2F;&#x2F;实例销毁之前调用。在这一步，实例仍然完全可用。</span><br><span class="line">  destroyed: function ()&#123;</span><br><span class="line">    &#x2F;&#x2F;Vue 实例销毁后调用。</span><br><span class="line">    &#x2F;&#x2F;调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;).$mount(&#39;#app&#39;)</span><br></pre></td></tr></table></figure><h5 id="二、Vue-事件处理、绑定属性"><a href="#二、Vue-事件处理、绑定属性" class="headerlink" title="二、Vue 事件处理、绑定属性"></a>二、Vue 事件处理、绑定属性</h5><p><a href="https://cn.vuejs.org/v2/api/?#v-on" target="_blank" rel="noopener">v-on：</a></p><blockquote><p>1、绑定事件监听器。用在普通元素上时，只能监听<a href="https://developer.mozilla.org/zh-CN/docs/Web/Events" target="_blank" rel="noopener"><strong>原生 DOM 事件</strong></a>（如：click、keyup/down、mouseenter/over/move/down/out 等）。也可以监听自定义事件即 methods 里面的事件。<br>2、在监听原生 DOM 事件时，方法以事件为唯一的参数。如果使用内联语句，语句可以访问一个 $event 属性：v-on:click=”handle(‘ok’, $event)”。</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">修饰符：</span><br><span class="line">.stop - 调用 event.stopPropagation()。阻止冒泡</span><br><span class="line">.prevent - 调用 event.preventDefault()。阻止默认事件</span><br><span class="line">.capture - 添加事件侦听器时使用 capture 模式。</span><br><span class="line">.self - 只当事件是从侦听器绑定的元素本身触发时才触发回调。</span><br><span class="line">.&#123;keyCode | keyAlias&#125; - 只当事件是从特定键触发时才触发回调。</span><br><span class="line">.native - 监听组件根元素的原生事件。</span><br><span class="line">.once - 只触发一次回调。</span><br><span class="line">.left - (2.2.0) 只当点击鼠标左键时触发。</span><br><span class="line">.right - (2.2.0) 只当点击鼠标右键时触发。</span><br><span class="line">.middle - (2.2.0) 只当点击鼠标中键时触发。</span><br><span class="line">.passive - (2.3.0) 以 &#123; passive: true &#125; 模式添加侦听器</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">用法：</span><br><span class="line">&lt;!-- 内联语句 --&gt;</span><br><span class="line">&lt;button v-on:click&#x3D;&quot;doThat(&#39;hello&#39;, $event)&quot;&gt;&lt;&#x2F;button&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 缩写 --&gt;</span><br><span class="line">&lt;button @click&#x3D;&quot;doThis&quot;&gt;&lt;&#x2F;button&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 停止冒泡 --&gt;</span><br><span class="line">&lt;button @click.stop&#x3D;&quot;doThis&quot;&gt;&lt;&#x2F;button&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 对象语法 (2.4.0+) --&gt;</span><br><span class="line">&lt;button v-on&#x3D;&quot;&#123; mousedown: doThis, mouseup: doThat &#125;&quot;&gt;&lt;&#x2F;button&gt;</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br></pre></td></tr></table></figure><ul><li>v-on 还提供了<a href="https://cn.vuejs.org/v2/guide/events.html#%E6%8C%89%E9%94%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6" target="_blank" rel="noopener">按键修饰符</a></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">键盘按钮的别名</span><br><span class="line">.enter</span><br><span class="line">.tab</span><br><span class="line">.delete (捕获“删除”和“退格”键)</span><br><span class="line">.esc</span><br><span class="line">.space</span><br><span class="line">.up</span><br><span class="line">.down</span><br><span class="line">.left</span><br><span class="line">.right</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 可以通过全局 &#96;config.keyCodes&#96; 对象自定义按键修饰符别名</span><br><span class="line">&#x2F;&#x2F; 使用 方式 &#96;v-on:keyup.f1&#96; ，f1 这个名字你可以任意取，你知道是什么意思就可以了</span><br><span class="line">Vue.config.keyCodes.f1 &#x3D; 112</span><br></pre></td></tr></table></figure><p><a href="https://cn.vuejs.org/v2/api/?#v-bind" target="_blank" rel="noopener">v-bind：</a></p><blockquote><p>动态地绑定一个或多个特性，或一个组件 prop 到表达式。</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 绑定一个属性 --&gt;</span><br><span class="line">&lt;img v-bind:src&#x3D;&quot;imageSrc&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 缩写 --&gt;</span><br><span class="line">&lt;img :src&#x3D;&quot;imageSrc&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 内联字符串拼接 --&gt;</span><br><span class="line">&lt;img :src&#x3D;&quot;&#39;&#x2F;path&#x2F;to&#x2F;images&#x2F;&#39; + fileName&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- class 绑定 --&gt;</span><br><span class="line">&lt;div :class&#x3D;&quot;&#123; red: isRed &#125;&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;div :class&#x3D;&quot;[classA, classB]&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;div :class&#x3D;&quot;[classA, &#123; classB: isB, classC: isC &#125;]&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- style 绑定 --&gt;</span><br><span class="line">&lt;div :style&#x3D;&quot;&#123; fontSize: size + &#39;px&#39; &#125;&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;div :style&#x3D;&quot;[styleObjectA, styleObjectB]&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 绑定一个有属性的对象 --&gt;</span><br><span class="line">&lt;div v-bind&#x3D;&quot;&#123; id: someProp, &#39;other-attr&#39;: otherProp &#125;&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- prop 绑定。“prop”必须在 my-component 中声明。--&gt;</span><br><span class="line">&lt;my-component :prop&#x3D;&quot;someThing&quot;&gt;&lt;&#x2F;my-component&gt;</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br></pre></td></tr></table></figure><h4 id="三、Vue-指令、自定义指令"><a href="#三、Vue-指令、自定义指令" class="headerlink" title="三、Vue 指令、自定义指令"></a>三、Vue 指令、自定义指令</h4><p><a href="https://cn.vuejs.org/v2/api/?#%E6%8C%87%E4%BB%A4" target="_blank" rel="noopener">Vue指令：</a></p><p>v-text：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;span v-text&#x3D;&quot;msg&quot;&gt;&lt;&#x2F;span&gt;</span><br><span class="line">&lt;!-- 和下面的一样 --&gt;</span><br><span class="line">&lt;span&gt;&#123;&#123;msg&#125;&#125;&lt;&#x2F;span&gt;</span><br></pre></td></tr></table></figure><p>v-html：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;输出真正的 HTML</span><br><span class="line">&lt;div v-html&#x3D;&quot;html&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">data&#123;</span><br><span class="line">  html:&#39;&lt;strong&gt;我是真正的html&lt;&#x2F;strong&gt;&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>v-show：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;根据表达式之真假值，切换元素的 display CSS 属性。</span><br><span class="line">&lt;h1 v-show&#x3D;&quot;ok&quot;&gt;Hello!&lt;&#x2F;h1&gt;</span><br></pre></td></tr></table></figure><p>v-if、v-if-else、v-else：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;v-if 是“真正”的条件渲染，如果条件为假，dom不会渲染在页面当中</span><br><span class="line">&#x2F;&#x2F;v-show 会一直渲染在dom当中</span><br><span class="line">&#x2F;&#x2F;当 v-if 与 v-for 一起使用时，v-for 具有比 v-if 更高的优先级。</span><br><span class="line">&lt;h1 v-if&#x3D;&quot;ok&quot;&gt;Yes&lt;&#x2F;h1&gt;</span><br><span class="line"></span><br><span class="line">&lt;h1 v-if&#x3D;&quot;ok&quot;&gt;Yes&lt;&#x2F;h1&gt;</span><br><span class="line">&lt;h1 v-else&gt;No&lt;&#x2F;h1&gt;</span><br><span class="line"></span><br><span class="line">&lt;div v-if&#x3D;&quot;type &#x3D;&#x3D;&#x3D; &#39;A&#39;&quot;&gt;A&lt;&#x2F;div&gt;</span><br><span class="line">&lt;div v-else-if&#x3D;&quot;type &#x3D;&#x3D;&#x3D; &#39;B&#39;&quot;&gt;B&lt;&#x2F;div&gt;</span><br><span class="line">&lt;div v-else-if&#x3D;&quot;type &#x3D;&#x3D;&#x3D; &#39;C&#39;&quot;&gt;C&lt;&#x2F;div&gt;</span><br><span class="line">&lt;div v-else&gt;Not A&#x2F;B&#x2F;C&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><p>v-for：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;基于源数据多次渲染元素或模板块。</span><br><span class="line">&lt;div v-for&#x3D;&quot;item in items&quot;&gt;</span><br><span class="line">  &#123;&#123; item.text &#125;&#125;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;另外也可以为数组索引指定别名 (或者用于对象的键)：val-&gt;对象的键值  key-&gt;对象的键  index-&gt;对象的下标</span><br><span class="line">&lt;div v-for&#x3D;&quot;(item, index) in items&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;div v-for&#x3D;&quot;(val, key) in object&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;div v-for&#x3D;&quot;(val, key, index) in object&quot;&gt;&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><p>v-model：作用于<input>、<select>、<textarea>，<br>当v-model作用于 <strong>多个复选框</strong>、<strong>当选择按钮</strong>、<strong>选择框</strong> 时，都是把这些标签的value值赋值给v-model的变量</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">修饰符：</span><br><span class="line">.lazy - 取代 &#96;input&#96; 监听 &#96;change&#96; 事件</span><br><span class="line">.number- 输入字符串转为数字</span><br><span class="line">.trim- 输入首尾空格过滤</span><br><span class="line"></span><br><span class="line">&lt;input v-model&#x3D;&quot;message&quot; placeholder&#x3D;&quot;edit me&quot;&gt;</span><br><span class="line">&lt;textarea v-model&#x3D;&quot;message&quot; placeholder&#x3D;&quot;add multiple lines&quot;&gt;&lt;&#x2F;textarea&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 选择框</span><br><span class="line">&lt;select v-model&#x3D;&quot;selected&quot;&gt;</span><br><span class="line">   &lt;option disabled value&#x3D;&quot;&quot;&gt;请选择&lt;&#x2F;option&gt;</span><br><span class="line">   &lt;option&gt;A&lt;&#x2F;option&gt;</span><br><span class="line">   &lt;option&gt;B&lt;&#x2F;option&gt;</span><br><span class="line">   &lt;option&gt;C&lt;&#x2F;option&gt;</span><br><span class="line">&lt;&#x2F;select&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 用 v-for 渲染的动态选项：</span><br><span class="line">&lt;select v-model&#x3D;&quot;selected&quot;&gt;</span><br><span class="line">  &lt;option v-for&#x3D;&quot;option in options&quot; v-bind:value&#x3D;&quot;option.value&quot;&gt;</span><br><span class="line">    &#123;&#123; option.text &#125;&#125;</span><br><span class="line">  &lt;&#x2F;option&gt;</span><br><span class="line">&lt;&#x2F;select&gt;</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br></pre></td></tr></table></figure><p>v-pre：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;跳过这个元素和它的子元素的编译过程。可以用来显示原始 Mustache 标签。跳过大量没有指令的节点会加快编译。</span><br><span class="line">&#x2F;&#x2F;Mustache 标签：&#123;&#123; &#125;&#125;</span><br><span class="line">&lt;span v-pre&gt;&#123;&#123; this will not be compiled &#125;&#125;&lt;&#x2F;span&gt;</span><br></pre></td></tr></table></figure><p>v-cloak：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;这个指令保持在元素上直到关联实例结束编译</span><br><span class="line">css:</span><br><span class="line">[v-cloak] &#123;</span><br><span class="line">  display: none;</span><br><span class="line">&#125;</span><br><span class="line">html:</span><br><span class="line">&lt;div v-cloak&gt;</span><br><span class="line">  &#123;&#123; message &#125;&#125;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><p>v-once：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">只渲染元素和组件一次。随后的重新渲染，元素&#x2F;组件及其所有的子节点将被视为静态内容并跳过。这可以用于优化更新性能。</span><br><span class="line"></span><br><span class="line">&lt;!-- 单个元素 --&gt;</span><br><span class="line">&lt;span v-once&gt;This will never change: &#123;&#123;msg&#125;&#125;&lt;&#x2F;span&gt;</span><br><span class="line">&lt;!-- 有子元素 --&gt;</span><br><span class="line">&lt;div v-once&gt;</span><br><span class="line">  &lt;h1&gt;comment&lt;&#x2F;h1&gt;</span><br><span class="line">  &lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;&#x2F;p&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;!-- 组件 --&gt;</span><br><span class="line">&lt;my-component v-once :comment&#x3D;&quot;msg&quot;&gt;&lt;&#x2F;my-component&gt;</span><br><span class="line">&lt;!-- &#96;v-for&#96; 指令--&gt;</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;li v-for&#x3D;&quot;i in list&quot; v-once&gt;&#123;&#123;i&#125;&#125;&lt;&#x2F;li&gt;</span><br><span class="line">&lt;&#x2F;ul&gt;</span><br></pre></td></tr></table></figure><p><a href="https://cn.vuejs.org/v2/guide/custom-directive.html" target="_blank" rel="noopener">Vue自定义指令：</a></p><p><a href="https://cn.vuejs.org/v2/guide/custom-directive.html#%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0" target="_blank" rel="noopener">指令的钩子函数：</a> 一个指令定义对象可以提供如下几个钩子函数 (均为可选)：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;bind&#96;：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。</span><br><span class="line"></span><br><span class="line">&#96;inserted&#96;：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。</span><br><span class="line"></span><br><span class="line">&#96;update&#96;：1、所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。</span><br><span class="line">          2、指令的值可能发生了改变，也可能没有。</span><br><span class="line">          3、你可以通过比较更新前后的值来忽略不必要的模板更新 (详细的钩子函数参数见下)。</span><br><span class="line"></span><br><span class="line">&#96;componentUpdated&#96;：指令所在组件的 VNode 及其子 VNode 全部更新后调用。</span><br><span class="line"></span><br><span class="line">&#96;unbind&#96;：只调用一次，指令与元素解绑时调用。</span><br></pre></td></tr></table></figure><p><a href="https://cn.vuejs.org/v2/guide/custom-directive.html#%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0" target="_blank" rel="noopener">钩子函数的参数</a> (即 el、binding、vnode 和 oldVnode)。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;el&#96;：指令所绑定的元素，可以用来直接操作 DOM 。</span><br><span class="line"></span><br><span class="line">&#96;binding&#96;：一个对象，包含以下属性：</span><br><span class="line">    &#96;name&#96;：指令名，不包括 &#96;v-&#96; 前缀。</span><br><span class="line">    &#96;value&#96;：指令的绑定值，例如：&#96;v-my-directive&#x3D;&quot;1 + 1&quot;&#96; 中，绑定值为 &#96;2&#96;。</span><br><span class="line">    &#96;oldValue&#96;：指令绑定的前一个值，仅在 &#96;update&#96; 和 &#96;componentUpdated&#96; 钩子中可用。无论值是否改变都可用。</span><br><span class="line">    &#96;expression&#96;：字符串形式的指令表达式。例如 &#96;v-my-directive&#x3D;&quot;1 + 1&quot;&#96; 中，表达式为 &#96;&quot;1 + 1&quot;&#96;。</span><br><span class="line">    &#96;arg&#96;：传给指令的参数，可选。例如 &#96;v-my-directive:foo&#96; 中，参数为 &#96;&quot;foo&quot;&#96;。</span><br><span class="line">    &#96;modifiers&#96;：一个包含修饰符的对象。例如：&#96;v-my-directive.foo.bar&#96; 中，修饰符对象为 &#96;&#123; foo: true, bar: true &#125;&#96;。</span><br><span class="line"></span><br><span class="line">&#96;vnode&#96;：Vue 编译生成的虚拟节点。移步(https:&#x2F;&#x2F;cn.vuejs.org&#x2F;v2&#x2F;api&#x2F;#VNode%E6%8E%A5%E5%8F%A3) 来了解更多详情。</span><br><span class="line"></span><br><span class="line">&#96;oldVnode&#96;：上一个虚拟节点，仅在 &#96;update&#96; 和 &#96;componentUpdated&#96; 钩子中可用。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 注册一个全局自定义指令 &#96;v-focus&#96;</span><br><span class="line">&#x2F;&#x2F; 在这里需要注意一下，给一个全局指令命名的时候不要加 &#96;v-&#96; 前缀，用在dom的时候再加上</span><br><span class="line">Vue.directive(&#39;focus&#39;, &#123;</span><br><span class="line">  &#x2F;&#x2F; 当被绑定的元素插入到 DOM 中时……</span><br><span class="line">  inserted: function (el,binding) &#123;</span><br><span class="line">    &#x2F;&#x2F; 聚焦元素</span><br><span class="line">    el.focus();</span><br><span class="line">    console.log(binding.value) &#x2F;&#x2F;&#x3D;&gt;666</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;如果想注册局部指令，组件中也接受一个 directives 的选项：</span><br><span class="line">directives: &#123;</span><br><span class="line">  focus: &#123;</span><br><span class="line">    &#x2F;&#x2F; 指令的定义</span><br><span class="line">    inserted: function (el,binding) &#123;</span><br><span class="line">      el.focus(); </span><br><span class="line">      console.log(binding.value) &#x2F;&#x2F;&#x3D;&gt;666</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;然后你可以在模板中任何元素上使用新的 v-focus 属性，如下：</span><br><span class="line">&lt;input v-focus&#x3D;&quot;6666&quot;&gt;  &#x2F;&#x2F; 6666 可用data 里面的变量替换，建议传简单数据类型</span><br></pre></td></tr></table></figure><blockquote><p>一个正常的业务不可能只有一个指令，如果把所有的指令都注册在main.js里面会不好管理，所以最好放在一个统一文件 directives.js<br>这里就产生了两个问题：<br>1、怎么把directives.js 这个文件引用到main.js<br>2、Vue.directives() 支不支持链式调用（因为老版本angular 支持，所以做一个假想）</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 第二个问题很好解决，经过测试，Vue.directives() 不支持链式调用 &#96;Vue.directives().directives()&#96;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 第一个问题：经过查阅相关资料之后可以以插件的形式引入</span><br><span class="line">&#x2F;&#x2F; 这种方式引入暂时还没有发现有其他的问题</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; main.js</span><br><span class="line">import directives from &#39;.&#x2F;directives.js&#39;</span><br><span class="line">Vue.use(directives);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; directives.js</span><br><span class="line">export default&#123;</span><br><span class="line">  &#x2F;&#x2F; install 方法会默认在main.js里面调用</span><br><span class="line">  install(Vue)&#123;</span><br><span class="line">    Vue.directive(&#39;focus&#39;,&#123;</span><br><span class="line">      inserted(el,binding)&#123;</span><br><span class="line">        el.focus();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    Vue.directive(&#39;data&#39;,&#123;</span><br><span class="line">      inserted(el)&#123;</span><br><span class="line">        console.log(el)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    &#x2F;&#x2F;有多个就继续往这里添加就好了</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="四、Vue-过滤器"><a href="#四、Vue-过滤器" class="headerlink" title="四、Vue 过滤器"></a>四、Vue 过滤器</h4><p><a href="https://cn.vuejs.org/v2/guide/filters.html" target="_blank" rel="noopener">Vue 过滤器的用法</a></p><blockquote><p>过滤器可以用在两个地方：双花括号插值和 v-bind 表达式 (后者从 2.1.0+ 开始支持)。<br>与指令的用法类似，但过滤器一定要有返回值，也不支持链式调用</p></blockquote><blockquote><p><strong>这里需要注意的地方是，vue 2.0 之后移除了自带的过滤器</strong></p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 在双花括号中</span><br><span class="line">&#123;&#123; message | capitalize &#125;&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 在 &#96;v-bind&#96; 中</span><br><span class="line">&lt;div v-bind:id&#x3D;&quot;rawId | formatId&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 局部注册过滤器</span><br><span class="line">filters: &#123;</span><br><span class="line">  &#x2F;&#x2F; 首字母大写</span><br><span class="line">  capitalize: function (value) &#123;</span><br><span class="line">    &#x2F;&#x2F; value 就是 ‘|’ 符号前面的值</span><br><span class="line">    if (!value) return &#39;&#39;;</span><br><span class="line">    value &#x3D; value.toString()</span><br><span class="line">    return value.charAt(0).toUpperCase() + value.slice(1)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 注册全局过滤器</span><br><span class="line">Vue.filter(&#39;capitalize&#39;, function (value) &#123;</span><br><span class="line">  if (!value) return &#39;&#39;;</span><br><span class="line">  value &#x3D; value.toString()</span><br><span class="line">  return value.charAt(0).toUpperCase() + value.slice(1)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 过滤器传值</span><br><span class="line">&#123;&#123; number | dual(2) &#125;&#125;</span><br><span class="line"></span><br><span class="line">Vue.filter(&#39;dual&#39;, function (value,type) &#123;</span><br><span class="line">  &#x2F;&#x2F; 回调函数里面默认有 value ,在页面上传过来的值会依次添加在后面</span><br><span class="line">  console.log(type)  &#x2F;&#x2F; &#x3D;&gt; 2</span><br><span class="line">  if (!value) return &#39;&#39;;</span><br><span class="line">  if (typeof value !&#x3D;&#x3D; &quot;number&quot;) return alert(value + &#39; 不是数字&#39;);</span><br><span class="line">  if( parseInt(type) &#x3D;&#x3D;&#x3D; 2 )&#123;</span><br><span class="line">    return value &#x3D; value &gt; 10 ? value : &#39;0&#39; + value</span><br><span class="line">  &#125;</span><br><span class="line">  return value</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 过滤器的插件用法，与 directives.js 一致</span><br><span class="line">&#x2F;&#x2F; main.js</span><br><span class="line">import directives from &#39;.&#x2F;filters.js&#39;</span><br><span class="line">Vue.use(filters);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; filters.js</span><br><span class="line">export default &#123;</span><br><span class="line">  install(Vue)&#123;</span><br><span class="line">    Vue.filter(&#39;dual&#39;, function (value,type) &#123;</span><br><span class="line">      if (!value) return &#39;&#39;;</span><br><span class="line">      if (typeof value !&#x3D;&#x3D; &quot;number&quot;) return alert(value + &#39; 不是数字&#39;);</span><br><span class="line">      if( parseInt(type) &#x3D;&#x3D;&#x3D; 2 )&#123;</span><br><span class="line">        return value &#x3D; value &gt; 10 ? value : &#39;0&#39; + value</span><br><span class="line">      &#125;</span><br><span class="line">      return value</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="五、Vue-数据监听"><a href="#五、Vue-数据监听" class="headerlink" title="五、Vue 数据监听"></a>五、Vue 数据监听</h4><p><a href="https://cn.vuejs.org/v2/api/#watch" target="_blank" rel="noopener">Vue 数据监听 watch</a></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; watch 基本用法与注意事项</span><br><span class="line">data: &#123;</span><br><span class="line">  a: 1,</span><br><span class="line">  e: &#123;</span><br><span class="line">    f: &#123;</span><br><span class="line">      g: 5</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  items: [</span><br><span class="line">    &#123; message: &#39;Foo&#39; &#125;,</span><br><span class="line">    &#123; message: &#39;Bar&#39; &#125;</span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br><span class="line">mounted: function()&#123;</span><br><span class="line">  this.a &#x3D; 2；</span><br><span class="line">  this.e.f.g &#x3D; 10;</span><br><span class="line">  this.$set(this.items, 0, &#123; message: &#39;AAA&#39; &#125;);  &#x2F;&#x2F; $set 赋值</span><br><span class="line">  this.items[0] &#x3D; &#123; message: &#39;AAA&#39; &#125;;  &#x2F;&#x2F; 直接赋值</span><br><span class="line">&#125;,</span><br><span class="line">watch: &#123;</span><br><span class="line">  &#x2F;&#x2F; 最简单最直接的监听方式，能监听简单的数据变化，这种方法默认就是执行 handler: function()&#123;&#125;</span><br><span class="line">  &#x2F;&#x2F; 注意：这种方式监听不到对象的变化</span><br><span class="line">  a: function(val, oldVal)&#123;</span><br><span class="line">    console.log(val);  &#x2F;&#x2F; &#x3D;&gt; 变化之后的数据</span><br><span class="line">    console.log(oldVal); &#x2F;&#x2F; &#x3D;&gt; 变化之前的数据</span><br><span class="line">  &#125;,</span><br><span class="line">  &#x2F;&#x2F; 深度监听，这里要注意一下，这样的方式打印出来两个值都是变化之后的值</span><br><span class="line">  &#x2F;&#x2F; deep 的值默认为false，如果不写或者deep: false 都不能监听到对象值的变化</span><br><span class="line">  e: &#123;</span><br><span class="line">    handler: function (val, oldVal) &#123;</span><br><span class="line">      console.log(val);  &#x2F;&#x2F; &#x3D;&gt; 变化之后的数据</span><br><span class="line">      console.log(oldVal);  &#x2F;&#x2F; &#x3D;&gt; 变化之后的数据</span><br><span class="line">    &#125;,</span><br><span class="line">    deep: true, </span><br><span class="line">  &#125;,</span><br><span class="line">  &#x2F;&#x2F; 如果要精准监听的对象值的变化，可以用这种方法</span><br><span class="line">  &#39;e.f.g&#39;: function (val, oldVal) &#123;</span><br><span class="line">    console.log(val);  &#x2F;&#x2F; &#x3D;&gt; 变化之后的数据</span><br><span class="line">    console.log(oldVal);  &#x2F;&#x2F; &#x3D;&gt; 变化之前的数据</span><br><span class="line">  &#125;,</span><br><span class="line">  &#x2F;&#x2F; 监听数组</span><br><span class="line">  &#x2F;&#x2F; 由于 JavaScript 的限制，Vue 不能检测 this.items[0] &#x3D; &#123; message: &#39;AAA&#39; &#125;; 这种方式赋值的变化</span><br><span class="line">  &#x2F;&#x2F; 所以你要用 $set、或者数组变异的方法赋值</span><br><span class="line">  items: function(val, oldVal)&#123;</span><br><span class="line">    console.log(val);  &#x2F;&#x2F; &#x3D;&gt; 变化之后的数据</span><br><span class="line">    console.log(oldVal);  &#x2F;&#x2F; &#x3D;&gt; 变化之后的数据</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://cn.vuejs.org/v2/guide/list.html#%E6%95%B0%E7%BB%84%E6%9B%B4%E6%96%B0%E6%A3%80%E6%B5%8B" target="_blank" rel="noopener">Vue 数组更新检测</a></p><p>官网的介绍：<strong>由于 JavaScript 的限制，Vue 不能检测以下变动的数组</strong><br>换句话来说：<strong>这样赋值不触发视图更新</strong></p><ul><li>1、当你利用索引直接设置一个项时，例如：</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">this.items[indexOfItem] &#x3D; newValue  &#x2F;&#x2F; indexOfItem 是指数组的index 下标</span><br></pre></td></tr></table></figure><ul><li>2、当你修改数组的长度时，例如：</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">this.items.length &#x3D; newLength</span><br></pre></td></tr></table></figure><p>要解决上面问题，你可以用以下方式解决：</p><h6 id="1、Vue-set-target-key-value-，set方法有下面3个参数"><a href="#1、Vue-set-target-key-value-，set方法有下面3个参数" class="headerlink" title="1、Vue.set( target, key, value) ，set方法有下面3个参数"></a>1、<a href="https://cn.vuejs.org/v2/api/#Vue-set" target="_blank" rel="noopener">Vue.set( target, key, value)</a> ，set方法有下面3个参数</h6><ul><li>{Object | Array} target  – 给谁设置值（对象，数组）都可以</li><li>{string | number} key – 给对象设值，key 就是对象的key，给数组设值，key 就是数组的下标 index</li><li>{any} value – 添加任何值都可以</li></ul><h6 id="2、数组变异的方式"><a href="#2、数组变异的方式" class="headerlink" title="2、数组变异的方式"></a>2、数组变异的方式</h6><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/push" target="_blank" rel="noopener">push()</a>：将一个或多个元素添加到数组的末尾，并返回新数组的长度。<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/pop" target="_blank" rel="noopener">pop()</a>：从数组中删除最后一个元素，并返回该元素的值。此方法更改数组的长度。<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/shift" target="_blank" rel="noopener">shift()</a>：从数组中删除第一个元素，并返回该元素的值。<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/unshift" target="_blank" rel="noopener">unshift()</a>：将一个或多个元素添加到数组的开头，并返回新数组的长度。<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/splice" target="_blank" rel="noopener">splice()</a>：通过删除现有元素和/或添加新元素来更改一个数组的内容。<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/sort" target="_blank" rel="noopener">sort()</a>：用<a href="https://en.wikipedia.org/wiki/Sorting_algorithm#Stability" target="_blank" rel="noopener">就地（ in-place ）的算法</a>对数组的元素进行排序，并返回数组。 sort 排序不一定是<a href="https://zh.wikipedia.org/wiki/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95#.E7.A9.A9.E5.AE.9A.E6.80.A7" target="_blank" rel="noopener">稳定的</a>。默认排序顺序是根据字符串Unicode码点。<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/reverse" target="_blank" rel="noopener">reverse()</a>：将数组中元素的位置颠倒。</p><h4 id="六、Vue-组件"><a href="#六、Vue-组件" class="headerlink" title="六、Vue 组件"></a>六、Vue 组件</h4><p><a href="https://cn.vuejs.org/v2/guide/components.html" target="_blank" rel="noopener">Vue 组件基础</a></p><blockquote><p>组件是可复用的 Vue 实例，所以它们与 new Vue 接收相同的选项，例如 data、computed、watch、methods 以及生命周期钩子等。<br>注意：<strong>组件没有 el 这样根实例特有的选项；而根实例没有 props 这个子组件特有的属性</strong></p></blockquote><ul><li>Vue.component( 组件名 ,{ 选项 }) 全局注册</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 全局注册组件的时候必须写在Vue实例创建之前</span><br><span class="line">&#x2F;&#x2F; 下面这几种方式是等价的</span><br><span class="line">import Vue from &#39;vue&#39;</span><br><span class="line">var MyComponent &#x3D; Vue.extend(&#123;</span><br><span class="line">  template:&quot;&lt;h1&gt;我是全局组件&lt;&#x2F;h1&gt;&quot;</span><br><span class="line">&#125;);</span><br><span class="line">Vue.component(&quot;my-component&quot;,MyComponent);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 注册组件，传入一个扩展过的构造器</span><br><span class="line">Vue.component(&#39;my-component&#39;, Vue.extend(&#123; &#x2F;* ... *&#x2F; &#125;))</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 注册组件，传入一个选项对象 (自动调用 Vue.extend)</span><br><span class="line">Vue.component(&#39;my-component&#39;, &#123; &#x2F;* ... *&#x2F; &#125;)</span><br></pre></td></tr></table></figure><ul><li>通常情况下一个组件肯定是由很多html标签组成的，如果全部写在template 里会非常难看且没有语法高亮提示，有没有其他解决办法？还真有</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 一个定义模板的方式是在一个 &lt;script&gt; 元素中，并为其带上 text&#x2F;x-template 的类型，然后通过一个 id 将模板引用过去。</span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;x-template&quot; id&#x3D;&quot;hello-world-template&quot;&gt;</span><br><span class="line">  &lt;p&gt;Hello hello hello&lt;&#x2F;p&gt;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 另一个定义模板的方式是在一个 &lt;template&gt; 元素中，通过一个 id 将模板引用过去；在单文件组件 .vue 当中，id可以省略；</span><br><span class="line">&lt;template id&#x3D;&quot;hello-world-template&quot;&gt;</span><br><span class="line">  &lt;p&gt;Hello hello hello&lt;&#x2F;p&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">Vue.component(&quot;my-component&quot;,&#123;</span><br><span class="line">    template:&quot;#hello-world-template&quot;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>引入外部单文件组件注册成全局组件</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; .vue </span><br><span class="line">&#x2F;&#x2F; 在单文件组件中 template 标签下只能有一个根元素</span><br><span class="line">&#x2F;&#x2F; 如果硬要有多个根元素，你只能在多个根元素中添加 v-if、v-else-if、v-else 来判断什么时候用哪个根元素</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;home&quot;&gt;</span><br><span class="line">    &lt;p&gt;&#123;&#123;getting&#125;&#125;&lt;&#x2F;p&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">  &lt;!-- &lt;p&gt;这样是不行的&lt;&#x2F;p&gt; --&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    name: &quot;home&quot;,  &#x2F;&#x2F; 便于在vue-devtools 调试中提供更加友好的警告信息</span><br><span class="line">    data: function () &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        getting: &#39;welcome&#39;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">&#x2F;&#x2F; 局部css样式</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; main.js</span><br><span class="line">import home from &#39;.&#x2F;components&#x2F;home&#x2F;home&#39;</span><br><span class="line">Vue.component(&#39;home&#39;,home);</span><br></pre></td></tr></table></figure><ul><li>局部注册组件</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 每个vue 实例都会有一个 components 的选项，而组件是可复用的 Vue 实例，所以每个组件都有components 选项</span><br><span class="line">&#x2F;&#x2F; 引入外部文件注册成局部组件</span><br><span class="line">import home from &#39;.&#x2F;components&#x2F;home&#x2F;home&#39;</span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el:&quot;#app&quot;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    home, &#x2F;&#x2F; 等价于home: home，ES6对象中属性的简洁表示，ES6(http:&#x2F;&#x2F;es6.ruanyifeng.com&#x2F;#docs&#x2F;object)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 直接在components 选项中写，(不推荐这种用法)</span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el:&quot;#app&quot;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    loading: &#123;</span><br><span class="line">      data: function () &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">          getting: &#39;welcome&#39;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      components:&#123;</span><br><span class="line">       &#x2F;&#x2F; 这里还可以嵌套局部组件... </span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li><h6 id="组件间的传值"><a href="#组件间的传值" class="headerlink" title="组件间的传值"></a>组件间的传值</h6></li></ul><p><a href="https://cn.vuejs.org/v2/guide/components-props.html" target="_blank" rel="noopener">通过 Prop 向子组件传递数据</a></p><ul><li>注意：这种传值方式是<a href="https://cn.vuejs.org/v2/guide/components-props.html#%E5%8D%95%E5%90%91%E6%95%B0%E6%8D%AE%E6%B5%81" target="_blank" rel="noopener">单向数据流</a>，不可逆。</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; HTML 中的特性名是大小写不敏感的，所以浏览器会把所有大写字符解释为小写字符。</span><br><span class="line">&#x2F;&#x2F; 这意味着当你使用 DOM 中的模板时，驼峰命名法的 prop 名需要使用其等价的 短横线分隔命名命名。</span><br><span class="line">&#x2F;&#x2F; 如果使用字符串模板，那么这个限制就不存在了。</span><br><span class="line">Vue.component(&#39;my-component&#39;, &#123;</span><br><span class="line">  props: [&#39;myTitle&#39;],</span><br><span class="line">  template: &#39;&lt;h3&gt;&#123;&#123; myTitle&#125;&#125;&lt;&#x2F;h3&gt;&#39;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; HTML</span><br><span class="line">&lt;my-component my-title&#x3D;&#39;hello world&#39;&gt;&lt;&#x2F;my-component&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 上述例子只是一个静态数据传输，如果你要动态传输数据，可以用 v-bind 绑定一个属性</span><br><span class="line">&#x2F;&#x2F; 也可以用v-bind 的缩写形式</span><br><span class="line">&lt;my-component v-bind:my-title&#x3D;&#39;hello world&#39;&gt;&lt;&#x2F;my-component&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 任何类型的值都可以传递给 prop，prop 允许很多个</span><br><span class="line">&#x2F;&#x2F; 如果你想要将一个对象的所有属性都作为 prop 传入，你可以使用不带参数的 v-bind，如：</span><br><span class="line">obj: &#123;</span><br><span class="line">  id: 1,</span><br><span class="line">  title: &#39;Hello World&#39;</span><br><span class="line">&#125;</span><br><span class="line">&lt;my-component v-bind&#x3D;&#39;obj&#39;&gt;&lt;&#x2F;my-component&gt;</span><br><span class="line">&#x2F;&#x2F; 等价于：</span><br><span class="line">&lt;my-component </span><br><span class="line">  v-bind:id&#x3D;&#39;obj.id&#39;</span><br><span class="line">  v-bind:title&#x3D;&#39;obj.title&#39;</span><br><span class="line">&gt;&lt;&#x2F;my-component&gt;</span><br></pre></td></tr></table></figure><p><a href="https://cn.vuejs.org/v2/guide/components-props.html#Prop-%E9%AA%8C%E8%AF%81" target="_blank" rel="noopener">Prop 还提供验证的方式指定传什么值</a></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Vue.component(&#39;my-component&#39;, &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    &#x2F;&#x2F; 基础的类型检查 (&#96;null&#96; 匹配任何类型)</span><br><span class="line">    propA: Number,</span><br><span class="line">    &#x2F;&#x2F; 多个可能的类型</span><br><span class="line">    propB: [String, Number],</span><br><span class="line">    &#x2F;&#x2F; 必填的字符串</span><br><span class="line">    propC: &#123;</span><br><span class="line">      type: String,</span><br><span class="line">      required: true</span><br><span class="line">    &#125;,</span><br><span class="line">    &#x2F;&#x2F; 带有默认值的数字</span><br><span class="line">    propD: &#123;</span><br><span class="line">      type: Number,</span><br><span class="line">      default: 100</span><br><span class="line">    &#125;,</span><br><span class="line">    &#x2F;&#x2F; 带有默认值的对象</span><br><span class="line">    propE: &#123;</span><br><span class="line">      type: Object,</span><br><span class="line">      &#x2F;&#x2F; 对象或数组且一定会从一个工厂函数返回默认值</span><br><span class="line">      default: function () &#123;</span><br><span class="line">        return &#123; message: &#39;hello&#39; &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#x2F;&#x2F; 自定义验证函数</span><br><span class="line">    propF: &#123;</span><br><span class="line">      validator: function (value) &#123;</span><br><span class="line">        &#x2F;&#x2F; 这个值必须匹配下列字符串中的一个</span><br><span class="line">        return [&#39;success&#39;, &#39;warning&#39;, &#39;danger&#39;].indexOf(value) !&#x3D;&#x3D; -1</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>既然 prop 的单向的，那如果子组件向父组件传值怎么办？</p><ul><li>子传父，使用 <a href="https://cn.vuejs.org/v2/guide/components-custom-events.html" target="_blank" rel="noopener">自定义事件</a> 的方式</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 子组件,子组件可以通过$emit() 广播一个事件给父组件</span><br><span class="line">&#x2F;&#x2F; 命名的这个事件名没有限制，子组件与父组件的名字保持一致就可以了</span><br><span class="line">&lt;button v-on:click&#x3D;&quot;$emit(&#39;broadcast&#39;)&quot;&gt;向父组件广播这个事件&lt;&#x2F;button&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; $emit() 这个方法也可以写在 子组件的 methods 里面</span><br><span class="line">&lt;button v-on:click&#x3D;&quot;broadcast&quot;&gt;向父组件广播这个事件&lt;&#x2F;button&gt;</span><br><span class="line">methods: &#123;</span><br><span class="line">  broadcast()&#123;</span><br><span class="line">    this.$emit(&#39;broadcast&#39;)</span><br><span class="line">    &#x2F;&#x2F; 如果要传值，就使用$emit(事件名, 值) 的第二个参数</span><br><span class="line">    this.$emit(&#39;broadcast&#39;, value)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 在父组件中，父组件可以用 v-on 监听子组件触发的 &#96;broadcast&#96; 事件，类似监听Dom 事件一样的用法</span><br><span class="line">&lt;my-component v-on:broadcast&#x3D;&#39;catchYou&#39;&gt;&lt;&#x2F;my-component&gt;</span><br><span class="line">methods: &#123;</span><br><span class="line">  catchYou(val)&#123;</span><br><span class="line">    &#x2F;&#x2F; 子组件传过来的值就会作为第一个参数传入这个方法 </span><br><span class="line">    console.log(val)</span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br><span class="line">&#x2F;&#x2F; 在组件的表达式里面，你可以通过$event 访问到子组件传递过来的值</span><br><span class="line">&lt;my-component v-on:broadcast&#x3D;&#39;$event&#39;&gt;&lt;&#x2F;my-component&gt;</span><br></pre></td></tr></table></figure><ul><li>组件的一些其他用法，感兴趣可以去了解 <a href="https://cn.vuejs.org/v2/guide/components-slots.html" target="_blank" rel="noopener">插槽</a>   <a href="https://cn.vuejs.org/v2/guide/components-dynamic-async.html" target="_blank" rel="noopener">动态组件 &amp; 异步组件</a></li><li><a href="https://cn.vuejs.org/v2/guide/transitions.html#%E5%8D%95%E5%85%83%E7%B4%A0-%E7%BB%84%E4%BB%B6%E7%9A%84%E8%BF%87%E6%B8%A1" target="_blank" rel="noopener">单元素/组件的过渡</a></li></ul><h4 id="七、vue-router"><a href="#七、vue-router" class="headerlink" title="七、vue-router"></a>七、vue-router</h4><ul><li>贴一段 app 构建的案例。官网API <a href="https://router.vuejs.org/zh-cn/essentials/getting-started.html" target="_blank" rel="noopener">点这里</a></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 这里我让 app.vue作为最大的渲染层，渲染tabs --&gt;</span><br><span class="line">&lt;!-- 这里我模拟的是一个商场app，下面几个tab；点击&#96;tab&#96;直接渲染在&#96;tabs&#96;的&lt;router-view&gt;&lt;&#x2F;router-view&gt;上 --&gt;</span><br><span class="line">&lt;!-- tabs 之外的页面直接渲染在app.vue 的&lt;router-view&gt;&lt;&#x2F;router-view&gt;上 --&gt;</span><br><span class="line">&lt;!--  app.vue --&gt;</span><br><span class="line">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">  &lt;router-view&gt;&lt;&#x2F;router-view&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tabs.vue --&gt;</span><br><span class="line">&lt;div class&#x3D;&quot;tabs&quot;&gt;</span><br><span class="line">  &lt;router-view&gt;&lt;&#x2F;router-view&gt;</span><br><span class="line">  &lt;nav class&#x3D;&quot;nav&quot;&gt;</span><br><span class="line">    &lt;router-link class&#x3D;&quot;nav-link&quot; to&#x3D;&quot;home&quot;&gt;</span><br><span class="line">      &lt;i&gt;&lt;&#x2F;i&gt;</span><br><span class="line">      &lt;p&gt;首页&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;&#x2F;router-link&gt;</span><br><span class="line">  &lt;nav&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 以下一些配置是简单要用到的，高级的用法请看官网</span><br><span class="line">&#x2F;&#x2F; router.js</span><br><span class="line">import tabs from &#39;.&#x2F;components&#x2F;tabs&#x2F;tabs&#39;</span><br><span class="line">import home from &#39;.&#x2F;components&#x2F;home&#x2F;home&#39;</span><br><span class="line">const router &#x3D;  new VueRouter(&#123;</span><br><span class="line">  mode: &#39;history&#39;,  &#x2F;&#x2F; 可选值: &quot;hash&quot; 、 &quot;history&quot; 、 &quot;abstract&quot; </span><br><span class="line">  linkActiveClass: &#39;active&#39;,  &#x2F;&#x2F; 默认值: &quot;router-link-active&quot; 全局配置 &lt;router-link&gt; 的默认『激活 class 类名』</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: &quot;&#x2F;tabs&quot;,    &#x2F;&#x2F; 指向的路径</span><br><span class="line">      name: &quot;tabs&quot;,   &#x2F;&#x2F; 命名路由，可以通过这个名称跳转到这个组件</span><br><span class="line">      component: tabs, &#x2F;&#x2F; 指向路径加载的组件</span><br><span class="line">      children: [  &#x2F;&#x2F; 嵌套路由也有跟父级一样的选项</span><br><span class="line">        &#123;</span><br><span class="line">          path:&quot;home&quot;,</span><br><span class="line">          name: &quot;home&quot;,</span><br><span class="line">          component: home, </span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      path: &#39;&#x2F;&#39;,</span><br><span class="line">      redirect: &#39;&#x2F;tabs&#x2F;home&#39;   &#x2F;&#x2F; 重定向，即无目标地址的时候转到这个路径</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;);</span><br><span class="line">export default router;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; main.js</span><br><span class="line">import router from &#39;.&#x2F;router.js&#39;</span><br><span class="line">new Vue(&#123;</span><br><span class="line">  router,</span><br><span class="line">  render: h &#x3D;&gt; h(App)</span><br><span class="line">&#125;).$mount(&#39;#app&#39;);</span><br></pre></td></tr></table></figure><ul><li><a href="https://router.vuejs.org/zh/api/#router-link" target="_blank" rel="noopener">router-link</a> 的几种跳转方式</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 字符串模式，可以说是静态模式，不用v-bind --&gt;</span><br><span class="line">&lt;router-link to&#x3D;&quot;home&quot;&gt;Home&lt;&#x2F;router-link&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 下面几种是动态模式 --&gt;</span><br><span class="line">&lt;!-- 使用 v-bind 的 JS 表达式 --&gt;</span><br><span class="line">&lt;router-link v-bind:to&#x3D;&quot;&#39;home&#39;&quot;&gt;Home&lt;&#x2F;router-link&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 不写 v-bind 也可以，就像绑定别的属性一样 --&gt;</span><br><span class="line">&lt;router-link :to&#x3D;&quot;&#39;home&#39;&quot;&gt;Home&lt;&#x2F;router-link&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 同上 --&gt;</span><br><span class="line">&lt;router-link :to&#x3D;&quot;&#123; path: &#39;home&#39; &#125;&quot;&gt;Home&lt;&#x2F;router-link&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 跳转到命名的路由 --&gt;</span><br><span class="line">&lt;!-- 这里有需要注意的地方是，如果路由有传值，那这里的params 就不能省略--&gt;</span><br><span class="line">&lt;router-link :to&#x3D;&quot;&#123; name: &#39;user&#39; , params: &#123; userId &#125;&#125;&quot;&gt;User&lt;&#x2F;router-link&gt;</span><br></pre></td></tr></table></figure><ul><li>router 传值的几种方式<br><strong>注意：如果提供了 path，params 会被忽略，取而代之的是提供路由的 name 或手写完整的带有参数的 path，同样的规则也适用于 router-link 组件的 to 属性</strong></li><li>另外的传参方式，有兴趣可以了解一下 <a href="https://router.vuejs.org/zh/guide/essentials/passing-props.html#%E5%B8%83%E5%B0%94%E6%A8%A1%E5%BC%8F" target="_blank" rel="noopener">props</a></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 在函数里面</span><br><span class="line">this.$router.push(&#123; name: &#39;user&#39;, params: &#123; userId &#125;&#125;)</span><br><span class="line">this.$router.push(&#123; path: &#96;&#x2F;user&#x2F;$&#123;userId&#125;&#96; &#125;)  &#x2F;&#x2F; &#96;$&#123; &#125;&#96; 是ES6 的模板字符串概念，标识符是 &#96; &#96;</span><br><span class="line">&#x2F;&#x2F; 这里的 params 不生效</span><br><span class="line">this.$router.push(&#123; path: &#39;&#x2F;user&#39;, params: &#123; userId &#125;&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; router-link 传值</span><br><span class="line">&lt;router-link :to&#x3D;&quot;&#123; name: &#39;user&#39;,params: &#123; userId &#125; &#125;&quot;&gt;User&lt;&#x2F;router-link&gt;</span><br><span class="line">&lt;router-link :to&#x3D;&quot;&#123; path: &#96;&#x2F;user&#x2F;$&#123;userId&#125;&#96; &#125;&quot;&gt;User&lt;&#x2F;router-link&gt;</span><br><span class="line">&#x2F;&#x2F; 这里的 params 不生效</span><br><span class="line">&lt;router-link :to&#x3D;&quot;&#123; path: &#39;&#x2F;user&#39;, params: &#123; userId &#125;&#125;&quot;&gt;User&lt;&#x2F;router-link&gt;</span><br></pre></td></tr></table></figure><ul><li>目标组件取值<br><strong>这里要很小心，是 this.$route，不是 this.$router，没有 r 的</strong></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 使用这种方式获取路由传过来的值</span><br><span class="line">this.$route.params.userId</span><br></pre></td></tr></table></figure><ul><li>路由的命名视图，这里贴的是官网的例子，官网API <a href="https://router.vuejs.org/zh/guide/essentials/named-views.html#%E5%B5%8C%E5%A5%97%E5%91%BD%E5%90%8D%E8%A7%86%E5%9B%BE" target="_blank" rel="noopener">点这里</a></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- html --&gt;</span><br><span class="line">&lt;router-view class&#x3D;&quot;view one&quot;&gt;&lt;&#x2F;router-view&gt;</span><br><span class="line">&lt;router-view class&#x3D;&quot;view two&quot; name&#x3D;&quot;a&quot;&gt;&lt;&#x2F;router-view&gt;</span><br><span class="line">&lt;router-view class&#x3D;&quot;view three&quot; name&#x3D;&quot;b&quot;&gt;&lt;&#x2F;router-view&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js</span><br><span class="line">const router &#x3D; new VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: &#39;&#x2F;&#39;,</span><br><span class="line">      components: &#123; &#x2F;&#x2F; 这里的 &#96;components&#96; 要跟上面的 &#96;component&#96; 区分一下，有多个视图渲染的时候有 &#96;s&#96;，别漏了</span><br><span class="line">        default: Foo,  &#x2F;&#x2F; 这是默认指定的 Foo 这个组件，也就是在没有命名的&lt;router-view&gt;上渲染</span><br><span class="line">        a: Bar,  &#x2F;&#x2F; 这里一一对应有 name 属性的&lt;router-view&gt;就可以了</span><br><span class="line">        b: Baz</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>几种导航的方法，官网 <a href="https://router.vuejs.org/zh/guide/essentials/navigation.html" target="_blank" rel="noopener">点这里</a><br>下面几种方法跟 window.history 的几种方法很像，其实就是仿照 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/History" target="_blank" rel="noopener">window.history</a></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 往路由历史新增一条记录，相关参数参考官网</span><br><span class="line">this.$router.push(location, onComplete?, onAbort?)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 替换掉当前的记录</span><br><span class="line">this.$router.replace(location, onComplete?, onAbort?)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 在浏览器记录中前进一步，等同于 this.$router.forward()</span><br><span class="line">this.$router.go(1)</span><br><span class="line">this.$router.forward()</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 后退一步记录，等同于 this.$router.back()</span><br><span class="line">this.$router.go(-1)</span><br><span class="line">this.$router.back()</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 前进 3 步记录</span><br><span class="line">this.$router.go(3)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 如果 history 记录不够用，那就默默地失败呗</span><br><span class="line">this.$router.go(-100)</span><br><span class="line">this.$router.go(100)</span><br></pre></td></tr></table></figure><ul><li>路由跳转的时候支持过度动效，感兴趣可以去玩一下，官网 <a href="https://router.vuejs.org/zh/guide/advanced/transitions.html#%E5%8D%95%E4%B8%AA%E8%B7%AF%E7%94%B1%E7%9A%84%E8%BF%87%E6%B8%A1" target="_blank" rel="noopener">点这里</a> （还有其他更加高级的用法要靠自己去<a href="https://router.vuejs.org/zh/guide/advanced/scroll-behavior.html" target="_blank" rel="noopener">查阅</a>了）</li></ul><h4 id="八、axios"><a href="#八、axios" class="headerlink" title="八、axios"></a>八、axios</h4><p><a href="https://www.npmjs.com/package/axios" target="_blank" rel="noopener">axios 英文文档</a><br><a href="https://www.kancloud.cn/yunye/axios/234845" target="_blank" rel="noopener">axios 中文文档 — 对英文文档的翻译</a><br><strong>axios 是基于 ES6 的 Promise 写的，具体可以看</strong> <a href="http://es6.ruanyifeng.com/#docs/promise" target="_blank" rel="noopener">Promise 相关说明</a></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; npm 安装</span><br><span class="line">npm i axiso  &#x2F;&#x2F; 等价于 npm install axios ，i 是 install 的简写</span><br></pre></td></tr></table></figure><p><strong>axios 的一些简单用法</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; GET 请求</span><br><span class="line">&#x2F;&#x2F; 为给定 ID 的 user 创建请求</span><br><span class="line">axios.get(&#39;&#x2F;user?ID&#x3D;12345&#39;)</span><br><span class="line">  .then(function (response) &#123;</span><br><span class="line">    console.log(response);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(function (error) &#123;</span><br><span class="line">    console.log(error);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 上面的请求可以这样做</span><br><span class="line">axios.get(&#39;&#x2F;user&#39;, &#123;</span><br><span class="line">  params: &#123;</span><br><span class="line">    ID: 12345</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">.then(function (response) &#123;</span><br><span class="line">  console.log(response);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(function (error) &#123;</span><br><span class="line">  console.log(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; POST 请求</span><br><span class="line">axios.post(&#39;&#x2F;user&#39;, &#123;</span><br><span class="line">    firstName: &#39;Fred&#39;,</span><br><span class="line">    lastName: &#39;Flintstone&#39;</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(function (response) &#123;</span><br><span class="line">    console.log(response);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(function (error) &#123;</span><br><span class="line">    console.log(error);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;  执行多个并发请求</span><br><span class="line">function getUserAccount() &#123;</span><br><span class="line">  return axios.get(&#39;&#x2F;user&#x2F;12345&#39;);</span><br><span class="line">&#125;</span><br><span class="line">function getUserPermissions() &#123;</span><br><span class="line">  return axios.get(&#39;&#x2F;user&#x2F;12345&#x2F;permissions&#39;);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 这两个方法返回的都是 Promise 对象，这两个请求方法都成功返回的时候，下面方法才返回成功。</span><br><span class="line">&#x2F;&#x2F; 这两个方法中有一个返回不成功就算返回失败 </span><br><span class="line">axios.all([getUserAccount(), getUserPermissions()])</span><br><span class="line">  .then(axios.spread(function (acct, perms) &#123;</span><br><span class="line">    &#x2F;&#x2F; 两个请求现在都执行完成</span><br><span class="line">  &#125;));</span><br></pre></td></tr></table></figure><p><strong>通过向 axios 传递相关配置来创建请求</strong></p><ul><li>axios(config)</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 发送 POST 请求</span><br><span class="line">axios(&#123;</span><br><span class="line">  method: &#39;post&#39;,</span><br><span class="line">  url: &#39;&#x2F;user&#x2F;12345&#39;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    firstName: &#39;Fred&#39;,</span><br><span class="line">    lastName: &#39;Flintstone&#39;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>axios(url[, config])</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 发送 GET 请求（默认的方法）</span><br><span class="line">axios(&#39;&#x2F;user&#x2F;12345&#39;);</span><br></pre></td></tr></table></figure><p><strong>为方便，axios 还为支持的请求方法提供了别名，如：</strong><br><em>注意：在使用别名方法时， url、method、data 这些属性都不必在配置中指定。</em></p><ul><li>axios.request(config)</li><li>axios.get(url[, config])</li><li>axios.delete(url[, config])</li><li>axios.head(url[, config])</li><li>axios.post(url[, data[, config]])</li><li>axios.put(url[, data[, config]])</li><li>axios.patch(url[, data[, config]])</li></ul><p><strong>处理并发请求的助手函数</strong></p><ul><li>axios.all(iterable)</li><li>axios.spread(callback)</li></ul><p><strong>还有其他高级用法，具体请查阅官网</strong> <a href="https://www.npmjs.com/package/axios" target="_blank" rel="noopener">axios 英文文档</a></p>]]></content>
    
    <summary type="html">
    
      前端体系、前后端分离
    
    </summary>
    
    
      <category term="Vue" scheme="https://SomunsTao.github.io/categories/Vue/"/>
    
    
      <category term="Vue" scheme="https://SomunsTao.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue 11：实战快速上手</title>
    <link href="https://somunstao.github.io/2020/04/21/Vue%2011%EF%BC%9A%E5%AE%9E%E6%88%98%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/"/>
    <id>https://somunstao.github.io/2020/04/21/Vue%2011%EF%BC%9A%E5%AE%9E%E6%88%98%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/</id>
    <published>2020-04-20T16:00:00.000Z</published>
    <updated>2020-08-01T15:19:27.256Z</updated>
    
    <content type="html"><![CDATA[<p>​    </p><h1 id="Vue：实战快速上手"><a href="#Vue：实战快速上手" class="headerlink" title="Vue：实战快速上手"></a>Vue：实战快速上手</h1><p>我们采用实战教学模式并结合 <code>ElementUI</code> 组件库，将所需知识点应用到实际中，以最快速度带领大家掌握 Vue 的使用;</p><h2 id="创建工程"><a href="#创建工程" class="headerlink" title="创建工程"></a>创建工程</h2><p>注意： 命令行都要使用管理员模式运行</p><p>1、创建一个名为 hello-vue 的工程 <code>vue init webpack hello-vue</code><br>2、安装依赖，我们需要安装 vue-router、element-ui、sass-loader 和 node-sass 四个插件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 进入工程目录</span><br><span class="line">cd hello-vue</span><br><span class="line"># 安装 vue-router</span><br><span class="line">npm install vue-router --save-dev</span><br><span class="line"># 安装 element-ui</span><br><span class="line">npm i element-ui -S</span><br><span class="line"># 安装依赖</span><br><span class="line">npm install</span><br><span class="line"># 安装 SASS 加载器</span><br><span class="line">cnpm install sass-loader node-sass --save-dev</span><br><span class="line"># 启动测试</span><br><span class="line">npm run dev</span><br></pre></td></tr></table></figure><p>3、Npm命令解释：</p><ul><li><code>npm install moduleName</code>：安装模块到项目目录下</li><li><code>npm install -g moduleName</code>：-g 的意思是将模块安装到全局，具体安装到磁盘哪个位置，要看 npm config prefix 的位置</li><li><code>npm install -save moduleName</code>：–save 的意思是将模块安装到项目目录下，并在 package 文件的 dependencies 节点写入依赖，-S 为该命令的缩写</li><li><code>npm install -save-dev moduleNam</code>e：–save-dev 的意思是将模块安装到项目目录下，并在 package 文件的 devDependencies 节点写入依赖，-D 为该命令的缩写</li></ul><h2 id="创建登录页面"><a href="#创建登录页面" class="headerlink" title="创建登录页面"></a>创建登录页面</h2><p>把没有用的初始化东西删掉！</p><p>在源码目录中创建如下结构：</p><ul><li>assets：用于存放资源文件</li><li>components：用于存放 Vue 功能组件</li><li>views：用于存放 Vue 视图组件</li><li>router：用于存放 vue-router 配置</li></ul><p><img src="https://blog.kuangstudy.com/usr/uploads/2019/10/1596391106.jpg" alt="QQ截图20191025101406.jpg"></p><p><strong>创建首页视图，在 views 目录下创建一个名为 Main.vue 的视图组件；</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      首页</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    export default &#123;</span><br><span class="line">        name: &quot;Main&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure><p><strong>创建登录页视图在 views 目录下创建一个名为 Login.vue 的视图组件，其中 el-* 的元素为 ElementUI 组件；</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;el-form ref&#x3D;&quot;loginForm&quot; :model&#x3D;&quot;form&quot; :rules&#x3D;&quot;rules&quot; label-width&#x3D;&quot;80px&quot; class&#x3D;&quot;login-box&quot;&gt;</span><br><span class="line">      &lt;h3 class&#x3D;&quot;login-title&quot;&gt;欢迎登录&lt;&#x2F;h3&gt;</span><br><span class="line">      &lt;el-form-item label&#x3D;&quot;账号&quot; prop&#x3D;&quot;username&quot;&gt;</span><br><span class="line">        &lt;el-input type&#x3D;&quot;text&quot; placeholder&#x3D;&quot;请输入账号&quot; v-model&#x3D;&quot;form.username&quot;&#x2F;&gt;</span><br><span class="line">      &lt;&#x2F;el-form-item&gt;</span><br><span class="line">      &lt;el-form-item label&#x3D;&quot;密码&quot; prop&#x3D;&quot;password&quot;&gt;</span><br><span class="line">        &lt;el-input type&#x3D;&quot;password&quot; placeholder&#x3D;&quot;请输入密码&quot; v-model&#x3D;&quot;form.password&quot;&#x2F;&gt;</span><br><span class="line">      &lt;&#x2F;el-form-item&gt;</span><br><span class="line">      &lt;el-form-item&gt;</span><br><span class="line">        &lt;el-button type&#x3D;&quot;primary&quot; v-on:click&#x3D;&quot;onSubmit(&#39;loginForm&#39;)&quot;&gt;登录&lt;&#x2F;el-button&gt;</span><br><span class="line">      &lt;&#x2F;el-form-item&gt;</span><br><span class="line">    &lt;&#x2F;el-form&gt;</span><br><span class="line"></span><br><span class="line">    &lt;el-dialog</span><br><span class="line">      title&#x3D;&quot;温馨提示&quot;</span><br><span class="line">      :visible.sync&#x3D;&quot;dialogVisible&quot;</span><br><span class="line">      width&#x3D;&quot;30%&quot;</span><br><span class="line">      :before-close&#x3D;&quot;handleClose&quot;&gt;</span><br><span class="line">      &lt;span&gt;请输入账号和密码&lt;&#x2F;span&gt;</span><br><span class="line">      &lt;span slot&#x3D;&quot;footer&quot; class&#x3D;&quot;dialog-footer&quot;&gt;</span><br><span class="line">        &lt;el-button type&#x3D;&quot;primary&quot; @click&#x3D;&quot;dialogVisible &#x3D; false&quot;&gt;确 定&lt;&#x2F;el-button&gt;</span><br><span class="line">      &lt;&#x2F;span&gt;</span><br><span class="line">    &lt;&#x2F;el-dialog&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    name: &quot;Login&quot;,</span><br><span class="line">    data() &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        form: &#123;</span><br><span class="line">          username: &#39;&#39;,</span><br><span class="line">          password: &#39;&#39;</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 表单验证，需要在 el-form-item 元素中增加 prop 属性</span><br><span class="line">        rules: &#123;</span><br><span class="line">          username: [</span><br><span class="line">            &#123;required: true, message: &#39;账号不可为空&#39;, trigger: &#39;blur&#39;&#125;</span><br><span class="line">          ],</span><br><span class="line">          password: [</span><br><span class="line">            &#123;required: true, message: &#39;密码不可为空&#39;, trigger: &#39;blur&#39;&#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 对话框显示和隐藏</span><br><span class="line">        dialogVisible: false</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      onSubmit(formName) &#123;</span><br><span class="line">        &#x2F;&#x2F; 为表单绑定验证功能</span><br><span class="line">        this.$refs[formName].validate((valid) &#x3D;&gt; &#123;</span><br><span class="line">          if (valid) &#123;</span><br><span class="line">            &#x2F;&#x2F; 使用 vue-router 路由到指定页面，该方式称之为编程式导航</span><br><span class="line">            this.$router.push(&quot;&#x2F;main&quot;);</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">            this.dialogVisible &#x3D; true;</span><br><span class="line">            return false;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style lang&#x3D;&quot;scss&quot; scoped&gt;</span><br><span class="line">  .login-box &#123;</span><br><span class="line">    border: 1px solid #DCDFE6;</span><br><span class="line">    width: 350px;</span><br><span class="line">    margin: 180px auto;</span><br><span class="line">    padding: 35px 35px 15px 35px;</span><br><span class="line">    border-radius: 5px;</span><br><span class="line">    -webkit-border-radius: 5px;</span><br><span class="line">    -moz-border-radius: 5px;</span><br><span class="line">    box-shadow: 0 0 25px #909399;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  .login-title &#123;</span><br><span class="line">    text-align: center;</span><br><span class="line">    margin: 0 auto 40px auto;</span><br><span class="line">    color: #303133;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure><p><strong>创建路由,在 router 目录下创建一个名为 index.js 的 vue-router 路由配置文件</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import Vue from &#39;vue&#39;</span><br><span class="line">import Router from &#39;vue-router&#39;</span><br><span class="line"></span><br><span class="line">import Login from &quot;..&#x2F;views&#x2F;Login&quot;</span><br><span class="line">import Main from &#39;..&#x2F;views&#x2F;Main&#39;</span><br><span class="line"></span><br><span class="line">Vue.use(Router);</span><br><span class="line"></span><br><span class="line">export default new Router(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      &#x2F;&#x2F; 登录页</span><br><span class="line">      path: &#39;&#x2F;login&#39;,</span><br><span class="line">      name: &#39;Login&#39;,</span><br><span class="line">      component: Login</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &#x2F;&#x2F; 首页</span><br><span class="line">      path: &#39;&#x2F;main&#39;,</span><br><span class="line">      name: &#39;Main&#39;,</span><br><span class="line">      component: Main</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>配置路由，修改入口代码，修改 main.js 入口代码</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import Vue from &#39;vue&#39;</span><br><span class="line">import VueRouter from &#39;vue-router&#39;</span><br><span class="line">import router from &#39;.&#x2F;router&#39;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 导入 ElementUI</span><br><span class="line">import ElementUI from &#39;element-ui&#39;</span><br><span class="line">import &#39;element-ui&#x2F;lib&#x2F;theme-chalk&#x2F;index.css&#39;</span><br><span class="line"></span><br><span class="line">import App from &#39;.&#x2F;App&#39;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 安装路由</span><br><span class="line">Vue.use(VueRouter);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 安装 ElementUI</span><br><span class="line">Vue.use(ElementUI);</span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: &#39;#app&#39;,</span><br><span class="line">  &#x2F;&#x2F; 启用路由</span><br><span class="line">  router,</span><br><span class="line">  &#x2F;&#x2F; 启用 ElementUI</span><br><span class="line">  render: h &#x3D;&gt; h(App)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>修改 App.vue 组件代码</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">    &lt;router-view&#x2F;&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    name: &#39;App&#39;,</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>测试 ： 在浏览器打开 <a href="http://localhost/" target="_blank" rel="noopener">http://localhost</a>:8080/#/login</p><p>如果出现错误: 可能是因为sass-loader的版本过高导致的编译错误，当前最高版本是8.x，需要退回到7.3.1 ；</p><p>去package.json文件里面的 “sass-loader”的版本更换成7.3.1，然后重新<code>cnpm install</code>就可以了；</p><p><img src="https://blog.kuangstudy.com/usr/uploads/2019/10/1972241333.jpg" alt="QQ截图20191025111608.jpg"></p><h2 id="路由嵌套"><a href="#路由嵌套" class="headerlink" title="路由嵌套"></a>路由嵌套</h2><p>嵌套路由又称子路由，在实际应用中，通常由多层嵌套的组件组合而成。同样地，URL 中各段动态路径也按某种结构对应嵌套的各层组件，例如：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;user&#x2F;foo&#x2F;profile                     &#x2F;user&#x2F;foo&#x2F;posts</span><br><span class="line">+------------------+                  +-----------------+</span><br><span class="line">| User             |                  | User            |</span><br><span class="line">| +--------------+ |                  | +-------------+ |</span><br><span class="line">| | Profile      | |  +------------&gt;  | | Posts       | |</span><br><span class="line">| |              | |                  | |             | |</span><br><span class="line">| +--------------+ |                  | +-------------+ |</span><br><span class="line">+------------------+                  +-----------------+</span><br></pre></td></tr></table></figure><p>1、用户信息组件，在 views/user 目录下创建一个名为 Profile.vue 的视图组件；</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      个人信息</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    export default &#123;</span><br><span class="line">        name: &quot;UserProfile&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure><p>2、用户列表组件在 views/user 目录下创建一个名为 List.vue 的视图组件；</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      用户列表</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    export default &#123;</span><br><span class="line">        name: &quot;UserList&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure><p>3、配置嵌套路由修改 router 目录下的 index.js 路由配置文件，代码如</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import Vue from &#39;vue&#39;</span><br><span class="line">import Router from &#39;vue-router&#39;</span><br><span class="line"></span><br><span class="line">import Login from &quot;..&#x2F;views&#x2F;Login&quot;</span><br><span class="line">import Main from &#39;..&#x2F;views&#x2F;Main&#39;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 用于嵌套的路由组件</span><br><span class="line">import UserProfile from &#39;..&#x2F;views&#x2F;user&#x2F;Profile&#39;</span><br><span class="line">import UserList from &#39;..&#x2F;views&#x2F;user&#x2F;List&#39;</span><br><span class="line"></span><br><span class="line">Vue.use(Router);</span><br><span class="line"></span><br><span class="line">export default new Router(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      &#x2F;&#x2F; 登录页</span><br><span class="line">      path: &#39;&#x2F;login&#39;,</span><br><span class="line">      name: &#39;Login&#39;,</span><br><span class="line">      component: Login</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &#x2F;&#x2F; 首页</span><br><span class="line">      path: &#39;&#x2F;main&#39;,</span><br><span class="line">      name: &#39;Main&#39;,</span><br><span class="line">      component: Main,</span><br><span class="line">      &#x2F;&#x2F; 配置嵌套路由</span><br><span class="line">      children: [</span><br><span class="line">        &#123;path: &#39;&#x2F;user&#x2F;profile&#39;, component: UserProfile&#125;,</span><br><span class="line">        &#123;path: &#39;&#x2F;user&#x2F;list&#39;, component: UserList&#125;,</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>说明：主要在路由配置中增加了 children 数组配置，用于在该组件下设置嵌套路由</p><p>4、修改首页视图，我们修改 Main.vue 视图组件，此处使用了 ElementUI 布局容器组件，代码如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;el-container&gt;</span><br><span class="line">        &lt;el-aside width&#x3D;&quot;200px&quot;&gt;</span><br><span class="line">          &lt;el-menu :default-openeds&#x3D;&quot;[&#39;1&#39;]&quot;&gt;</span><br><span class="line">            &lt;el-submenu index&#x3D;&quot;1&quot;&gt;</span><br><span class="line">              &lt;template slot&#x3D;&quot;title&quot;&gt;&lt;i class&#x3D;&quot;el-icon-caret-right&quot;&gt;&lt;&#x2F;i&gt;用户管理&lt;&#x2F;template&gt;</span><br><span class="line">              &lt;el-menu-item-group&gt;</span><br><span class="line">                &lt;el-menu-item index&#x3D;&quot;1-1&quot;&gt;</span><br><span class="line">                  &lt;router-link to&#x3D;&quot;&#x2F;user&#x2F;profile&quot;&gt;个人信息&lt;&#x2F;router-link&gt;</span><br><span class="line">                &lt;&#x2F;el-menu-item&gt;</span><br><span class="line">                &lt;el-menu-item index&#x3D;&quot;1-2&quot;&gt;</span><br><span class="line">                  &lt;router-link to&#x3D;&quot;&#x2F;user&#x2F;list&quot;&gt;用户列表&lt;&#x2F;router-link&gt;</span><br><span class="line">                &lt;&#x2F;el-menu-item&gt;</span><br><span class="line">              &lt;&#x2F;el-menu-item-group&gt;</span><br><span class="line">            &lt;&#x2F;el-submenu&gt;</span><br><span class="line">            &lt;el-submenu index&#x3D;&quot;2&quot;&gt;</span><br><span class="line">              &lt;template slot&#x3D;&quot;title&quot;&gt;&lt;i class&#x3D;&quot;el-icon-caret-right&quot;&gt;&lt;&#x2F;i&gt;内容管理&lt;&#x2F;template&gt;</span><br><span class="line">              &lt;el-menu-item-group&gt;</span><br><span class="line">                &lt;el-menu-item index&#x3D;&quot;2-1&quot;&gt;分类管理&lt;&#x2F;el-menu-item&gt;</span><br><span class="line">                &lt;el-menu-item index&#x3D;&quot;2-2&quot;&gt;内容列表&lt;&#x2F;el-menu-item&gt;</span><br><span class="line">              &lt;&#x2F;el-menu-item-group&gt;</span><br><span class="line">            &lt;&#x2F;el-submenu&gt;</span><br><span class="line">          &lt;&#x2F;el-menu&gt;</span><br><span class="line">        &lt;&#x2F;el-aside&gt;</span><br><span class="line"></span><br><span class="line">        &lt;el-container&gt;</span><br><span class="line">          &lt;el-header style&#x3D;&quot;text-align: right; font-size: 12px&quot;&gt;</span><br><span class="line">            &lt;el-dropdown&gt;</span><br><span class="line">              &lt;i class&#x3D;&quot;el-icon-setting&quot; style&#x3D;&quot;margin-right: 15px&quot;&gt;&lt;&#x2F;i&gt;</span><br><span class="line">              &lt;el-dropdown-menu slot&#x3D;&quot;dropdown&quot;&gt;</span><br><span class="line">                &lt;el-dropdown-item&gt;个人信息&lt;&#x2F;el-dropdown-item&gt;</span><br><span class="line">                &lt;el-dropdown-item&gt;退出登录&lt;&#x2F;el-dropdown-item&gt;</span><br><span class="line">              &lt;&#x2F;el-dropdown-menu&gt;</span><br><span class="line">            &lt;&#x2F;el-dropdown&gt;</span><br><span class="line">          &lt;&#x2F;el-header&gt;</span><br><span class="line"></span><br><span class="line">          &lt;el-main&gt;</span><br><span class="line">            &lt;router-view &#x2F;&gt;</span><br><span class="line">          &lt;&#x2F;el-main&gt;</span><br><span class="line">        &lt;&#x2F;el-container&gt;</span><br><span class="line">      &lt;&#x2F;el-container&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    export default &#123;</span><br><span class="line">        name: &quot;Main&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped lang&#x3D;&quot;scss&quot;&gt;</span><br><span class="line">  .el-header &#123;</span><br><span class="line">    background-color: #B3C0D1;</span><br><span class="line">    color: #333;</span><br><span class="line">    line-height: 60px;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  .el-aside &#123;</span><br><span class="line">    color: #333;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure><p>说明：</p><p>在 <el-main> 元素中配置了 <router-view /> 用于展示嵌套路由,主要使用 <router-link to="/user/profile">个人信息</router-link> 展示嵌套路由内容</p><h2 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h2><p>我们经常需要把某种模式匹配到的所有路由，全都映射到同个组件。例如，我们有一个 User 组件，对于所有 ID 各不相同的用户，都要使用这个组件来渲染。此时我们就需要传递参数了；</p><p>1、修改路由配置, 主要是在 path 属性中增加了 :id 这样的占位符</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;path: &#39;&#x2F;user&#x2F;profile&#x2F;:id&#39;, name:&#39;UserProfile&#39;, component: UserProfile&#125;</span><br></pre></td></tr></table></figure><p>2、传递参数</p><p>此时我们将 to 改为了 :to，是为了将这一属性当成对象使用，注意 router-link 中的 name 属性名称 一定要和 路由中的 name 属性名称 匹配，因为这样 Vue 才能找到对应的路由路径；</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;router-link :to&#x3D;&quot;&#123;name: &#39;UserProfile&#39;, params: &#123;id: 1&#125;&#125;&quot;&gt;个人信息&lt;&#x2F;router-link&gt;</span><br></pre></td></tr></table></figure><p>3、接收参数, 在目标组件中</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&#123; $route.params.id &#125;&#125;</span><br></pre></td></tr></table></figure><h3 id="使用-props-的方式"><a href="#使用-props-的方式" class="headerlink" title="使用 props 的方式"></a>使用 props 的方式</h3><p>1、修改路由配置 , 主要增加了 props: true 属性</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;path: &#39;&#x2F;user&#x2F;profile&#x2F;:id&#39;, name:&#39;UserProfile&#39;, component: UserProfile, props: true&#125;</span><br></pre></td></tr></table></figure><p>2、传递参数和之前一样<br>3、接收参数为目标组件增加 props 属性</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    个人信息</span><br><span class="line">    &#123;&#123; id &#125;&#125;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    export default &#123;</span><br><span class="line">      props: [&#39;id&#39;],</span><br><span class="line">      name: &quot;UserProfile&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure><h2 id="组件重定向"><a href="#组件重定向" class="headerlink" title="组件重定向"></a>组件重定向</h2><p>重定向的意思大家都明白，但 Vue 中的重定向是作用在路径不同但组件相同的情况下，比如：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  path: &#39;&#x2F;main&#39;,</span><br><span class="line">  name: &#39;Main&#39;,</span><br><span class="line">  component: Main</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">  path: &#39;&#x2F;goHome&#39;,</span><br><span class="line">  redirect: &#39;&#x2F;main&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：这里定义了两个路径，一个是 /main ，一个是 /goHome，其中 /goHome 重定向到了 /main 路径，由此可以看出重定向不需要定义组件；</p><p>使用的话，只需要设置对应路径即可；</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;el-menu-item index&#x3D;&quot;1-3&quot;&gt;</span><br><span class="line">    &lt;router-link to&#x3D;&quot;&#x2F;goHome&quot;&gt;回到首页&lt;&#x2F;router-link&gt;</span><br><span class="line">&lt;&#x2F;el-menu-item&gt;</span><br></pre></td></tr></table></figure><h2 id="路由模式与-404"><a href="#路由模式与-404" class="headerlink" title="路由模式与 404"></a>路由模式与 404</h2><p>路由模式有两种</p><ul><li>hash：路径带 # 符号，如 <a href="http://localhost/#/login" target="_blank" rel="noopener">http://localhost/#/login</a></li><li>history：路径不带 # 符号，如 <a href="http://localhost/login" target="_blank" rel="noopener">http://localhost/login</a></li></ul><p>修改路由配置，代码如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export default new Router(&#123;</span><br><span class="line">  mode: &#39;history&#39;,</span><br><span class="line">  routes: [</span><br><span class="line">  ]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>处理 404</strong> 创建一个名为 <code>NotFound.vue</code> 的视图组件，代码如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    页面不存在，请重试！</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    name: &quot;NotFount&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure><p>修改路由配置，代码如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import NotFound from &#39;..&#x2F;views&#x2F;NotFound&#39;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">   path: &#39;*&#39;,</span><br><span class="line">   component: NotFound</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="路由钩子与异步请求"><a href="#路由钩子与异步请求" class="headerlink" title="路由钩子与异步请求"></a>路由钩子与异步请求</h3><p><code>beforeRouteEnter</code>：在进入路由前执行<br><code>beforeRouteLeave</code>：在离开路由前执行</p><p>上代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">  props: [&#39;id&#39;],</span><br><span class="line">  name: &quot;UserProfile&quot;,</span><br><span class="line">  beforeRouteEnter: (to, from, next) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&quot;准备进入个人信息页&quot;);</span><br><span class="line">    next();</span><br><span class="line">  &#125;,</span><br><span class="line">  beforeRouteLeave: (to, from, next) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&quot;准备离开个人信息页&quot;);</span><br><span class="line">    next();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li>to：路由将要跳转的路径信息</li><li>from：路径跳转前的路径信息</li><li>next：路由的控制参数<ul><li>next() 跳入下一个页面</li><li>next(‘/path’) 改变路由的跳转方向，使其跳到另一个路由</li><li>next(false) 返回原来的页面</li><li>next((vm)=&gt;{}) 仅在 beforeRouteEnter 中可用，vm 是组件实例</li></ul></li></ul><p><strong>在钩子函数中使用异步请求</strong></p><p>1、安装 Axios <code>cnpm install axios -s</code><br>2、<code>main.js</code>引用 Axios</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import axios from &#39;axios&#39;</span><br><span class="line">Vue.prototype.axios &#x3D; axios;</span><br></pre></td></tr></table></figure><p>3、准备数据 ： 只有我们的 static 目录下的文件是可以被访问到的，所以我们就把静态文件放入该目录下。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 静态数据存放的位置</span><br><span class="line">static&#x2F;mock&#x2F;data.json</span><br></pre></td></tr></table></figure><p>4、在 beforeRouteEnter 中进行异步请求</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">   props: [&#39;id&#39;],</span><br><span class="line">   name: &quot;UserProfile&quot;,</span><br><span class="line">   beforeRouteEnter: (to, from, next) &#x3D;&gt; &#123;</span><br><span class="line">     console.log(&quot;准备进入个人信息页&quot;);</span><br><span class="line">     &#x2F;&#x2F; 注意，一定要在 next 中请求，因为该方法调用时 Vue 实例还没有创建，此时无法获取到 this 对象，在这里使用官方提供的回调函数拿到当前实例</span><br><span class="line">     next(vm &#x3D;&gt; &#123;</span><br><span class="line">       vm.getData();</span><br><span class="line">     &#125;);</span><br><span class="line">   &#125;,</span><br><span class="line">   beforeRouteLeave: (to, from, next) &#x3D;&gt; &#123;</span><br><span class="line">     console.log(&quot;准备离开个人信息页&quot;);</span><br><span class="line">     next();</span><br><span class="line">   &#125;,</span><br><span class="line">   methods: &#123;</span><br><span class="line">     getData: function () &#123;</span><br><span class="line">       this.axios(&#123;</span><br><span class="line">         method: &#39;get&#39;,</span><br><span class="line">         url: &#39;http:&#x2F;&#x2F;localhost:8080&#x2F;static&#x2F;mock&#x2F;data.json&#39;</span><br><span class="line">       &#125;).then(function (repos) &#123;</span><br><span class="line">         console.log(repos);</span><br><span class="line">       &#125;).catch(function (error) &#123;</span><br><span class="line">         console.log(error);</span><br><span class="line">       &#125;);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      前端体系、前后端分离
    
    </summary>
    
    
      <category term="Vue" scheme="https://SomunsTao.github.io/categories/Vue/"/>
    
    
      <category term="Vue" scheme="https://SomunsTao.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue 10：实战快速上手</title>
    <link href="https://somunstao.github.io/2020/04/20/Vue%2010%EF%BC%9A%E5%AE%9E%E6%88%98%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/"/>
    <id>https://somunstao.github.io/2020/04/20/Vue%2010%EF%BC%9A%E5%AE%9E%E6%88%98%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/</id>
    <published>2020-04-19T16:00:00.000Z</published>
    <updated>2020-08-01T15:19:07.123Z</updated>
    
    <content type="html"><![CDATA[<p>​    </p><h1 id="Vue：实战快速上手"><a href="#Vue：实战快速上手" class="headerlink" title="Vue：实战快速上手"></a>Vue：实战快速上手</h1><p>我们采用实战教学模式并结合 <code>ElementUI</code> 组件库，将所需知识点应用到实际中，以最快速度带领大家掌握 Vue 的使用;</p><h2 id="创建工程"><a href="#创建工程" class="headerlink" title="创建工程"></a>创建工程</h2><p>注意： 命令行都要使用管理员模式运行</p><p>1、创建一个名为 hello-vue 的工程 <code>vue init webpack hello-vue</code><br>2、安装依赖，我们需要安装 vue-router、element-ui、sass-loader 和 node-sass 四个插件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 进入工程目录</span><br><span class="line">cd hello-vue</span><br><span class="line"># 安装 vue-router</span><br><span class="line">npm install vue-router --save-dev</span><br><span class="line"># 安装 element-ui</span><br><span class="line">npm i element-ui -S</span><br><span class="line"># 安装依赖</span><br><span class="line">npm install</span><br><span class="line"># 安装 SASS 加载器</span><br><span class="line">cnpm install sass-loader node-sass --save-dev</span><br><span class="line"># 启动测试</span><br><span class="line">npm run dev</span><br></pre></td></tr></table></figure><p>3、Npm命令解释：</p><ul><li><code>npm install moduleName</code>：安装模块到项目目录下</li><li><code>npm install -g moduleName</code>：-g 的意思是将模块安装到全局，具体安装到磁盘哪个位置，要看 npm config prefix 的位置</li><li><code>npm install -save moduleName</code>：–save 的意思是将模块安装到项目目录下，并在 package 文件的 dependencies 节点写入依赖，-S 为该命令的缩写</li><li><code>npm install -save-dev moduleNam</code>e：–save-dev 的意思是将模块安装到项目目录下，并在 package 文件的 devDependencies 节点写入依赖，-D 为该命令的缩写</li></ul><h2 id="创建登录页面"><a href="#创建登录页面" class="headerlink" title="创建登录页面"></a>创建登录页面</h2><p>把没有用的初始化东西删掉！</p><p>在源码目录中创建如下结构：</p><ul><li>assets：用于存放资源文件</li><li>components：用于存放 Vue 功能组件</li><li>views：用于存放 Vue 视图组件</li><li>router：用于存放 vue-router 配置</li></ul><p><img src="https://blog.kuangstudy.com/usr/uploads/2019/10/1596391106.jpg" alt="QQ截图20191025101406.jpg"></p><p><strong>创建首页视图，在 views 目录下创建一个名为 Main.vue 的视图组件；</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      首页</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    export default &#123;</span><br><span class="line">        name: &quot;Main&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure><p><strong>创建登录页视图在 views 目录下创建一个名为 Login.vue 的视图组件，其中 el-* 的元素为 ElementUI 组件；</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;el-form ref&#x3D;&quot;loginForm&quot; :model&#x3D;&quot;form&quot; :rules&#x3D;&quot;rules&quot; label-width&#x3D;&quot;80px&quot; class&#x3D;&quot;login-box&quot;&gt;</span><br><span class="line">      &lt;h3 class&#x3D;&quot;login-title&quot;&gt;欢迎登录&lt;&#x2F;h3&gt;</span><br><span class="line">      &lt;el-form-item label&#x3D;&quot;账号&quot; prop&#x3D;&quot;username&quot;&gt;</span><br><span class="line">        &lt;el-input type&#x3D;&quot;text&quot; placeholder&#x3D;&quot;请输入账号&quot; v-model&#x3D;&quot;form.username&quot;&#x2F;&gt;</span><br><span class="line">      &lt;&#x2F;el-form-item&gt;</span><br><span class="line">      &lt;el-form-item label&#x3D;&quot;密码&quot; prop&#x3D;&quot;password&quot;&gt;</span><br><span class="line">        &lt;el-input type&#x3D;&quot;password&quot; placeholder&#x3D;&quot;请输入密码&quot; v-model&#x3D;&quot;form.password&quot;&#x2F;&gt;</span><br><span class="line">      &lt;&#x2F;el-form-item&gt;</span><br><span class="line">      &lt;el-form-item&gt;</span><br><span class="line">        &lt;el-button type&#x3D;&quot;primary&quot; v-on:click&#x3D;&quot;onSubmit(&#39;loginForm&#39;)&quot;&gt;登录&lt;&#x2F;el-button&gt;</span><br><span class="line">      &lt;&#x2F;el-form-item&gt;</span><br><span class="line">    &lt;&#x2F;el-form&gt;</span><br><span class="line"></span><br><span class="line">    &lt;el-dialog</span><br><span class="line">      title&#x3D;&quot;温馨提示&quot;</span><br><span class="line">      :visible.sync&#x3D;&quot;dialogVisible&quot;</span><br><span class="line">      width&#x3D;&quot;30%&quot;</span><br><span class="line">      :before-close&#x3D;&quot;handleClose&quot;&gt;</span><br><span class="line">      &lt;span&gt;请输入账号和密码&lt;&#x2F;span&gt;</span><br><span class="line">      &lt;span slot&#x3D;&quot;footer&quot; class&#x3D;&quot;dialog-footer&quot;&gt;</span><br><span class="line">        &lt;el-button type&#x3D;&quot;primary&quot; @click&#x3D;&quot;dialogVisible &#x3D; false&quot;&gt;确 定&lt;&#x2F;el-button&gt;</span><br><span class="line">      &lt;&#x2F;span&gt;</span><br><span class="line">    &lt;&#x2F;el-dialog&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    name: &quot;Login&quot;,</span><br><span class="line">    data() &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        form: &#123;</span><br><span class="line">          username: &#39;&#39;,</span><br><span class="line">          password: &#39;&#39;</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 表单验证，需要在 el-form-item 元素中增加 prop 属性</span><br><span class="line">        rules: &#123;</span><br><span class="line">          username: [</span><br><span class="line">            &#123;required: true, message: &#39;账号不可为空&#39;, trigger: &#39;blur&#39;&#125;</span><br><span class="line">          ],</span><br><span class="line">          password: [</span><br><span class="line">            &#123;required: true, message: &#39;密码不可为空&#39;, trigger: &#39;blur&#39;&#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 对话框显示和隐藏</span><br><span class="line">        dialogVisible: false</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      onSubmit(formName) &#123;</span><br><span class="line">        &#x2F;&#x2F; 为表单绑定验证功能</span><br><span class="line">        this.$refs[formName].validate((valid) &#x3D;&gt; &#123;</span><br><span class="line">          if (valid) &#123;</span><br><span class="line">            &#x2F;&#x2F; 使用 vue-router 路由到指定页面，该方式称之为编程式导航</span><br><span class="line">            this.$router.push(&quot;&#x2F;main&quot;);</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">            this.dialogVisible &#x3D; true;</span><br><span class="line">            return false;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style lang&#x3D;&quot;scss&quot; scoped&gt;</span><br><span class="line">  .login-box &#123;</span><br><span class="line">    border: 1px solid #DCDFE6;</span><br><span class="line">    width: 350px;</span><br><span class="line">    margin: 180px auto;</span><br><span class="line">    padding: 35px 35px 15px 35px;</span><br><span class="line">    border-radius: 5px;</span><br><span class="line">    -webkit-border-radius: 5px;</span><br><span class="line">    -moz-border-radius: 5px;</span><br><span class="line">    box-shadow: 0 0 25px #909399;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  .login-title &#123;</span><br><span class="line">    text-align: center;</span><br><span class="line">    margin: 0 auto 40px auto;</span><br><span class="line">    color: #303133;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure><p><strong>创建路由,在 router 目录下创建一个名为 index.js 的 vue-router 路由配置文件</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import Vue from &#39;vue&#39;</span><br><span class="line">import Router from &#39;vue-router&#39;</span><br><span class="line"></span><br><span class="line">import Login from &quot;..&#x2F;views&#x2F;Login&quot;</span><br><span class="line">import Main from &#39;..&#x2F;views&#x2F;Main&#39;</span><br><span class="line"></span><br><span class="line">Vue.use(Router);</span><br><span class="line"></span><br><span class="line">export default new Router(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      &#x2F;&#x2F; 登录页</span><br><span class="line">      path: &#39;&#x2F;login&#39;,</span><br><span class="line">      name: &#39;Login&#39;,</span><br><span class="line">      component: Login</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &#x2F;&#x2F; 首页</span><br><span class="line">      path: &#39;&#x2F;main&#39;,</span><br><span class="line">      name: &#39;Main&#39;,</span><br><span class="line">      component: Main</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>配置路由，修改入口代码，修改 main.js 入口代码</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import Vue from &#39;vue&#39;</span><br><span class="line">import VueRouter from &#39;vue-router&#39;</span><br><span class="line">import router from &#39;.&#x2F;router&#39;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 导入 ElementUI</span><br><span class="line">import ElementUI from &#39;element-ui&#39;</span><br><span class="line">import &#39;element-ui&#x2F;lib&#x2F;theme-chalk&#x2F;index.css&#39;</span><br><span class="line"></span><br><span class="line">import App from &#39;.&#x2F;App&#39;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 安装路由</span><br><span class="line">Vue.use(VueRouter);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 安装 ElementUI</span><br><span class="line">Vue.use(ElementUI);</span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: &#39;#app&#39;,</span><br><span class="line">  &#x2F;&#x2F; 启用路由</span><br><span class="line">  router,</span><br><span class="line">  &#x2F;&#x2F; 启用 ElementUI</span><br><span class="line">  render: h &#x3D;&gt; h(App)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>修改 App.vue 组件代码</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">    &lt;router-view&#x2F;&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    name: &#39;App&#39;,</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>测试 ： 在浏览器打开 <a href="http://localhost/" target="_blank" rel="noopener">http://localhost</a>:8080/#/login</p><p>如果出现错误: 可能是因为sass-loader的版本过高导致的编译错误，当前最高版本是8.x，需要退回到7.3.1 ；</p><p>去package.json文件里面的 “sass-loader”的版本更换成7.3.1，然后重新<code>cnpm install</code>就可以了；</p><p><img src="https://blog.kuangstudy.com/usr/uploads/2019/10/1972241333.jpg" alt="QQ截图20191025111608.jpg"></p><h2 id="路由嵌套"><a href="#路由嵌套" class="headerlink" title="路由嵌套"></a>路由嵌套</h2><p>嵌套路由又称子路由，在实际应用中，通常由多层嵌套的组件组合而成。同样地，URL 中各段动态路径也按某种结构对应嵌套的各层组件，例如：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;user&#x2F;foo&#x2F;profile                     &#x2F;user&#x2F;foo&#x2F;posts</span><br><span class="line">+------------------+                  +-----------------+</span><br><span class="line">| User             |                  | User            |</span><br><span class="line">| +--------------+ |                  | +-------------+ |</span><br><span class="line">| | Profile      | |  +------------&gt;  | | Posts       | |</span><br><span class="line">| |              | |                  | |             | |</span><br><span class="line">| +--------------+ |                  | +-------------+ |</span><br><span class="line">+------------------+                  +-----------------+</span><br></pre></td></tr></table></figure><p>1、用户信息组件，在 views/user 目录下创建一个名为 Profile.vue 的视图组件；</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      个人信息</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    export default &#123;</span><br><span class="line">        name: &quot;UserProfile&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure><p>2、用户列表组件在 views/user 目录下创建一个名为 List.vue 的视图组件；</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      用户列表</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    export default &#123;</span><br><span class="line">        name: &quot;UserList&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure><p>3、配置嵌套路由修改 router 目录下的 index.js 路由配置文件，代码如</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import Vue from &#39;vue&#39;</span><br><span class="line">import Router from &#39;vue-router&#39;</span><br><span class="line"></span><br><span class="line">import Login from &quot;..&#x2F;views&#x2F;Login&quot;</span><br><span class="line">import Main from &#39;..&#x2F;views&#x2F;Main&#39;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 用于嵌套的路由组件</span><br><span class="line">import UserProfile from &#39;..&#x2F;views&#x2F;user&#x2F;Profile&#39;</span><br><span class="line">import UserList from &#39;..&#x2F;views&#x2F;user&#x2F;List&#39;</span><br><span class="line"></span><br><span class="line">Vue.use(Router);</span><br><span class="line"></span><br><span class="line">export default new Router(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      &#x2F;&#x2F; 登录页</span><br><span class="line">      path: &#39;&#x2F;login&#39;,</span><br><span class="line">      name: &#39;Login&#39;,</span><br><span class="line">      component: Login</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &#x2F;&#x2F; 首页</span><br><span class="line">      path: &#39;&#x2F;main&#39;,</span><br><span class="line">      name: &#39;Main&#39;,</span><br><span class="line">      component: Main,</span><br><span class="line">      &#x2F;&#x2F; 配置嵌套路由</span><br><span class="line">      children: [</span><br><span class="line">        &#123;path: &#39;&#x2F;user&#x2F;profile&#39;, component: UserProfile&#125;,</span><br><span class="line">        &#123;path: &#39;&#x2F;user&#x2F;list&#39;, component: UserList&#125;,</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>说明：主要在路由配置中增加了 children 数组配置，用于在该组件下设置嵌套路由</p><p>4、修改首页视图，我们修改 Main.vue 视图组件，此处使用了 ElementUI 布局容器组件，代码如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;el-container&gt;</span><br><span class="line">        &lt;el-aside width&#x3D;&quot;200px&quot;&gt;</span><br><span class="line">          &lt;el-menu :default-openeds&#x3D;&quot;[&#39;1&#39;]&quot;&gt;</span><br><span class="line">            &lt;el-submenu index&#x3D;&quot;1&quot;&gt;</span><br><span class="line">              &lt;template slot&#x3D;&quot;title&quot;&gt;&lt;i class&#x3D;&quot;el-icon-caret-right&quot;&gt;&lt;&#x2F;i&gt;用户管理&lt;&#x2F;template&gt;</span><br><span class="line">              &lt;el-menu-item-group&gt;</span><br><span class="line">                &lt;el-menu-item index&#x3D;&quot;1-1&quot;&gt;</span><br><span class="line">                  &lt;router-link to&#x3D;&quot;&#x2F;user&#x2F;profile&quot;&gt;个人信息&lt;&#x2F;router-link&gt;</span><br><span class="line">                &lt;&#x2F;el-menu-item&gt;</span><br><span class="line">                &lt;el-menu-item index&#x3D;&quot;1-2&quot;&gt;</span><br><span class="line">                  &lt;router-link to&#x3D;&quot;&#x2F;user&#x2F;list&quot;&gt;用户列表&lt;&#x2F;router-link&gt;</span><br><span class="line">                &lt;&#x2F;el-menu-item&gt;</span><br><span class="line">              &lt;&#x2F;el-menu-item-group&gt;</span><br><span class="line">            &lt;&#x2F;el-submenu&gt;</span><br><span class="line">            &lt;el-submenu index&#x3D;&quot;2&quot;&gt;</span><br><span class="line">              &lt;template slot&#x3D;&quot;title&quot;&gt;&lt;i class&#x3D;&quot;el-icon-caret-right&quot;&gt;&lt;&#x2F;i&gt;内容管理&lt;&#x2F;template&gt;</span><br><span class="line">              &lt;el-menu-item-group&gt;</span><br><span class="line">                &lt;el-menu-item index&#x3D;&quot;2-1&quot;&gt;分类管理&lt;&#x2F;el-menu-item&gt;</span><br><span class="line">                &lt;el-menu-item index&#x3D;&quot;2-2&quot;&gt;内容列表&lt;&#x2F;el-menu-item&gt;</span><br><span class="line">              &lt;&#x2F;el-menu-item-group&gt;</span><br><span class="line">            &lt;&#x2F;el-submenu&gt;</span><br><span class="line">          &lt;&#x2F;el-menu&gt;</span><br><span class="line">        &lt;&#x2F;el-aside&gt;</span><br><span class="line"></span><br><span class="line">        &lt;el-container&gt;</span><br><span class="line">          &lt;el-header style&#x3D;&quot;text-align: right; font-size: 12px&quot;&gt;</span><br><span class="line">            &lt;el-dropdown&gt;</span><br><span class="line">              &lt;i class&#x3D;&quot;el-icon-setting&quot; style&#x3D;&quot;margin-right: 15px&quot;&gt;&lt;&#x2F;i&gt;</span><br><span class="line">              &lt;el-dropdown-menu slot&#x3D;&quot;dropdown&quot;&gt;</span><br><span class="line">                &lt;el-dropdown-item&gt;个人信息&lt;&#x2F;el-dropdown-item&gt;</span><br><span class="line">                &lt;el-dropdown-item&gt;退出登录&lt;&#x2F;el-dropdown-item&gt;</span><br><span class="line">              &lt;&#x2F;el-dropdown-menu&gt;</span><br><span class="line">            &lt;&#x2F;el-dropdown&gt;</span><br><span class="line">          &lt;&#x2F;el-header&gt;</span><br><span class="line"></span><br><span class="line">          &lt;el-main&gt;</span><br><span class="line">            &lt;router-view &#x2F;&gt;</span><br><span class="line">          &lt;&#x2F;el-main&gt;</span><br><span class="line">        &lt;&#x2F;el-container&gt;</span><br><span class="line">      &lt;&#x2F;el-container&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    export default &#123;</span><br><span class="line">        name: &quot;Main&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped lang&#x3D;&quot;scss&quot;&gt;</span><br><span class="line">  .el-header &#123;</span><br><span class="line">    background-color: #B3C0D1;</span><br><span class="line">    color: #333;</span><br><span class="line">    line-height: 60px;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  .el-aside &#123;</span><br><span class="line">    color: #333;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure><p>说明：</p><p>在 <el-main> 元素中配置了 <router-view /> 用于展示嵌套路由,主要使用 <router-link to="/user/profile">个人信息</router-link> 展示嵌套路由内容</p><h2 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h2><p>我们经常需要把某种模式匹配到的所有路由，全都映射到同个组件。例如，我们有一个 User 组件，对于所有 ID 各不相同的用户，都要使用这个组件来渲染。此时我们就需要传递参数了；</p><p>1、修改路由配置, 主要是在 path 属性中增加了 :id 这样的占位符</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;path: &#39;&#x2F;user&#x2F;profile&#x2F;:id&#39;, name:&#39;UserProfile&#39;, component: UserProfile&#125;</span><br></pre></td></tr></table></figure><p>2、传递参数</p><p>此时我们将 to 改为了 :to，是为了将这一属性当成对象使用，注意 router-link 中的 name 属性名称 一定要和 路由中的 name 属性名称 匹配，因为这样 Vue 才能找到对应的路由路径；</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;router-link :to&#x3D;&quot;&#123;name: &#39;UserProfile&#39;, params: &#123;id: 1&#125;&#125;&quot;&gt;个人信息&lt;&#x2F;router-link&gt;</span><br></pre></td></tr></table></figure><p>3、接收参数, 在目标组件中</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&#123; $route.params.id &#125;&#125;</span><br></pre></td></tr></table></figure><h3 id="使用-props-的方式"><a href="#使用-props-的方式" class="headerlink" title="使用 props 的方式"></a>使用 props 的方式</h3><p>1、修改路由配置 , 主要增加了 props: true 属性</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;path: &#39;&#x2F;user&#x2F;profile&#x2F;:id&#39;, name:&#39;UserProfile&#39;, component: UserProfile, props: true&#125;</span><br></pre></td></tr></table></figure><p>2、传递参数和之前一样<br>3、接收参数为目标组件增加 props 属性</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    个人信息</span><br><span class="line">    &#123;&#123; id &#125;&#125;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    export default &#123;</span><br><span class="line">      props: [&#39;id&#39;],</span><br><span class="line">      name: &quot;UserProfile&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure><h2 id="组件重定向"><a href="#组件重定向" class="headerlink" title="组件重定向"></a>组件重定向</h2><p>重定向的意思大家都明白，但 Vue 中的重定向是作用在路径不同但组件相同的情况下，比如：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  path: &#39;&#x2F;main&#39;,</span><br><span class="line">  name: &#39;Main&#39;,</span><br><span class="line">  component: Main</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">  path: &#39;&#x2F;goHome&#39;,</span><br><span class="line">  redirect: &#39;&#x2F;main&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：这里定义了两个路径，一个是 /main ，一个是 /goHome，其中 /goHome 重定向到了 /main 路径，由此可以看出重定向不需要定义组件；</p><p>使用的话，只需要设置对应路径即可；</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;el-menu-item index&#x3D;&quot;1-3&quot;&gt;</span><br><span class="line">    &lt;router-link to&#x3D;&quot;&#x2F;goHome&quot;&gt;回到首页&lt;&#x2F;router-link&gt;</span><br><span class="line">&lt;&#x2F;el-menu-item&gt;</span><br></pre></td></tr></table></figure><h2 id="路由模式与-404"><a href="#路由模式与-404" class="headerlink" title="路由模式与 404"></a>路由模式与 404</h2><p>路由模式有两种</p><ul><li>hash：路径带 # 符号，如 <a href="http://localhost/#/login" target="_blank" rel="noopener">http://localhost/#/login</a></li><li>history：路径不带 # 符号，如 <a href="http://localhost/login" target="_blank" rel="noopener">http://localhost/login</a></li></ul><p>修改路由配置，代码如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export default new Router(&#123;</span><br><span class="line">  mode: &#39;history&#39;,</span><br><span class="line">  routes: [</span><br><span class="line">  ]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>处理 404</strong> 创建一个名为 <code>NotFound.vue</code> 的视图组件，代码如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    页面不存在，请重试！</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    name: &quot;NotFount&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure><p>修改路由配置，代码如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import NotFound from &#39;..&#x2F;views&#x2F;NotFound&#39;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">   path: &#39;*&#39;,</span><br><span class="line">   component: NotFound</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="路由钩子与异步请求"><a href="#路由钩子与异步请求" class="headerlink" title="路由钩子与异步请求"></a>路由钩子与异步请求</h3><p><code>beforeRouteEnter</code>：在进入路由前执行<br><code>beforeRouteLeave</code>：在离开路由前执行</p><p>上代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">  props: [&#39;id&#39;],</span><br><span class="line">  name: &quot;UserProfile&quot;,</span><br><span class="line">  beforeRouteEnter: (to, from, next) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&quot;准备进入个人信息页&quot;);</span><br><span class="line">    next();</span><br><span class="line">  &#125;,</span><br><span class="line">  beforeRouteLeave: (to, from, next) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&quot;准备离开个人信息页&quot;);</span><br><span class="line">    next();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li>to：路由将要跳转的路径信息</li><li>from：路径跳转前的路径信息</li><li>next：路由的控制参数<ul><li>next() 跳入下一个页面</li><li>next(‘/path’) 改变路由的跳转方向，使其跳到另一个路由</li><li>next(false) 返回原来的页面</li><li>next((vm)=&gt;{}) 仅在 beforeRouteEnter 中可用，vm 是组件实例</li></ul></li></ul><p><strong>在钩子函数中使用异步请求</strong></p><p>1、安装 Axios <code>cnpm install axios -s</code><br>2、<code>main.js</code>引用 Axios</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import axios from &#39;axios&#39;</span><br><span class="line">Vue.prototype.axios &#x3D; axios;</span><br></pre></td></tr></table></figure><p>3、准备数据 ： 只有我们的 static 目录下的文件是可以被访问到的，所以我们就把静态文件放入该目录下。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 静态数据存放的位置</span><br><span class="line">static&#x2F;mock&#x2F;data.json</span><br></pre></td></tr></table></figure><p>4、在 beforeRouteEnter 中进行异步请求</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">   props: [&#39;id&#39;],</span><br><span class="line">   name: &quot;UserProfile&quot;,</span><br><span class="line">   beforeRouteEnter: (to, from, next) &#x3D;&gt; &#123;</span><br><span class="line">     console.log(&quot;准备进入个人信息页&quot;);</span><br><span class="line">     &#x2F;&#x2F; 注意，一定要在 next 中请求，因为该方法调用时 Vue 实例还没有创建，此时无法获取到 this 对象，在这里使用官方提供的回调函数拿到当前实例</span><br><span class="line">     next(vm &#x3D;&gt; &#123;</span><br><span class="line">       vm.getData();</span><br><span class="line">     &#125;);</span><br><span class="line">   &#125;,</span><br><span class="line">   beforeRouteLeave: (to, from, next) &#x3D;&gt; &#123;</span><br><span class="line">     console.log(&quot;准备离开个人信息页&quot;);</span><br><span class="line">     next();</span><br><span class="line">   &#125;,</span><br><span class="line">   methods: &#123;</span><br><span class="line">     getData: function () &#123;</span><br><span class="line">       this.axios(&#123;</span><br><span class="line">         method: &#39;get&#39;,</span><br><span class="line">         url: &#39;http:&#x2F;&#x2F;localhost:8080&#x2F;static&#x2F;mock&#x2F;data.json&#39;</span><br><span class="line">       &#125;).then(function (repos) &#123;</span><br><span class="line">         console.log(repos);</span><br><span class="line">       &#125;).catch(function (error) &#123;</span><br><span class="line">         console.log(error);</span><br><span class="line">       &#125;);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      前端体系、前后端分离
    
    </summary>
    
    
      <category term="Vue" scheme="https://SomunsTao.github.io/categories/Vue/"/>
    
    
      <category term="Vue" scheme="https://SomunsTao.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue 09：vue-router路由</title>
    <link href="https://somunstao.github.io/2020/04/19/Vue%2009%EF%BC%9Avue-router%E8%B7%AF%E7%94%B1/"/>
    <id>https://somunstao.github.io/2020/04/19/Vue%2009%EF%BC%9Avue-router%E8%B7%AF%E7%94%B1/</id>
    <published>2020-04-18T16:00:00.000Z</published>
    <updated>2020-08-01T15:18:48.746Z</updated>
    
    <content type="html"><![CDATA[<p>​    </p><h1 id="Vue：vue-router路由"><a href="#Vue：vue-router路由" class="headerlink" title="Vue：vue-router路由"></a>Vue：vue-router路由</h1><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>学习的时候，尽量的打开官方的文档</p><p>Vue Router 是 Vue.js 官方的路由管理器。它和 Vue.js 的核心深度集成，让构建单页面应用变得易如反掌。包含的功能有：</p><ul><li>嵌套的路由/视图表</li><li>模块化的、基于组件的路由配置</li><li>路由参数、查询、通配符</li><li>基于 Vue.js 过渡系统的视图过渡效果</li><li>细粒度的导航控制</li><li>带有自动激活的 CSS class 的链接</li><li>HTML5 历史模式或 hash 模式，在 IE9 中自动降级</li><li>自定义的滚动条行为</li></ul><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p><strong>基于第一个vue-cli进行测试学习;先查看node_modules中是否存在 vue-router</strong></p><p>vue-router 是一个插件包，所以我们还是需要用 npm/cnpm 来进行安装的。打开命令行工具，进入你的项目目录，输入下面命令。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install vue-router --save-dev</span><br></pre></td></tr></table></figure><p>如果在一个模块化工程中使用它，必须要通过 Vue.use() 明确地安装路由功能：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import Vue from &#39;vue&#39;</span><br><span class="line">import VueRouter from &#39;vue-router&#39;</span><br><span class="line"></span><br><span class="line">Vue.use(VueRouter);</span><br></pre></td></tr></table></figure><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>1、先删除没有用的东西<br>2、<code>components</code>目录下存放我们自己编写的组件<br>3、定义一个<code>Content.vue</code> 的组件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line"> &lt;h1&gt;内容页&lt;&#x2F;h1&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"> export default &#123;</span><br><span class="line">     name: &quot;Content&quot;</span><br><span class="line"> &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>4、 <strong>安装路由,在src目录下,新建一个文件夹 : router,专门存放路由</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import Vue from &#39;vue&#39;</span><br><span class="line">&#x2F;&#x2F; 导入路由插件</span><br><span class="line">import Router from &#39;vue-router&#39;</span><br><span class="line">&#x2F;&#x2F; 导入上面定义的组件</span><br><span class="line">import Content from &#39;..&#x2F;components&#x2F;Content&#39;</span><br><span class="line">import main from &#39;..&#x2F;components&#x2F;main&#39;</span><br><span class="line">&#x2F;&#x2F; 安装路由</span><br><span class="line">Vue.use(Router);</span><br><span class="line">&#x2F;&#x2F; 配置路由</span><br><span class="line">export default new Router(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      &#x2F;&#x2F; 路由路径</span><br><span class="line">      path: &#39;&#x2F;content&#39;,</span><br><span class="line">      &#x2F;&#x2F; 路由名称</span><br><span class="line">      name: &#39;Content&#39;,</span><br><span class="line">      &#x2F;&#x2F; 跳转到组件</span><br><span class="line">      component: Content</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">      &#x2F;&#x2F; 路由路径</span><br><span class="line">      path: &#39;&#x2F;main&#39;,</span><br><span class="line">      &#x2F;&#x2F; 路由名称</span><br><span class="line">      name: &#39;main&#39;,</span><br><span class="line">      &#x2F;&#x2F; 跳转到组件</span><br><span class="line">      component: main</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>5、在<code>main.js</code> 中配置路由</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import Vue from &#39;vue&#39;</span><br><span class="line">import App from &#39;.&#x2F;App&#39;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 导入上面创建的路由配置目录</span><br><span class="line">import router from &#39;.&#x2F;router&#39;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;来关闭生产模式下给出的提示</span><br><span class="line">Vue.config.productionTip &#x3D; false;</span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: &#39;#app&#39;,</span><br><span class="line">  &#x2F;&#x2F; 配置路由</span><br><span class="line">  router,</span><br><span class="line">  components: &#123; App &#125;,</span><br><span class="line">  template: &#39;&lt;App&#x2F;&gt;&#39;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>6、在<code>App.vue</code>中使用路由</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">    &lt;!--</span><br><span class="line">      router-link： 默认会被渲染成一个 &lt;a&gt; 标签，to 属性为指定链接</span><br><span class="line">      router-view： 用于渲染路由匹配到的组件</span><br><span class="line">    --&gt;</span><br><span class="line">    &lt;router-link to&#x3D;&quot;&#x2F;&quot;&gt;首页&lt;&#x2F;router-link&gt;</span><br><span class="line">    &lt;router-link to&#x3D;&quot;&#x2F;content&quot;&gt;内容&lt;&#x2F;router-link&gt;</span><br><span class="line">    &lt;router-view&gt;&lt;&#x2F;router-view&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#39;App&#39;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">  #app &#123;</span><br><span class="line">    font-family: &#39;Avenir&#39;, Helvetica, Arial, sans-serif;</span><br><span class="line">    -webkit-font-smoothing: antialiased;</span><br><span class="line">    -moz-osx-font-smoothing: grayscale;</span><br><span class="line">    text-align: center;</span><br><span class="line">    color: #2c3e50;</span><br><span class="line">    margin-top: 60px;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure><p>启动测试一下 ： <code>npm run dev</code></p><p><strong>练习： 在现有的基础上，在增加一个路由组件，优化一下！</strong></p>]]></content>
    
    <summary type="html">
    
      前端体系、前后端分离
    
    </summary>
    
    
      <category term="Vue" scheme="https://SomunsTao.github.io/categories/Vue/"/>
    
    
      <category term="Vue" scheme="https://SomunsTao.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue 08：Webpack学习</title>
    <link href="https://somunstao.github.io/2020/04/18/Vue%2008%EF%BC%9AWebpack%E5%AD%A6%E4%B9%A0/"/>
    <id>https://somunstao.github.io/2020/04/18/Vue%2008%EF%BC%9AWebpack%E5%AD%A6%E4%B9%A0/</id>
    <published>2020-04-17T16:00:00.000Z</published>
    <updated>2020-08-01T15:18:32.935Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Vue：Webpack学习"><a href="#Vue：Webpack学习" class="headerlink" title="Vue：Webpack学习"></a>Vue：Webpack学习</h1><h2 id="什么是Webpack"><a href="#什么是Webpack" class="headerlink" title="什么是Webpack"></a>什么是Webpack</h2><p>本质上，webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle.</p><p>Webpack 是当下最热门的前端资源模块化管理和打包工具，它可以将许多松散耦合的模块按照依赖和规则打包成符合生产环境部署的前端资源。还可以将按需加载的模块进行代码分离，等到实际需要时再异步加载。通过 loader 转换，任何形式的资源都可以当做模块，比如 CommonsJS、AMD、ES6、CSS、JSON、CoffeeScript、LESS 等；</p><p>伴随着移动互联网的大潮，当今越来越多的网站已经从网页模式进化到了 WebApp 模式。它们运行在现代浏览器里，使用 HTML5、CSS3、ES6 等新的技术来开发丰富的功能，网页已经不仅仅是完成浏览器的基本需求；WebApp 通常是一个 SPA （单页面应用），每一个视图通过异步的方式加载，这导致页面初始化和使用过程中会加载越来越多的 JS 代码，这给前端的开发流程和资源组织带来了巨大挑战。</p><p>前端开发和其他开发工作的主要区别，首先是前端基于多语言、多层次的编码和组织工作，其次前端产品的交付是基于浏览器的，这些资源是通过增量加载的方式运行到浏览器端，如何在开发环境组织好这些碎片化的代码和资源，并且保证他们在浏览器端快速、优雅的加载和更新，就需要一个模块化系统，这个理想中的模块化系统是前端工程师多年来一直探索的难题。</p><h3 id="模块化的演进"><a href="#模块化的演进" class="headerlink" title="模块化的演进"></a>模块化的演进</h3><h4 id="Script-标签"><a href="#Script-标签" class="headerlink" title="Script 标签"></a>Script 标签</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script src&#x3D;&quot;module1.js&quot;&gt;&lt;&#x2F;scirpt&gt;</span><br><span class="line">&lt;script src&#x3D;&quot;module2.js&quot;&gt;&lt;&#x2F;scirpt&gt;</span><br><span class="line">&lt;script src&#x3D;&quot;module3.js&quot;&gt;&lt;&#x2F;scirpt&gt;</span><br><span class="line">&lt;script src&#x3D;&quot;module4.js&quot;&gt;&lt;&#x2F;scirpt&gt;</span><br></pre></td></tr></table></figure><p>这是最原始的 JavaScript 文件加载方式，如果把每一个文件看做是一个模块，那么他们的接口通常是暴露在全局作用域下，也就是定义在 window 对象中，不同模块的调用都是一个作用域。</p><p>这种原始的加载方式暴露了一些显而易见的弊端：</p><ul><li>全局作用域下容易造成变量冲突</li><li>文件只能按照 <script> 的书写顺序进行加载</li><li>开发人员必须主观解决模块和代码库的依赖关系</li><li>在大型项目中各种资源难以管理，长期积累的问题导致代码库混乱不堪</li></ul><h4 id="CommonsJS"><a href="#CommonsJS" class="headerlink" title="CommonsJS"></a>CommonsJS</h4><p>服务器端的 NodeJS 遵循 CommonsJS 规范，该规范核心思想是允许模块通过 require 方法来同步加载所需依赖的其它模块，然后通过 exports 或 module.exports 来导出需要暴露的接口。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">require(&quot;module&quot;);</span><br><span class="line">require(&quot;..&#x2F;module.js&quot;);</span><br><span class="line">export.doStuff &#x3D; function() &#123;&#125;;</span><br><span class="line">module.exports &#x3D; someValue;</span><br></pre></td></tr></table></figure><p><strong>优点:</strong></p><ul><li>服务器端模块便于重用</li><li>NPM 中已经有超过 45 万个可以使用的模块包</li><li>简单易用</li></ul><p><strong>缺点:</strong></p><ul><li>同步的模块加载方式不适合在浏览器环境中，同步意味着阻塞加载，浏览器资源是异步加载的</li><li>不能非阻塞的并行加载多个模块</li></ul><p><strong>实现:</strong></p><ul><li>服务端的 NodeJS</li><li>Browserify，浏览器端的 CommonsJS 实现，可以使用 NPM 的模块，但是编译打包后的文件体积较大</li><li>modules-webmake，类似 Browserify，但不如 Browserify 灵活</li><li>wreq，Browserify 的前身</li></ul><h4 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h4><p>Asynchronous Module Definition 规范其实主要一个主要接口 define(id?, dependencies?, factory); 它要在声明模块的时候指定所有的依赖 dependencies，并且还要当做形参传到 factory 中，对于依赖的模块提前执行。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">define(&quot;module&quot;, [&quot;dep1&quot;, &quot;dep2&quot;], function(d1, d2) &#123;</span><br><span class="line">  return someExportedValue;</span><br><span class="line">&#125;);</span><br><span class="line">require([&quot;module&quot;, &quot;..&#x2F;file.js&quot;], function(module, file) &#123;&#125;);</span><br></pre></td></tr></table></figure><p><strong>优点</strong></p><ul><li>适合在浏览器环境中异步加载模块</li><li>可以并行加载多个模块</li></ul><p><strong>缺点</strong></p><ul><li>提高了开发成本，代码的阅读和书写比较困难，模块定义方式的语义不畅</li><li>不符合通用的模块化思维方式，是一种妥协的实现</li></ul><p><strong>实现</strong></p><ul><li>RequireJS</li><li>curl</li></ul><h4 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h4><p>Commons Module Definition 规范和 AMD 很相似，尽量保持简单，并与 CommonsJS 和 NodeJS 的 Modules 规范保持了很大的兼容性。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">define(function(require, exports, module) &#123;</span><br><span class="line">  var $ &#x3D; require(&quot;jquery&quot;);</span><br><span class="line">  var Spinning &#x3D; require(&quot;.&#x2F;spinning&quot;);</span><br><span class="line">  exports.doSomething &#x3D; ...;</span><br><span class="line">  module.exports &#x3D; ...;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>优点:</strong></p><ul><li>依赖就近，延迟执行</li><li>可以很容易在 NodeJS 中运行</li></ul><p><strong>缺点</strong></p><ul><li>依赖 SPM 打包，模块的加载逻辑偏重</li></ul><p><strong>实现</strong></p><ul><li>Sea.js</li><li>coolie</li></ul><h4 id="ES6-模块"><a href="#ES6-模块" class="headerlink" title="ES6 模块"></a>ES6 模块</h4><p>EcmaScript6 标准增加了 JavaScript 语言层面的模块体系定义。 ES6 模块的设计思想，是尽量静态化，使编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonsJS 和 AMD 模块，都只能在运行时确定这些东西。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &quot;jquery&quot;;</span><br><span class="line">export function doStuff() &#123;&#125;</span><br><span class="line">module &quot;localModule&quot; &#123;&#125;</span><br></pre></td></tr></table></figure><p><strong>优点</strong></p><ul><li>容易进行静态分析</li><li>面向未来的 EcmaScript 标准</li></ul><p><strong>缺点</strong></p><ul><li>原生浏览器端还没有实现该标准</li><li>全新的命令，新版的 NodeJS 才支持</li></ul><p><strong>实现</strong></p><ul><li>Babel</li></ul><p><strong>大家期望的模块系统</strong></p><p>可以兼容多种模块风格，尽量可以利用已有的代码，不仅仅只是 JavaScript 模块化，还有 CSS、图片、字体等资源也需要模块化。</p><h2 id="安装Webpack"><a href="#安装Webpack" class="headerlink" title="安装Webpack"></a>安装Webpack</h2><p>WebPack 是一款模块加载器兼打包工具，它能把各种资源，如 JS、JSX、ES6、SASS、LESS、图片等都作为模块来处理和使用。</p><p><strong>安装:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install webpack -g</span><br><span class="line">npm install webpack-cli -g</span><br></pre></td></tr></table></figure><p>测试安装成功:</p><ul><li><code>webpack -v</code></li><li><code>webpack-cli -v</code></li></ul><p><img src="https://blog.kuangstudy.com/usr/uploads/2019/10/2035564066.png" alt="QQ截图20191023173431.png"></p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>创建 <code>webpack.config.js</code> 配置文件</p><ul><li>entry：入口文件，指定 WebPack 用哪个文件作为项目的入口</li><li>output：输出，指定 WebPack 把处理完成的文件放置到指定路径</li><li>module：模块，用于处理各种类型的文件</li><li>plugins：插件，如：热更新、代码重用等</li><li>resolve：设置路径指向</li><li>watch：监听，用于设置文件改动后直接打包</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">    entry: &quot;&quot;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: &quot;&quot;,</span><br><span class="line">        filename: &quot;&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    module: &#123;</span><br><span class="line">        loaders: [</span><br><span class="line">            &#123;test: &#x2F;\.js$&#x2F;, loader: &quot;&quot;&#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: &#123;&#125;,</span><br><span class="line">    resolve: &#123;&#125;,</span><br><span class="line">    watch: true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接运行 <code>webpack</code> 命令打包</p><h2 id="使用webpack"><a href="#使用webpack" class="headerlink" title="使用webpack"></a>使用webpack</h2><ol><li><p>创建项目</p></li><li><p>创建一个名为 modules 的目录，用于放置 JS 模块等资源文件</p></li><li><p>在modules下创建模块文件，如 hello.js，用于编写 JS 模块相关代码</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;暴露一个方法:sayHi</span><br><span class="line">exports.sayHi &#x3D; function () &#123;</span><br><span class="line">  document.write(&quot;&lt;div&gt;Hello WebPack&lt;&#x2F;div&gt;&quot;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>在modules下创建一个名为 main.js 的入口文件，用于打包时设置 entry 属性</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;require 导入一个模块,就可以调用这个模块中的方法了</span><br><span class="line">var hello &#x3D; require(&quot;.&#x2F;hello&quot;);</span><br><span class="line">hello.sayHi();</span><br></pre></td></tr></table></figure></li><li><p>在项目目录下创建 webpack.config.js 配置文件，使用 webpack 命令打包</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">    entry: &quot;.&#x2F;modules&#x2F;main.js&quot;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: &quot;.&#x2F;js&#x2F;bundle.js&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>在项目目录下创建 HTML 页面，如 index.html，导入 WebPack 打包后的 JS 文件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!doctype html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line"> &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line"> &lt;title&gt;狂神说Java&lt;&#x2F;title&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;script src&#x3D;&quot;dist&#x2F;js&#x2F;bundle.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure></li><li><p>在IDEA控制台中直接执行webpack;如果失败的话,就使用管理员权限运行即可!</p></li><li><p>运行 HTML 看效果</p></li></ol><p><strong>说明:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 参数 --watch 用于监听变化</span><br><span class="line">webpack --watch</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      前端体系、前后端分离
    
    </summary>
    
    
      <category term="Vue" scheme="https://SomunsTao.github.io/categories/Vue/"/>
    
    
      <category term="Vue" scheme="https://SomunsTao.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue 07：第一个vue-cli项目</title>
    <link href="https://somunstao.github.io/2020/04/17/Vue%2007%EF%BC%9A%E7%AC%AC%E4%B8%80%E4%B8%AAvue-cli%E9%A1%B9%E7%9B%AE/"/>
    <id>https://somunstao.github.io/2020/04/17/Vue%2007%EF%BC%9A%E7%AC%AC%E4%B8%80%E4%B8%AAvue-cli%E9%A1%B9%E7%9B%AE/</id>
    <published>2020-04-16T16:00:00.000Z</published>
    <updated>2020-08-01T15:18:13.793Z</updated>
    
    <content type="html"><![CDATA[<p>​    </p><h1 id="Vue：第一个vue-cli项目"><a href="#Vue：第一个vue-cli项目" class="headerlink" title="Vue：第一个vue-cli项目"></a>Vue：第一个vue-cli项目</h1><h2 id="什么是vue-cli"><a href="#什么是vue-cli" class="headerlink" title="什么是vue-cli"></a>什么是vue-cli</h2><p>vue-cli 官方提供的一个脚手架,用于快速生成一个 vue 的项目模板;</p><p>预先定义好的目录结构及基础代码，就好比咱们在创建 Maven 项目时可以选择创建一个骨架项目，这个骨架项目就是脚手架,我们的开发更加的快速;</p><p><strong>主要的功能:</strong></p><ul><li>统一的目录结构</li><li>本地调试</li><li>热部署</li><li>单元测试</li><li>集成打包上线</li></ul><h2 id="需要的环境"><a href="#需要的环境" class="headerlink" title="需要的环境"></a>需要的环境</h2><ul><li>Node.js : <a href="http://nodejs.cn/download/" target="_blank" rel="noopener">http://nodejs.cn/download/</a><br>安装就无脑下一步就好,安装在自己的环境目录下</li><li>Git : <a href="https://git-scm.com/downloads" target="_blank" rel="noopener">https://git-scm.com/downloads</a><br>镜像:<a href="https://npm.taobao.org/mirrors/git-for-windows/" target="_blank" rel="noopener">https://npm.taobao.org/mirrors/git-for-windows/</a></li></ul><p><strong>确认nodejs安装成功:</strong></p><ul><li>cmd 下输入 <code>node -v</code>,查看是否能够正确打印出版本号即可!</li><li>cmd 下输入 <code>npm-v</code>,查看是否能够正确打印出版本号即可!</li></ul><p>这个npm,就是一个软件包管理工具,就和linux下的apt软件安装差不多!</p><p><strong>安装 Node.js 淘宝镜像加速器（cnpm）</strong></p><p>这样子的话,下载会快很多~</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># -g 就是全局安装</span><br><span class="line">npm install cnpm -g</span><br><span class="line"></span><br><span class="line"># 或使用如下语句解决 npm 速度慢的问题</span><br><span class="line">npm install --registry&#x3D;https:&#x2F;&#x2F;registry.npm.taobao.org</span><br></pre></td></tr></table></figure><p>安装过程可能有点慢~,耐心等待!虽然安装了cnpm,但是尽量少用!</p><p>安装的位置:<code>C:\Users\Administrator\AppData\Roaming\npm</code></p><p><img src="https://blog.kuangstudy.com/usr/uploads/2019/10/3274148234.png" alt="QQ截图20191023160802.png"></p><p><strong>安装 vue-cli</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cnpm install vue-cli -g</span><br><span class="line"></span><br><span class="line"># 测试是否安装成功</span><br><span class="line"># 查看可以基于哪些模板创建 vue 应用程序，通常我们选择 webpack</span><br><span class="line">vue list</span><br></pre></td></tr></table></figure><p><img src="https://blog.kuangstudy.com/usr/uploads/2019/10/1623428782.png" alt="QQ截图20191023161055.png"></p><h2 id="第一个-vue-cli-应用程序"><a href="#第一个-vue-cli-应用程序" class="headerlink" title="第一个 vue-cli 应用程序"></a>第一个 vue-cli 应用程序</h2><ol><li><p>创建一个Vue项目,我们随便建立一个空的文件夹在电脑上,我这里在D盘下新建一个目录<code>D:\Project\vue-study</code>;</p></li><li><p>创建一个基于 webpack 模板的 vue 应用程序</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 这里的 myvue 是项目名称，可以根据自己的需求起名</span><br><span class="line">vue init webpack myvue</span><br></pre></td></tr></table></figure><p>一路都选择no即可;</p></li></ol><p><strong>说明:</strong></p><ul><li>Project name：项目名称，默认 回车 即可</li><li>Project description：项目描述，默认 回车 即可</li><li>Author：项目作者，默认 回车 即可</li><li>Install vue-router：是否安装 vue-router，选择 n 不安装（后期需要再手动添加）</li><li>Use ESLint to lint your code：是否使用 ESLint 做代码检查，选择 n 不安装（后期需要再手动添加）</li><li>Set up unit tests：单元测试相关，选择 n 不安装（后期需要再手动添加）</li><li>Setup e2e tests with Nightwatch：单元测试相关，选择 n 不安装（后期需要再手动添加）</li><li>Should we run npm install for you after the project has been created：创建完成后直接初始化，选择 n，我们手动执行;运行结果!<br><img src="https://blog.kuangstudy.com/usr/uploads/2019/10/1192113224.png" alt="QQ截图20191023161857.png"></li></ul><h3 id="初始化并运行"><a href="#初始化并运行" class="headerlink" title="初始化并运行"></a>初始化并运行</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd myvue</span><br><span class="line">npm install</span><br><span class="line">npm run dev</span><br></pre></td></tr></table></figure><p>执行完成后,目录多了很多依赖</p><p><img src="https://blog.kuangstudy.com/usr/uploads/2019/10/1102095439.png" alt="QQ截图20191023162254.png"></p><p>安装并运行成功后在浏览器输入：<a href="http://localhost/" target="_blank" rel="noopener">http://localhost</a>:8080</p><p><img src="https://blog.kuangstudy.com/usr/uploads/2019/10/2731297978.png" alt="QQ截图20191023162439.png"></p><p><strong>效果:</strong></p><p><img src="https://blog.kuangstudy.com/usr/uploads/2019/10/3761367777.png" alt="QQ截图20191023162508.png"></p><h2 id="Vue-cli目录结构"><a href="#Vue-cli目录结构" class="headerlink" title="Vue-cli目录结构"></a>Vue-cli目录结构</h2><p>我们用IDEA,open刚才的项目!</p><p><img src="https://blog.kuangstudy.com/usr/uploads/2019/10/3943650778.png" alt="QQ截图20191023162755.png"></p><ul><li>build 和 config：WebPack 配置文件</li><li>node_modules：用于存放 npm install 安装的依赖文件</li><li>src： 项目源码目录</li><li>static：静态资源文件</li><li>.babelrc：Babel 配置文件，主要作用是将 ES6 转换为 ES5</li><li>.editorconfig：编辑器配置</li><li>eslintignore：需要忽略的语法检查配置文件</li><li>.gitignore：git 忽略的配置文件</li><li>.postcssrc.js：css 相关配置文件，其中内部的 module.exports 是 NodeJS 模块化语法</li><li>index.html：首页，仅作为模板页，实际开发时不使用</li><li>package.json：项目的配置文件<ul><li>name：项目名称</li><li>version：项目版本</li><li>description：项目描述</li><li>author：项目作者</li><li>scripts：封装常用命令</li><li>dependencies：生产环境依赖</li><li>devDependencies：开发环境依赖</li></ul></li></ul><h2 id="src-目录"><a href="#src-目录" class="headerlink" title="src 目录"></a>src 目录</h2><p><code>src</code> 目录是项目的源码目录，所有代码都会写在这里</p><p><img src="https://blog.kuangstudy.com/usr/uploads/2019/10/1887353409.png" alt="QQ截图20191023164841.png"></p><h3 id="main-js"><a href="#main-js" class="headerlink" title="main.js"></a>main.js</h3><p>项目的入口文件，我们知道所有的程序都会有一个入口</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; The Vue build version to load with the &#96;import&#96; command</span><br><span class="line">&#x2F;&#x2F; (runtime-only or standalone) has been set in webpack.base.conf with an alias.</span><br><span class="line">import Vue from &#39;vue&#39;</span><br><span class="line">import App from &#39;.&#x2F;App&#39;</span><br><span class="line"></span><br><span class="line">Vue.config.productionTip &#x3D; false;</span><br><span class="line"></span><br><span class="line">&#x2F;* eslint-disable no-new *&#x2F;</span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: &#39;#app&#39;,</span><br><span class="line">  components: &#123; App &#125;,</span><br><span class="line">  template: &#39;&lt;App&#x2F;&gt;&#39;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li><code>import Vue from &#39;vue&#39;</code>：ES6 写法，会被转换成 require(“vue”); （require 是 NodeJS 提供的模块加载器）</li><li><code>import App from &#39;./App&#39;</code>：意思同上，但是指定了查找路径，./ 为当前目录</li><li><code>Vue.config.productionTip = false</code>：关闭浏览器控制台关于环境的相关提示</li><li><code>new Vue({...})</code>：实例化 Vue<ul><li><code>el: &#39;#app&#39;</code>：查找 index.html 中 id 为 app 的元素</li><li><code>template: &#39;&lt;App/&gt;&#39;</code>：模板，会将 index.html 中 <div id="app"></div> 替换为 <App /></li><li><code>components: { App }</code>：引入组件，使用的是 import App from ‘./App’ 定义的 App 组件;</li></ul></li></ul><h3 id="App-vue"><a href="#App-vue" class="headerlink" title="App.vue"></a>App.vue</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">    &lt;img src&#x3D;&quot;.&#x2F;assets&#x2F;logo.png&quot;&gt;</span><br><span class="line">    &lt;HelloWorld&#x2F;&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import HelloWorld from &#39;.&#x2F;components&#x2F;HelloWorld&#39;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#39;App&#39;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    HelloWorld</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">#app &#123;</span><br><span class="line">  font-family: &#39;Avenir&#39;, Helvetica, Arial, sans-serif;</span><br><span class="line">  -webkit-font-smoothing: antialiased;</span><br><span class="line">  -moz-osx-font-smoothing: grayscale;</span><br><span class="line">  text-align: center;</span><br><span class="line">  color: #2c3e50;</span><br><span class="line">  margin-top: 60px;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure><ul><li>template：HTML 代码模板，会替换 <App /> 中的内容</li><li>import HelloWorld from ‘./components/HelloWorld’：引入 HelloWorld 组件，用于替换 template 中的 <HelloWorld/></li><li>export default{…}：导出 NodeJS 对象，作用是可以通过 import 关键字导入<ul><li>name: ‘App’：定义组件的名称</li><li>components: { HelloWorld }：定义子组件</li></ul></li></ul><p>在hello,Vue中,关于 <style scoped> 的说明：CSS 样式仅在当前组件有效，声明了样式的作用域,是当前的界面私有的!</p>]]></content>
    
    <summary type="html">
    
      前端体系、前后端分离
    
    </summary>
    
    
      <category term="Vue" scheme="https://SomunsTao.github.io/categories/Vue/"/>
    
    
      <category term="Vue" scheme="https://SomunsTao.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue 06：计算属性、内容分发、自定义事件</title>
    <link href="https://somunstao.github.io/2020/04/16/Vue%2006%EF%BC%9A%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E3%80%81%E5%86%85%E5%AE%B9%E5%88%86%E5%8F%91%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BA%8B%E4%BB%B6/"/>
    <id>https://somunstao.github.io/2020/04/16/Vue%2006%EF%BC%9A%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E3%80%81%E5%86%85%E5%AE%B9%E5%88%86%E5%8F%91%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BA%8B%E4%BB%B6/</id>
    <published>2020-04-15T16:00:00.000Z</published>
    <updated>2020-08-01T15:17:52.691Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Vue：计算属性、内容分发、自定义事件"><a href="#Vue：计算属性、内容分发、自定义事件" class="headerlink" title="Vue：计算属性、内容分发、自定义事件"></a>Vue：计算属性、内容分发、自定义事件</h1><h2 id="什么是计算属性"><a href="#什么是计算属性" class="headerlink" title="什么是计算属性"></a>什么是计算属性</h2><p>计算属性的重点突出在 <code>属性</code> 两个字上（属性是名词），首先它是个 <code>属性</code> 其次这个属性有 <code>计算</code> 的能力（计算是动词），这里的 <code>计算</code> 就是个函数；简单点说，它就是一个能够将计算结果缓存起来的属性（将行为转化成了静态的属性），仅此而已；可以想象为缓存！</p><p><strong>上代码：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;狂神说Java&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;vue@2.5.21&#x2F;dist&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;div id&#x3D;&quot;vue&quot;&gt;</span><br><span class="line">    &lt;!--注意，一个是方法，一个是属性--&gt;</span><br><span class="line">    &lt;p&gt;调用当前时间的方法：&#123;&#123;currentTime1()&#125;&#125;&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;p&gt;当前时间的计算属性：&#123;&#123;currentTime2&#125;&#125;&lt;&#x2F;p&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">    var vm &#x3D; new Vue(&#123;</span><br><span class="line">        el: &#39;#vue&#39;,</span><br><span class="line">        data: &#123;</span><br><span class="line">            message: &#39;Hello Vue&#39;</span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line">            currentTime1: function () &#123;</span><br><span class="line">                return Date.now();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        computed: &#123;</span><br><span class="line">            &#x2F;&#x2F;currentTime2 ，这是一个属性！不是方法</span><br><span class="line">            currentTime2: function () &#123;</span><br><span class="line">                this.message;</span><br><span class="line">                return Date.now();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p><strong>注意：methods 和 computed 里的东西不能重名</strong></p><p><strong>说明：</strong></p><ul><li>methods：定义方法，调用方法使用 currentTime1()，需要带括号</li><li>computed：定义计算属性，调用属性使用 currentTime2，不需要带括号；this.message 是为了能够让 currentTime2 观察到数据变化而变化</li><li>如何在方法中的值发生了变化，则缓存就会刷新！可以在控制台使用 <code>vm.message=&quot;qinjiang&quot;</code>,改变下数据的值，再次测试观察效果！</li></ul><p><strong>结论：</strong></p><p>调用方法时，每次都需要进行计算，既然有计算过程则必定产生系统开销，那如果这个结果是不经常变化的呢？此时就可以考虑将这个结果缓存起来，采用计算属性可以很方便的做到这一点,<strong>计算属性的主要特性就是为了将不经常变化的计算结果进行缓存，以节约我们的系统开销;</strong></p><h2 id="内容分发"><a href="#内容分发" class="headerlink" title="内容分发"></a>内容分发</h2><p>在 <code>Vue.js</code> 中我们使用 <code>&lt;slot&gt;</code> 元素作为承载分发内容的出口，作者称其为 插槽，可以应用在组合组件的场景中;</p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>比如准备制作一个待办事项组件（todo），该组件由待办标题（todo-title）和待办内容（todo-items）组成，但这三个组件又是相互独立的，该如何操作呢？</p><p><strong>第一步: 定义一个待办事项的组件</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;vue&quot;&gt;</span><br><span class="line">    &lt;todo&gt;&lt;&#x2F;todo&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">    Vue.component(&#39;todo&#39;, &#123;</span><br><span class="line">        template: &#39;&lt;div&gt;\</span><br><span class="line">                    &lt;div&gt;待办事项&lt;&#x2F;div&gt;\</span><br><span class="line">                    &lt;ul&gt;\</span><br><span class="line">                        &lt;li&gt;学习狂神说Java&lt;&#x2F;li&gt;\</span><br><span class="line">                    &lt;&#x2F;ul&gt;\</span><br><span class="line">               &lt;&#x2F;div&gt;&#39;</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p><strong>第二步: 我们需要让,待办事项的标题和值实现动态绑定,怎么做呢? 我们可以留出一个插槽!</strong></p><p>1-将上面的代码留出一个插槽,即 slot</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Vue.component(&#39;todo&#39;, &#123;</span><br><span class="line">    template: &#39;&lt;div&gt;\</span><br><span class="line">                    &lt;slot name&#x3D;&quot;todo-title&quot;&gt;&lt;&#x2F;slot&gt;\</span><br><span class="line">                    &lt;ul&gt;\</span><br><span class="line">                        &lt;slot name&#x3D;&quot;todo-items&quot;&gt;&lt;&#x2F;slot&gt;\</span><br><span class="line">                    &lt;&#x2F;ul&gt;\</span><br><span class="line">               &lt;&#x2F;div&gt;&#39;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>2-定义一个名为 todo-title 的待办标题组件 和 todo-items 的待办内容组件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Vue.component(&#39;todo-title&#39;, &#123;</span><br><span class="line">    props: [&#39;title&#39;],</span><br><span class="line">    template: &#39;&lt;div&gt;&#123;&#123;title&#125;&#125;&lt;&#x2F;div&gt;&#39;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;这里的index,就是数组的下标,使用for循环遍历的时候,可以循环出来!</span><br><span class="line">Vue.component(&#39;todo-items&#39;, &#123;</span><br><span class="line">    props: [&#39;item&#39;, &#39;index&#39;],</span><br><span class="line">    template: &#39;&lt;li&gt;&#123;&#123;index + 1&#125;&#125;. &#123;&#123;item&#125;&#125;&lt;&#x2F;li&gt;&#39;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>3-实例化 Vue 并初始化数据</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var vm &#x3D; new Vue(&#123;</span><br><span class="line">    el: &#39;#vue&#39;,</span><br><span class="line">    data: &#123;</span><br><span class="line">        todoItems: [&#39;狂神说Java&#39;, &#39;狂神说运维&#39;, &#39;狂神说前端&#39;]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>4-将这些值,通过插槽插入</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;vue&quot;&gt;</span><br><span class="line">    &lt;todo&gt;</span><br><span class="line">        &lt;todo-title slot&#x3D;&quot;todo-title&quot; title&#x3D;&quot;秦老师系列课程&quot;&gt;&lt;&#x2F;todo-title&gt;</span><br><span class="line">        &lt;todo-items slot&#x3D;&quot;todo-items&quot; v-for&#x3D;&quot;(item, index) in todoItems&quot; v-bind:item&#x3D;&quot;item&quot; v-bind:index&#x3D;&quot;index&quot; :key&#x3D;&quot;index&quot;&gt;&lt;&#x2F;todo-items&gt;</span><br><span class="line">    &lt;&#x2F;todo&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><p>说明:我们的 todo-title 和 todo-items 组件分别被分发到了 todo 组件的 todo-title 和 todo-items 插槽中</p><h2 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a>自定义事件</h2><p>通过以上代码不难发现，数据项在 Vue 的实例中，但删除操作要在组件中完成，那么组件如何才能删除 Vue 实例中的数据呢？此时就涉及到参数传递与事件分发了，Vue 为我们提供了自定义事件的功能很好的帮助我们解决了这个问题；使用 this.$emit(‘自定义事件名’, 参数)，操作过程如下:</p><p>1-在vue的实例中,增加了 methods 对象并定义了一个名为 removeTodoItems 的方法</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var vm &#x3D; new Vue(&#123;</span><br><span class="line">    el: &#39;#vue&#39;,</span><br><span class="line">    data: &#123;</span><br><span class="line">        title: &quot;秦老师系列课程1&quot;,</span><br><span class="line">        todoItems: [&#39;狂神说Java&#39;, &#39;狂神说运维&#39;, &#39;狂神说前端&#39;]</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        &#x2F;&#x2F; 该方法可以被模板中自定义事件触发</span><br><span class="line">        removeTodoItems: function (index) &#123;</span><br><span class="line">            console.log(&quot;删除 &quot; + this.todoItems[index] + &quot; 成功&quot;);</span><br><span class="line">            &#x2F;&#x2F; splice() 方法向&#x2F;从数组中添加&#x2F;删除项目，然后返回被删除的项目，其中 index 为添加&#x2F;删除项目的位置，1 表示删除的数量</span><br><span class="line">            this.todoItems.splice(index, 1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>2-修改 todo-items 待办内容组件的代码,增加一个删除按钮,并且绑定事件!</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Vue.component(&#39;todo-items&#39;, &#123;</span><br><span class="line">    props: [&#39;item&#39;, &#39;index&#39;],</span><br><span class="line">    template: &#39;&lt;li&gt;&#123;&#123;index + 1&#125;&#125;. &#123;&#123;item&#125;&#125;  &lt;button @click&#x3D;&quot;remove_component&quot;&gt;删除&lt;&#x2F;button&gt;&lt;&#x2F;li&gt;&#39;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        remove_component: function (index) &#123;</span><br><span class="line">            &#x2F;&#x2F; 这里的 remove 是自定义事件的名称，需要在 HTML 中使用 v-on:remove 的方式指派</span><br><span class="line">            this.$emit(&#39;remove&#39;, index);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>3-修改 todo-items 待办内容组件的 HTML 代码,增加一个自定义事件,比如叫 remove,可以和组件的方法绑定,然后绑定到vue的方法中!</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--增加了 v-on:remove&#x3D;&quot;removeTodoItems(index)&quot; 自定义事件，该事件会调用 Vue 实例中定义的名为 removeTodoItems 的方法--&gt;</span><br><span class="line">&lt;todo-items slot&#x3D;&quot;todo-items&quot; v-for&#x3D;&quot;(item, index) in todoItems&quot;</span><br><span class="line">            v-bind:item&#x3D;&quot;item&quot; v-bind:index&#x3D;&quot;index&quot; :key&#x3D;&quot;index&quot;</span><br><span class="line">            v-on:remove&#x3D;&quot;removeTodoItems(index)&quot;&gt;&lt;&#x2F;todo-items&gt;</span><br></pre></td></tr></table></figure><h3 id="逻辑理解"><a href="#逻辑理解" class="headerlink" title="逻辑理解"></a>逻辑理解</h3><p><img src="https://blog.kuangstudy.com/usr/uploads/2019/10/2041589231.png" alt="20191023150103.png"></p><h2 id="Vue-入门小结"><a href="#Vue-入门小结" class="headerlink" title="Vue 入门小结"></a>Vue 入门小结</h2><p>核心 : 数据驱动 , 组件化<br>优点 : 借鉴了 AngulaJS 的模块化开发 和 React 的虚拟Dom , 虚拟Dom就是把Dom操作放到内存中执行;</p><p>常用的属性:</p><ul><li>v-if</li><li>v-else-if</li><li>v-else</li><li>v-for</li><li>v-on 绑定事件 , 简写<code>@</code></li><li>v-model 数据双向绑定</li><li>v-bind 给组件绑定参数,简写 <code>:</code></li></ul><p>组件化:</p><ul><li>组合组件 slot 插槽</li><li>组件内部绑定事件需要使用到 <code>this.$emit(&quot;事件名&quot;,参数)</code>;</li><li>计算属性的特色,缓存计算数据</li></ul><p>遵循SoC 关注度分离原则,Vue是纯粹的视图框架,并不包含,比如Ajax之类的通信功能,为了解决通信问题,我们需要使用Axios 框架做异步通信;</p><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>Vue的开发都是要基于NodeJS, 实际开发采用 vue-cli脚手架开发,vue-router 路由,vuex做状态管理; Vue UI,界面我们一般使用 ElementUI(饿了么出品),或者ICE(阿里巴巴出品!)来快速搭建前端项目~</p><p>官网:</p><ul><li><a href="https://element.eleme.cn/#/zh-CN" target="_blank" rel="noopener">https://element.eleme.cn/#/zh-CN</a></li><li><a href="https://ice.work/" target="_blank" rel="noopener">https://ice.work/</a></li></ul>]]></content>
    
    <summary type="html">
    
      前端体系、前后端分离
    
    </summary>
    
    
      <category term="Vue" scheme="https://SomunsTao.github.io/categories/Vue/"/>
    
    
      <category term="Vue" scheme="https://SomunsTao.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue 05：表单双绑、组件</title>
    <link href="https://somunstao.github.io/2020/04/15/Vue%2005%EF%BC%9A%E8%A1%A8%E5%8D%95%E5%8F%8C%E7%BB%91%E3%80%81%E7%BB%84%E4%BB%B6/"/>
    <id>https://somunstao.github.io/2020/04/15/Vue%2005%EF%BC%9A%E8%A1%A8%E5%8D%95%E5%8F%8C%E7%BB%91%E3%80%81%E7%BB%84%E4%BB%B6/</id>
    <published>2020-04-14T16:00:00.000Z</published>
    <updated>2020-08-01T15:17:33.652Z</updated>
    
    <content type="html"><![CDATA[<p>​    </p><h1 id="Vue：表单双绑、组件"><a href="#Vue：表单双绑、组件" class="headerlink" title="Vue：表单双绑、组件"></a>Vue：表单双绑、组件</h1><h2 id="什么是双向数据绑定"><a href="#什么是双向数据绑定" class="headerlink" title="什么是双向数据绑定"></a>什么是双向数据绑定</h2><p>Vue.js 是一个 MVVM 框架，即数据双向绑定，即当数据发生变化的时候，视图也就发生变化，当视图发生变化的时候，数据也会跟着同步变化。这也算是 Vue.js 的精髓之处了。</p><p>值得注意的是，我们所说的数据双向绑定，一定是对于 UI 控件来说的，非 UI 控件不会涉及到数据双向绑定。单向数据绑定是使用状态管理工具的前提。如果我们使用 <code>vuex</code>，那么数据流也是单项的，这时就会和双向数据绑定有冲突。</p><h3 id="为什么要实现数据的双向绑定"><a href="#为什么要实现数据的双向绑定" class="headerlink" title="为什么要实现数据的双向绑定"></a>为什么要实现数据的双向绑定</h3><p>在 <code>Vue.js</code> 中，如果使用 <code>vuex</code>，实际上数据还是单向的，之所以说是数据双向绑定，这是用的 UI 控件来说，对于我们处理表单，Vue.js 的双向数据绑定用起来就特别舒服了。即两者并不互斥，在全局性数据流使用单项，方便跟踪；局部性数据流使用双向，简单易操作。</p><h2 id="在表单中使用双向数据绑定"><a href="#在表单中使用双向数据绑定" class="headerlink" title="在表单中使用双向数据绑定"></a>在表单中使用双向数据绑定</h2><p>你可以用 <code>v-model</code> 指令在表单 <code>&lt;input&gt;</code>、<code>&lt;textarea&gt;</code> 及 <code>&lt;select&gt;</code> 元素上创建双向数据绑定。它会根据控件类型自动选取正确的方法来更新元素。尽管有些神奇，但 v-model 本质上不过是语法糖。它负责监听用户的输入事件以更新数据，并对一些极端场景进行一些特殊处理。</p><p><strong>注意：v-model 会忽略所有表单元素的 value、checked、selected 特性的初始值而总是将 Vue 实例的数据作为数据来源。你应该通过 JavaScript 在组件的 data 选项中声明初始值!</strong></p><h3 id="单行文本"><a href="#单行文本" class="headerlink" title="单行文本"></a>单行文本</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;狂神说Java&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;vue@2.5.21&#x2F;dist&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--我们这里希望，输入框的值和&#123;&#125;取值动态绑定，实时相同，我们就使用v-model绑定message--&gt;</span><br><span class="line">&lt;div id&#x3D;&quot;vue&quot;&gt;</span><br><span class="line">    单行文本：&lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;message&quot; value&#x3D;&quot;hello&quot; &#x2F;&gt;&amp;nbsp;&amp;nbsp;单行文本是：&#123;&#123;message&#125;&#125;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">    var vm &#x3D; new Vue(&#123;</span><br><span class="line">        el: &#39;#vue&#39;,</span><br><span class="line">        data: &#123;</span><br><span class="line">            message: &quot;Hello Vue&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><h3 id="多行文本"><a href="#多行文本" class="headerlink" title="多行文本"></a>多行文本</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;vue&quot;&gt;</span><br><span class="line">    多行文本：&lt;textarea v-model&#x3D;&quot;message&quot;&gt;&lt;&#x2F;textarea&gt;&amp;nbsp;&amp;nbsp;多行文本是：&#123;&#123;message&#125;&#125;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">    var vm &#x3D; new Vue(&#123;</span><br><span class="line">        el: &#39;#vue&#39;,</span><br><span class="line">        data: &#123;</span><br><span class="line">            message: &quot;Hello Textarea&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h3 id="单复选框"><a href="#单复选框" class="headerlink" title="单复选框"></a>单复选框</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;vue&quot;&gt;</span><br><span class="line">    单复选框：</span><br><span class="line">    &lt;input type&#x3D;&quot;checkbox&quot; id&#x3D;&quot;checkbox&quot; v-model&#x3D;&quot;checked&quot;&gt;</span><br><span class="line">    &amp;nbsp;&amp;nbsp;</span><br><span class="line">    &lt;label for&#x3D;&quot;checkbox&quot;&gt;&#123;&#123; checked &#125;&#125;&lt;&#x2F;label&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">    var vm &#x3D; new Vue(&#123;</span><br><span class="line">        el: &#39;#vue&#39;,</span><br><span class="line">        data: &#123;</span><br><span class="line">            checked: false</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h3 id="多复选框"><a href="#多复选框" class="headerlink" title="多复选框"></a>多复选框</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;vue&quot;&gt;</span><br><span class="line">    多复选框：</span><br><span class="line">    &lt;input type&#x3D;&quot;checkbox&quot; id&#x3D;&quot;jack&quot; value&#x3D;&quot;Jack&quot; v-model&#x3D;&quot;checkedNames&quot;&gt;</span><br><span class="line">    &lt;label for&#x3D;&quot;jack&quot;&gt;Jack&lt;&#x2F;label&gt;</span><br><span class="line">    &lt;input type&#x3D;&quot;checkbox&quot; id&#x3D;&quot;john&quot; value&#x3D;&quot;John&quot; v-model&#x3D;&quot;checkedNames&quot;&gt;</span><br><span class="line">    &lt;label for&#x3D;&quot;john&quot;&gt;John&lt;&#x2F;label&gt;</span><br><span class="line">    &lt;input type&#x3D;&quot;checkbox&quot; id&#x3D;&quot;mike&quot; value&#x3D;&quot;Mike&quot; v-model&#x3D;&quot;checkedNames&quot;&gt;</span><br><span class="line">    &lt;label for&#x3D;&quot;mike&quot;&gt;Mike&lt;&#x2F;label&gt;</span><br><span class="line">    &lt;span&gt;选中的值: &#123;&#123; checkedNames &#125;&#125;&lt;&#x2F;span&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">    var vm &#x3D; new Vue(&#123;</span><br><span class="line">        el: &#39;#vue&#39;,</span><br><span class="line">        data: &#123;</span><br><span class="line">            checkedNames: []</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h3 id="单选按钮"><a href="#单选按钮" class="headerlink" title="单选按钮"></a>单选按钮</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;vue&quot;&gt;</span><br><span class="line">    单选按钮：</span><br><span class="line">    &lt;input type&#x3D;&quot;radio&quot; id&#x3D;&quot;one&quot; value&#x3D;&quot;One&quot; v-model&#x3D;&quot;picked&quot;&gt;</span><br><span class="line">    &lt;label for&#x3D;&quot;one&quot;&gt;One&lt;&#x2F;label&gt;</span><br><span class="line">    &lt;input type&#x3D;&quot;radio&quot; id&#x3D;&quot;two&quot; value&#x3D;&quot;Two&quot; v-model&#x3D;&quot;picked&quot;&gt;</span><br><span class="line">    &lt;label for&#x3D;&quot;two&quot;&gt;Two&lt;&#x2F;label&gt;</span><br><span class="line">    &lt;span&gt;选中的值: &#123;&#123; picked &#125;&#125;&lt;&#x2F;span&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">    var vm &#x3D; new Vue(&#123;</span><br><span class="line">        el: &#39;#vue&#39;,</span><br><span class="line">        data: &#123;</span><br><span class="line">            picked: &#39;&#39;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h3 id="下拉框"><a href="#下拉框" class="headerlink" title="下拉框"></a>下拉框</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;vue&quot;&gt;</span><br><span class="line">    下拉框：</span><br><span class="line">    &lt;select v-model&#x3D;&quot;selected&quot;&gt;</span><br><span class="line">        &lt;option disabled value&#x3D;&quot;&quot;&gt;请选择&lt;&#x2F;option&gt;</span><br><span class="line">        &lt;option&gt;A&lt;&#x2F;option&gt;</span><br><span class="line">        &lt;option&gt;B&lt;&#x2F;option&gt;</span><br><span class="line">        &lt;option&gt;C&lt;&#x2F;option&gt;</span><br><span class="line">    &lt;&#x2F;select&gt;</span><br><span class="line">    &lt;span&gt;选中的值: &#123;&#123; selected &#125;&#125;&lt;&#x2F;span&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">    var vm &#x3D; new Vue(&#123;</span><br><span class="line">        el: &#39;#vue&#39;,</span><br><span class="line">        data: &#123;</span><br><span class="line">            selected: &#39;&#39;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：如果 <code>v-model</code> 表达式的初始值未能匹配任何选项，<select> 元素将被渲染为“未选中”状态。在 iOS 中，这会使用户无法选择第一个选项。因为这样的情况下，iOS 不会触发 change 事件。因此，更推荐像上面这样提供一个值为空的禁用选项。</p><h2 id="什么是组件"><a href="#什么是组件" class="headerlink" title="什么是组件"></a>什么是组件</h2><p>组件是可复用的 <code>Vue</code> 实例，说白了就是一组可以重复使用的模板，跟 JSTL 的自定义标签、Thymeleaf 的 <code>th:fragment</code>等框架有着异曲同工之妙。通常一个应用会以一棵嵌套的组件树的形式来组织：</p><p><img src="https://blog.kuangstudy.com/usr/uploads/2019/10/1384909422.png" alt="vue-component.png"></p><p>例如，你可能会有页头、侧边栏、内容区等组件，每个组件又包含了其它的像导航链接、博文之类的组件。</p><h3 id="第一个-Vue-组件"><a href="#第一个-Vue-组件" class="headerlink" title="第一个 Vue 组件"></a>第一个 Vue 组件</h3><p>注意：在实际开发中，我们并不会用以下方式开发组件，而是采用 vue-cli 创建 .vue 模板文件的方式开发，以下方法只是为了让大家理解什么是组件。</p><p><strong>使用 Vue.component() 方法注册组件,格式如下：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">    &#x2F;&#x2F; 先注册组件</span><br><span class="line">    Vue.component(&#39;my-component-li&#39;, &#123;</span><br><span class="line">        template: &#39;&lt;li&gt;Hello li&lt;&#x2F;li&gt;&#39;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 再实例化 Vue</span><br><span class="line">    var vm &#x3D; new Vue(&#123;</span><br><span class="line">        el: &#39;#vue&#39;</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;div id&#x3D;&quot;vue&quot;&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">        &lt;my-component-li&gt;&lt;&#x2F;my-component-li&gt;</span><br><span class="line">    &lt;&#x2F;ul&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li>Vue.component()：注册组件</li><li>my-component-li：自定义组件的名字</li><li>template：组件的模板</li></ul><h3 id="使用-props-属性传递参数"><a href="#使用-props-属性传递参数" class="headerlink" title="使用 props 属性传递参数"></a>使用 <code>props</code> 属性传递参数</h3><p>像上面那样用组件没有任何意义，所以我们是需要传递参数到组件的，此时就需要使用 <code>props</code> 属性了！</p><p><strong>注意：默认规则下 props 属性里的值不能为大写；</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">    &#x2F;&#x2F; 先注册组件</span><br><span class="line">    Vue.component(&#39;my-component-li&#39;, &#123;</span><br><span class="line">        props: [&#39;item&#39;],</span><br><span class="line">        template: &#39;&lt;li&gt;Hello &#123;&#123;item&#125;&#125;&lt;&#x2F;li&gt;&#39;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 再实例化 Vue</span><br><span class="line">    var vm &#x3D; new Vue(&#123;</span><br><span class="line">        el: &#39;#vue&#39;,</span><br><span class="line">        data: &#123;</span><br><span class="line">            items: [&quot;张三&quot;, &quot;李四&quot;, &quot;王五&quot;]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;div id&#x3D;&quot;vue&quot;&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">        &lt;my-component-li v-for&#x3D;&quot;item in items&quot; v-bind:item&#x3D;&quot;item&quot;&gt;&lt;&#x2F;my-component-li&gt;</span><br><span class="line">    &lt;&#x2F;ul&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li><code>v-for=&quot;item in items&quot;</code>：遍历 <code>Vue</code> 实例中定义的名为 <code>items</code> 的数组，并创建同等数量的组件</li><li><code>v-bind:item=&quot;item&quot;</code>：将遍历的 <code>item</code> 项绑定到组件中 <code>props</code> 定义的名为 <code>item</code> 属性上；= 号左边的 item 为 props 定义的属性名，右边的为 <code>item in items</code> 中遍历的 item 项的值</li></ul>]]></content>
    
    <summary type="html">
    
      前端体系、前后端分离
    
    </summary>
    
    
      <category term="Vue" scheme="https://SomunsTao.github.io/categories/Vue/"/>
    
    
      <category term="Vue" scheme="https://SomunsTao.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue 04：Axios异步通信</title>
    <link href="https://somunstao.github.io/2020/04/14/Vue%2004%EF%BC%9AAxios%E5%BC%82%E6%AD%A5%E9%80%9A%E4%BF%A1/"/>
    <id>https://somunstao.github.io/2020/04/14/Vue%2004%EF%BC%9AAxios%E5%BC%82%E6%AD%A5%E9%80%9A%E4%BF%A1/</id>
    <published>2020-04-13T16:00:00.000Z</published>
    <updated>2020-08-01T15:17:11.703Z</updated>
    
    <content type="html"><![CDATA[<p>​    </p><h1 id="Vue：Axios异步通信"><a href="#Vue：Axios异步通信" class="headerlink" title="Vue：Axios异步通信"></a>Vue：Axios异步通信</h1><h2 id="什么是Axios"><a href="#什么是Axios" class="headerlink" title="什么是Axios"></a>什么是Axios</h2><p>Axios 是一个开源的可以用在浏览器端和 <code>NodeJS</code> 的异步通信框架，她的主要作用就是实现 AJAX 异步通信，其功能特点如下：</p><ul><li>从浏览器中创建 <code>XMLHttpRequests</code></li><li>从 node.js 创建 http 请求</li><li>支持 Promise API [JS中链式编程]</li><li>拦截请求和响应</li><li>转换请求数据和响应数据</li><li>取消请求</li><li>自动转换 JSON 数据</li><li>客户端支持防御 XSRF（跨站请求伪造）</li></ul><p>GitHub：<a href="https://github.com/axios/axios" target="_blank" rel="noopener">https://github.com/axios/axios</a></p><p>中文文档：<a href="http://www.axios-js.com/" target="_blank" rel="noopener">http://www.axios-js.com/</a></p><h3 id="为什么要使用-Axios"><a href="#为什么要使用-Axios" class="headerlink" title="为什么要使用 Axios"></a>为什么要使用 Axios</h3><p>由于 <code>Vue.js</code> 是一个 视图层框架 并且作者（尤雨溪）严格准守 SoC （关注度分离原则），所以 <code>Vue.js</code> 并不包含 AJAX 的通信功能，为了解决通信问题，作者单独开发了一个名为 <code>vue-resource</code> 的插件，不过在进入 2.0 版本以后停止了对该插件的维护并推荐了 <code>Axios</code> 框架。少用jQuery，因为它操作Dom太频繁！</p><h2 id="第一个-Axios-应用程序"><a href="#第一个-Axios-应用程序" class="headerlink" title="第一个 Axios 应用程序"></a>第一个 Axios 应用程序</h2><p>咱们开发的接口大部分都是采用 JSON 格式，可以先在项目里模拟一段 JSON 数据，数据内容如下：创建一个名为 data.json 的文件并填入上面的内容，放在项目的根目录下</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;狂神说Java&quot;,</span><br><span class="line">  &quot;url&quot;: &quot;https:&#x2F;&#x2F;blog.kuangstudy.com&quot;,</span><br><span class="line">  &quot;page&quot;: 1,</span><br><span class="line">  &quot;isNonProfit&quot;: true,</span><br><span class="line">  &quot;address&quot;: &#123;</span><br><span class="line">    &quot;street&quot;: &quot;含光门&quot;,</span><br><span class="line">    &quot;city&quot;: &quot;陕西西安&quot;,</span><br><span class="line">    &quot;country&quot;: &quot;中国&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;links&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;name&quot;: &quot;bilibili&quot;,</span><br><span class="line">      &quot;url&quot;: &quot;https:&#x2F;&#x2F;space.bilibili.com&#x2F;95256449&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;name&quot;: &quot;狂伸说java&quot;,</span><br><span class="line">      &quot;url&quot;: &quot;https:&#x2F;&#x2F;blog.kuangstudy.com&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;name&quot;: &quot;百度&quot;,</span><br><span class="line">      &quot;url&quot;: &quot;https:&#x2F;&#x2F;www.baidu.com&#x2F;&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试代码</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot; xmlns:v-bind&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;1999&#x2F;xhtml&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;狂神说Java&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;!--v-cloak 解决闪烁问题--&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        [v-cloak] &#123;</span><br><span class="line">            display: none;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;&#x2F;style&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;div id&#x3D;&quot;vue&quot; v-cloak&gt;</span><br><span class="line">    &lt;div&gt;名称：&#123;&#123;info.name&#125;&#125;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;div&gt;地址：&#123;&#123;info.address.country&#125;&#125;-&#123;&#123;info.address.city&#125;&#125;-&#123;&#123;info.address.street&#125;&#125;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;div&gt;链接：&lt;a v-bind:href&#x3D;&quot;info.url&quot; target&#x3D;&quot;_blank&quot;&gt;&#123;&#123;info.url&#125;&#125;&lt;&#x2F;a&gt; &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--引入 JS 文件--&gt;</span><br><span class="line">&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;vue@2.5.21&#x2F;dist&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;unpkg.com&#x2F;axios&#x2F;dist&#x2F;axios.min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">    var vm &#x3D; new Vue(&#123;</span><br><span class="line">        el: &#39;#vue&#39;,</span><br><span class="line">        data() &#123;</span><br><span class="line">            return &#123;</span><br><span class="line">                info: &#123;</span><br><span class="line">                    name: null,</span><br><span class="line">                    address: &#123;</span><br><span class="line">                        country: null,</span><br><span class="line">                        city: null,</span><br><span class="line">                        street: null</span><br><span class="line">                    &#125;,</span><br><span class="line">                    url: null</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        mounted() &#123; &#x2F;&#x2F;钩子函数</span><br><span class="line">            axios</span><br><span class="line">                .get(&#39;data.json&#39;)</span><br><span class="line">                .then(response &#x3D;&gt; (this.info &#x3D; response.data));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p>说明:</p><ol><li>在这里使用了 v-bind 将 a:href 的属性值与 Vue 实例中的数据进行绑定</li><li>使用 axios 框架的 get 方法请求 AJAX 并自动将数据封装进了 Vue 实例的数据对象中</li><li>我们在data中的数据结构必须要和<code>Ajax</code>响应回来的数据格式匹配！</li></ol><h2 id="Vue的生命周期"><a href="#Vue的生命周期" class="headerlink" title="Vue的生命周期"></a>Vue的生命周期</h2><p>官方文档：<a href="https://cn.vuejs.org/v2/guide/instance.html#生命周期图示" target="_blank" rel="noopener">https://cn.vuejs.org/v2/guide/instance.html#生命周期图示</a></p><p>Vue 实例有一个完整的生命周期，也就是从开始创建、初始化数据、编译模板、挂载 DOM、渲染→更新→渲染、卸载等一系列过程，我们称这是 Vue 的生命周期。通俗说就是 Vue 实例从创建到销毁的过程，就是生命周期。</p><p>在 Vue 的整个生命周期中，它提供了一系列的事件，可以让我们在事件触发时注册 JS 方法，可以让我们用自己注册的 JS 方法控制整个大局，在这些事件响应方法中的 this 直接指向的是 Vue 的实例。</p><p><img src="https://blog.kuangstudy.com/usr/uploads/2019/10/1579484219.jpg" alt="vue-life.jpg"></p>]]></content>
    
    <summary type="html">
    
      前端体系、前后端分离
    
    </summary>
    
    
      <category term="Vue" scheme="https://SomunsTao.github.io/categories/Vue/"/>
    
    
      <category term="Vue" scheme="https://SomunsTao.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue 03：基础语法</title>
    <link href="https://somunstao.github.io/2020/04/13/Vue%2003%EF%BC%9A%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    <id>https://somunstao.github.io/2020/04/13/Vue%2003%EF%BC%9A%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</id>
    <published>2020-04-12T16:00:00.000Z</published>
    <updated>2020-08-01T15:16:45.568Z</updated>
    
    <content type="html"><![CDATA[<p>​    </p><h1 id="Vue：基础语法"><a href="#Vue：基础语法" class="headerlink" title="Vue：基础语法"></a>Vue：基础语法</h1><h2 id="v-bind"><a href="#v-bind" class="headerlink" title="v-bind"></a>v-bind</h2><p>我们已经成功创建了第一个 Vue 应用！看起来这跟渲染一个字符串模板非常类似，但是 Vue 在背后做了大量工作。现在数据和 DOM 已经被建立了关联，所有东西都是响应式的。我们在控制台操作对象属性，界面可以实时更新！</p><p>我们还可以使用<code>v-bind</code>来绑定元素特性!</p><p><strong>上代码：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html xmlns:v-bind&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;1999&#x2F;xhtml&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;狂神说Java&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;vue@2.5.21&#x2F;dist&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">  &lt;span v-bind:title&#x3D;&quot;message&quot;&gt;</span><br><span class="line">    鼠标悬停几秒钟查看此处动态绑定的提示信息！</span><br><span class="line">  &lt;&#x2F;span&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">    var app &#x3D; new Vue(&#123;</span><br><span class="line">        el: &#39;#app&#39;,</span><br><span class="line">        data: &#123;</span><br><span class="line">            message: &#39;页面加载于 &#39; + new Date().toLocaleString()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p>你看到的 v-bind 等被称为指令。指令带有前缀 v-，以表示它们是 Vue 提供的特殊特性。可能你已经猜到了，它们会在渲染的 DOM 上应用特殊的响应式行为。在这里，该指令的意思是：“将这个元素节点的 title 特性和 Vue 实例的 message 属性保持一致”。</p><p>如果你再次打开浏览器的 JavaScript 控制台，输入 app.message = ‘新消息’，就会再一次看到这个绑定了 title 特性的 HTML 已经进行了更新。</p><h2 id="v-if-v-else"><a href="#v-if-v-else" class="headerlink" title="v-if,v-else"></a>v-if,v-else</h2><p>什么是条件判断语句，就不需要我说明了吧（￣▽￣）,以下两个属性！</p><ul><li><code>v-if</code></li><li><code>v-else</code></li></ul><p><strong>上代码：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;狂神说Java&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;vue@2.5.21&#x2F;dist&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;div id&#x3D;&quot;vue&quot;&gt;</span><br><span class="line">    &lt;h1 v-if&#x3D;&quot;ok&quot;&gt;YES&lt;&#x2F;h1&gt;</span><br><span class="line">    &lt;h1 v-else&gt;NO&lt;&#x2F;h1&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">    var vm &#x3D; new Vue(&#123;</span><br><span class="line">        el: &#39;#vue&#39;,</span><br><span class="line">        data: &#123;</span><br><span class="line">            ok: true</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p>测试：</p><ol><li>在浏览器上运行，打开控制台！</li><li>在控制台输入 <code>vm.ok = false</code> ，然后 回车，你会发现浏览器中显示的内容会直接变成 NO</li></ol><p>注：使用 <code>v-*</code> 属性绑定数据是不需要 <code>双花括号</code> 包裹的</p><h2 id="v-else-if"><a href="#v-else-if" class="headerlink" title="v-else-if"></a>v-else-if</h2><ul><li>v-if</li><li>v-else-if</li><li>v-else</li></ul><p>注：<code>===</code> 三个等号在 JS 中表示绝对等于（就是数据与类型都要相等）</p><p><strong>上代码：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;狂神说Java&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;vue@2.5.21&#x2F;dist&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;div id&#x3D;&quot;vue&quot;&gt;</span><br><span class="line">    &lt;h1 v-if&#x3D;&quot;type &#x3D;&#x3D;&#x3D; &#39;A&#39;&quot;&gt;A&lt;&#x2F;h1&gt;</span><br><span class="line">    &lt;h1 v-else-if&#x3D;&quot;type &#x3D;&#x3D;&#x3D; &#39;B&#39;&quot;&gt;B&lt;&#x2F;h1&gt;</span><br><span class="line">    &lt;h1 v-else-if&#x3D;&quot;type &#x3D;&#x3D;&#x3D; &#39;C&#39;&quot;&gt;C&lt;&#x2F;h1&gt;</span><br><span class="line">    &lt;h1 v-else&gt;who&lt;&#x2F;h1&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">    var vm &#x3D; new Vue(&#123;</span><br><span class="line">        el: &#39;#vue&#39;,</span><br><span class="line">        data: &#123;</span><br><span class="line">            type: &#39;A&#39;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p>测试：观察在控制台输入 vm.type = ‘B’、’C’、’D’ 的变化</p><h2 id="v-for"><a href="#v-for" class="headerlink" title="v-for"></a>v-for</h2><ul><li>v-for</li></ul><p>格式说明：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;vue&quot;&gt;</span><br><span class="line">    &lt;li v-for&#x3D;&quot;item in items&quot;&gt;</span><br><span class="line">        &#123;&#123; item.message &#125;&#125;</span><br><span class="line">    &lt;&#x2F;li&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><p>注：<code>items</code> 是数组，<code>item</code>是数组元素迭代的别名。我们之后学习的Thymeleaf模板引擎的语法和这个十分的相似！</p><p><strong>上代码：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;狂神说Java&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;vue@2.5.21&#x2F;dist&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;div id&#x3D;&quot;vue&quot;&gt;</span><br><span class="line">    &lt;li v-for&#x3D;&quot;item in items&quot;&gt;</span><br><span class="line">        &#123;&#123; item.message &#125;&#125;</span><br><span class="line">    &lt;&#x2F;li&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">    var vm &#x3D; new Vue(&#123;</span><br><span class="line">        el: &#39;#vue&#39;,</span><br><span class="line">        data: &#123;</span><br><span class="line">            &#x2F;&#x2F;items数组</span><br><span class="line">            items: [</span><br><span class="line">                &#123;message: &#39;狂神说Java&#39;&#125;,</span><br><span class="line">                &#123;message: &#39;狂神说前端&#39;&#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p>测试 ：在控制台输入 <code>vm.items.push({message: &#39;狂神说运维&#39;})</code> ，尝试追加一条数据，你会发现浏览器中显示的内容会增加一条 <code>狂神说运维</code>.</p><h2 id="v-on"><a href="#v-on" class="headerlink" title="v-on"></a>v-on</h2><p><code>v-on</code> 监听事件</p><p>事件有Vue的事件、和前端页面本身的一些事件！我们这里的<code>click</code>是vue的事件，可以绑定到Vue中的<code>methods</code>中的方法事件！</p><p><strong>上代码：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html xmlns:v-on&#x3D;&quot;&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;狂神说Java&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;vue@2.5.21&#x2F;dist&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;div id&#x3D;&quot;vue&quot;&gt;</span><br><span class="line">    &lt;!--在这里我们使用了 v-on 绑定了 click 事件，并指定了名为 sayHi 的方法--&gt;</span><br><span class="line">    &lt;button v-on:click&#x3D;&quot;sayHi&quot;&gt;点我&lt;&#x2F;button&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">    var vm &#x3D; new Vue(&#123;</span><br><span class="line">        el: &#39;#vue&#39;,</span><br><span class="line">        data: &#123;</span><br><span class="line">            message: &#39;Hello World&#39;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#x2F;&#x2F; 方法必须定义在 Vue 实例的 methods 对象中</span><br><span class="line">        methods: &#123;</span><br><span class="line">            sayHi: function (event) &#123;</span><br><span class="line">                &#x2F;&#x2F; &#96;this&#96; 在方法里指向当前 Vue 实例</span><br><span class="line">                alert(this.message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p>点击测试</p><p>Vue还有一些基本的使用方式，大家有需要的可以再跟着官方文档看看，因为这些基本的指令几乎我们都见过了，一通百通！掌握学习的方式！</p><p><a href="https://blog.kuangstudy.com/index.php/tag/Vue/" target="_blank" rel="noopener">VUE</a></p>]]></content>
    
    <summary type="html">
    
      前端体系、前后端分离
    
    </summary>
    
    
      <category term="Vue" scheme="https://SomunsTao.github.io/categories/Vue/"/>
    
    
      <category term="Vue" scheme="https://SomunsTao.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue 02：MVVM模式和第一个Vue程序</title>
    <link href="https://somunstao.github.io/2020/04/12/Vue%2002%EF%BC%9AMVVM%E6%A8%A1%E5%BC%8F%E5%92%8C%E7%AC%AC%E4%B8%80%E4%B8%AAVue%E7%A8%8B%E5%BA%8F/"/>
    <id>https://somunstao.github.io/2020/04/12/Vue%2002%EF%BC%9AMVVM%E6%A8%A1%E5%BC%8F%E5%92%8C%E7%AC%AC%E4%B8%80%E4%B8%AAVue%E7%A8%8B%E5%BA%8F/</id>
    <published>2020-04-11T16:00:00.000Z</published>
    <updated>2020-08-01T15:16:10.772Z</updated>
    
    <content type="html"><![CDATA[<p>​    </p><h1 id="Vue：MVVM模式和第一个Vue程序"><a href="#Vue：MVVM模式和第一个Vue程序" class="headerlink" title="Vue：MVVM模式和第一个Vue程序"></a>Vue：MVVM模式和第一个Vue程序</h1><h2 id="什么是-MVVM"><a href="#什么是-MVVM" class="headerlink" title="什么是 MVVM"></a>什么是 MVVM</h2><p>MVVM（Model-View-ViewModel）是一种软件架构设计模式，由微软 WPF（用于替代 WinForm，以前就是用这个技术开发桌面应用程序的）和 Silverlight（类似于 Java Applet，简单点说就是在浏览器上运行的 WPF） 的架构师 Ken Cooper 和 Ted Peters 开发，是一种简化用户界面的<strong>事件驱动编程方式</strong>。由 John Gossman（同样也是 WPF 和 Silverlight 的架构师）于 2005 年在他的博客上发表。</p><p>MVVM 源自于经典的 MVC（Model-View-Controller）模式。MVVM 的核心是 ViewModel 层，负责转换 Model 中的数据对象来让数据变得更容易管理和使用，其作用如下：</p><ul><li>该层向上与视图层进行双向数据绑定</li><li>向下与 Model 层通过接口请求进行数据交互<br><img src="https://blog.kuangstudy.com/usr/uploads/2019/10/1897504213.png" alt="20191017111649.png"></li></ul><p>MVVM 已经相当成熟了，主要运用但不仅仅在网络应用程序开发中。当下流行的 MVVM 框架有 <code>Vue.js</code>，<code>AngularJS</code> 等。</p><h2 id="为什么要使用-MVVM"><a href="#为什么要使用-MVVM" class="headerlink" title="为什么要使用 MVVM"></a>为什么要使用 MVVM</h2><p>MVVM 模式和 MVC 模式一样，主要目的是分离视图（View）和模型（Model），有几大好处</p><ul><li><strong>低耦合</strong>： 视图（View）可以独立于 Model 变化和修改，一个 ViewModel 可以绑定到不同的 View 上，当 View 变化的时候 Model 可以不变，当 Model 变化的时候 View 也可以不变。</li><li><strong>可复用</strong>： 你可以把一些视图逻辑放在一个 ViewModel 里面，让很多 View 重用这段视图逻辑。</li><li><strong>独立开发</strong>： 开发人员可以专注于业务逻辑和数据的开发（ViewModel），设计人员可以专注于页面设计。</li><li><strong>可测试</strong>： 界面素来是比较难于测试的，而现在测试可以针对 ViewModel 来写。</li></ul><h2 id="MVVM-的组成部分"><a href="#MVVM-的组成部分" class="headerlink" title="MVVM 的组成部分"></a>MVVM 的组成部分</h2><p><img src="https://blog.kuangstudy.com/usr/uploads/2019/10/1552878682.png" alt="20191017111955.png"></p><h3 id="View"><a href="#View" class="headerlink" title="View"></a>View</h3><p>View 是视图层，也就是用户界面。前端主要由 <code>HTML</code> 和 <code>CSS</code> 来构建，为了更方便地展现 <code>ViewModel</code> 或者 <code>Model</code> 层的数据，已经产生了各种各样的前后端模板语言，比如 FreeMarker、Thymeleaf 等等，各大 MVVM 框架如 Vue.js，AngularJS，EJS 等也都有自己用来构建用户界面的内置模板语言。</p><h3 id="Model"><a href="#Model" class="headerlink" title="Model"></a>Model</h3><p>Model 是指数据模型，泛指后端进行的各种业务逻辑处理和数据操控，主要围绕数据库系统展开。这里的难点主要在于需要和前端约定统一的 <code>接口规则</code></p><h3 id="ViewModel"><a href="#ViewModel" class="headerlink" title="ViewModel"></a>ViewModel</h3><p>ViewModel 是由前端开发人员组织生成和维护的视图数据层。在这一层，前端开发者对从后端获取的 Model 数据进行转换处理，做二次封装，以生成符合 View 层使用预期的视图数据模型。</p><p>需要注意的是 ViewModel 所封装出来的数据模型包括视图的状态和行为两部分，而 Model 层的数据模型是只包含状态的</p><ul><li>比如页面的这一块展示什么，那一块展示什么这些都属于视图状态（展示）</li><li>页面加载进来时发生什么，点击这一块发生什么，这一块滚动时发生什么这些都属于视图行为（交互）</li></ul><p>视图状态和行为都封装在了 ViewModel 里。这样的封装使得 ViewModel 可以完整地去描述 View 层`。由于实现了双向绑定，ViewModel 的内容会实时展现在 View 层，这是激动人心的，因为前端开发者再也不必低效又麻烦地通过操纵 DOM 去更新视图。</p><p>MVVM 框架已经把最脏最累的一块做好了，我们开发者只需要处理和维护 ViewModel，更新数据视图就会自动得到相应更新，真正实现 <code>事件驱动编程</code>。</p><p>View 层展现的不是 <code>Model</code> 层的数据，而是 <code>ViewModel</code> 的数据，由 <code>ViewModel</code> 负责与 <code>Model</code> 层交互，这就<strong>完全解耦了 View 层和 Model 层，这个解耦是至关重要的，它是前后端分离方案实施的重要一环。</strong></p><h2 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h2><p>Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式框架，发布于 2014 年 2 月。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库（如：vue-router，vue-resource，vuex）或既有项目整合。</p><h3 id="MVVM-模式的实现者"><a href="#MVVM-模式的实现者" class="headerlink" title="MVVM 模式的实现者"></a>MVVM 模式的实现者</h3><ul><li>Model：模型层，在这里表示 JavaScript 对象</li><li>View：视图层，在这里表示 DOM（HTML 操作的元素）</li><li>ViewModel：连接视图和数据的中间件，Vue.js 就是 MVVM 中的 ViewModel 层的实现者</li></ul><p>在 MVVM 架构中，是不允许 数据 和 视图 直接通信的，只能通过 ViewModel 来通信，而 ViewModel 就是定义了一个 Observer 观察者</p><ul><li>ViewModel 能够观察到数据的变化，并对视图对应的内容进行更新</li><li>ViewModel 能够监听到视图的变化，并能够通知数据发生改变</li></ul><p>至此，我们就明白了，Vue.js 就是一个 MVVM 的实现者，他的核心就是实现了 DOM 监听 与 数据绑定</p><h3 id="为什么要使用-Vue-js"><a href="#为什么要使用-Vue-js" class="headerlink" title="为什么要使用 Vue.js"></a>为什么要使用 Vue.js</h3><ul><li>轻量级，体积小是一个重要指标。Vue.js 压缩后有只有 20多kb （Angular 压缩后 56kb+，React 压缩后 44kb+）</li><li>移动优先。更适合移动端，比如移动端的 Touch 事件</li><li>易上手，学习曲线平稳，文档齐全</li><li>吸取了 Angular（模块化）和 React（虚拟 DOM）的长处，并拥有自己独特的功能，如：计算属性</li><li>开源，社区活跃度高</li><li>……</li></ul><h2 id="第一个Vue程序"><a href="#第一个Vue程序" class="headerlink" title="第一个Vue程序"></a>第一个Vue程序</h2><p>【说明】IDEA 可以安装 Vue 的插件！</p><p>注意：Vue 不支持 IE8 及以下版本，因为 Vue 使用了 IE8 无法模拟的 ECMAScript 5 特性。但它支持所有兼容 ECMAScript 5 的浏览器。</p><h3 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h3><ul><li>开发版本<ul><li>包含完整的警告和调试模式：<a href="https://vuejs.org/js/vue.js" target="_blank" rel="noopener">https://vuejs.org/js/vue.js</a></li><li>删除了警告，30.96KB min + gzip：<a href="https://vuejs.org/js/vue.min.js" target="_blank" rel="noopener">https://vuejs.org/js/vue.min.js</a></li></ul></li><li>CDN<ul><li><code>&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.js&quot;&gt;&lt;/script&gt;</code></li><li><code>&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.min.js&quot;&gt;&lt;/script&gt;</code></li></ul></li></ul><h3 id="代码编写"><a href="#代码编写" class="headerlink" title="代码编写"></a>代码编写</h3><p>Vue.js 的核心是实现了 MVVM 模式，她扮演的角色就是 ViewModel 层，那么所谓的第一个应用程序就是展示她的 数据绑定 功能，操作流程如下：</p><p><strong>1、创建一个 HTML 文件</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;狂神说&lt;&#x2F;title&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p><strong>2、引入 Vue.js</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;vue@2.5.21&#x2F;dist&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p><strong>3、创建一个 Vue 的实例</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">    var vm &#x3D; new Vue(&#123;</span><br><span class="line">        el: &#39;#vue&#39;,</span><br><span class="line">        data: &#123;</span><br><span class="line">            message: &#39;Hello Vue!&#39;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>说明:</p><ul><li><code>el:&#39;#vue&#39;</code>：绑定元素的 ID</li><li><code>data:{message:&#39;Hello Vue!&#39;}</code>：数据对象中有一个名为 message 的属性，并设置了初始值 Hello Vue!</li></ul><p><strong>4、将数据绑定到页面元素</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;vue&quot;&gt;</span><br><span class="line">    &#123;&#123;message&#125;&#125;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><p>说明：只需要在绑定的元素中使用 双花括号 将 Vue 创建的名为 message 属性包裹起来，即可实现数据绑定功能，也就实现了 ViewModel 层所需的效果，是不是和 EL 表达式非常像？</p><h3 id="完整的-HTML"><a href="#完整的-HTML" class="headerlink" title="完整的 HTML"></a>完整的 HTML</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;第一个 Vue 应用程序&lt;&#x2F;title&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--View--&gt;</span><br><span class="line">&lt;div id&#x3D;&quot;vue&quot;&gt;</span><br><span class="line">     &#123;&#123;message&#125;&#125;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;vue@2.5.21&#x2F;dist&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">    &#x2F;&#x2F; var vm &#x3D; new Vue(&#123;&#125;); &#x2F;&#x2F;ViewModel</span><br><span class="line">    var vm &#x3D; new Vue(&#123;</span><br><span class="line">        el: &#39;#vue&#39;,</span><br><span class="line">        data: &#123; &#x2F;&#x2F;Model</span><br><span class="line">            message: &#39;Hello Vue!&#39;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>为了能够更直观的体验 Vue 带来的数据绑定功能，我们需要在浏览器测试一番，操作流程如下：</p><p>1、在浏览器上运行第一个 Vue 应用程序，进入 开发者工具</p><p>2、在控制台输入 vm.message = ‘Hello World’ ，然后 回车，你会发现浏览器中显示的内容会直接变成 Hello World</p><p>此时就可以在控制台直接输入 vm.message 来修改值，中间是可以省略 data 的，在这个操作中，我并没有主动操作 DOM，就让页面的内容发生了变化，这就是借助了 Vue 的 数据绑定 功能实现的；MVVM 模式中要求 ViewModel 层就是使用 观察者模式 来实现数据的监听与绑定，以做到数据与视图的快速响应。</p>]]></content>
    
    <summary type="html">
    
      前端体系、前后端分离MVVM
    
    </summary>
    
    
      <category term="Vue" scheme="https://SomunsTao.github.io/categories/Vue/"/>
    
    
      <category term="Vue" scheme="https://SomunsTao.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue 01：前端体系、前后端分离</title>
    <link href="https://somunstao.github.io/2020/04/11/Vue%2001%EF%BC%9A%E5%89%8D%E7%AB%AF%E4%BD%93%E7%B3%BB%E3%80%81%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB/"/>
    <id>https://somunstao.github.io/2020/04/11/Vue%2001%EF%BC%9A%E5%89%8D%E7%AB%AF%E4%BD%93%E7%B3%BB%E3%80%81%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB/</id>
    <published>2020-04-10T16:00:00.000Z</published>
    <updated>2020-08-01T15:15:51.467Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Vue：前端体系、前后端分离"><a href="#Vue：前端体系、前后端分离" class="headerlink" title="Vue：前端体系、前后端分离"></a>Vue：前端体系、前后端分离</h1><h2 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h2><p>Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的<strong>渐进式框架</strong>，发布于 2014 年 2 月。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。<strong>Vue 的核心库只关注视图层</strong>，不仅易于上手，还便于与第三方库（如：<code>vue-router：跳转</code>，<code>vue-resource：通信</code>，<code>vuex：管理</code>）或既有项目整合。</p><p>官网：<a href="https://cn.vuejs.org/v2/guide/" target="_blank" rel="noopener">https://cn.vuejs.org/v2/guide/</a></p><h2 id="2、前端知识体系"><a href="#2、前端知识体系" class="headerlink" title="2、前端知识体系"></a>2、前端知识体系</h2><p>想要成为真正的“互联网 Java 全栈工程师”还有很长的一段路要走，其中“我大前端”是绕不开的一门必修课。本阶段课程的主要目的就是带领我 Java 后台程序员认识前端、了解前端、掌握前端，为实现成为“互联网 Java 全栈工程师”再向前迈进一步。</p><h3 id="2-1、前端三要素"><a href="#2-1、前端三要素" class="headerlink" title="2.1、前端三要素"></a>2.1、前端三要素</h3><ul><li>HTML（结构）：超文本标记语言（Hyper Text Markup Language），决定网页的结构和内容</li><li>CSS（表现）：层叠样式表（Cascading Style Sheets），设定网页的表现样式</li><li>JavaScript（行为）：是一种弱类型脚本语言，其源代码不需经过编译，而是由浏览器解释运行，用于控制网页的行为</li></ul><h3 id="2-2、结构层（HTML）"><a href="#2-2、结构层（HTML）" class="headerlink" title="2.2、结构层（HTML）"></a>2.2、结构层（HTML）</h3><p>太简单，略</p><h3 id="2-3、表现层（CSS）"><a href="#2-3、表现层（CSS）" class="headerlink" title="2.3、表现层（CSS）"></a>2.3、表现层（CSS）</h3><p>CSS 层叠样式表是一门标记语言，并不是编程语言，因此不可以自定义变量，不可以引用等，换句话说就是不具备任何语法支持，它主要缺陷如下：</p><ul><li>语法不够强大，比如无法嵌套书写，导致模块化开发中需要书写很多重复的选择器；</li><li>没有变量和合理的样式复用机制，使得逻辑上相关的属性值必须以字面量的形式重复输出，导致难以维护；</li></ul><p>这就导致了我们在工作中无端增加了许多工作量。为了解决这个问题，前端开发人员会使用一种称之为 <strong>【CSS 预处理器】</strong> 的工具，提供 CSS 缺失的样式层复用机制、减少冗余代码，提高样式代码的可维护性。大大提高了前端在样式上的开发效率。</p><h3 id="什么是-CSS-预处理器"><a href="#什么是-CSS-预处理器" class="headerlink" title="什么是 CSS 预处理器"></a>什么是 CSS 预处理器</h3><p>CSS 预处理器定义了一种新的语言，其基本思想是，用一种专门的编程语言，为 CSS 增加了一些编程的特性，将 CSS 作为目标生成文件，然后开发者就只要使用这种语言进行 CSS 的编码工作。转化成通俗易懂的话来说就是“<strong>用一种专门的编程语言，进行 Web 页面样式设计，再通过编译器转化为正常的 CSS 文件，以供项目使用</strong>”。</p><p><strong>常用的 CSS 预处理器有哪些</strong></p><ul><li>SASS：基于 Ruby，通过服务端处理，功能强大。解析效率高。需要学习 Ruby 语言，上手难度高于 LESS。</li><li>LESS：基于 NodeJS，通过客户端处理，使用简单。功能比 SASS 简单，解析效率也低于 SASS，但在实际开发中足够了，所以我们后台人员如果需要的话，建议使用 LESS。</li></ul><h3 id="2-4、行为层（JavaScript）"><a href="#2-4、行为层（JavaScript）" class="headerlink" title="2.4、行为层（JavaScript）"></a>2.4、行为层（JavaScript）</h3><p>JavaScript 一门弱类型脚本语言，其源代码在发往客户端运行之前不需经过编译，而是将文本格式的字符代码发送给浏览器由浏览器解释运行。</p><p><strong>Native 原生 JS 开发</strong></p><p>原生 JS 开发，也就是让我们按照 <strong>【ECMAScript】</strong> 标准的开发方式，简称是 ES，特点是所有浏览器都支持。截止到当前博客发布时间，ES 标准已发布如下版本：</p><ul><li>ES3</li><li>ES4（内部，未正式发布）</li><li>ES5（全浏览器支持）</li><li>ES6（常用，当前主流版本：webpack打包成为ES5支持！）</li><li>ES7</li><li>ES8</li><li>ES9（草案阶段）</li></ul><p>区别就是逐步增加新特性。</p><p><strong>TypeScript 微软的标准</strong></p><p>TypeScript 是一种由微软开发的自由和开源的编程语言。它是 JavaScript 的一个超集，而且本质上向这个语言添加了可选的静态类型和基于类的面向对象编程。由安德斯·海尔斯伯格（C#、Delphi、TypeScript 之父；.NET 创立者）主导。</p><p>该语言的特点就是除了具备 ES 的特性之外还纳入了许多不在标准范围内的新特性，所以会导致很多浏览器不能直接支持 TypeScript 语法，需要编译后（编译成 JS）才能被浏览器正确执行。</p><h3 id="JavaScript-框架"><a href="#JavaScript-框架" class="headerlink" title="JavaScript 框架"></a>JavaScript 框架</h3><ul><li>jQuery：大家熟知的 JavaScript 框架，优点是简化了 DOM 操作，缺点是 DOM 操作太频繁，影响前端性能；在前端眼里使用它仅仅是为了兼容 IE6、7、8；</li><li>Angular：Google 收购的前端框架，由一群 Java 程序员开发，其特点是将后台的 MVC 模式搬到了前端并增加了<strong>模块化开发</strong>的理念，与微软合作，采用 TypeScript 语法开发；对后台程序员友好，对前端程序员不太友好；最大的缺点是版本迭代不合理（如：1代 -&gt; 2代，除了名字，基本就是两个东西；截止发表博客时已推出了 Angular6）</li><li>React：Facebook 出品，一款高性能的 JS 前端框架；特点是提出了新概念 <strong>【虚拟 DOM】</strong> 用于减少真实 DOM 操作，在内存中模拟 DOM 操作，有效的提升了前端渲染效率；缺点是使用复杂，因为需要额外学习一门 <strong>【JSX】</strong> 语言；</li><li><code>Vue</code>：一款渐进式 JavaScript 框架，所谓渐进式就是逐步实现新特性的意思，如实现模块化开发、路由、状态管理等新特性。其特点是综合了 Angular（模块化） 和 React（虚拟 DOM） 的优点；</li><li><code>Axios</code>：前端通信框架；因为 <code>Vue</code> 的边界很明确，就是为了处理 DOM，所以并不具备通信能力，此时就需要额外使用一个通信框架与服务器交互；当然也可以直接选择使用 jQuery 提供的 AJAX 通信功能；</li></ul><h3 id="UI-框架"><a href="#UI-框架" class="headerlink" title="UI 框架"></a>UI 框架</h3><ul><li>Ant-Design：阿里巴巴出品，基于 React 的 UI 框架</li><li>ElementUI、iview、ice：饿了么出品，基于 Vue 的 UI 框架</li><li>Bootstrap：Twitter 推出的一个用于前端开发的开源工具包</li><li>AmazeUI：又叫“妹子 UI”，一款 HTML5 跨屏前端框架</li></ul><h3 id="JavaScript-构建工具"><a href="#JavaScript-构建工具" class="headerlink" title="JavaScript 构建工具"></a>JavaScript 构建工具</h3><ul><li>Babel：JS 编译工具，主要用于浏览器不支持的 ES 新特性，比如用于编译 TypeScript</li><li>WebPack：模块打包器，主要作用是打包、压缩、合并及按序加载</li></ul><p><strong>注：以上知识点已将 WebApp 开发所需技能全部梳理完毕</strong></p><h2 id="2-5、三端统一"><a href="#2-5、三端统一" class="headerlink" title="2.5、三端统一"></a>2.5、三端统一</h2><h3 id="混合开发（Hybrid-App）"><a href="#混合开发（Hybrid-App）" class="headerlink" title="混合开发（Hybrid App）"></a>混合开发（Hybrid App）</h3><p>主要目的是实现一套代码三端统一（PC、Android：.apk 、iOS: .ipa ）并能够调用到设备底层硬件（如：传感器、GPS、摄像头等），打包方式主要有以下两种：</p><ul><li>云打包：HBuild -&gt; HBuildX，DCloud 出品；API Cloud</li><li>本地打包： Cordova（前身是 PhoneGap）</li></ul><h3 id="微信小程序"><a href="#微信小程序" class="headerlink" title="微信小程序"></a>微信小程序</h3><p>详见微信官网，这里就是介绍一个方便微信小程序 UI 开发的框架：WeUI</p><h2 id="2-6、后端技术"><a href="#2-6、后端技术" class="headerlink" title="2.6、后端技术"></a>2.6、后端技术</h2><p>前端人员为了方便开发也需要掌握一定的后端技术，但我们 Java 后台人员知道后台知识体系极其庞大复杂，所以为了方便前端人员开发后台应用，就出现了 NodeJS 这样的技术。</p><p>NodeJS 的作者已经声称放弃 NodeJS（说是架构做的不好再加上笨重的 node_modules，可能让作者不爽了吧），开始开发全新架构的 Deno</p><p>既然是后台技术，那肯定也需要框架和项目管理工具，NodeJS 框架及项目管理工具如下：</p><ul><li>Express：NodeJS 框架</li><li>Koa：Express 简化版</li><li>NPM：项目综合管理工具，类似于 Maven</li><li>YARN：NPM 的替代方案，类似于 Maven 和 Gradle 的关系</li></ul><h3 id="2-7、主流前端框架"><a href="#2-7、主流前端框架" class="headerlink" title="2.7、主流前端框架"></a>2.7、主流前端框架</h3><p><strong>Vue.js</strong></p><h3 id="iView"><a href="#iView" class="headerlink" title="iView"></a>iView</h3><p>iview 是一个强大的基于 Vue 的 UI 库，有很多实用的基础组件比 elementui 的组件更丰富，主要服务于 PC 界面的中后台产品。使用单文件的 Vue 组件化开发模式 基于 npm + webpack + babel 开发，支持 ES2015 高质量、功能丰富 友好的 API ，自由灵活地使用空间。</p><ul><li><a href="https://www.iviewui.com/" target="_blank" rel="noopener">官网地址</a></li><li><a href="https://github.com/TalkingData/iview-weapp" target="_blank" rel="noopener">Github</a></li><li><a href="https://github.com/iview/iview-admin" target="_blank" rel="noopener">iview-admin</a></li></ul><p><strong>备注：属于前端主流框架，选型时可考虑使用，主要特点是移动端支持较多</strong></p><h3 id="ElementUI"><a href="#ElementUI" class="headerlink" title="ElementUI"></a>ElementUI</h3><p>Element 是饿了么前端开源维护的 Vue UI 组件库，组件齐全，基本涵盖后台所需的所有组件，文档讲解详细，例子也很丰富。主要用于开发 PC 端的页面，是一个质量比较高的 Vue UI 组件库。</p><ul><li><a href="http://element-cn.eleme.io/#/zh-CN" target="_blank" rel="noopener">官网地址</a></li><li><a href="https://github.com/ElementUI/element-starter" target="_blank" rel="noopener">Github</a></li><li><a href="https://github.com/PanJiaChen/vue-element-admin" target="_blank" rel="noopener">vue-element-admin</a></li></ul><p><strong>备注：属于前端主流框架，选型时可考虑使用，主要特点是桌面端支持较多</strong></p><h3 id="ICE"><a href="#ICE" class="headerlink" title="ICE"></a>ICE</h3><p>飞冰是阿里巴巴团队基于 React/Angular/Vue 的中后台应用解决方案，在阿里巴巴内部，已经有 270 多个来自几乎所有 BU 的项目在使用。飞冰包含了一条从设计端到开发端的完整链路，帮助用户快速搭建属于自己的中后台应用。</p><ul><li><a href="https://alibaba.github.io/ice" target="_blank" rel="noopener">官网地址</a></li><li><a href="https://github.com/alibaba/ice" target="_blank" rel="noopener">Github</a></li></ul><p><strong>备注：主要组件还是以 React 为主，截止 2019 年 02 月 17 日更新博客前对 Vue 的支持还不太完善，目前尚处于观望阶段</strong></p><h3 id="VantUI"><a href="#VantUI" class="headerlink" title="VantUI"></a>VantUI</h3><p>Vant UI 是有赞前端团队基于有赞统一的规范实现的 Vue 组件库，提供了一整套 UI 基础组件和业务组件。通过 Vant，可以快速搭建出风格统一的页面，提升开发效率。</p><ul><li><a href="https://youzan.github.io/vant/#/zh-CN/intro" target="_blank" rel="noopener">官网地址</a></li><li><a href="https://github.com/youzan/vant" target="_blank" rel="noopener">Github</a></li></ul><h3 id="AtUI"><a href="#AtUI" class="headerlink" title="AtUI"></a>AtUI</h3><p>at-ui 是一款基于 Vue 2.x 的前端 UI 组件库，主要用于快速开发 PC 网站产品。 它提供了一套 npm + webpack + babel 前端开发工作流程，CSS 样式独立，即使采用不同的框架实现都能保持统一的 UI 风格。</p><ul><li><a href="https://at-ui.github.io/at-ui/#/zh" target="_blank" rel="noopener">官网地址</a></li><li><a href="https://github.com/at-ui/at-ui" target="_blank" rel="noopener">Github</a></li></ul><h3 id="CubeUI"><a href="#CubeUI" class="headerlink" title="CubeUI"></a>CubeUI</h3><p>cube-ui 是滴滴团队开发的基于 Vue.js 实现的精致移动端组件库。支持按需引入和后编译，轻量灵活；扩展性强，可以方便地基于现有组件实现二次开发。</p><ul><li><a href="https://didi.github.io/cube-ui/#/zh-CN" target="_blank" rel="noopener">官网地址</a></li><li><a href="https://github.com/didi/cube-ui/" target="_blank" rel="noopener">Github</a></li></ul><h3 id="混合开发"><a href="#混合开发" class="headerlink" title="混合开发"></a>混合开发</h3><h3 id="Flutter"><a href="#Flutter" class="headerlink" title="Flutter"></a>Flutter</h3><p>Flutter 是谷歌的移动端 UI 框架，可在极短的时间内构建 Android 和 iOS 上高质量的原生级应用。Flutter 可与现有代码一起工作, 它被世界各地的开发者和组织使用, 并且 Flutter 是免费和开源的。</p><ul><li><a href="http://doc.flutter-dev.cn/" target="_blank" rel="noopener">官网地址</a></li><li><a href="https://github.com/flutter/flutter" target="_blank" rel="noopener">Github</a></li></ul><p><strong>备注：Google 出品，主要特点是快速构建原生 APP 应用程序，如做混合应用该框架为必选框架</strong></p><h3 id="Ionic"><a href="#Ionic" class="headerlink" title="Ionic"></a>Ionic</h3><p>Ionic 既是一个 CSS 框架也是一个 Javascript UI 库，Ionic 是目前最有潜力的一款 HTML5 手机应用开发框架。通过 SASS 构建应用程序，它提供了很多 UI 组件来帮助开发者开发强大的应用。它使用 JavaScript MVVM 框架和 AngularJS/Vue 来增强应用。提供数据的双向绑定，使用它成为 Web 和移动开发者的共同选择。</p><ul><li><a href="https://ionicframework.com/" target="_blank" rel="noopener">官网地址</a></li><li><a href="https://ionicframework.com/docs/" target="_blank" rel="noopener">官网文档</a></li><li><a href="https://github.com/ionic-team/ionic" target="_blank" rel="noopener">Github</a></li></ul><h3 id="微信小程序-1"><a href="#微信小程序-1" class="headerlink" title="微信小程序"></a>微信小程序</h3><h3 id="mpvue"><a href="#mpvue" class="headerlink" title="mpvue"></a>mpvue</h3><p>mpvue 是美团开发的一个使用 <code>Vue.js</code> 开发小程序的前端框架，目前支持 <strong>微信小程序</strong>、<strong>百度智能小程序</strong>，<strong>头条小程序</strong> 和 <strong>支付宝小程序</strong>。 框架基于 <code>Vue.js</code>，修改了的运行时框架 <code>runtime</code> 和代码编译器 <code>compiler</code> 实现，使其可运行在小程序环境中，从而为小程序开发引入了 <code>Vue.js</code> 开发体验。</p><ul><li><a href="http://mpvue.com/" target="_blank" rel="noopener">官网地址</a></li><li><a href="https://github.com/Meituan-Dianping/mpvue" target="_blank" rel="noopener">Github</a></li></ul><p><strong>备注：完备的 Vue 开发体验，并且支持多平台的小程序开发，推荐使用</strong></p><h3 id="WeUI"><a href="#WeUI" class="headerlink" title="WeUI"></a>WeUI</h3><p>WeUI 是一套同微信原生视觉体验一致的基础样式库，由微信官方设计团队为微信内网页和微信小程序量身设计，令用户的使用感知更加统一。包含 button、cell、dialog、toast、article、icon 等各式元素。</p><ul><li><a href="https://weui.io/" target="_blank" rel="noopener">官网地址</a></li><li><a href="https://github.com/weui/weui.git" target="_blank" rel="noopener">Github</a></li></ul><h2 id="3、了解前后分离的演变史"><a href="#3、了解前后分离的演变史" class="headerlink" title="3、了解前后分离的演变史"></a>3、了解前后分离的演变史</h2><p><strong>为什么需要前后分离</strong></p><h3 id="3-1、后端为主的-MVC-时代"><a href="#3-1、后端为主的-MVC-时代" class="headerlink" title="3.1、后端为主的 MVC 时代"></a>3.1、后端为主的 MVC 时代</h3><p>为了降低开发的复杂度，以后端为出发点，比如：Struts、SpringMVC 等框架的使用，就是后端的 MVC 时代;</p><p>以 <code>SpringMVC</code> 流程为例：</p><p><img src="https://blog.kuangstudy.com/usr/uploads/2019/10/1982474755.png" alt="Lusifer2018120811230001.png"></p><ul><li>发起请求到前端控制器(<code>DispatcherServlet</code>)</li><li>前端控制器请求 <code>HandlerMapping</code> 查找 <code>Handler</code>，可以根据 <code>xml</code> 配置、注解进行查找</li><li>处理器映射器 <code>HandlerMapping</code> 向前端控制器返回 <code>Handler</code></li><li>前端控制器调用处理器适配器去执行 <code>Handler</code></li><li>处理器适配器去执行 <code>Handler</code></li><li><code>Handler</code> 执行完成给适配器返回 <code>ModelAndView</code></li><li>处理器适配器向前端控制器返回 <code>ModelAndView</code>，<code>ModelAndView</code> 是 <code>SpringMVC</code> 框架的一个底层对象，包括 <code>Model</code> 和 <code>View</code></li><li>前端控制器请求视图解析器去进行视图解析，根据逻辑视图名解析成真正的视图(<code>JSP</code>)</li><li>视图解析器向前端控制器返回 <code>View</code></li><li>前端控制器进行视图渲染，视图渲染将模型数据(在 <code>ModelAndView</code> 对象中)填充到 <code>request</code> 域</li><li>前端控制器向用户响应结果</li></ul><p><strong>优点</strong></p><p>MVC 是一个非常好的协作模式，能够有效降低代码的耦合度，从架构上能够让开发者明白代码应该写在哪里。为了让 View 更纯粹，还可以使用 Thymeleaf、Freemarker 等模板引擎，使模板里无法写入 Java 代码，让前后端分工更加清晰。</p><p><strong>缺点</strong></p><ul><li>前端开发重度依赖开发环境，开发效率低，这种架构下，前后端协作有两种模式：<ul><li>第一种是前端写 DEMO，写好后，让后端去套模板。好处是 DEMO 可以本地开发，很高效。不足是还需要后端套模板，有可能套错，套完后还需要前端确定，来回沟通调整的成本比较大；</li><li>另一种协作模式是前端负责浏览器端的所有开发和服务器端的 View 层模板开发。好处是 UI 相关的代码都是前端去写就好，后端不用太关注，不足就是前端开发重度绑定后端环境，环境成为影响前端开发效率的重要因素。</li></ul></li><li>前后端职责纠缠不清：模板引擎功能强大，依旧可以通过拿到的上下文变量来实现各种业务逻辑。这样，只要前端弱势一点，往往就会被后端要求在模板层写出不少业务代码。还有一个很大的灰色地带是 <code>Controller</code>，页面路由等功能本应该是前端最关注的，但却是由后端来实现。 <code>Controller</code> 本身与 <code>Model</code> 往往也会纠缠不清，看了让人咬牙的业务代码经常会出现在 <code>Controller</code> 层。这些问题不能全归结于程序员的素养，否则 JSP 就够了。</li><li>对前端发挥的局限性：性能优化如果只在前端做空间非常有限，于是我们经常需要后端合作，但由于后端框架限制，我们很难使用 <a href="https://www.ibm.com/developerworks/cn/web/wa-lo-comet/index.html" target="_blank" rel="noopener"><strong>【Comet】</strong></a>、<a href="https://segmentfault.com/a/1190000002998812" target="_blank" rel="noopener"><strong>【BigPipe】</strong></a> 等技术方案来优化性能。</li></ul><p><strong>注：在这期间（2005 年以前），包括早期的 JSP、PHP 可以称之为 Web 1.0 时代。在这里想说一句，如果你是一名 Java 初学者，请你不要再把一些陈旧的技术当回事了，比如 JSP，因为时代在变、技术在变、什么都在变（引用扎克伯格的一句话：唯一不变的是变化本身）；当我们去给大学做实训时，有些同学会认为我们没有讲什么 干货 ，其实不然，只能说是你认知里的干货对于市场来说早就过时了而已。</strong></p><h3 id="3-2、基于-AJAX-带来的-SPA-时代"><a href="#3-2、基于-AJAX-带来的-SPA-时代" class="headerlink" title="3.2、基于 AJAX 带来的 SPA 时代"></a>3.2、基于 AJAX 带来的 SPA 时代</h3><p>时间回到 2005 年 <code>AJAX</code>（Asynchronous JavaScript And XML，异步 JavaScript 和 XML，老技术新用法） 被正式提出并开始使用 <code>CDN</code> 作为静态资源存储，于是出现了 JavaScript 王者归来（在这之前 JS 都是用来在网页上贴狗皮膏药广告的）的 SPA（Single Page Application）单页面应用时代。</p><p><img src="https://blog.kuangstudy.com/usr/uploads/2019/10/2422752164.png" alt="Lusifer201812090001.png"></p><p><strong>优点</strong></p><p>这种模式下，<strong>前后端的分工非常清晰，前后端的关键协作点是 AJAX 接口</strong>。看起来是如此美妙，但回过头来看看的话，这与 JSP 时代区别不大。复杂度从服务端的 JSP 里移到了浏览器的 JavaScript，浏览器端变得很复杂。类似 Spring MVC，<strong>这个时代开始出现浏览器端的分层架构</strong>：</p><p><img src="https://blog.kuangstudy.com/usr/uploads/2019/10/287702245.png" alt="Lusifer201812090002.png"></p><p><strong>缺点</strong></p><ul><li><strong>前后端接口的约定：</strong> 如果后端的接口一塌糊涂，如果后端的业务模型不够稳定，那么前端开发会很痛苦；不少团队也有类似尝试，通过接口规则、接口平台等方式来做。<strong>有了和后端一起沉淀的 接口规则，还可以用来模拟数据，使得前后端可以在约定接口后实现高效并行开发</strong>。</li><li><strong>前端开发的复杂度控制：</strong> SPA 应用大多以功能交互型为主，JavaScript 代码过十万行很正常。大量 JS 代码的组织，与 View 层的绑定等，都不是容易的事情。</li></ul><h3 id="3-3、前端为主的-MV-时代"><a href="#3-3、前端为主的-MV-时代" class="headerlink" title="3.3、前端为主的 MV* 时代"></a>3.3、前端为主的 MV* 时代</h3><p>此处的 MV* 模式如下：</p><ul><li>MVC（同步通信为主）：Model、View、Controller</li><li>MVP（异步通信为主）：Model、View、Presenter</li><li>MVVM（异步通信为主）：Model、View、ViewModel</li></ul><p>为了降低前端开发复杂度，涌现了大量的前端框架，比如：<code>AngularJS</code>、<code>React</code>、<code>Vue.js</code>、<code>EmberJS</code>等，这些框架总的原则是先按类型分层，比如 Templates、Controllers、Models，然后再在层内做切分，如下图：</p><p><img src="https://blog.kuangstudy.com/usr/uploads/2019/10/2242308737.png" alt="Lusifer201812090003.png"></p><p><strong>优点</strong></p><ul><li><strong>前后端职责很清晰：</strong> 前端工作在浏览器端，后端工作在服务端。清晰的分工，可以让开发并行，测试数据的模拟不难，前端可以本地开发。后端则可以专注于业务逻辑的处理，输出 RESTful等接口。</li><li><strong>前端开发的复杂度可控：</strong> 前端代码很重，但合理的分层，让前端代码能各司其职。这一块蛮有意思的，简单如模板特性的选择，就有很多很多讲究。并非越强大越好，限制什么，留下哪些自由，代码应该如何组织，所有这一切设计，得花一本书的厚度去说明。</li><li><strong>部署相对独立：</strong> 可以快速改进产品体验</li></ul><p><strong>缺点</strong></p><ul><li>代码不能复用。比如后端依旧需要对数据做各种校验，校验逻辑无法复用浏览器端的代码。如果可以复用，那么后端的数据校验可以相对简单化。</li><li>全异步，对 SEO 不利。往往还需要服务端做同步渲染的降级方案。</li><li>性能并非最佳，特别是移动互联网环境下。</li><li>SPA 不能满足所有需求，依旧存在大量多页面应用。URL Design 需要后端配合，前端无法完全掌控。</li></ul><h3 id="3-4、NodeJS-带来的全栈时代"><a href="#3-4、NodeJS-带来的全栈时代" class="headerlink" title="3.4、NodeJS 带来的全栈时代"></a>3.4、NodeJS 带来的全栈时代</h3><p>前端为主的 MV* 模式解决了很多很多问题，但如上所述，依旧存在不少不足之处。随着 NodeJS 的兴起，JavaScript 开始有能力运行在服务端。这意味着可以有一种新的研发模式：</p><p><img src="https://blog.kuangstudy.com/usr/uploads/2019/10/3703089123.jpg" alt="63918611gw1efj2vvjwtfj20ge0gzab9.jpg"></p><p>在这种研发模式下，前后端的职责很清晰。对前端来说，两个 UI 层各司其职：</p><ul><li>Front-end UI layer 处理浏览器层的展现逻辑。通过 CSS 渲染样式，通过 JavaScript 添加交互功能，HTML 的生成也可以放在这层，具体看应用场景。</li><li>Back-end UI layer 处理路由、模板、数据获取、Cookie 等。通过路由，前端终于可以自主把控 URL Design，这样无论是单页面应用还是多页面应用，前端都可以自由调控。后端也终于可以摆脱对展现的强关注，转而可以专心于业务逻辑层的开发。</li></ul><p>通过 Node，Web Server 层也是 JavaScript 代码，这意味着部分代码可前后复用，需要 SEO 的场景可以在服务端同步渲染，由于异步请求太多导致的性能问题也可以通过服务端来缓解。前一种模式的不足，通过这种模式几乎都能完美解决掉。</p><p>与 JSP 模式相比，全栈模式看起来是一种回归，也的确是一种向原始开发模式的回归，不过是一种螺旋上升式的回归。</p><p>基于 NodeJS 的全栈模式，依旧面临很多挑战：</p><ul><li>需要前端对服务端编程有更进一步的认识。比如 TCP/IP 等网络知识的掌握。</li><li>NodeJS 层与 Java 层的高效通信。NodeJS 模式下，都在服务器端，RESTful HTTP 通信未必高效，通过 SOAP 等方式通信更高效。一切需要在验证中前行。</li><li>对部署、运维层面的熟练了解，需要更多知识点和实操经验。</li><li>大量历史遗留问题如何过渡。这可能是最大最大的阻力。</li></ul><p><strong>注：看到这里，相信很多同学就可以理解，为什么我总在课堂上说：“前端想学后台很难，而我们后端程序员学任何东西都很简单”；就是因为我们后端程序员具备相对完善的知识体系。</strong></p><p><strong>全栈！So Easy！╮(￣▽￣)╭！</strong></p><h3 id="3-5、总结"><a href="#3-5、总结" class="headerlink" title="3.5、总结"></a>3.5、总结</h3><p>综上所述，模式也好，技术也罢，没有好坏优劣之分，只有适合不适合；前后分离的开发思想主要是基于 <code>SoC</code>（关注度分离原则），上面种种模式，都是让前后端的职责更清晰，分工更合理高效。</p>]]></content>
    
    <summary type="html">
    
      前端体系、前后端分离
    
    </summary>
    
    
      <category term="Vue" scheme="https://SomunsTao.github.io/categories/Vue/"/>
    
    
      <category term="Vue" scheme="https://SomunsTao.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Springcloud-Alibaba 〖四〗actuator微服务信息完善  DiscoveryClient Eureka自我保护理论知识</title>
    <link href="https://somunstao.github.io/2020/04/04/Springcloud-Alibaba%20%E3%80%96%E5%9B%9B%E3%80%97actuator%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BF%A1%E6%81%AF%E5%AE%8C%E5%96%84%20%E6%B7%BB%E5%8A%A0%20DiscoveryClient%20Eureka%E8%87%AA%E6%88%91%E4%BF%9D%E6%8A%A4%E7%90%86%E8%AE%BA%E7%9F%A5%E8%AF%86/"/>
    <id>https://somunstao.github.io/2020/04/04/Springcloud-Alibaba%20%E3%80%96%E5%9B%9B%E3%80%97actuator%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BF%A1%E6%81%AF%E5%AE%8C%E5%96%84%20%E6%B7%BB%E5%8A%A0%20DiscoveryClient%20Eureka%E8%87%AA%E6%88%91%E4%BF%9D%E6%8A%A4%E7%90%86%E8%AE%BA%E7%9F%A5%E8%AF%86/</id>
    <published>2020-04-03T16:00:00.000Z</published>
    <updated>2020-08-02T04:06:06.627Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Springcloud-Alibaba-〖四〗actuator微服务信息完善-添加-DiscoveryClient-Eureka自我保护理论知识"><a href="#Springcloud-Alibaba-〖四〗actuator微服务信息完善-添加-DiscoveryClient-Eureka自我保护理论知识" class="headerlink" title="Springcloud-Alibaba 〖四〗actuator微服务信息完善 添加 DiscoveryClient Eureka自我保护理论知识"></a>Springcloud-Alibaba 〖四〗actuator微服务信息完善 添加 DiscoveryClient Eureka自我保护理论知识</h1><p><img src="https://csdnimg.cn/release/phoenix/template/new_img/original.png" alt="img"></p><p><a href="https://me.csdn.net/kingtok" target="_blank" rel="noopener">ktoking</a> 2020-03-21 21:35:01 <img src="https://csdnimg.cn/release/phoenix/template/new_img/articleReadEyes.png" alt="img"> 517 <img src="https://csdnimg.cn/release/phoenix/template/new_img/tobarCollect.png" alt="img"> 收藏 2 <img src="https://csdnimg.cn/release/phoenix/template/new_img/planImg.png" alt="img"> 原力计划</p><p>分类专栏： <a href="https://blog.csdn.net/kingtok/category_9822291.html" target="_blank" rel="noopener">springcloud-Alibaba</a></p><p>版权</p><h3 id="Springcloud-Alibaba-〖四〗"><a href="#Springcloud-Alibaba-〖四〗" class="headerlink" title="Springcloud-Alibaba 〖四〗"></a>Springcloud-Alibaba 〖四〗</h3><ul><li><ul><li><ul><li><a href="https://blog.csdn.net/kingtok/article/details/105016708#PS_githubhttpsgithubcomktokingspringcloudalibaba_1" target="_blank" rel="noopener">PS: github仓库<a href="https://github.com/ktoking/springcloud-alibaba" target="_blank" rel="noopener">仓库地址</a>项目都放到里面了</a></li></ul></li><li><p><a href="https://blog.csdn.net/kingtok/article/details/105016708#_actuator_2" target="_blank" rel="noopener">一. actuator微服务信息完善</a></p></li><li><ul><li><a href="https://blog.csdn.net/kingtok/article/details/105016708#11_80018002_3" target="_blank" rel="noopener">1.1 在8001与8002项目中分别添加</a></li><li><a href="https://blog.csdn.net/kingtok/article/details/105016708#12_payment8001_health__15" target="_blank" rel="noopener">1.2 点开payment8001找到 /health 路径</a></li><li><a href="https://blog.csdn.net/kingtok/article/details/105016708#13_IP_19" target="_blank" rel="noopener">1.3 配置访问路径可以访问IP</a></li></ul></li><li><p><a href="https://blog.csdn.net/kingtok/article/details/105016708#__DiscoveryClient__24" target="_blank" rel="noopener">二. 添加 DiscoveryClient 发现微服务</a></p></li><li><ul><li><a href="https://blog.csdn.net/kingtok/article/details/105016708#21_8001controller_25" target="_blank" rel="noopener">2.1 修改8001项目controller层</a></li><li><a href="https://blog.csdn.net/kingtok/article/details/105016708#22__93" target="_blank" rel="noopener">2.2 调用该服务</a></li></ul></li><li><p><a href="https://blog.csdn.net/kingtok/article/details/105016708#_Eureka_97" target="_blank" rel="noopener">三. Eureka自我保护理论知识</a></p></li><li><ul><li><a href="https://blog.csdn.net/kingtok/article/details/105016708#31_Eureka_105" target="_blank" rel="noopener">3.1 关闭Eureka自我保护机制</a></li></ul></li><li><p><a href="https://blog.csdn.net/kingtok/article/details/105016708#Springcloud_Eureka_109" target="_blank" rel="noopener">至此,Springcloud Eureka篇章结束~</a></p></li></ul></li></ul><h3 id="PS-github仓库仓库地址项目都放到里面了"><a href="#PS-github仓库仓库地址项目都放到里面了" class="headerlink" title="PS: github仓库仓库地址项目都放到里面了"></a>PS: github仓库<a href="https://github.com/ktoking/springcloud-alibaba" target="_blank" rel="noopener">仓库地址</a>项目都放到里面了</h3><h2 id="一-actuator微服务信息完善"><a href="#一-actuator微服务信息完善" class="headerlink" title="一. actuator微服务信息完善"></a>一. actuator微服务信息完善</h2><h3 id="1-1-在8001与8002项目中分别添加"><a href="#1-1-在8001与8002项目中分别添加" class="headerlink" title="1.1 在8001与8002项目中分别添加"></a>1.1 在8001与8002项目中分别添加</h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">instance:</span></span><br><span class="line">    <span class="attr">instance-id:</span> <span class="string">payment8001</span></span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200321203438263.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2tpbmd0b2s=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>改完后我们的自定义服务名称就暴露出来了</strong><br><img src="https://img-blog.csdnimg.cn/20200321203543950.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2tpbmd0b2s=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="1-2-点开payment8001找到-health-路径"><a href="#1-2-点开payment8001找到-health-路径" class="headerlink" title="1.2 点开payment8001找到 /health 路径"></a>1.2 点开payment8001找到 /health 路径</h3><p><strong>安全检查正常</strong><br><img src="https://img-blog.csdnimg.cn/20200321203732481.png" alt="在这里插入图片描述"></p><h3 id="1-3-配置访问路径可以访问IP"><a href="#1-3-配置访问路径可以访问IP" class="headerlink" title="1.3 配置访问路径可以访问IP"></a>1.3 配置访问路径可以访问IP</h3><p><img src="https://img-blog.csdnimg.cn/20200321203955191.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2tpbmd0b2s=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>当鼠标放到刚配置的主机名上时,左下角就会显示主机的IP</strong><br><img src="https://img-blog.csdnimg.cn/20200321204135427.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2tpbmd0b2s=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="二-添加-DiscoveryClient-发现微服务"><a href="#二-添加-DiscoveryClient-发现微服务" class="headerlink" title="二. 添加 DiscoveryClient 发现微服务"></a>二. 添加 DiscoveryClient 发现微服务</h2><h3 id="2-1-修改8001项目controller层"><a href="#2-1-修改8001项目controller层" class="headerlink" title="2.1 修改8001项目controller层"></a>2.1 修改8001项目controller层</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.springcloud.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atguigu.springcloud.entities.CommonResult;</span><br><span class="line"><span class="keyword">import</span> com.atguigu.springcloud.entities.Payment;</span><br><span class="line"><span class="keyword">import</span> com.atguigu.springcloud.service.PaymentService;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.client.ServiceInstance;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.client.discovery.DiscoveryClient;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PaymentController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;server.port&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String serverPort;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> DiscoveryClient discoveryClient;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> PaymentService paymentService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span>(value = <span class="string">"/payment/create"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonResult <span class="title">create</span><span class="params">(@RequestBody Payment payment)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = paymentService.create(payment);</span><br><span class="line">        log.info(<span class="string">"*******插入结果为: "</span>+result);</span><br><span class="line">        <span class="keyword">if</span>(result&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> CommonResult(<span class="number">200</span>,<span class="string">"插入数据库成功"</span>+<span class="string">"机器端口号为:"</span>+serverPort,result);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> CommonResult(<span class="number">444</span>,<span class="string">"插入数据库失败"</span>+<span class="string">"机器端口号为:"</span>+serverPort,<span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(value = <span class="string">"/payment/get/&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonResult <span class="title">getPaymentById</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> Long id)</span>&#123;</span><br><span class="line">        Payment paymentById = paymentService.getPaymentById(id);</span><br><span class="line">        log.info(<span class="string">"*********查找结果为: "</span>+paymentById);</span><br><span class="line">        <span class="keyword">if</span>(paymentById!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> CommonResult(<span class="number">200</span>,<span class="string">"查找成功: "</span>+<span class="string">"机器端口号为:"</span>+serverPort,paymentById);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> CommonResult(<span class="number">444</span>,<span class="string">"查找为空,查找ID为: "</span>+id+<span class="string">"机器端口号为:"</span>+serverPort,<span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(value = <span class="string">"/payment/discovery"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">discovery</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;String&gt; services = discoveryClient.getServices();</span><br><span class="line">        <span class="keyword">for</span> (String service : services) &#123;</span><br><span class="line">           log.info(<span class="string">"********服务名称*****"</span>+service);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;ServiceInstance&gt; instances = discoveryClient.getInstances(<span class="string">"CLOUD-PAYMENT-SERVICE"</span>);</span><br><span class="line">        <span class="keyword">for</span> (ServiceInstance instance : instances) &#123;</span><br><span class="line">            log.info(instance.getServiceId()+<span class="string">"\t"</span>+instance.getHost()+<span class="string">"\t"</span>+instance.getPort()+<span class="string">"\t"</span>+instance.getUri());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.discoveryClient;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364</span></span><br></pre></td></tr></table></figure><h3 id="2-2-调用该服务"><a href="#2-2-调用该服务" class="headerlink" title="2.2 调用该服务"></a>2.2 调用该服务</h3><p><img src="https://img-blog.csdnimg.cn/20200321210702833.png" alt="在这里插入图片描述"><br><strong>控制台打印出了相关信息</strong><br><img src="https://img-blog.csdnimg.cn/20200321210854959.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2tpbmd0b2s=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="三-Eureka自我保护理论知识"><a href="#三-Eureka自我保护理论知识" class="headerlink" title="三. Eureka自我保护理论知识"></a>三. Eureka自我保护理论知识</h2><p><strong>概述：</strong> 保护模式主要用于一组客户端和Eureka Server之间存在网络分区场景下的保护，一旦进入保护模式，Eureka Server将会尝试保护其服务注册表中的信息，不再删除服务注册表中的数据，也就是不会注销任何微服务。<br><strong>一句话：</strong> 某时刻某一个微服务不可用了，Eureka不会立刻清理，依旧会对该微服务的信息进行保存。<br><img src="https://img-blog.csdnimg.cn/20200321211613651.png" alt="在这里插入图片描述"></p><p>如果在Eureka Server的首页看到以上这段提示，则说明Eureka进入了保护模式。属于CAP里面的AP分支。</p><p><img src="https://img-blog.csdnimg.cn/20200321211655637.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2tpbmd0b2s=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="3-1-关闭Eureka自我保护机制"><a href="#3-1-关闭Eureka自我保护机制" class="headerlink" title="3.1 关闭Eureka自我保护机制"></a>3.1 关闭Eureka自我保护机制</h3><p><strong>这里开启暴力剔除模式</strong><br><img src="https://img-blog.csdnimg.cn/20200321212731532.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200321212959822.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2tpbmd0b2s=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="至此-Springcloud-Eureka篇章结束"><a href="#至此-Springcloud-Eureka篇章结束" class="headerlink" title="至此,Springcloud Eureka篇章结束~"></a>至此,Springcloud Eureka篇章结束~</h2>]]></content>
    
    <summary type="html">
    
      Springcloud-Alibaba
    
    </summary>
    
    
      <category term="Springcloud-Alibaba" scheme="https://SomunsTao.github.io/categories/Springcloud-Alibaba/"/>
    
    
      <category term="Springcloud-Alibaba" scheme="https://SomunsTao.github.io/tags/Springcloud-Alibaba/"/>
    
  </entry>
  
  <entry>
    <title>Springcloud-Alibaba 〖三〗微服务Eureka集群搭建,负载均衡,服务注册发现</title>
    <link href="https://somunstao.github.io/2020/04/03/Springcloud-Alibaba%20%E3%80%96%E4%B8%89%E3%80%97%E5%BE%AE%E6%9C%8D%E5%8A%A1Eureka%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA,%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1,%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E5%8F%91%E7%8E%B0/"/>
    <id>https://somunstao.github.io/2020/04/03/Springcloud-Alibaba%20%E3%80%96%E4%B8%89%E3%80%97%E5%BE%AE%E6%9C%8D%E5%8A%A1Eureka%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA,%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1,%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E5%8F%91%E7%8E%B0/</id>
    <published>2020-04-03T00:08:08.000Z</published>
    <updated>2020-08-02T04:04:54.464Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Springcloud-Alibaba-〖三〗微服务Eureka集群搭建-负载均衡-服务注册发现"><a href="#Springcloud-Alibaba-〖三〗微服务Eureka集群搭建-负载均衡-服务注册发现" class="headerlink" title="Springcloud-Alibaba 〖三〗微服务Eureka集群搭建,负载均衡,服务注册发现"></a>Springcloud-Alibaba 〖三〗微服务Eureka集群搭建,负载均衡,服务注册发现</h1><h3 id="Springcloud-Alibaba-〖三〗微服务Eureka集群搭建-负载均衡-服务注册发现-1"><a href="#Springcloud-Alibaba-〖三〗微服务Eureka集群搭建-负载均衡-服务注册发现-1" class="headerlink" title="Springcloud-Alibaba 〖三〗微服务Eureka集群搭建,负载均衡,服务注册发现"></a>Springcloud-Alibaba 〖三〗微服务Eureka集群搭建,负载均衡,服务注册发现</h3><ul><li><ul><li><ul><li><a href="https://blog.csdn.net/kingtok/article/details/105005139#PS_githubhttpsgithubcomktokingspringcloudalibaba_1" target="_blank" rel="noopener">PS: github仓库<a href="https://github.com/ktoking/springcloud-alibaba" target="_blank" rel="noopener">仓库地址</a>项目都放到里面了</a></li></ul></li><li><p><a href="https://blog.csdn.net/kingtok/article/details/105005139#_cloudeurekaserver7001_4" target="_blank" rel="noopener">六. cloud-eureka-server7001模块构建</a></p></li><li><ul><li><a href="https://blog.csdn.net/kingtok/article/details/105005139#61_Eureka_5" target="_blank" rel="noopener">6.1 Eureka系统架构</a></li><li><a href="https://blog.csdn.net/kingtok/article/details/105005139#62_Eureka_7" target="_blank" rel="noopener">6.2 创建Eureka模块</a></li><li><a href="https://blog.csdn.net/kingtok/article/details/105005139#63_pom_9" target="_blank" rel="noopener">6.3 pom文件里添加依赖</a></li><li><a href="https://blog.csdn.net/kingtok/article/details/105005139#64_applicationyml_69" target="_blank" rel="noopener">6.4 application.yml</a></li><li><a href="https://blog.csdn.net/kingtok/article/details/105005139#65__90" target="_blank" rel="noopener">6.5 主启动类</a></li><li><a href="https://blog.csdn.net/kingtok/article/details/105005139#66__httplocalhost7001_UI_110" target="_blank" rel="noopener">6.6 打开 http://localhost:7001/ 进入UI界面</a></li></ul></li><li><p><a href="https://blog.csdn.net/kingtok/article/details/105005139#__114" target="_blank" rel="noopener">七. 服务注册</a></p></li><li><ul><li><p><a href="https://blog.csdn.net/kingtok/article/details/105005139#71_8001eurekaServer_115" target="_blank" rel="noopener">7.1 支付微服务8001入驻进eurekaServer</a></p></li><li><ul><li><a href="https://blog.csdn.net/kingtok/article/details/105005139#711__116" target="_blank" rel="noopener">7.1.1 增加新依赖</a></li><li><a href="https://blog.csdn.net/kingtok/article/details/105005139#712_applicationyml_Eureka_125" target="_blank" rel="noopener">7.1.2 application.yml 里面添加Eureka配置</a></li><li><a href="https://blog.csdn.net/kingtok/article/details/105005139#713__EnableEurekaClient_138" target="_blank" rel="noopener">7.1.3 主启动添加 @EnableEurekaClient</a></li><li><a href="https://blog.csdn.net/kingtok/article/details/105005139#714__140" target="_blank" rel="noopener">7.1.4 启动测试</a></li></ul></li><li><p><a href="https://blog.csdn.net/kingtok/article/details/105005139#72_80eurekaServer_144" target="_blank" rel="noopener">7.2 订单微服务80入驻进eurekaServer</a></p></li><li><ul><li><a href="https://blog.csdn.net/kingtok/article/details/105005139#721__145" target="_blank" rel="noopener">7.2.1 增加新依赖</a></li><li><a href="https://blog.csdn.net/kingtok/article/details/105005139#722_applicationyml_Eureka_154" target="_blank" rel="noopener">7.2.2 application.yml 里面添加Eureka配置</a></li><li><a href="https://blog.csdn.net/kingtok/article/details/105005139#723___EnableEurekaClient_169" target="_blank" rel="noopener">7.2.3 主启动添加 @EnableEurekaClient</a></li><li><a href="https://blog.csdn.net/kingtok/article/details/105005139#724__171" target="_blank" rel="noopener">7.2.4 启动测试</a></li></ul></li></ul></li><li><p><a href="https://blog.csdn.net/kingtok/article/details/105005139#_Eureka_175" target="_blank" rel="noopener">八. Eureka集群搭建</a></p></li><li><ul><li><p><a href="https://blog.csdn.net/kingtok/article/details/105005139#81_cloudeurekaserver7002_176" target="_blank" rel="noopener">8.1 cloud-eureka-server7002模块构建</a></p></li><li><ul><li><a href="https://blog.csdn.net/kingtok/article/details/105005139#811_module_cloudeurekaserver7002_177" target="_blank" rel="noopener">8.1.1 创建module cloud-eureka-server7002</a></li><li><a href="https://blog.csdn.net/kingtok/article/details/105005139#812_pom_179" target="_blank" rel="noopener">8.1.2 pom文件添加依赖</a></li><li><a href="https://blog.csdn.net/kingtok/article/details/105005139#813__241" target="_blank" rel="noopener">8.1.3 添加主启动类</a></li><li><a href="https://blog.csdn.net/kingtok/article/details/105005139#814__applicationyml__243" target="_blank" rel="noopener">8.1.4 添加 application.yml 时先修改本机端口映射</a></li></ul></li><li><p><a href="https://blog.csdn.net/kingtok/article/details/105005139#82_70017002applicationyml_256" target="_blank" rel="noopener">8.2 修改7001和7002的application.yml</a></p></li><li><ul><li><a href="https://blog.csdn.net/kingtok/article/details/105005139#821_7001_applicationyml_257" target="_blank" rel="noopener">8.2.1 修改7001 application.yml,直接粘贴</a></li><li><a href="https://blog.csdn.net/kingtok/article/details/105005139#822_7002_applicationyml_275" target="_blank" rel="noopener">8.2.2 修改7002 application.yml,直接粘贴</a></li></ul></li><li><p><a href="https://blog.csdn.net/kingtok/article/details/105005139#83__292" target="_blank" rel="noopener">8.3 测试集群</a></p></li></ul></li><li><p><a href="https://blog.csdn.net/kingtok/article/details/105005139#_Eureka_298" target="_blank" rel="noopener">九. 将两个微服务发布到Eureka集群配置中</a></p></li><li><ul><li><a href="https://blog.csdn.net/kingtok/article/details/105005139#91_8001_applicationyml_299" target="_blank" rel="noopener">9.1 8001项目 application.yml</a></li><li><a href="https://blog.csdn.net/kingtok/article/details/105005139#92_80_applicationyml_305" target="_blank" rel="noopener">9.2 80项目 application.yml</a></li><li><a href="https://blog.csdn.net/kingtok/article/details/105005139#93__310" target="_blank" rel="noopener">9.3 测试</a></li></ul></li><li><p><a href="https://blog.csdn.net/kingtok/article/details/105005139#__module_cloudproviderpayment8002_319" target="_blank" rel="noopener">十. 创建module cloud-provider-payment8002</a></p></li><li><ul><li><p><a href="https://blog.csdn.net/kingtok/article/details/105005139#101_POM_322" target="_blank" rel="noopener">10.1 改POM</a></p></li><li><p><a href="https://blog.csdn.net/kingtok/article/details/105005139#102__applicationyml__323" target="_blank" rel="noopener">10.2 建 application.yml 文件</a></p></li><li><p><a href="https://blog.csdn.net/kingtok/article/details/105005139#103__324" target="_blank" rel="noopener">10.3 主启动</a></p></li><li><p><a href="https://blog.csdn.net/kingtok/article/details/105005139#104__325" target="_blank" rel="noopener">10.4 业务类</a></p></li><li><p><a href="https://blog.csdn.net/kingtok/article/details/105005139#105__Controller_327" target="_blank" rel="noopener">10.5 修改 Controller</a></p></li><li><p><a href="https://blog.csdn.net/kingtok/article/details/105005139#106__332" target="_blank" rel="noopener">10.6 开启负载均衡</a></p></li><li><ul><li><a href="https://blog.csdn.net/kingtok/article/details/105005139#1061_80urlEureka_333" target="_blank" rel="noopener">10.6.1 首先到80服务下去修改写死的对外暴露的服务url为Eureka注册中心的名字</a></li><li><a href="https://blog.csdn.net/kingtok/article/details/105005139#1062_80restTemplatespringbean_LoadBalanced_336" target="_blank" rel="noopener">10.6.2 在我们80项目的restTemplate加入spring容器的bean中增加一个负载均衡的注解 @LoadBalanced</a></li><li><a href="https://blog.csdn.net/kingtok/article/details/105005139#1063__339" target="_blank" rel="noopener">10.6.3 测试</a></li></ul></li></ul></li><li><p><a href="https://blog.csdn.net/kingtok/article/details/105005139#_346" target="_blank" rel="noopener">制作不易,转载请标注,别白嫖啊~~</a></p></li></ul></li></ul><h3 id="PS-github仓库仓库地址项目都放到里面了"><a href="#PS-github仓库仓库地址项目都放到里面了" class="headerlink" title="PS: github仓库仓库地址项目都放到里面了"></a>PS: github仓库<a href="https://github.com/ktoking/springcloud-alibaba" target="_blank" rel="noopener">仓库地址</a>项目都放到里面了</h3><p><strong>本篇章的第三章</strong></p><h2 id="六-cloud-eureka-server7001模块构建"><a href="#六-cloud-eureka-server7001模块构建" class="headerlink" title="六. cloud-eureka-server7001模块构建"></a>六. cloud-eureka-server7001模块构建</h2><h3 id="6-1-Eureka系统架构"><a href="#6-1-Eureka系统架构" class="headerlink" title="6.1 Eureka系统架构"></a>6.1 Eureka系统架构</h3><p><img src="https://img-blog.csdnimg.cn/20200321103639323.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2tpbmd0b2s=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="6-2-创建Eureka模块"><a href="#6-2-创建Eureka模块" class="headerlink" title="6.2 创建Eureka模块"></a>6.2 创建Eureka模块</h3><p><img src="https://img-blog.csdnimg.cn/20200321105339340.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2tpbmd0b2s=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="6-3-pom文件里添加依赖"><a href="#6-3-pom文件里添加依赖" class="headerlink" title="6.3 pom文件里添加依赖"></a>6.3 pom文件里添加依赖</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cloud2020<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.aiguigu.springcloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cloud-eureka-server7001<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--eureka server--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--引入自己定义的api通用包，可以使用payment支付Entity--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.atguigu.springcloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cloud-api-commons<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;project.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--boot web actuator--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--一般通用配置--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br><span class="line"></span><br><span class="line">1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556</span><br></pre></td></tr></table></figure><h3 id="6-4-application-yml"><a href="#6-4-application-yml" class="headerlink" title="6.4 application.yml"></a>6.4 application.yml</h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">7001</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">localhost</span> <span class="comment">#eureka服务端的实例名称</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="comment">#false表示不向注册中心注册自己</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment">#false表示自己端就是注册中心，我的职责就是维护服务实例，并不需要去检索服务</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="comment">#设置与Eureka Server交互的地址查询服务和注册服务都需要依赖这个地址</span></span><br><span class="line">      <span class="attr">defaultZ4 one:</span> <span class="string">http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">12345678910111213141516</span></span><br></pre></td></tr></table></figure><h3 id="6-5-主启动类"><a href="#6-5-主启动类" class="headerlink" title="6.5 主启动类"></a>6.5 主启动类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.springcloud;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaMain7001</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(EurekaMain7001<span class="class">.<span class="keyword">class</span>,<span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">12345678910111213141516</span></span><br></pre></td></tr></table></figure><h3 id="6-6-打开-http-localhost-7001-进入UI界面"><a href="#6-6-打开-http-localhost-7001-进入UI界面" class="headerlink" title="6.6 打开 http://localhost:7001/ 进入UI界面"></a>6.6 打开 <a href="http://localhost:7001/" target="_blank" rel="noopener">http://localhost:7001/</a> 进入UI界面</h3><p><img src="https://img-blog.csdnimg.cn/20200321110257757.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2tpbmd0b2s=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>此时还没有服务注册进来</strong></p><h2 id="七-服务注册"><a href="#七-服务注册" class="headerlink" title="七. 服务注册"></a>七. 服务注册</h2><h3 id="7-1-支付微服务8001入驻进eurekaServer"><a href="#7-1-支付微服务8001入驻进eurekaServer" class="headerlink" title="7.1 支付微服务8001入驻进eurekaServer"></a>7.1 支付微服务8001入驻进eurekaServer</h3><h4 id="7-1-1-增加新依赖"><a href="#7-1-1-增加新依赖" class="headerlink" title="7.1.1 增加新依赖"></a>7.1.1 增加新依赖</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--eureka-client--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">123456</span><br></pre></td></tr></table></figure><h4 id="7-1-2-application-yml-里面添加Eureka配置"><a href="#7-1-2-application-yml-里面添加Eureka配置" class="headerlink" title="7.1.2 application.yml 里面添加Eureka配置"></a>7.1.2 application.yml 里面添加Eureka配置</h4><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="comment">#表示是否将自己注册进EurekaServer默认为true</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment">#是否从EurekaServer抓取已有的注册信息，默认为true。单节点无所谓，集群必须设置为true才能配合ribbon使用负载均衡</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:7001/eureka</span></span><br><span class="line"></span><br><span class="line"><span class="number">123456789</span></span><br></pre></td></tr></table></figure><h4 id="7-1-3-主启动添加-EnableEurekaClient"><a href="#7-1-3-主启动添加-EnableEurekaClient" class="headerlink" title="7.1.3 主启动添加 @EnableEurekaClient"></a>7.1.3 主启动添加 @EnableEurekaClient</h4><p><img src="https://img-blog.csdnimg.cn/20200321111324134.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2tpbmd0b2s=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="7-1-4-启动测试"><a href="#7-1-4-启动测试" class="headerlink" title="7.1.4 启动测试"></a>7.1.4 启动测试</h4><p><img src="https://img-blog.csdnimg.cn/20200321111618618.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2tpbmd0b2s=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>可以看到8001服务注册进来了</strong></p><h3 id="7-2-订单微服务80入驻进eurekaServer"><a href="#7-2-订单微服务80入驻进eurekaServer" class="headerlink" title="7.2 订单微服务80入驻进eurekaServer"></a>7.2 订单微服务80入驻进eurekaServer</h3><h4 id="7-2-1-增加新依赖"><a href="#7-2-1-增加新依赖" class="headerlink" title="7.2.1 增加新依赖"></a>7.2.1 增加新依赖</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--eureka-client--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">123456</span><br></pre></td></tr></table></figure><h4 id="7-2-2-application-yml-里面添加Eureka配置"><a href="#7-2-2-application-yml-里面添加Eureka配置" class="headerlink" title="7.2.2 application.yml 里面添加Eureka配置"></a>7.2.2 application.yml 里面添加Eureka配置</h4><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloud-order-server</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="comment">#表示是否将自己注册进EurekaServer默认为true</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:7001/eureka</span></span><br><span class="line"><span class="number">1234567891011</span></span><br></pre></td></tr></table></figure><h4 id="7-2-3-主启动添加-EnableEurekaClient"><a href="#7-2-3-主启动添加-EnableEurekaClient" class="headerlink" title="7.2.3 主启动添加 @EnableEurekaClient"></a>7.2.3 主启动添加 @EnableEurekaClient</h4><p><img src="https://img-blog.csdnimg.cn/20200321112519936.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2tpbmd0b2s=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="7-2-4-启动测试"><a href="#7-2-4-启动测试" class="headerlink" title="7.2.4 启动测试"></a>7.2.4 启动测试</h4><p><img src="https://img-blog.csdnimg.cn/2020032111390769.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2tpbmd0b2s=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>服务已经注册进来</strong></p><h2 id="八-Eureka集群搭建"><a href="#八-Eureka集群搭建" class="headerlink" title="八. Eureka集群搭建"></a>八. Eureka集群搭建</h2><h3 id="8-1-cloud-eureka-server7002模块构建"><a href="#8-1-cloud-eureka-server7002模块构建" class="headerlink" title="8.1 cloud-eureka-server7002模块构建"></a>8.1 cloud-eureka-server7002模块构建</h3><h4 id="8-1-1-创建module-cloud-eureka-server7002"><a href="#8-1-1-创建module-cloud-eureka-server7002" class="headerlink" title="8.1.1 创建module cloud-eureka-server7002"></a>8.1.1 创建module cloud-eureka-server7002</h4><p><img src="https://img-blog.csdnimg.cn/20200321155531138.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2tpbmd0b2s=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="8-1-2-pom文件添加依赖"><a href="#8-1-2-pom文件添加依赖" class="headerlink" title="8.1.2 pom文件添加依赖"></a>8.1.2 pom文件添加依赖</h4><p><strong>与7001项目依赖一样</strong></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cloud2020<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.aiguigu.springcloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cloud-eureka-server7002<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--eureka server--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--引入自己定义的api通用包，可以使用payment支付Entity--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.atguigu.springcloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cloud-api-commons<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;project.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--boot web actuator--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--一般通用配置--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br><span class="line"></span><br><span class="line">123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657</span><br></pre></td></tr></table></figure><h4 id="8-1-3-添加主启动类"><a href="#8-1-3-添加主启动类" class="headerlink" title="8.1.3 添加主启动类"></a>8.1.3 添加主启动类</h4><p><img src="https://img-blog.csdnimg.cn/20200321155703508.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2tpbmd0b2s=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="8-1-4-添加-application-yml-时先修改本机端口映射"><a href="#8-1-4-添加-application-yml-时先修改本机端口映射" class="headerlink" title="8.1.4 添加 application.yml 时先修改本机端口映射"></a>8.1.4 添加 application.yml 时先修改本机端口映射</h4><p><img src="https://img-blog.csdnimg.cn/20200321161045380.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2tpbmd0b2s=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>在HOSTS文件底添加端口映射</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1   eureka7001.com</span><br><span class="line">127.0.0.1   eureka7002.com</span><br><span class="line">12</span><br></pre></td></tr></table></figure><p><strong>修改不了文件没权限的可以参照以下链接去修改</strong></p><p><a href="https://jingyan.baidu.com/article/425e69e6e479a2be15fc16e1.html" target="_blank" rel="noopener">解决问题</a></p><h3 id="8-2-修改7001和7002的application-yml"><a href="#8-2-修改7001和7002的application-yml" class="headerlink" title="8.2 修改7001和7002的application.yml"></a>8.2 修改7001和7002的application.yml</h3><h4 id="8-2-1-修改7001-application-yml-直接粘贴"><a href="#8-2-1-修改7001-application-yml-直接粘贴" class="headerlink" title="8.2.1 修改7001 application.yml,直接粘贴"></a>8.2.1 修改7001 application.yml,直接粘贴</h4><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">7001</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">eureka7001.com</span>  <span class="comment">#eureka服务端的实例名称</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="comment">#false表示不向注册中心注册自己</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment">#false表示自己端就是注册中心，我的职责就是维护服务实例，并不需要去检索服务</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="comment">#设置与Eureka Server交互的地址查询服务和注册服务都需要依赖这个地址</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://eureka7002.com:7002/eureka/</span></span><br><span class="line"><span class="number">1234567891011121314</span></span><br></pre></td></tr></table></figure><h4 id="8-2-2-修改7002-application-yml-直接粘贴"><a href="#8-2-2-修改7002-application-yml-直接粘贴" class="headerlink" title="8.2.2 修改7002 application.yml,直接粘贴"></a>8.2.2 修改7002 application.yml,直接粘贴</h4><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">7002</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">eureka7002.com</span> <span class="comment">#eureka服务端的实例名称</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="comment">#false表示不向注册中心注册自己</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment">#false表示自己端就是注册中心，我的职责就是维护服务实例，并不需要去检索服务</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="comment">#设置与Eureka Server交互的地址查询服务和注册服务都需要依赖这个地址</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://eureka7001.com:7001/eureka/</span></span><br><span class="line"><span class="number">1234567891011121314</span></span><br></pre></td></tr></table></figure><h3 id="8-3-测试集群"><a href="#8-3-测试集群" class="headerlink" title="8.3 测试集群"></a>8.3 测试集群</h3><p><strong>在7002里能看见7001既守望7001端口,就算配置成功</strong><br><img src="https://img-blog.csdnimg.cn/20200321163551515.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2tpbmd0b2s=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="九-将两个微服务发布到Eureka集群配置中"><a href="#九-将两个微服务发布到Eureka集群配置中" class="headerlink" title="九. 将两个微服务发布到Eureka集群配置中"></a>九. 将两个微服务发布到Eureka集群配置中</h2><h3 id="9-1-8001项目-application-yml"><a href="#9-1-8001项目-application-yml" class="headerlink" title="9.1 8001项目 application.yml"></a>9.1 8001项目 application.yml</h3><p><img src="https://img-blog.csdnimg.cn/20200321164121417.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2tpbmd0b2s=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>添加如下</strong></p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"> <span class="attr">defaultZone:</span> <span class="string">http://eureka7001.com:7001/eureka/,http://eureka7002.com:7002/eureka/</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="9-2-80项目-application-yml"><a href="#9-2-80项目-application-yml" class="headerlink" title="9.2 80项目 application.yml"></a>9.2 80项目 application.yml</h3><p><strong>不同的地点,添加相同的配置</strong></p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"> <span class="attr">defaultZone:</span> <span class="string">http://eureka7001.com:7001/eureka/,http://eureka7002.com:7002/eureka/</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="9-3-测试"><a href="#9-3-测试" class="headerlink" title="9.3 测试"></a>9.3 测试</h3><p><strong>服务都已注册进来</strong><br><img src="https://img-blog.csdnimg.cn/20200321164444771.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2tpbmd0b2s=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><hr><p><img src="https://img-blog.csdnimg.cn/20200321164510998.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2tpbmd0b2s=,size_16,color_FFFFFF,t_70" alt="加粗样式"><br><strong>测试单个服务也成功</strong><br><img src="https://img-blog.csdnimg.cn/20200321164732150.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2tpbmd0b2s=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="十-创建module-cloud-provider-payment8002"><a href="#十-创建module-cloud-provider-payment8002" class="headerlink" title="十. 创建module cloud-provider-payment8002"></a>十. 创建module cloud-provider-payment8002</h2><p><strong>这个模块跟8001模块一样的只不过端口不一样,所以前期创建模块我就省略步骤了,大家copy即可,我把步骤贴出来</strong></p><h3 id="10-1-改POM"><a href="#10-1-改POM" class="headerlink" title="10.1 改POM"></a>10.1 改POM</h3><h3 id="10-2-建-application-yml-文件"><a href="#10-2-建-application-yml-文件" class="headerlink" title="10.2 建 application.yml 文件"></a>10.2 建 application.yml 文件</h3><h3 id="10-3-主启动"><a href="#10-3-主启动" class="headerlink" title="10.3 主启动"></a>10.3 主启动</h3><h3 id="10-4-业务类"><a href="#10-4-业务类" class="headerlink" title="10.4 业务类"></a>10.4 业务类</h3><h3 id="10-5-修改-Controller"><a href="#10-5-修改-Controller" class="headerlink" title="10.5 修改 Controller"></a>10.5 修改 Controller</h3><p><strong>8001 Controller</strong><br><img src="https://img-blog.csdnimg.cn/20200321181923251.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2tpbmd0b2s=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>8002 Controller</strong>.<br><img src="https://img-blog.csdnimg.cn/20200321181945443.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2tpbmd0b2s=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="10-6-开启负载均衡"><a href="#10-6-开启负载均衡" class="headerlink" title="10.6 开启负载均衡"></a>10.6 开启负载均衡</h3><h4 id="10-6-1-首先到80服务下去修改写死的对外暴露的服务url为Eureka注册中心的名字"><a href="#10-6-1-首先到80服务下去修改写死的对外暴露的服务url为Eureka注册中心的名字" class="headerlink" title="10.6.1 首先到80服务下去修改写死的对外暴露的服务url为Eureka注册中心的名字"></a>10.6.1 首先到80服务下去修改写死的对外暴露的服务url为Eureka注册中心的名字</h4><p><img src="https://img-blog.csdnimg.cn/20200321201659964.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2tpbmd0b2s=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200321201139749.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2tpbmd0b2s=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="10-6-2-在我们80项目的restTemplate加入spring容器的bean中增加一个负载均衡的注解-LoadBalanced"><a href="#10-6-2-在我们80项目的restTemplate加入spring容器的bean中增加一个负载均衡的注解-LoadBalanced" class="headerlink" title="10.6.2 在我们80项目的restTemplate加入spring容器的bean中增加一个负载均衡的注解 @LoadBalanced"></a>10.6.2 在我们80项目的restTemplate加入spring容器的bean中增加一个负载均衡的注解 @LoadBalanced</h4><p><img src="https://img-blog.csdnimg.cn/20200321201249540.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2tpbmd0b2s=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="10-6-3-测试"><a href="#10-6-3-测试" class="headerlink" title="10.6.3 测试"></a>10.6.3 测试</h4><p><strong>负载均衡测试成功</strong></p><ul><li><strong>8002端口</strong><br><img src="https://img-blog.csdnimg.cn/20200321201809465.png" alt="在这里插入图片描述"></li><li><strong>8001端口</strong><br><img src="https://img-blog.csdnimg.cn/20200321201847164.png" alt="在这里插入图片描述"></li></ul>]]></content>
    
    <summary type="html">
    
      Springcloud-Alibaba
    
    </summary>
    
    
      <category term="Springcloud-Alibaba" scheme="https://SomunsTao.github.io/categories/Springcloud-Alibaba/"/>
    
    
      <category term="Springcloud-Alibaba" scheme="https://SomunsTao.github.io/tags/Springcloud-Alibaba/"/>
    
  </entry>
  
  <entry>
    <title>Springcloud-Alibaba〖二〗微服务cloud-consumer-order80构建与公共类cloud-api-commons</title>
    <link href="https://somunstao.github.io/2020/04/02/Springcloud-Alibaba%E3%80%96%E4%BA%8C%E3%80%97%E5%BE%AE%E6%9C%8D%E5%8A%A1cloud-consumer-order80%E6%9E%84%E5%BB%BA%E4%B8%8E%E5%85%AC%E5%85%B1%E7%B1%BBcloud-api-commons/"/>
    <id>https://somunstao.github.io/2020/04/02/Springcloud-Alibaba%E3%80%96%E4%BA%8C%E3%80%97%E5%BE%AE%E6%9C%8D%E5%8A%A1cloud-consumer-order80%E6%9E%84%E5%BB%BA%E4%B8%8E%E5%85%AC%E5%85%B1%E7%B1%BBcloud-api-commons/</id>
    <published>2020-04-02T00:08:08.000Z</published>
    <updated>2020-08-02T04:03:18.310Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Springcloud-Alibaba〖二〗微服务cloud-consumer-order80构建与公共类cloud-api-commons"><a href="#Springcloud-Alibaba〖二〗微服务cloud-consumer-order80构建与公共类cloud-api-commons" class="headerlink" title="Springcloud-Alibaba〖二〗微服务cloud-consumer-order80构建与公共类cloud-api-commons"></a>Springcloud-Alibaba〖二〗微服务cloud-consumer-order80构建与公共类cloud-api-commons</h1><h3 id="Springcloud-Alibaba-微服务cloud-consumer-order80与cloud-api-commons构建"><a href="#Springcloud-Alibaba-微服务cloud-consumer-order80与cloud-api-commons构建" class="headerlink" title="Springcloud-Alibaba 微服务cloud-consumer-order80与cloud-api-commons构建"></a>Springcloud-Alibaba 微服务cloud-consumer-order80与cloud-api-commons构建</h3><ul><li><ul><li><ul><li><a href="https://blog.csdn.net/kingtok/article/details/104990775?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param#PS_githubhttpsgithubcomktokingspringcloudalibaba_1" target="_blank" rel="noopener">PS: github仓库<a href="https://github.com/ktoking/springcloud-alibaba" target="_blank" rel="noopener">仓库地址</a>项目都放到里面了</a></li></ul></li><li><p><a href="https://blog.csdn.net/kingtok/article/details/104990775?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param#__10" target="_blank" rel="noopener">四. 热部署(可做可不做,不做可跳过)</a></p></li><li><ul><li><a href="https://blog.csdn.net/kingtok/article/details/104990775?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param#41_8001_14" target="_blank" rel="noopener">4.1 添加依赖在8001项目中</a></li><li><a href="https://blog.csdn.net/kingtok/article/details/104990775?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param#42_pom_24" target="_blank" rel="noopener">4.2 配置父工程pom文件</a></li><li><a href="https://blog.csdn.net/kingtok/article/details/104990775?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param#43__40" target="_blank" rel="noopener">4.3 开启自动编译选项</a></li><li><a href="https://blog.csdn.net/kingtok/article/details/104990775?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param#44__43" target="_blank" rel="noopener">4.4 配置选项</a></li></ul></li><li><p><a href="https://blog.csdn.net/kingtok/article/details/104990775?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param#__cloudconsumerorder80_51" target="_blank" rel="noopener">五. 建立 cloud-consumer-order80微服务</a></p></li><li><ul><li><a href="https://blog.csdn.net/kingtok/article/details/104990775?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param#51__52" target="_blank" rel="noopener">5.1 创建模块</a></li><li><a href="https://blog.csdn.net/kingtok/article/details/104990775?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param#52_pom_54" target="_blank" rel="noopener">5.2 改pom文件</a></li><li><a href="https://blog.csdn.net/kingtok/article/details/104990775?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param#53_yml_86" target="_blank" rel="noopener">5.3 建立yml文件</a></li><li><a href="https://blog.csdn.net/kingtok/article/details/104990775?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param#54__93" target="_blank" rel="noopener">5.4 建立主启动</a></li><li><a href="https://blog.csdn.net/kingtok/article/details/104990775?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param#55__110" target="_blank" rel="noopener">5.5 引入实体类</a></li><li><a href="https://blog.csdn.net/kingtok/article/details/104990775?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param#56__RestTemplatespringbean_113" target="_blank" rel="noopener">5.6 创建 RestTemplate模板加入spring的bean中</a></li><li><a href="https://blog.csdn.net/kingtok/article/details/104990775?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param#57_controller_133" target="_blank" rel="noopener">5.7 controller层</a></li><li><a href="https://blog.csdn.net/kingtok/article/details/104990775?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param#58__172" target="_blank" rel="noopener">5.8 测试及坑</a></li></ul></li><li><p><a href="https://blog.csdn.net/kingtok/article/details/104990775?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param#__179" target="_blank" rel="noopener">六. 工程重构</a></p></li><li><ul><li><p><a href="https://blog.csdn.net/kingtok/article/details/104990775?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param#61__180" target="_blank" rel="noopener">6.1 重复代码存在</a></p></li><li><p><a href="https://blog.csdn.net/kingtok/article/details/104990775?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param#62__184" target="_blank" rel="noopener">6.2 创建一个公共模块</a></p></li><li><ul><li><a href="https://blog.csdn.net/kingtok/article/details/104990775?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param#621cloudapicommons_186" target="_blank" rel="noopener">6.2.1首先创建出cloud-api-commons模块</a></li><li><a href="https://blog.csdn.net/kingtok/article/details/104990775?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param#622_pom_188" target="_blank" rel="noopener">6.2.2 添加新模块的pom文件里的依赖</a></li><li><a href="https://blog.csdn.net/kingtok/article/details/104990775?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param#623__226" target="_blank" rel="noopener">6.2.3 将公共实体类代码拷贝到新模块中</a></li><li><a href="https://blog.csdn.net/kingtok/article/details/104990775?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param#624_Maven_229" target="_blank" rel="noopener">6.2.4 Maven打包</a></li><li><a href="https://blog.csdn.net/kingtok/article/details/104990775?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param#625_800180_236" target="_blank" rel="noopener">6.2.5 各自删除8001与80项目的实体包</a></li><li><a href="https://blog.csdn.net/kingtok/article/details/104990775?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param#626__237" target="_blank" rel="noopener">6.2.6 各自导入打包完成的实体类依赖</a></li><li><a href="https://blog.csdn.net/kingtok/article/details/104990775?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param#627__247" target="_blank" rel="noopener">6.2.7 测试代码</a></li></ul></li></ul></li><li><p><a href="https://blog.csdn.net/kingtok/article/details/104990775?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param#_252" target="_blank" rel="noopener">制作不易,转载请标注~</a></p></li></ul></li></ul><h3 id="PS-github仓库仓库地址项目都放到里面了"><a href="#PS-github仓库仓库地址项目都放到里面了" class="headerlink" title="PS: github仓库仓库地址项目都放到里面了"></a>PS: github仓库<a href="https://github.com/ktoking/springcloud-alibaba" target="_blank" rel="noopener">仓库地址</a>项目都放到里面了</h3><p><strong>接着上一章写</strong></p><p><strong>我摊牌了,大佬们总结的脑图给你们~</strong></p><p><a href="https://www.processon.com/view/link/5e6b6342e4b0e3993b62db71#map" target="_blank" rel="noopener">在线脑图点击就送~</a></p><h2 id="四-热部署-可做可不做-不做可跳过"><a href="#四-热部署-可做可不做-不做可跳过" class="headerlink" title="四. 热部署(可做可不做,不做可跳过)"></a>四. 热部署(可做可不做,不做可跳过)</h2><p><strong>每次代码写完后人工重启非常耗费时间的,所以我们选择热部署</strong></p><h3 id="4-1-添加依赖在8001项目中"><a href="#4-1-添加依赖在8001项目中" class="headerlink" title="4.1 添加依赖在8001项目中"></a>4.1 添加依赖在8001项目中</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">123456</span><br></pre></td></tr></table></figure><h3 id="4-2-配置父工程pom文件"><a href="#4-2-配置父工程pom文件" class="headerlink" title="4.2 配置父工程pom文件"></a>4.2 配置父工程pom文件</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">fork</span>&gt;</span>true<span class="tag">&lt;/<span class="name">fork</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">addResources</span>&gt;</span>true<span class="tag">&lt;/<span class="name">addResources</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line">123456789101112</span><br></pre></td></tr></table></figure><h3 id="4-3-开启自动编译选项"><a href="#4-3-开启自动编译选项" class="headerlink" title="4.3 开启自动编译选项"></a>4.3 开启自动编译选项</h3><p><strong>选项全勾中</strong><br><img src="https://img-blog.csdnimg.cn/20200320151651868.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2tpbmd0b2s=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="4-4-配置选项"><a href="#4-4-配置选项" class="headerlink" title="4.4 配置选项"></a>4.4 配置选项</h3><p><strong>来到8001工程,打开idea,按住ctrl +shift+ alt + /</strong><br><img src="https://img-blog.csdnimg.cn/20200320151919492.png" alt="在这里插入图片描述"><br><strong>点开,然后选择选项打勾</strong><br><img src="https://img-blog.csdnimg.cn/2020032015230186.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2tpbmd0b2s=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>热部署部署完成后,你每次修改一次代码,都会重启我们整个项目,所以开发可以用,但是一旦上生产环境,千万要关闭</strong></p><h2 id="五-建立-cloud-consumer-order80微服务"><a href="#五-建立-cloud-consumer-order80微服务" class="headerlink" title="五. 建立 cloud-consumer-order80微服务"></a>五. 建立 cloud-consumer-order80微服务</h2><h3 id="5-1-创建模块"><a href="#5-1-创建模块" class="headerlink" title="5.1 创建模块"></a>5.1 创建模块</h3><p><img src="https://img-blog.csdnimg.cn/20200320153656486.png" alt="在这里插入图片描述"></p><h3 id="5-2-改pom文件"><a href="#5-2-改pom文件" class="headerlink" title="5.2 改pom文件"></a>5.2 改pom文件</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br><span class="line">12345678910111213141516171819202122232425262728</span><br></pre></td></tr></table></figure><h3 id="5-3-建立yml文件"><a href="#5-3-建立yml文件" class="headerlink" title="5.3 建立yml文件"></a>5.3 建立yml文件</h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure><h3 id="5-4-建立主启动"><a href="#5-4-建立主启动" class="headerlink" title="5.4 建立主启动"></a>5.4 建立主启动</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.aiguigu.springcloud;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderMain80</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(OrderMain80<span class="class">.<span class="keyword">class</span>,<span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">123456789101112</span></span><br></pre></td></tr></table></figure><h3 id="5-5-引入实体类"><a href="#5-5-引入实体类" class="headerlink" title="5.5 引入实体类"></a>5.5 引入实体类</h3><p>还是之前8001项目的两个实体类<br><img src="https://img-blog.csdnimg.cn/20200320162858561.png" alt="在这里插入图片描述"></p><h3 id="5-6-创建-RestTemplate模板加入spring的bean中"><a href="#5-6-创建-RestTemplate模板加入spring的bean中" class="headerlink" title="5.6 创建 RestTemplate模板加入spring的bean中"></a>5.6 创建 RestTemplate模板加入spring的bean中</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.aiguigu.springcloud.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.client.RestTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationContextConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestTemplate <span class="title">getRestTemplate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">123456789101112131415</span></span><br></pre></td></tr></table></figure><h3 id="5-7-controller层"><a href="#5-7-controller层" class="headerlink" title="5.7 controller层"></a>5.7 controller层</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.aiguigu.springcloud.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.aiguigu.springcloud.entities.CommonResult;</span><br><span class="line"><span class="keyword">import</span> com.aiguigu.springcloud.entities.Payment;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.client.RestTemplate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String PAYMENT_URL= <span class="string">"http://localhost:8001"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/consumer/payment/create"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonResult&lt;Payment&gt; <span class="title">create</span><span class="params">(Payment payment)</span></span>&#123;</span><br><span class="line">        log.info(<span class="string">"*******消费者启动创建订单*******"</span>);</span><br><span class="line">        <span class="keyword">return</span> restTemplate.postForObject(PAYMENT_URL+<span class="string">"/payment/create"</span>,payment,CommonResult<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/consumer/payment/get/&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonResult&lt;Payment&gt; <span class="title">getPayment</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> Long id)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> restTemplate.getForObject(PAYMENT_URL+<span class="string">"/payment/get/"</span>+id,CommonResult<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">12345678910111213141516171819202122232425262728293031323334</span></span><br></pre></td></tr></table></figure><h3 id="5-8-测试及坑"><a href="#5-8-测试及坑" class="headerlink" title="5.8 测试及坑"></a>5.8 测试及坑</h3><p><strong>测试查找成功</strong><br><img src="https://img-blog.csdnimg.cn/20200320164624867.png" alt="在这里插入图片描述"></p><p><strong>测试一下插入发现成功了,但是数据库没值,只有自增主键,这里插入没成功的原因是,8001的创建参数没加@RequestBody,大家记得加上才能映射成功</strong></p><p><img src="https://img-blog.csdnimg.cn/20200320165356780.png" alt="在这里插入图片描述"></p><h2 id="六-工程重构"><a href="#六-工程重构" class="headerlink" title="六. 工程重构"></a>六. 工程重构</h2><h3 id="6-1-重复代码存在"><a href="#6-1-重复代码存在" class="headerlink" title="6.1 重复代码存在"></a>6.1 重复代码存在</h3><p><img src="https://img-blog.csdnimg.cn/20200320170148920.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2tpbmd0b2s=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="6-2-创建一个公共模块"><a href="#6-2-创建一个公共模块" class="headerlink" title="6.2 创建一个公共模块"></a>6.2 创建一个公共模块</h3><h4 id="6-2-1首先创建出cloud-api-commons模块"><a href="#6-2-1首先创建出cloud-api-commons模块" class="headerlink" title="6.2.1首先创建出cloud-api-commons模块"></a>6.2.1首先创建出cloud-api-commons模块</h4><p><img src="https://img-blog.csdnimg.cn/20200320174808869.png" alt="在这里插入图片描述"></p><h4 id="6-2-2-添加新模块的pom文件里的依赖"><a href="#6-2-2-添加新模块的pom文件里的依赖" class="headerlink" title="6.2.2 添加新模块的pom文件里的依赖"></a>6.2.2 添加新模块的pom文件里的依赖</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cloud2020<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.aiguigu.springcloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cloud-api-commons<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.hutool<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hutool-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br><span class="line"></span><br><span class="line">123456789101112131415161718192021222324252627282930313233</span><br></pre></td></tr></table></figure><h4 id="6-2-3-将公共实体类代码拷贝到新模块中"><a href="#6-2-3-将公共实体类代码拷贝到新模块中" class="headerlink" title="6.2.3 将公共实体类代码拷贝到新模块中"></a>6.2.3 将公共实体类代码拷贝到新模块中</h4><p><img src="https://img-blog.csdnimg.cn/20200320174922189.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2tpbmd0b2s=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="6-2-4-Maven打包"><a href="#6-2-4-Maven打包" class="headerlink" title="6.2.4 Maven打包"></a>6.2.4 Maven打包</h4><p><strong>先clean,记得提前点闪电跳过测试</strong><br><img src="https://img-blog.csdnimg.cn/20200320175300471.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2tpbmd0b2s=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>再点install</strong><br><img src="https://img-blog.csdnimg.cn/20200320175407468.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2tpbmd0b2s=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>成功</strong><br><img src="https://img-blog.csdnimg.cn/20200320175517660.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2tpbmd0b2s=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="6-2-5-各自删除8001与80项目的实体包"><a href="#6-2-5-各自删除8001与80项目的实体包" class="headerlink" title="6.2.5 各自删除8001与80项目的实体包"></a>6.2.5 各自删除8001与80项目的实体包</h4><h4 id="6-2-6-各自导入打包完成的实体类依赖"><a href="#6-2-6-各自导入打包完成的实体类依赖" class="headerlink" title="6.2.6 各自导入打包完成的实体类依赖"></a>6.2.6 各自导入打包完成的实体类依赖</h4><p><strong>引入如下依赖在8001项目与80项目中</strong></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.atguigu.springcloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cloud-api-commons<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;project.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">12345</span><br></pre></td></tr></table></figure><h4 id="6-2-7-测试代码"><a href="#6-2-7-测试代码" class="headerlink" title="6.2.7 测试代码"></a>6.2.7 测试代码</h4><p><strong>测试成功</strong><br><img src="https://img-blog.csdnimg.cn/20200320182640207.png" alt="在这里插入图片描述"></p>]]></content>
    
    <summary type="html">
    
      Springcloud-Alibaba
    
    </summary>
    
    
      <category term="Springcloud-Alibaba" scheme="https://SomunsTao.github.io/categories/Springcloud-Alibaba/"/>
    
    
      <category term="Springcloud-Alibaba" scheme="https://SomunsTao.github.io/tags/Springcloud-Alibaba/"/>
    
  </entry>
  
  <entry>
    <title>Springcloud-Alibaba〖一〗微服务提供支付payment8001模块</title>
    <link href="https://somunstao.github.io/2020/04/01/Springcloud-Alibaba%E3%80%96%E4%B8%80%E3%80%97%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%8F%90%E4%BE%9B%E6%94%AF%E4%BB%98payment8001%E6%A8%A1%E5%9D%97/"/>
    <id>https://somunstao.github.io/2020/04/01/Springcloud-Alibaba%E3%80%96%E4%B8%80%E3%80%97%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%8F%90%E4%BE%9B%E6%94%AF%E4%BB%98payment8001%E6%A8%A1%E5%9D%97/</id>
    <published>2020-04-01T00:08:08.000Z</published>
    <updated>2020-08-02T04:01:45.442Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Springcloud-Alibaba〖一〗微服务提供支付payment8001模块"><a href="#Springcloud-Alibaba〖一〗微服务提供支付payment8001模块" class="headerlink" title="Springcloud-Alibaba〖一〗微服务提供支付payment8001模块"></a>Springcloud-Alibaba〖一〗微服务提供支付payment8001模块</h1><h3 id="Springcloud-Alibaba-微服务提供支付payment8001模块"><a href="#Springcloud-Alibaba-微服务提供支付payment8001模块" class="headerlink" title="Springcloud-Alibaba 微服务提供支付payment8001模块"></a>Springcloud-Alibaba 微服务提供支付payment8001模块</h3><ul><li><ul><li><ul><li><a href="https://blog.csdn.net/kingtok/article/details/104963122#PS_githubhttpsgithubcomktokingspringcloudalibaba_4" target="_blank" rel="noopener">PS: github仓库<a href="https://github.com/ktoking/springcloud-alibaba" target="_blank" rel="noopener">仓库地址</a>项目都放到里面了</a></li></ul></li><li><p><a href="https://blog.csdn.net/kingtok/article/details/104963122#__5" target="_blank" rel="noopener">一. 技术选型.</a></p></li><li><p><a href="https://blog.csdn.net/kingtok/article/details/104963122#_POM_15" target="_blank" rel="noopener">二. 父工程POM聚合</a></p></li><li><p><a href="https://blog.csdn.net/kingtok/article/details/104963122#_module_cloudproviderpayment8001_132" target="_blank" rel="noopener">三. 建立支付module: cloud-provider-payment8001</a></p></li><li><ul><li><p><a href="https://blog.csdn.net/kingtok/article/details/104963122#31__133" target="_blank" rel="noopener">3.1 项目结构</a></p></li><li><p><a href="https://blog.csdn.net/kingtok/article/details/104963122#32_modulepom_135" target="_blank" rel="noopener">3.2 建立子module的pom文件</a></p></li><li><p><a href="https://blog.csdn.net/kingtok/article/details/104963122#33_yml_198" target="_blank" rel="noopener">3.3 子模块的yml配置文件</a></p></li><li><p><a href="https://blog.csdn.net/kingtok/article/details/104963122#34__219" target="_blank" rel="noopener">3.4 建库</a></p></li><li><p><a href="https://blog.csdn.net/kingtok/article/details/104963122#35__230" target="_blank" rel="noopener">3.5 业务类</a></p></li><li><ul><li><a href="https://blog.csdn.net/kingtok/article/details/104963122#351__231" target="_blank" rel="noopener">3.5.1 目录结构</a></li><li><a href="https://blog.csdn.net/kingtok/article/details/104963122#352__233" target="_blank" rel="noopener">3.5.2 实体类</a></li><li><a href="https://blog.csdn.net/kingtok/article/details/104963122#353_service_264" target="_blank" rel="noopener">3.5.3 service及实现类</a></li><li><a href="https://blog.csdn.net/kingtok/article/details/104963122#354_Controller_312" target="_blank" rel="noopener">3.5.4 Controller实现</a></li><li><a href="https://blog.csdn.net/kingtok/article/details/104963122#355__362" target="_blank" rel="noopener">3.5.5 测试启动</a></li></ul></li><li><p><a href="https://blog.csdn.net/kingtok/article/details/104963122#36__375" target="_blank" rel="noopener">3.6 建一个模块的总结</a></p></li><li><p><a href="https://blog.csdn.net/kingtok/article/details/104963122#_384" target="_blank" rel="noopener">制作不易,转载请标注~~</a></p></li></ul></li></ul></li></ul><p><strong>废话不多说,搞一点阳间的东西玩玩,大伙们懂得都懂哦~</strong><br><strong>此章节及之后Springcloud-Alibaba博客参照尚硅谷周阳老师视频<a href="https://www.bilibili.com/video/av93813318?p=11" target="_blank" rel="noopener">视频链接</a>,加上自己理解整理所成,点赞加关注给你们脑图,下一篇博客就更脑图!</strong></p><h3 id="PS-github仓库仓库地址项目都放到里面了"><a href="#PS-github仓库仓库地址项目都放到里面了" class="headerlink" title="PS: github仓库仓库地址项目都放到里面了"></a>PS: github仓库<a href="https://github.com/ktoking/springcloud-alibaba" target="_blank" rel="noopener">仓库地址</a>项目都放到里面了</h3><h2 id="一-技术选型"><a href="#一-技术选型" class="headerlink" title="一. 技术选型."></a>一. 技术选型.</h2><table><thead><tr><th>技术</th><th>版本</th></tr></thead><tbody><tr><td>cloud</td><td>Hoxton</td></tr><tr><td>boot</td><td>2.2.2.RELEASE</td></tr><tr><td>cloud alibaba</td><td>2.1.0.RELEASE</td></tr><tr><td>java</td><td>1.8</td></tr><tr><td>Maven</td><td>3.5.2</td></tr><tr><td>Mysql</td><td>5.7及以上</td></tr></tbody></table><h2 id="二-父工程POM聚合"><a href="#二-父工程POM聚合" class="headerlink" title="二. 父工程POM聚合"></a>二. 父工程POM聚合</h2><p>maven架构选择org.apache.maven.archetypes:maven-archetype-site</p><ul><li>删掉其中的src目录,因为我们这个项目是父工程,只提供版本控制</li><li><strong>&lt; dependencyManagement &gt;</strong> 标签 子模块继承之后，提供作用：锁定版本+子模块不用groupId和version,Maven工程会沿着父子层向上走,直到找到一个<strong>dependencyManagement</strong>元素的项目,然后他就会使用这个元素指定的版本号</li><li><strong>&lt; packaging&gt;pom&lt; /packaging &gt;</strong> POM是最简单的打包类型。不像一个JAR，SAR，或者EAR，它生成的构件只是它本身。没有代码需要测试或者编译，也没有资源需要处理。</li></ul><p><strong>pom文件如下,注释基本都有</strong></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.aiguigu.springcloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cloud2020<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>Maven<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- FIXME change it to the project's website --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.apache.org/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">inceptionYear</span>&gt;</span>2001<span class="tag">&lt;/<span class="name">inceptionYear</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">distributionManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">site</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>website<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">url</span>&gt;</span>scp://webhost.company.com/www/website<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">site</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">distributionManagement</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">junit.version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">junit.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">log4j.version</span>&gt;</span>1.2.17<span class="tag">&lt;/<span class="name">log4j.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">lombok.version</span>&gt;</span>1.16.18<span class="tag">&lt;/<span class="name">lombok.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mysql.version</span>&gt;</span>5.1.47<span class="tag">&lt;/<span class="name">mysql.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">druid.version</span>&gt;</span>1.1.16<span class="tag">&lt;/<span class="name">druid.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mybatis.spring.boot.version</span>&gt;</span>1.3.0<span class="tag">&lt;/<span class="name">mybatis.spring.boot.version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--子模块继承之后，提供作用：锁定版本+子module不用groupId和version--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--spring boot 2.2.2--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--spring cloud Hoxton.SR1--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>Hoxton.SR1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--spring cloud alibaba 2.1.0.RELEASE--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-alibaba-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;mysql.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;druid.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;mybatis.spring.boot.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;junit.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;lombok.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">fork</span>&gt;</span>true<span class="tag">&lt;/<span class="name">fork</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">addResources</span>&gt;</span>true<span class="tag">&lt;/<span class="name">addResources</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br><span class="line"></span><br><span class="line">123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106</span><br></pre></td></tr></table></figure><h2 id="三-建立支付module-cloud-provider-payment8001"><a href="#三-建立支付module-cloud-provider-payment8001" class="headerlink" title="三. 建立支付module: cloud-provider-payment8001"></a>三. 建立支付module: cloud-provider-payment8001</h2><h3 id="3-1-项目结构"><a href="#3-1-项目结构" class="headerlink" title="3.1 项目结构"></a>3.1 项目结构</h3><p><img src="https://img-blog.csdnimg.cn/20200319115831628.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2tpbmd0b2s=,size_16,color_FFFFFF,t_70" alt="项目结构图"></p><h3 id="3-2-建立子module的pom文件"><a href="#3-2-建立子module的pom文件" class="headerlink" title="3.2 建立子module的pom文件"></a>3.2 建立子module的pom文件</h3><ul><li><strong>dependencies</strong>可以不用写version,会去父工程里找,写了的话就会用自己的版本号</li></ul><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cloud2020<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.aiguigu.springcloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cloud-provider-payment8001<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--mysql-connector-java--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br><span class="line"></span><br><span class="line">1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859</span><br></pre></td></tr></table></figure><h3 id="3-3-子模块的yml配置文件"><a href="#3-3-子模块的yml配置文件" class="headerlink" title="3.3 子模块的yml配置文件"></a>3.3 子模块的yml配置文件</h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8001</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloud-provider-service</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span>      <span class="comment">#当前数据源操作类型</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">org.gjt.mm.mysql.Driver</span>        <span class="comment">#mysql驱动包</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/db2019?useUnicode=true&amp;characterEncoding-utr-8&amp;useSSL=false</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">root</span></span><br><span class="line"></span><br><span class="line"><span class="attr">mybatis:</span></span><br><span class="line">    <span class="attr">mapper-locations:</span> <span class="string">classpath:mapper/*.xml</span></span><br><span class="line">    <span class="attr">type-aliases-package:</span> <span class="string">com.atguigu.springcloud.entities</span>       <span class="comment">#所有Entity别名类所在包</span></span><br><span class="line"><span class="number">12345678910111213141516</span></span><br></pre></td></tr></table></figure><h3 id="3-4-建库"><a href="#3-4-建库" class="headerlink" title="3.4 建库"></a>3.4 建库</h3><p><strong>库名db2019</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`payment`</span>(</span><br><span class="line"><span class="string">`id`</span> <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">'ID'</span>,</span><br><span class="line"><span class="string">`serial`</span> <span class="built_in">varchar</span>(<span class="number">200</span>) <span class="keyword">DEFAULT</span> <span class="string">''</span>,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> AUTO_INCREMENT=<span class="number">1</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8</span><br><span class="line"></span><br><span class="line"><span class="number">123456</span></span><br></pre></td></tr></table></figure><h3 id="3-5-业务类"><a href="#3-5-业务类" class="headerlink" title="3.5 业务类"></a>3.5 业务类</h3><h4 id="3-5-1-目录结构"><a href="#3-5-1-目录结构" class="headerlink" title="3.5.1 目录结构"></a>3.5.1 目录结构</h4><p><img src="https://img-blog.csdnimg.cn/20200319144536407.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2tpbmd0b2s=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="3-5-2-实体类"><a href="#3-5-2-实体类" class="headerlink" title="3.5.2 实体类"></a>3.5.2 实体类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Payment</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String serial;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">12345678910</span></span><br></pre></td></tr></table></figure><p><strong>定义一个通用返回类</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommonResult</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer code;</span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line">    <span class="keyword">private</span>  T      data;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CommonResult</span><span class="params">(Integer code,String message)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(code,message,<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">1234567891011121314</span></span><br></pre></td></tr></table></figure><h4 id="3-5-3-service及实现类"><a href="#3-5-3-service及实现类" class="headerlink" title="3.5.3 service及实现类"></a>3.5.3 service及实现类</h4><p><strong>目录结构</strong><br><img src="https://img-blog.csdnimg.cn/20200319154716664.png" alt="在这里插入图片描述"><br><strong>PaymentService</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.springcloud.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atguigu.springcloud.entities.Payment;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Param;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PaymentService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">create</span><span class="params">(Payment payment)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Payment <span class="title">getPaymentById</span><span class="params">(@Param(<span class="string">"id"</span>)</span> Long id)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">123456789101112</span></span><br></pre></td></tr></table></figure><p><strong>PaymentServiceImpl</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.springcloud.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atguigu.springcloud.dao.PaymentDao;</span><br><span class="line"><span class="keyword">import</span> com.atguigu.springcloud.entities.Payment;</span><br><span class="line"><span class="keyword">import</span> com.atguigu.springcloud.service.PaymentService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PaymentServiceImpl</span> <span class="keyword">implements</span> <span class="title">PaymentService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> PaymentDao paymentDao;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">create</span><span class="params">(Payment payment)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  paymentDao.create(payment);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Payment <span class="title">getPaymentById</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> paymentDao.getPaymentById(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">123456789101112131415161718192021222324252627</span></span><br></pre></td></tr></table></figure><h4 id="3-5-4-Controller实现"><a href="#3-5-4-Controller实现" class="headerlink" title="3.5.4 Controller实现"></a>3.5.4 Controller实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.springcloud.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atguigu.springcloud.entities.CommonResult;</span><br><span class="line"><span class="keyword">import</span> com.atguigu.springcloud.entities.Payment;</span><br><span class="line"><span class="keyword">import</span> com.atguigu.springcloud.service.PaymentService;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PostMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PaymentController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> PaymentService paymentService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span>(value = <span class="string">"/payment/create"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonResult <span class="title">create</span><span class="params">(Payment payment)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = paymentService.create(payment);</span><br><span class="line">        log.info(<span class="string">"*******插入结果为: "</span>+result);</span><br><span class="line">        <span class="keyword">if</span>(result&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> CommonResult(<span class="number">200</span>,<span class="string">"插入数据库成功"</span>,result);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> CommonResult(<span class="number">444</span>,<span class="string">"插入数据库失败"</span>,<span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(value = <span class="string">"/payment/get/&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonResult <span class="title">getPaymentById</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> Long id)</span>&#123;</span><br><span class="line">        Payment paymentById = paymentService.getPaymentById(id);</span><br><span class="line">        log.info(<span class="string">"*********查找结果为: "</span>+paymentById);</span><br><span class="line">        <span class="keyword">if</span>(paymentById!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> CommonResult(<span class="number">200</span>,<span class="string">"查找成功"</span>,paymentById);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> CommonResult(<span class="number">444</span>,<span class="string">"查找为空,查找ID为: "</span>+id,<span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">12345678910111213141516171819202122232425262728293031323334353637383940414243444546</span></span><br></pre></td></tr></table></figure><h4 id="3-5-5-测试启动"><a href="#3-5-5-测试启动" class="headerlink" title="3.5.5 测试启动"></a>3.5.5 测试启动</h4><p>先启动我们本地springboot项目</p><p><strong>测试查询</strong></p><p>打开<strong>Postman</strong>测试工具,输入测试url进行测试,本地我之前进行插入过一条数据<br><img src="https://img-blog.csdnimg.cn/20200319163612245.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2tpbmd0b2s=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>测试插入</strong><br><img src="https://img-blog.csdnimg.cn/20200319164457239.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2tpbmd0b2s=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>数据库插入成功</strong><br><img src="https://img-blog.csdnimg.cn/20200319164538899.png" alt="在这里插入图片描述"></p><h3 id="3-6-建一个模块的总结"><a href="#3-6-建一个模块的总结" class="headerlink" title="3.6 建一个模块的总结"></a>3.6 建一个模块的总结</h3><p><strong>第一阶段的项目结构图</strong><br><img src="https://img-blog.csdnimg.cn/20200319165947280.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2tpbmd0b2s=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>建一个模块总结步骤</strong><br><img src="https://img-blog.csdnimg.cn/20200319170047684.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2tpbmd0b2s=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>业务类</strong><br><img src="https://img-blog.csdnimg.cn/20200319170735439.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2tpbmd0b2s=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>下一章节</strong> <a href="https://editor.csdn.net/md/?articleId=104990775" target="_blank" rel="noopener">Springcloud-Alibaba〖二〗</a></p>]]></content>
    
    <summary type="html">
    
      Springcloud-Alibaba
    
    </summary>
    
    
      <category term="Springcloud-Alibaba" scheme="https://SomunsTao.github.io/categories/Springcloud-Alibaba/"/>
    
    
      <category term="Springcloud-Alibaba" scheme="https://SomunsTao.github.io/tags/Springcloud-Alibaba/"/>
    
  </entry>
  
  <entry>
    <title>JVM和JUC复习</title>
    <link href="https://somunstao.github.io/2020/04/01/JUM%20JUC/"/>
    <id>https://somunstao.github.io/2020/04/01/JUM%20JUC/</id>
    <published>2020-03-31T16:00:00.000Z</published>
    <updated>2020-08-02T03:56:11.641Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JVM和JUC复习"><a href="#JVM和JUC复习" class="headerlink" title="JVM和JUC复习"></a>JVM和JUC复习</h1><!-- TOC --><ul><li><a href="#jdkjvmjuc部分图源javaguide">jdkjvmjuc(部分图源:</a><a href="https://github.com/Snailclimb/JavaGuide" target="_blank" rel="noopener">JavaGuide</a>)<ul><li><a href="#java基础知识">java基础知识</a><ul><li><a href="#java常见基础知识点">Java常见基础知识点</a><ul><li><a href="#面向对象和面向过程的区别">面向对象和面向过程的区别</a></li><li><a href="#oraclejdk与openjdk的区别">OracleJdk与OpenJdk的区别</a></li><li><a href="#java与c的异同">Java与C  的异同</a></li><li><a href="#jvmjdk和jre的区别">JVM,JDK和JRE的区别</a></li><li><a href="#java语言的特点">Java语言的特点</a></li><li><a href="#面向对象的特征">面向对象的特征</a></li><li><a href="#重载和重写的区别">重载和重写的区别</a></li><li><a href="#接口与抽象类的区别">接口与抽象类的区别</a></li><li><a href="#object类的方法有哪些">Object类的方法有哪些?</a></li><li><a href="#静态属性方法和成员属性方法区别">静态属性方法和成员属性方法区别</a></li><li><a href="#子类属性与父类属性初始化顺序">子类属性与父类属性初始化顺序</a></li><li><a href="#自动拆箱和装箱">自动拆箱和装箱</a></li><li><a href="#string为什么不可变">String为什么不可变?</a></li><li><a href="#final关键字的作用">final关键字的作用</a></li><li><a href="#stringbuilder和stringbuffer区别">StringBuilder和StringBuffer区别</a></li><li><a href="#equals知识点">equals知识点</a></li><li><a href="#深拷贝与浅拷贝">深拷贝与浅拷贝</a></li><li><a href="#io流分类">IO流分类</a></li><li><a href="#使用字节流还是字符流">使用字节流还是字符流?</a></li><li><a href="#bigdecimal">BigDecimal</a></li><li><a href="#java异常体系结构">Java异常体系结构</a></li><li><a href="#comparable和comparator">Comparable和Comparator</a></li><li><a href="#什么是泛型什么是类型擦除">什么是泛型，什么是类型擦除?</a></li><li><a href="#泛型通配符">泛型通配符</a></li><li><a href="#上界通配符--extend-e">上界通配符 ? extend E</a></li><li><a href="#下界通配符--super-e">下界通配符 ? super E</a></li><li><a href="#?和t的区别">?和T的区别</a></li><li><a href="#为什么要慎用-arraysaslist">为什么要慎用 Arrays.asList()?</a></li><li><a href="#java中引用的类型">Java中引用的类型</a></li></ul></li></ul></li><li><a href="#对象在内存中的布局64位">对象在内存中的布局(64位)</a>    * <a href="#实例数据">实例数据</a>    * <a href="#对齐填充">对齐填充</a><ul><li><a href="#对象头">对象头</a><ul><li><a href="#markword和metadata">markword和metadata</a></li><li><a href="#实例数据-1">实例数据</a></li><li><a href="#对齐填充-1">对齐填充</a></li></ul></li><li><a href="#jol工具查看对象布局">jol工具查看对象布局</a><ul><li><a href="#查看对象内存布局">查看对象内存布局</a></li><li><a href="#hashcode">hashcode</a></li><li><a href="#对象的hashcode返回的是对象的内存地址吗">对象的hashcode返回的是对象的内存地址吗?</a></li></ul></li></ul></li><li><a href="#线程并发jucaqscas">线程并发(JUC,AQS,CAS)</a><ul><li><a href="#多线程">多线程</a><ul><li><a href="#进程和线程">进程和线程</a></li><li><a href="#并发和并行">并发和并行</a></li><li><a href="#多线程的利弊">多线程的利弊</a></li><li><a href="#什么是上下文切换">什么是上下文切换?</a></li><li><a href="#线程的优先级">线程的优先级</a></li><li><a href="#线程的几种状态">线程的几种状态</a></li><li><a href="#sleep方法和wait方法">sleep方法和wait方法</a></li><li><a href="#stopsuspendresume等方法为什么会被遗弃">stop,suspend,resume等方法为什么会被遗弃</a></li><li><a href="#interruptinterruptedisinterrupted方法区别">interrupt,interrupted,isInterrupted方法区别</a></li><li><a href="#join方法">join方法</a></li><li><a href="#yield方法">yield方法</a></li></ul></li><li><a href="#并发">并发</a><ul><li><a href="#synchronized">synchronized</a></li><li><a href="#synchronized底层原理">synchronized底层原理</a></li><li><a href="#synchronized-使用方法">synchronized 使用方法</a></li><li><a href="#synchronized和reentrantlock的区别">Synchronized和ReentrantLock的区别</a></li><li><a href="#乐观锁">乐观锁</a></li><li><a href="#悲观锁">悲观锁</a></li><li><a href="#独占锁">独占锁</a></li><li><a href="#共享锁">共享锁</a></li><li><a href="#公平锁">公平锁</a></li><li><a href="#非公平锁">非公平锁</a></li><li><a href="#可重入锁递归锁">可重入锁(递归锁)</a></li><li><a href="#偏向锁">偏向锁</a></li><li><a href="#轻量级锁">轻量级锁</a></li><li><a href="#自旋锁">自旋锁</a></li><li><a href="#自适应自旋锁">自适应自旋锁</a></li><li><a href="#锁消除">锁消除</a></li><li><a href="#锁粗化">锁粗化</a></li><li><a href="#死锁">死锁</a></li><li><a href="#如何避免死锁">如何避免死锁?</a></li></ul></li><li><a href="#volatile">volatile</a><ul><li><a href="#volatile保证内存的可见性">volatile保证内存的可见性</a></li><li><a href="#volatile禁止指令重排序">volatile禁止指令重排序</a></li><li><a href="#volatile如何禁止指令重排序的">volatile如何禁止指令重排序的?</a></li><li><a href="#volatile不保证原子性">volatile不保证原子性</a></li></ul></li><li><a href="#cas">CAS</a><ul><li><a href="#cas在java中的底层实现atomic原子类实现">CAS在JAVA中的底层实现(Atomic原子类实现)</a></li><li><a href="#cas的缺点">CAS的缺点</a></li><li><a href="#解决aba问题">解决ABA问题</a></li><li><a href="#threadlocal">ThreadLocal</a></li><li><a href="#threadlocal引发的内存泄露">ThreadLocal引发的内存泄露</a></li><li><a href="#线程池的好处">线程池的好处</a></li><li><a href="#线程池构造参数">线程池构造参数</a></li><li><a href="#阿里巴巴开发者手册不建议开发者使用executors创建线程池">阿里巴巴开发者手册不建议开发者使用Executors创建线程池</a></li></ul></li><li><a href="#aqsabstractqueuedsynchronizer">AQS(AbstractQueuedSynchronizer)</a><ul><li><a href="#aqs概述">AQS概述</a></li><li><a href="#aqs的两种共享资源的访问方式">AQS的两种共享资源的访问方式</a></li><li><a href="#locktrylock和lockinterruptibly区别">lock,tryLock和lockInterruptibly区别</a></li><li><a href="#countdownlatch">CountDownLatch</a></li><li><a href="#semaphore">Semaphore</a></li><li><a href="#cyclibarrier">CycliBarrier</a></li><li><a href="#reentrantreadwritelock如何区分读写锁的">ReentrantReadWriteLock如何区分读写锁的?</a></li></ul></li></ul></li><li><a href="#java集合">Java集合</a>    * <a href="#hashmap的特点">HashMap的特点</a>    * <a href="#hashmap的长度容量为什么要设计成2的幂">HashMap的长度(容量)为什么要设计成2的幂？</a>    * <a href="#hashtable的特点">HashTable的特点</a>    * <a href="#treemap">TreeMap</a>    * <a href="#arraylist的特点">ArrayList的特点</a>    * <a href="#vector的特点">Vector的特点</a>    * <a href="#linkedlist的特点">LinkedList的特点</a>    * <a href="#set">Set</a>    * <a href="#concurrentmodificationexception异常">ConcurrentModificationException异常</a>    * <a href="#线程安全的-list">线程安全的 List</a>    * <a href="#copyonwritearraylist">CopyOnWriteArrayList</a>    * <a href="#线程安全的set">线程安全的Set</a>    * <a href="#线程安全的map">线程安全的Map</a>    * <a href="#concurrenthashmap">ConcurrentHashMap</a>    * <a href="#concurrentskiplistmap">ConcurrentSkipListMap</a></li><li><a href="#java-io">Java IO</a><ul><li><a href="#操作系统的内核">操作系统的内核</a><ul><li><a href="#操作系统的用户态与内核态">操作系统的用户态与内核态</a></li><li><a href="#为什么要有用户态与内核态">为什么要有用户态与内核态?</a></li><li><a href="#用户态切换到内核态的几种方式">用户态切换到内核态的几种方式</a></li><li><a href="#阻塞和非阻塞">阻塞和非阻塞</a></li><li><a href="#同步与异步">同步与异步</a></li></ul></li><li><a href="#linux-io模型">Linux IO模型</a><ul><li><a href="#阻塞io">阻塞IO</a></li><li><a href="#非阻塞io网络io模型">非阻塞IO(网络IO模型)</a></li><li><a href="#io多路复用网络io模型">IO多路复用(网络IO模型)</a></li><li><a href="#信号驱动io网络io模型">信号驱动IO(网络IO模型)</a></li><li><a href="#异步io">异步IO</a></li></ul></li></ul></li><li><a href="#jvm">JVM</a><ul><li><a href="#jvm运行时内存分区">JVM运行时内存分区</a><ul><li><a href="#程序计数器">程序计数器</a></li><li><a href="#程序计数器的特点">程序计数器的特点</a></li><li><a href="#java虚拟机栈">Java虚拟机栈</a></li><li><a href="#栈帧">栈帧</a></li><li><a href="#局部变量表">局部变量表</a></li><li><a href="#操作数栈">操作数栈</a></li><li><a href="#动态连接">动态连接</a></li><li><a href="#方法出口">方法出口</a></li><li><a href="#本地方法栈">本地方法栈</a></li><li><a href="#堆">堆</a></li><li><a href="#方法区">方法区</a></li></ul></li><li><a href="#javavirtualmachineerror">JavaVirtualMachineError</a><ul><li><a href="#stackoverflowerror">StackOverflowError</a></li><li><a href="#outofmemoryerror">OutOfMemoryError</a></li></ul></li><li><a href="#简单了解类文件结构">简单了解类文件结构</a></li><li><a href="#类的生命周期">类的生命周期</a><ul><li><a href="#类加载过程">类加载过程</a></li><li><a href="#加载">加载</a></li><li><a href="#连接">连接</a></li><li><a href="#初始化">初始化</a></li><li><a href="#使用">使用</a></li><li><a href="#类的卸载">类的卸载</a></li><li><a href="#java中类加载器有多少个">Java中类加载器有多少个</a></li><li><a href="#类加载器的命名空间">类加载器的命名空间</a></li><li><a href="#双亲委派机制">双亲委派机制</a></li><li><a href="#为什么需要双亲委派机制">为什么需要双亲委派机制?</a></li><li><a href="#双亲委派机制的实现原理">双亲委派机制的实现原理?</a></li></ul></li><li><a href="#jvm常量池">JVM常量池</a><ul><li><a href="#class常量池静态常量池">Class常量池(静态常量池)</a></li><li><a href="#运行时常量池">运行时常量池</a></li><li><a href="#字符串常量池全局常量池">字符串常量池(全局常量池)</a></li><li><a href="#包装类型缓存池">包装类型缓存池</a></li></ul></li></ul></li><li><a href="#gc">GC</a><ul><li><a href="#判断对象存活的方法">判断对象存活的方法</a><ul><li><a href="#引用计数法缺点">引用计数法缺点</a></li><li><a href="#什么是gc-root-">什么是GC Root ?</a></li></ul></li><li><a href="#垃圾回收算法">垃圾回收算法</a><ul><li><a href="#复制算法copying">复制算法(Copying)</a></li><li><a href="#标记-清除算法mark-sweep">标记-清除算法(Mark-Sweep)</a></li><li><a href="#标记-整理算法mark-compact">标记-整理算法(Mark-Compact)</a></li><li><a href="#分代收集算法">分代收集算法</a></li><li><a href="#内存分配与垃圾回收策略">内存分配与垃圾回收策略</a></li><li><a href="#一次gc的过程">一次GC的过程</a></li><li><a href="#动态年龄阈值">动态年龄阈值</a></li></ul></li><li><a href="#垃圾回收器">垃圾回收器</a><ul><li><a href="#serial串行收集器">Serial串行收集器</a></li><li><a href="#serial-old-串行收集器老年代版本">Serial Old 串行收集器(老年代版本)</a></li><li><a href="#parallel-scavenge-并行多线程收集器">Parallel Scavenge 并行多线程收集器</a></li><li><a href="#parallel-old-并行收集器老年代版本">Parallel Old 并行收集器(老年代版本)</a></li><li><a href="#parnew-多线程收集器">ParNew 多线程收集器</a></li><li><a href="#cms-并发标记清除收集器">CMS 并发标记清除收集器</a></li><li><a href="#cms收集器回收过程">CMS收集器回收过程</a></li><li><a href="#g1-收集器">G1 收集器</a></li><li><a href="#g1回收器的特点">G1回收器的特点</a></li><li><a href="#g1收集器回收过程">G1收集器回收过程</a></li></ul></li></ul></li><li><a href="#jvm调优相关">JVM调优相关</a><ul><li><a href="#jvm常见参数">JVM常见参数</a><ul><li><a href="#堆栈相关">堆栈相关</a></li><li><a href="#gc相关">GC相关</a></li><li><a href="#其他">其他</a></li></ul></li><li><a href="#java常用调优命令和工具">Java常用调优命令和工具</a></li></ul></li><li><a href="#jdk新特性">Jdk新特性</a><ul><li><a href="#jdk8新特性">Jdk8新特性</a></li><li><a href="#jdk9新特性">Jdk9新特性</a></li><li><a href="#jdk10新特性">Jdk10新特性</a></li><li><a href="#jdk11新特性">Jdk11新特性</a></li><li><a href="#jdk12新特性">Jdk12新特性</a></li><li><a href="#jdk13新特性">Jdk13新特性</a></li><li><a href="#jdk14新特性">Jdk14新特性</a></li></ul></li></ul></li></ul><!-- /TOC --><h1 id="jdk-amp-jvm-amp-juc-部分图源-JavaGuide"><a href="#jdk-amp-jvm-amp-juc-部分图源-JavaGuide" class="headerlink" title="jdk&amp;jvm&amp;juc(部分图源:JavaGuide)"></a>jdk&amp;jvm&amp;juc(部分图源:<a href="https://github.com/Snailclimb/JavaGuide" target="_blank" rel="noopener">JavaGuide</a>)</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">如有错误之处，敬请各位同学指教。</span><br></pre></td></tr></table></figure><p><strong>PS:以下部分内容希望各位同学下载openjdk的源码,亲自实践。</strong></p><p>openjdk8u:</p><ul><li>hotspot:<a href="http://hg.openjdk.java.net/jdk8u/hs-dev/hotspot/archive/tip.tar.gz" target="_blank" rel="noopener">hotspot</a></li><li>openjdk:<a href="https://hg.openjdk.java.net/jdk8u/hs-dev/jdk/archive/tip.tar.gz" target="_blank" rel="noopener">jdk</a></li></ul><p><strong>PS:JVM部分参考了《深入理解Java虚拟机 - 第二版》(周志明). 个人认为《深入理解Java虚拟机 - 第二版》上的部分内容已经过时 有些知识请各位同学明鉴，此外我后续会根据 《深入理解Java虚拟机 - 第三版》的内容来做更新和修改。</strong></p><h2 id="java基础知识"><a href="#java基础知识" class="headerlink" title="java基础知识"></a>java基础知识</h2><h3 id="Java常见基础知识点"><a href="#Java常见基础知识点" class="headerlink" title="Java常见基础知识点"></a>Java常见基础知识点</h3><h4 id="面向对象和面向过程的区别"><a href="#面向对象和面向过程的区别" class="headerlink" title="面向对象和面向过程的区别"></a>面向对象和面向过程的区别</h4><p>首先面向过程和面向对象的语言没有具体的性能高下之分,要依据每种语言的设计来做参考. 个人认为面向过程与面向对象的最大区别在于: <strong>面向过程的语言是结构化的,面向对象的语言是模块化的。</strong> <strong>模块化的代码比结构化的代码更易于维护,复用与扩展。</strong></p><h4 id="OracleJdk与OpenJdk的区别"><a href="#OracleJdk与OpenJdk的区别" class="headerlink" title="OracleJdk与OpenJdk的区别"></a>OracleJdk与OpenJdk的区别</h4><p>OpenJdk是基于Sum捐赠的HotSpot的源代码开发的,是开源的。 OracleJdk是Oracle对Jdk的商业化版本,由Oracle发布并维护. 因此OracleJdk比OpenJdk更可靠。</p><h4 id="Java与C-的异同"><a href="#Java与C-的异同" class="headerlink" title="Java与C++的异同"></a>Java与C++的异同</h4><ul><li>Java和C++都是基于面向对象思想的语言。</li><li>Java不提供指针来访问内存。C++允许指针访问内存。</li><li>垃圾回收机制。Java无需开发者手动释放内存,因为Java有垃圾回收机制自动回收内存; C++则需要开发者手动释放内存。因此Java在内存管理上相对C++更安全。</li><li>Java不支持多继承，而C++支持。</li></ul><h4 id="JVM-JDK和JRE的区别"><a href="#JVM-JDK和JRE的区别" class="headerlink" title="JVM,JDK和JRE的区别"></a>JVM,JDK和JRE的区别</h4><ul><li>JVM: JVM(java virtual machine)是java虚拟机</li><li>JRE: JRE(java runtime environment)是java运行时环境</li><li>JDK: JDK(java development kit)是java开发工具包,不仅包含了jre和jvm,还提供了javac编译器和javadoc等其他开发所需的工具</li></ul><h4 id="Java语言的特点"><a href="#Java语言的特点" class="headerlink" title="Java语言的特点"></a>Java语言的特点</h4><ul><li>面向对象</li><li>平台无关性,也就是跨平台(依靠JVM)</li><li>垃圾回收机制(GC)</li><li>支持多线程</li><li>支持便捷的网络编程</li><li>编译与解释(JIT)</li><li>安全(个人认为所有语言写出来的代码的安全性是开发者决定的, 而不是语言本身决定的,语言能决定的只是提供方便或不便的安全的API)</li></ul><h4 id="面向对象的特征"><a href="#面向对象的特征" class="headerlink" title="面向对象的特征"></a>面向对象的特征</h4><p>面向对象三大特征:封装,继承,多态。</p><ul><li>封装: 封装是隐藏对象属性和实现细节,只对外提供可访问或修改的接口的技术。 <strong>封装的目的是为了简化编程和增加程序的安全性,使得使用者无需了解对象的具体实现细节。</strong></li><li>继承: 继承是 在已存在的类上定义新的类的技术。 在Java中,已存在的类被称为基类(父类),新的类叫做派生类(子类).子类拥有父类的所有属性,方法。 但是子类对于父类中私有的方法或属性只是拥有,并不能访问和使用。 <strong>继承的目的主要是为了代码的复用.</strong></li><li>多态: 多态指的是相同类型的对象,调用其相同的方法,参数也相同,但是它的表现形式也就是结果不同。 <strong>多态的目的是为了程序的可扩展性和维护性。</strong> 在Java中可以使用继承与接口2大特性实现多态。</li></ul><h4 id="重载和重写的区别"><a href="#重载和重写的区别" class="headerlink" title="重载和重写的区别"></a>重载和重写的区别</h4><p>个人认为重载和重写完全没有可比性,不知道为啥老有人喜欢拿它们做比较。</p><ul><li>重载: 重载是描述一个类中有多个方法名相同的方法，但是它们的参数,类型,返回值,参数的顺序可能不同，表现形式也就不同。</li><li>重写: 重写是描述子类对父类的某个方法的逻辑进行了重新编写,但重写的只是方法的内容, 方法名,参数,类型,顺序,返回值都是不变的。</li></ul><h4 id="接口与抽象类的区别"><a href="#接口与抽象类的区别" class="headerlink" title="接口与抽象类的区别"></a>接口与抽象类的区别</h4><ul><li>接口需要被实现,而抽象类是需要被继承的。</li><li>接口里的方法都是公共抽象的，而抽象类既允许抽象也允许非抽象的方法(在jdk8中,接口被允许定义default方法,jdk9中还允许定义private私有方法)。</li><li>一个类允许实现多个接口,但只允许继承一个抽象父类。</li><li>接口是对类的规范,规范的是行为能力。而抽象类是对类的抽象,抽象的是逻辑。</li></ul><h4 id="Object类的方法有哪些"><a href="#Object类的方法有哪些" class="headerlink" title="Object类的方法有哪些?"></a>Object类的方法有哪些?</h4><ol><li>getClass</li><li>equals</li><li>hashCode</li><li>toString</li><li>wait</li><li>wait(long): 让当前对象进入TIMED_WATING状态</li><li>wait(long,int):让当前对象进入TIMED_WATING状态</li><li>notify</li><li>nofifyAll</li><li>clone</li><li>finalize</li></ol><h4 id="静态属性方法和成员属性方法区别"><a href="#静态属性方法和成员属性方法区别" class="headerlink" title="静态属性方法和成员属性方法区别"></a>静态属性方法和成员属性方法区别</h4><p><strong>静态属性和方法属于类Class,而成员属性和方法属于实例化的对象。</strong></p><p>静态方法只能使用静态方法和静态属性,不能使用成员属性和方法, 因为静态属性和方法在对象还没被实例化的时候就存在了。</p><p><strong>简单理解就是不允许一个已存在的事物使用一个不存在的事物。</strong></p><h4 id="子类属性与父类属性初始化顺序"><a href="#子类属性与父类属性初始化顺序" class="headerlink" title="子类属性与父类属性初始化顺序"></a>子类属性与父类属性初始化顺序</h4><ol><li>无论如何,静态数据首先加载,所以先初始化父类静态变量和静态初始化块(静态变量和静态初始化块按源码编写的顺序执行， 普通初始化块和普通成员变量也是如此),再初始化子类静态变量和静态初始化块。</li><li>普通初始化块和普通成员变量优先于构造方法,所以接下来加载父类的普通初始化块和普通成员变量,再调用父类构造方法。</li><li>调用子类普通代码块，普通成员变量和构造方法。</li></ol><h4 id="自动拆箱和装箱"><a href="#自动拆箱和装箱" class="headerlink" title="自动拆箱和装箱"></a>自动拆箱和装箱</h4><p>自动拆箱和装箱实际上是Java编译器的一个语法糖。</p><p>自动装箱是指: <strong>将基本数据类型转为对应的包装类对象的过程。</strong></p><p>自动拆箱是指: <strong>将包装类转为对应的基本数据类型。</strong></p><p><strong>自动装箱实际上是调用了包装类对象的valueof方法</strong>,如: Integer.valueof(1)</p><p><strong>自动拆箱实际上是调用了包装类的xxxValue方法</strong>,如: Integer.intValue()</p><p><strong>在自动装箱的时候,如果包装类允许缓存并且值在缓存的范围内,那么装箱生成的对象会被缓存到常量池中。</strong></p><p><strong>Integer,Byte,Short,Long,Character包装类型具有缓存池, 而其他三种:Float,Double,Boolean不具有缓存池。</strong></p><p>包装类的缓存池缓存的范围基本都为: -128 - 127之间， 除了Character的缓存范围为 0 - 127。</p><h4 id="String为什么不可变"><a href="#String为什么不可变" class="headerlink" title="String为什么不可变?"></a>String为什么不可变?</h4><p>先说下我的看法:String是Java中最常使用的类没有之一,如果String是可变的,那么会发生非常多数不清的问题。 如ip地址,人名,邮箱非常多的敏感数据。 如果String是可变的,就会发生安全问题, 且字符串常量池也就无从谈起了。</p><p>String是不可变的,那么它本质上也是线程安全的。 <strong>不可变类的缺点就是每个不同的值需要创建一个对象</strong></p><p><strong>String 是用final修饰的，保证了String类不能被扩展。 String内部的字段是用final修饰的(我的jdk版本是11,String由byte[]实现)， 并且没有对外提供修改字段的方法。这也是为什么String不可变的原理。</strong></p><h4 id="final关键字的作用"><a href="#final关键字的作用" class="headerlink" title="final关键字的作用"></a>final关键字的作用</h4><ul><li>被final修饰的类，不能被继承，并且这个类所有的成员方法都为final，不能被重写。</li><li>被final修饰的属性变量，不能被修改。如果该变量是基本数据类型的，那么其值在初始化后不能被修改。 如果该变量是引用类型的，那么该引用不能再指向其他对象。</li><li>被final修饰的方法不能被子类重写。</li></ul><h4 id="StringBuilder和StringBuffer区别"><a href="#StringBuilder和StringBuffer区别" class="headerlink" title="StringBuilder和StringBuffer区别"></a>StringBuilder和StringBuffer区别</h4><p><strong>StringBuilder和StringBuffer都是可变的字符串,但是StringBuilder是线程不安全的。</strong></p><p>StringBuffer是安全的,因此单线程情况下考虑使用StringBuilder,多线程情况下考虑使用StringBuffer。</p><p><strong>他们之间的关系就好比HashMap和HashTable的关系。</strong></p><h4 id="equals知识点"><a href="#equals知识点" class="headerlink" title="equals知识点"></a>equals知识点</h4><ul><li><p><strong>== 和 equals区别</strong>:</p><ul><li>==比较的是对象的内存地址,equals比较的是对象的值。 因此在Java中比较2个对象的值是否相等使用equals,判断2个对象是否是一个对象,使用==。</li></ul></li><li><p>hashCode方法返回的真是对象内存地址吗? 这个已在对象内存布局部分有讲解，此处就不重复写了。</p></li><li><p>equals方法重写要求</p><ul><li>自反性: x.equals(x) == true 永远成立</li><li>非空性: x.equals(null) == false 永远成立</li><li>对称性: 如果 x.equals(y) == true , 那 y.equals(x)== true  </li><li>传递性: 如果 x.equals(y) == true,并且 y.equals(z) == true,那么一定满足x.equals(z) == true</li><li>一致性: 如果x.equals(y) == true , 那么只要x和y的值不变,那么x.equals(y) == true 永远成立</li></ul></li><li><p>为什么重写equals方法一定要重写hashcode方法?</p><p>在普通环境下(不涉及hash表),equals方法和hashcode方法一毛钱关系没有的, 此时重写equals但不重写hashcode是没有关系的。 但<strong>当使用map,set这些散列表时, 它们会根据对象的hashcode来计算对象在散列表中的位置的。</strong> 试想下,如果2个对象的值相等,但是由于它们是2个对象,hashcode却不相等。 那么即使放入map,set(map)仍会存在重复数据。</p></li></ul><h4 id="深拷贝与浅拷贝"><a href="#深拷贝与浅拷贝" class="headerlink" title="深拷贝与浅拷贝"></a>深拷贝与浅拷贝</h4><p><strong>深拷贝: 拷贝所有的内容,除了基本数据类型的变量复制一份,连引用类型的变量也复制一份。</strong></p><p><strong>浅拷贝: 复制基本数据类型的变量,对于引用类型的变量,直接返回这个引用本身。</strong></p><h4 id="IO流分类"><a href="#IO流分类" class="headerlink" title="IO流分类"></a>IO流分类</h4><ol><li>按照流的流向,分为:输入流和输入流。</li><li>按照操作单元,分为:字节流和字符流。</li></ol><h4 id="使用字节流还是字符流"><a href="#使用字节流还是字符流" class="headerlink" title="使用字节流还是字符流?"></a>使用字节流还是字符流?</h4><p>考虑通用性,应该使用字节流。 如果只是文本文件的操作,可以使用字符流。</p><h4 id="BigDecimal"><a href="#BigDecimal" class="headerlink" title="BigDecimal"></a>BigDecimal</h4><p>BigDecimal是Java中表示大浮点数的类型。</p><p>在Java中,如果遇到浮点数的判断,可以使用BigDecimal来做计算, 因为如果使用普通数据类型很可能会发生精度丢失的情况,这个时候的结果可能会出乎意料之外.</p><h4 id="Java异常体系结构"><a href="#Java异常体系结构" class="headerlink" title="Java异常体系结构"></a>Java异常体系结构</h4><p>在Java中,异常分为 Exception和Error,这2个类都继承自Throwable。</p><ul><li>Exception: Exception异常是程序本身可以处理的。Exception 分为运行时异常(RuntimeException)和 非运行时异常(CheckedException)。<ul><li>RuntimeException: RuntimeException(运行时异常)是在程序运行时可能会发生的异常,如NullPointException, 这类异常往往是不可预料的,编译器也不会要求你手动try catch或throws。</li><li>CheckedException: CheckedException(非运行时异常)是RuntimeException以外的异常,如IOException， 这类异常要求必须显示的try catch或throws ， 如果不处理,那么编译就不会通过。</li></ul></li><li>Error: Error错误是程序无法处理的,表示程序或JVM出现了很严重的，无法解决的问题。</li></ul><h4 id="Comparable和Comparator"><a href="#Comparable和Comparator" class="headerlink" title="Comparable和Comparator"></a>Comparable和Comparator</h4><ul><li>Comparable: 自然排序接口。实现了它的类意味着就支持排序。</li><li>Comparator: 外部比较器。无需让需要排序的对象实现排序逻辑，而是根据Comparator定义的逻辑来排序。 Comparator相较于Comparable更加的灵活。</li></ul><h4 id="什么是泛型-什么是类型擦除"><a href="#什么是泛型-什么是类型擦除" class="headerlink" title="什么是泛型,什么是类型擦除?"></a>什么是泛型,什么是类型擦除?</h4><p>Java泛型(Generics) 是JDK5中引入的一个新特性，泛型提供了编译时类型安全检测机制， 该机制允许程序员在编译时检测到非法的类型。 泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。</p><p>Java中的<strong>泛型</strong>是<strong>伪泛型</strong>，在Java编译期间，所有的泛型信息都会被擦除，这就是通常所说的类型擦除。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; list &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">list.add(12);</span><br><span class="line">&#x2F;&#x2F;这里直接添加会报错</span><br><span class="line">list.add(&quot;a&quot;);</span><br><span class="line">Class&lt;? extends List&gt; clazz &#x3D; list.getClass();</span><br><span class="line">Method add &#x3D; clazz.getDeclaredMethod(&quot;add&quot;, Object.class);</span><br><span class="line">&#x2F;&#x2F;但是通过反射添加，是可以的</span><br><span class="line">add.invoke(list, &quot;kl&quot;);</span><br><span class="line"></span><br><span class="line">System.out.println(list)</span><br></pre></td></tr></table></figure><h4 id="泛型通配符"><a href="#泛型通配符" class="headerlink" title="泛型通配符"></a>泛型通配符</h4><p><strong>常用的 T，E，K，V，?</strong></p><ul><li>？ 表示不确定的 java 类型</li><li>T (type) 表示具体的一个java类型</li><li>K V (key value) 分别代表java键值中的Key Value</li><li>E (element) 代表Element</li></ul><p><strong>? 无界通配符</strong></p><p>一个抽象父类Animal和子类Dog，现在需要一个动物列表，我的第一反应是这样的：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">List&lt;Animal&gt; listAnimals</span><br></pre></td></tr></table></figure><p>但是老板的想法却是这样的：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">List&lt;? extends Animal&gt; listAnimals</span><br></pre></td></tr></table></figure><p>通配符在声明局部变量时是没有什么意义的，但是当你为一个方法设置声明一个参数时，它是非常重要的。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">      List&lt;Dog&gt; dogs &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line"> </span><br><span class="line">      countLegs(dogs);</span><br><span class="line">      &#x2F;*编译器会会报错，显示类型不匹配*&#x2F;</span><br><span class="line">      &#x2F;&#x2F;countLegs1(dogs);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  static int countLegs(List&lt;? extends Animal&gt; animals)&#123;</span><br><span class="line">      int reVal &#x3D; 0;</span><br><span class="line">      for (Animal animal : animals) &#123;</span><br><span class="line">          reVal+&#x3D; animal.getLegs();</span><br><span class="line">      &#125;</span><br><span class="line">      return reVal;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  static int countLegs1(List&lt;Animal&gt; animals)&#123;</span><br><span class="line">      int reVal &#x3D; 0;</span><br><span class="line">      for (Animal animal : animals) &#123;</span><br><span class="line">          reVal+&#x3D; animal.getLegs();</span><br><span class="line">      &#125;</span><br><span class="line">      return reVal;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>所以，对于不确定或者不关心实际要操作的类型，可以使用无限制通配符(****)，表示可以持有任意类型。像countLegs方法，规定了参数传入的上界，但是并不关心具体类型是什么，对于传入的参数，只要是<code>Animal</code>的子类，就都可以支持，而countLegs1方法不行。</p><p>为什么countLegs1方法就不行呢？<code>Dog</code>不是<code>Animal</code>的子类吗，根据多态的角度来讲，理论上应该是可以的，但是，在泛型的继承体系中，<code>Dog</code>并不算<code>Animal</code>的一个子类。</p><p>假设我们有以下代码：</p><p>animals的泛型是父类对象<code>Animal</code>，dogs的泛型是子类对象<code>Dog</code>，那么dogs转换animals能成功吗，我们知道子类对象转父类对象是可以的，但是子类泛型转父类泛型能成功吗，我们假设能成功。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">       List&lt;Animal&gt; animals &#x3D; new ArrayList&lt;Animal&gt;();</span><br><span class="line">       List&lt;Dog&gt; dogs &#x3D; new ArrayList&lt;Dog&gt;();</span><br><span class="line">       </span><br><span class="line">       animals &#x3D; dogs;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>那么animals就指向了一个泛型为<code>Dog</code>的集合容器，但是现在这个集合容器的泛型是<code>Animal</code>，看上去可以将另一个子类<code>Cat</code>加进容器中。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">       List&lt;Animal&gt; animals &#x3D; new ArrayList&lt;Animal&gt;();</span><br><span class="line">       List&lt;Dog&gt; dogs &#x3D; new ArrayList&lt;Dog&gt;();</span><br><span class="line"></span><br><span class="line">       animals &#x3D; dogs;</span><br><span class="line">       animals.add(new Cat(4));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>这段代码看上去好像没什么问题，但是仔细想想。现在animals指向的是一个泛型为Dog的容器，现在又将Cat放进容器中，就相当于在一堆狗里面放进一只猫，这就矛盾了。所以子类泛型<strong>不能</strong>转换为父类泛型，反过来也是一样。</p><h4 id="上界通配符-lt-extend-E-gt"><a href="#上界通配符-lt-extend-E-gt" class="headerlink" title="上界通配符 &lt;? extend E&gt;"></a>上界通配符 &lt;? extend E&gt;</h4><p>上界：用extend关键字指定，表示所指定的类型只能是某个类的子类或者这个类本身</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> static &lt;K extends Comparable,E extends Serializable&gt; K test(K arg1,E arg2)&#123;</span><br><span class="line">        K result &#x3D; arg1;</span><br><span class="line">        arg1.compareTo(arg2);</span><br><span class="line"></span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"> &#x2F;&#x2F; 表示既要实现Comparable接口，又要实现Serializable接口</span><br><span class="line">static &lt;K extends Comparable &amp; Serializable&gt; K test(K arg1) &#123;</span><br><span class="line">        K result &#x3D; arg1;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>有多个限定类型用”&amp;”隔开，有多个类型变量用”,”逗号隔开</p><h4 id="下界通配符-lt-super-E-gt"><a href="#下界通配符-lt-super-E-gt" class="headerlink" title="下界通配符&lt;? super E&gt;"></a>下界通配符&lt;? super E&gt;</h4><p>下界：用super关键字指定，表示所指定的类型只能是这个类本身或者某个类的父类，直至Object</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static &lt;T&gt; void  test1(List&lt;? super  T&gt; dst ,List&lt;T&gt; list)&#123;</span><br><span class="line">        for (T t : list) &#123;</span><br><span class="line">            dst.add(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="和T的区别"><a href="#和T的区别" class="headerlink" title="?和T的区别"></a>?和T的区别</h4><p>? 表示不确定的类型，常用于泛型方法的调用代码和形参，不能用于定义泛型类、泛型方法和泛型变量。</p><p>T 表示一个具体的类型，常用于泛型类和泛型方法的定义，可以定义泛型变量。</p><p><strong>利用T来保证泛型的一致性。</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 通过 T 来 确保 泛型参数的一致性,通常我们需要先声明</span><br><span class="line">public &lt;T extends Number&gt; void</span><br><span class="line">test(List&lt;T&gt; dest, List&lt;T&gt; src)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;通配符是 不确定的，所以这个方法不能保证两个 List 具有相同的元素类型，不需要提前声明</span><br><span class="line">public void</span><br><span class="line">test(List&lt;? extends Number&gt; dest, List&lt;? extends Number&gt; src)</span><br></pre></td></tr></table></figure><p><strong>类型参数可以多重限定而通配符不行。</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static &lt;T extends Comparable &amp; Serializable&gt; T test(T arg1) &#123;</span><br><span class="line">       T result &#x3D; arg1;</span><br><span class="line"></span><br><span class="line">       return result;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><strong>?可以使用下界限定，但T不行。</strong></p><p>类型参数 T 只具有 一种 类型限定方式：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">T extends A</span><br></pre></td></tr></table></figure><p>但是通配符 ? 可以进行 两种限定：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">? extends A</span><br><span class="line">? super A</span><br></pre></td></tr></table></figure><h4 id="为什么要慎用-Arrays-asList"><a href="#为什么要慎用-Arrays-asList" class="headerlink" title="为什么要慎用 Arrays.asList()?"></a>为什么要慎用 Arrays.asList()?</h4><p><strong>因为Arrays.asList这个方法返回的根本就不是我们期盼的ArrayList, 而是Arrays类内部实现的ArrayList,这个内部类只支持访问和set操作, 并不支持remove,add,clear等修改操作。</strong></p><h4 id="Java中引用的类型"><a href="#Java中引用的类型" class="headerlink" title="Java中引用的类型"></a>Java中引用的类型</h4><p>Java中引用类型总共有四种: 强引用，软引用，弱引用，虚引用。</p><ul><li>强引用(Strong Reference): Java程序中绝大部分都是强引用，一般使用new关键字创建的对象就是强引用。 只要强引用存在，强引用的对象就不会被回收，除非不可达(参考jvm部分)</li><li>软引用(Soft Reference): 软引用一般不会被回收，但是当堆内存不够的时候， 比如几乎快要发生OOM的时候，就会回收掉软引用对象。</li><li>弱引用(Weak Reference): 只要垃圾回收开始，就会回收掉弱引用的对象。</li><li>虚引用(Phantom Reference,又称幽灵引用): 和其他几种引用不同，虚引用不决定对象的生命周期， 它在任何时候都可能被回收掉。</li></ul><h2 id="对象在内存中的布局-64位"><a href="#对象在内存中的布局-64位" class="headerlink" title="对象在内存中的布局(64位)"></a>对象在内存中的布局(64位)</h2><p>鉴于此章已经涉及到jvm的内容了，所以各位同学在此章需要对JVM的一些基本术语有所了解。 这里我找到了openjdk官方对于hotspot的一些基本词汇表，各位同学在学习的时候，可以参考这个词汇表: <a href="https://openjdk.java.net/groups/hotspot/docs/HotSpotGlossary.html" target="_blank" rel="noopener">OpendJdk Hotspot Glossary</a></p><p><strong>对象在内存中的布局,在32位和64位操作系统上的实现也是不同的，以我的机器为例(64位)</strong></p><p><strong>对象在内存中由 对象头,实例数据,对齐填充三部分组成。</strong></p><p><strong>其中实例数据和对齐填充是不固定的</strong>。</p><p><img src="file://E:/%E5%B0%9A%E7%A1%85%E8%B0%B7java/JVMzhouyang/framework-learning/img/jdk-jvm-juc/%E5%AF%B9%E8%B1%A1%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E5%B8%83%E5%B1%80.png?lastModify=1596340467" alt="对象内存布局">           </p><h4 id="实例数据"><a href="#实例数据" class="headerlink" title="实例数据"></a>实例数据</h4><p>实例数据存储着对象在程序中被定义的各个字段的数据,也就是对象的字段的 数据。<strong>如果一个类没有字段，也就不存在实例数据，所以这是它不固定的原因。</strong></p><h4 id="对齐填充"><a href="#对齐填充" class="headerlink" title="对齐填充"></a>对齐填充</h4><p><strong>Java对象的大小必须是8字节的倍数</strong>,像13,15这种非8的倍数的对象的大小, 不足或多余的部分就要使用对齐填充数据补齐。 <strong>如果Java对象大小正好是8的倍数,那么就无需对齐填充数据。</strong></p><h3 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h3><p>关于对象头，在hotspot中，opendjdk是这样描述的:</p><p><img src="file://E:/%E5%B0%9A%E7%A1%85%E8%B0%B7java/JVMzhouyang/framework-learning/img/jdk-jvm-juc/%E5%AF%B9%E8%B1%A1%E5%A4%B4%E7%9A%84%E6%8F%8F%E8%BF%B0.png?lastModify=1596340467" alt="对象头描述"></p><p>大意是说: <strong>对象头是jvm在每次GC时管理的对象的通用结构，包含了对象的布局，类型(Class Type),GC状态， 同步状态和hashcode等信息，在数组中，还会跟随数组的长度。java对象和vm对象都具有通用的对象头格式。</strong></p><p>在hotspot虚拟机中的对象头由2部分组成: mark 和 metadata(包括klass* , compressed_klass)(<strong>如果是数组,对象头还会保存数组长度</strong>)(见oop.hpp文件)</p><p><img src="file://E:/%E5%B0%9A%E7%A1%85%E8%B0%B7java/JVMzhouyang/framework-learning/img/jdk-jvm-juc/%E5%AF%B9%E8%B1%A1%E5%A4%B4%E7%9A%84markword%E7%BB%84%E6%88%901.png?lastModify=1596340467" alt="对象头组成1"></p><p>mark/markword就是说面说过的，保存了对象的GC状态，同步状态和hashcode等信息。</p><p>下面是mark/markword的组成(见:markOop.hpp头文件):</p><p><img src="file://E:/%E5%B0%9A%E7%A1%85%E8%B0%B7java/JVMzhouyang/framework-learning/img/jdk-jvm-juc/%E5%AF%B9%E8%B1%A1%E5%A4%B4%E7%9A%84markword%E7%BB%84%E6%88%902.png?lastModify=1596340467" alt="对象头组成2"></p><p>对象处于不同的同步状态和GC状态，markword都不同(见:markOop.hpp头文件):</p><p><img src="file://E:/%E5%B0%9A%E7%A1%85%E8%B0%B7java/JVMzhouyang/framework-learning/img/jdk-jvm-juc/%E5%AF%B9%E8%B1%A1%E5%A4%B4%E7%9A%84markword%E7%BB%84%E6%88%903.png?lastModify=1596340467" alt="对象头组成3"></p><p><img src="file://E:/%E5%B0%9A%E7%A1%85%E8%B0%B7java/JVMzhouyang/framework-learning/img/jdk-jvm-juc/%E5%AF%B9%E8%B1%A1%E5%A4%B4%E7%9A%84markword%E7%BB%84%E6%88%904.png?lastModify=1596340467" alt="对象头组成4"></p><h4 id="markword和metadata"><a href="#markword和metadata" class="headerlink" title="markword和metadata"></a>markword和metadata</h4><p>Mark Word(mark)组成:</p><table><thead><tr><th align="center">锁状态</th><th align="center">锁标志</th><th align="center">markword组成</th></tr></thead><tbody><tr><td align="center">无锁</td><td align="center">01</td><td align="center">由hashcode,分代年龄,是否偏向锁(1位),锁标志位组成</td></tr><tr><td align="center">偏向锁</td><td align="center">01</td><td align="center">由偏向线程的ID,偏向时间戳(epoch),是否偏向锁(1位),分代年龄,锁标志位组成</td></tr><tr><td align="center">轻量级锁</td><td align="center">00</td><td align="center">由指向栈中锁的记录和锁标志位组成</td></tr><tr><td align="center">膨胀锁</td><td align="center">10</td><td align="center">由指向锁的指针和锁标志位组成</td></tr><tr><td align="center">GC</td><td align="center">11</td><td align="center">无数据</td></tr></tbody></table><p>Klass Pointer /  Compressed Klass: <strong>Klass Pointer是指向对象类型的指针，指针指向对象的类元数据。</strong> jvm通过klass pointer判断对象属于哪个类。 在64位的jvm实现中，Klass Pointer的长度为64bit(32位系统, 指针为32bit)，也就意味着,64位系统比32位的系统占用更多内存。</p><p>所以<strong>jvm提供了压缩指针(Compressed Klass)来节省空间，在64位系统下，压缩指针是默认开启的， 可以使用-XX:-UseCompressedOops来关闭指针压缩。</strong>           </p><h4 id="实例数据-1"><a href="#实例数据-1" class="headerlink" title="实例数据"></a>实例数据</h4><p>实例数据存储着对象在程序中被定义的各个字段的数据,也就是对象的字段的 数据。<strong>如果一个类没有字段，也就不存在实例数据，所以这是它不固定的原因。</strong>        </p><h4 id="对齐填充-1"><a href="#对齐填充-1" class="headerlink" title="对齐填充"></a>对齐填充</h4><p><strong>Java对象的小必须是8字节的倍数</strong>,像13,15这种非8的倍数的对象的大小, 不足或多余的部分就要使用对齐填充数据补齐。 <strong>如果Java对象大小正好是8的倍数,那么就无需对齐填充数据。</strong></p><h3 id="jol工具查看对象布局"><a href="#jol工具查看对象布局" class="headerlink" title="jol工具查看对象布局"></a>jol工具查看对象布局</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--可用此工具查看对象内存布局--&gt;</span><br><span class="line"> &lt;dependency&gt;</span><br><span class="line">     &lt;groupId&gt;org.openjdk.jol&lt;&#x2F;groupId&gt;</span><br><span class="line">     &lt;artifactId&gt;jol-core&lt;&#x2F;artifactId&gt;</span><br><span class="line">     &lt;version&gt;0.10&lt;&#x2F;version&gt;</span><br><span class="line"> &lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><p>相信各位同学可能还是对上面的概念有点模糊，那就可以使用jol工具来查看一下 对象的真实布局，在实践之前，请各位同学带着几个问题看下面的内容:</p><ul><li>hashCode方法返回的真是对象内存地址吗?</li><li>hashcode真实存在吗?</li></ul><h4 id="查看对象内存布局"><a href="#查看对象内存布局" class="headerlink" title="查看对象内存布局"></a>查看对象内存布局</h4><p>以下是我自己的一个测试demo，详解了jol的使用:</p><p><img src="file://E:/%E5%B0%9A%E7%A1%85%E8%B0%B7java/JVMzhouyang/framework-learning/img/jdk-jvm-juc/jol%E5%B7%A5%E5%85%B7%E6%9F%A5%E7%9C%8B%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%801.png?lastModify=1596340467" alt="jol工具查看对象内存布局1"></p><p>以上可以看到jol工具很直观的给我们展现了对象的内存布局， 但是在对象的markword之中，我们并没有看到hashcode的值， 难道对象不存在hashcode吗？</p><h4 id="hashcode"><a href="#hashcode" class="headerlink" title="hashcode"></a>hashcode</h4><p>上一个测试在打印对象内存布局之前，我并没有调用对象的hashcode方法， 相信各位同学也注意到了，我把那2行代码注释掉了。</p><p>打开那2行注释再运行看看:</p><p><img src="file://E:/%E5%B0%9A%E7%A1%85%E8%B0%B7java/JVMzhouyang/framework-learning/img/jdk-jvm-juc/jol%E5%B7%A5%E5%85%B7%E6%9F%A5%E7%9C%8B%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%802.png?lastModify=1596340467" alt="jol工具查看对象内存布局2"></p><p>我们发现，在调用hashcode方法后，对象的hashcode的值与打印结果完全一致， 到这里可以初步猜想(没有实际验证):</p><p><strong>hashcode的值也是不固定存在的。</strong></p><p><strong>在没有调用对象的hashcode方法之前，对象不存在hashcode。</strong></p><p><strong>当调用完对象的hashcode之后，jvm就把生成的hashcode值赋予了对象的markword之中。</strong></p><h4 id="对象的hashcode返回的是对象的内存地址吗"><a href="#对象的hashcode返回的是对象的内存地址吗" class="headerlink" title="对象的hashcode返回的是对象的内存地址吗?"></a>对象的hashcode返回的是对象的内存地址吗?</h4><p><strong>在hotspot中，hashcode返回的不完全是地址</strong> (见：hotspot的/src/share/vm/runtime/synchronizer.cpp):</p><p><img src="file://E:/%E5%B0%9A%E7%A1%85%E8%B0%B7java/JVMzhouyang/framework-learning/img/jdk-jvm-juc/hashcode%E6%96%B9%E6%B3%95%E6%BA%90%E7%A0%81.png?lastModify=1596340467" alt="hashcode方法源码"></p><p>可以看到hashcode有:随机数，自增长序列，关联地址等多种生成策略。</p><h2 id="线程并发-JUC-AQS-CAS"><a href="#线程并发-JUC-AQS-CAS" class="headerlink" title="线程并发(JUC,AQS,CAS)"></a>线程并发(JUC,AQS,CAS)</h2><h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><h4 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h4><p><strong>进程与线程最主要的区别是它们是操作系统管理资源的不同方式的体现。</strong> 准确来说进程与线程属于衍生关系。 进程是操作系统执行程序的一次过程,在这个过程中可能会产生多个线程。</p><blockquote><p>比如在使用QQ时，有窗口线程， 文字发送的线程，语音输入的线程，可能不是很恰当，但是就是这个意思。</p></blockquote><p><strong>由于系统在线程之间的切换比在进程之间的切换更高效率，所以线程也被成为轻量级进程。</strong></p><h4 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a>并发和并行</h4><ol><li>并发: 多个线程任务被一个cpu轮流执行。注意，这里并不是只允许一个cpu执行多任务，多个cpu执行也是可以的。 <strong>并发强调的是计算机应用程序有处理多个任务的能力。</strong></li><li>并行:多个线程被多个cpu同时执行。这里也并不是只允许多个cpu处理多任务，一个cpu也是可以的， 只要cpu能在同一时刻处理多任务。<strong>并行强调的是计算机应用程序拥有同时处理多任务的能力。</strong></li></ol><h4 id="多线程的利弊"><a href="#多线程的利弊" class="headerlink" title="多线程的利弊"></a>多线程的利弊</h4><ul><li>利:<ul><li>线程可以比作轻量级的进程，cpu在线程之间的切换比在进程之间的切换，耗费的资源要少的多。</li><li>现在是多核cpu时代，意味着多个线程可以被多个cpu同时运行(并行)，如果可以利用好多线程，那么可以编写出高并发的程序。</li></ul></li><li>弊:<ul><li>虽然线程带来的好处很多，但是并发编程并不容易，如果控制不好线程，那么就可能造成死锁，资源闲置，内存泄露等问题。</li></ul></li></ul><h4 id="什么是上下文切换"><a href="#什么是上下文切换" class="headerlink" title="什么是上下文切换?"></a>什么是上下文切换?</h4><p>cpu是采用时间片的轮转制度，在多个线程之间来回切换运行的。 当cpu切换到另一个线程的时候，它会先保存当前线程执行的状态， 以便在下次切换回来执行时，可以重新加载状态，继续运行。 <strong>从保存线程的状态再到重新加载回线程的状态的这个过程就叫做上下文切换。</strong></p><h4 id="线程的优先级"><a href="#线程的优先级" class="headerlink" title="线程的优先级"></a>线程的优先级</h4><p>在Java中可以通过Thread类的setPriority方法来设置线程的优先级， 虽然可以通过这样的方式来设置线程的优先级，但是线程执行的先后顺序并不依赖与线程的优先级。 换句话说就是，<strong>线程的优先级不保证线程执行的顺序。</strong></p><h4 id="线程的几种状态"><a href="#线程的几种状态" class="headerlink" title="线程的几种状态"></a>线程的几种状态</h4><p>见:jdk Thread类源码中的state枚举类</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NEW,RUNNABLE,BLOCKED,WAITING,TIMED_WAITING,TERMINATED</span><br></pre></td></tr></table></figure><h4 id="sleep方法和wait方法"><a href="#sleep方法和wait方法" class="headerlink" title="sleep方法和wait方法"></a>sleep方法和wait方法</h4><ol><li>sleep方法是Thread类的方法；而wait方法是Object类的方法。</li><li>sleep方法会<strong>使当前线程让出cpu的调度资源</strong>，从而让其他线程有获得被执行的机会， <strong>但是并不会让当前线程释放锁对象。</strong>  而wait方法是<strong>让当前线程释放锁并进入wait状态，</strong>  不参与获取锁的争夺，从而让其他等待资源的线程有机会获取锁， 只有当其他线程调用notify或notifyAll方法是，被wait的线程才能重新与其他线程一起争夺资源。 被wait的线程才能重新与其他线程一起争夺资源。</li></ol><h4 id="stop-suspend-resume等方法为什么会被遗弃"><a href="#stop-suspend-resume等方法为什么会被遗弃" class="headerlink" title="stop,suspend,resume等方法为什么会被遗弃"></a>stop,suspend,resume等方法为什么会被遗弃</h4><ul><li>stop: stop方法被弃用很好理解，因为stop方法是强行终止线程的执行， 不管线程的run方法是否执行完，资源是否释放完，它都会终止线程的运行，并释放锁。 显然，这在设计上就不合理。  </li><li>suspend和resume: suspend方法用于阻塞一个线程,但并不释放锁， 而resume方法的作用只是为了恢复被suspend的线程。 假设A，B线程都争抢同一把锁，A线程成功的获得了锁， 然后被suspend阻塞了，却并没有释放锁，它需要其他线程来唤醒， 但此时B线程需要获得这把锁才能唤醒A，所以此时就陷入了死锁。        </li></ul><h4 id="interrupt-interrupted-isInterrupted方法区别"><a href="#interrupt-interrupted-isInterrupted方法区别" class="headerlink" title="interrupt,interrupted,isInterrupted方法区别"></a>interrupt,interrupted,isInterrupted方法区别</h4><ul><li>interrupt: 这个方法并不是中断当前线程，而是给当前线程设置一个中断状态。</li><li>isInterrupted: 当线程调用interrupt方法后，线程就有了一个中断状态， 而使用isInterrupted方法就可以检测到线程的中断状态。</li><li>interrupted: 这个方法用于清除interrupt方法设置的中断状态。 如果一个线程之前调用了interrupt方法设置了中断状态， 那么interrupted方法就可以清除这个中断状态。           </li></ul><h4 id="join方法"><a href="#join方法" class="headerlink" title="join方法"></a>join方法</h4><p>join方法的作用是让指定线程加入到当前线程中执行。</p><p>假如在main方法里面创建一个线程A执行，并调用A的join方法， 那么当前线程就是main，指定的A线程就会在main之前执行， 等A执行完后，才会继续执行main。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) throws Exception</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    Thread a &#x3D; new Thread(()-&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        try</span><br><span class="line">        &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(1);</span><br><span class="line">            </span><br><span class="line">        &#125;catch (Exception e)&#123;&#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;thread join&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">    a.start();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;a会在main线程之前执行</span><br><span class="line">    a.join();</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;main&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>join方法的底层是wait方法，调用A线程(子线程)的join方法实际上是让main线程wait， 等A线程执行完后，才能继续执行后面的代码。</strong>            </p><h4 id="yield方法"><a href="#yield方法" class="headerlink" title="yield方法"></a>yield方法</h4><p>yield属于Thread的静态方法， 它的作用是让当前线程让出cpu调度资源。</p><p>yield方法其实就和线程的优先级一样，你虽然指定了， 但是最后的结果不由得你说了算， <strong>即使调用了yield方法，最后仍然可能是这个线程先执行， 只不过说别的线程可能先执行的机会稍大一些。</strong></p><h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><h4 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h4><p>synchronized是jdk提供的jvm层面的同步机制。 <strong>它解决的是多线程之间访问共享资源的同步问题,它保证了 在被它修饰的方法或代码块同一时间只有一个线程执行。</strong></p><p>java6之前的synchronized属于重量锁,性能较差, 它是基于操作系统的Mutex Lock互斥量实现的。</p><p><strong>因为java线程是映射到操作系统的线程之上的, 所以暂停或唤醒线程都需要Java程序从用户态转换为内核态,这段转换时间消耗较长。</strong></p><blockquote><p>java6之后jvm团队对synchronized做出了非常大的优化。</p></blockquote><h4 id="synchronized底层原理"><a href="#synchronized底层原理" class="headerlink" title="synchronized底层原理"></a>synchronized底层原理</h4><p>先看我编写的一段测试代码:</p><p><img src="file://E:/%E5%B0%9A%E7%A1%85%E8%B0%B7java/JVMzhouyang/framework-learning/img/jdk-jvm-juc/synchronized%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%861.png?lastModify=1596340467" alt="synchronized底层原理1"></p><p>使用 javap -c 指令反编译 class文件后的 <strong>字节码指令</strong> 如下</p><p><img src="file://E:/%E5%B0%9A%E7%A1%85%E8%B0%B7java/JVMzhouyang/framework-learning/img/jdk-jvm-juc/synchronized%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%862.png?lastModify=1596340467" alt="synchronized底层原理2"></p><blockquote><p>可以清楚的看到,在进入synchronized的时候，底层字节码编译出来的指令为 <strong>monitorenter</strong>,在执行完同步代码块后又有一个<strong>monitorexit</strong>指令.</p></blockquote><p>想了解synchronized究竟是如何实现的,可以直接进入openjdk:src/share/vm/runtime 目录,这个目录存放的是hotspot虚拟机在运行时 所需的代码.</p><blockquote><p>可以直接锁定其中的 objectMonitor.cpp源文件和objectMonitor.hpp头文件. 看到这2个文件，相信各位同学应该就知道，这个就是synchronized锁对象的monitor，它也是 一个对象,不过它是一个c++对象(见:objectMonitor.hpp头文件):</p></blockquote><p><img src="file://E:/%E5%B0%9A%E7%A1%85%E8%B0%B7java/JVMzhouyang/framework-learning/img/jdk-jvm-juc/synchronized%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%863.png?lastModify=1596340467" alt="synchronized底层原理3"> </p><p><strong>其实真正的锁应该是这个monitor cpp对象,synchronized锁的那个java对象起到的只是关联monitor的作用, 只不过我们身在java层面，无法感知到jvm层面monitor的作用，所以才称synchronized的java锁对象为锁。</strong></p><p>以下是monitorenter指令执行过程(见 InterpreterRuntime.cpp):</p><p><img src="file://E:/%E5%B0%9A%E7%A1%85%E8%B0%B7java/JVMzhouyang/framework-learning/img/jdk-jvm-juc/synchronized%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%864.png?lastModify=1596340467" alt="synchronized底层原理4"></p><p>PS:本来想真正弄清楚fast_enter(偏向锁的实现),slow_enter(轻量级锁实现)和inflate(膨胀锁实现) 的,无奈暂时看不太懂cpp源码，但是有的地方是可以根据语义来推断的。</p><p>这里做一个总结吧,这个总结可能不太准确，但大致是这样的: <strong>每次执行monitorenter指令的时候,是将当前synchronized锁对象 关联的</strong>monitor<strong>的_recursions加1, 执行monitorexit指令的时候,将当前object对象关联的</strong>monitor<strong>的*recursions减1, 当*recursions为0的时候，就说明线程不再持有锁对象。</strong></p><p><strong>如果熟悉AQS原理的同学就知道在AQS内部， 有一个被volatile修饰state变量， 这个state变量就是AQS的核心， state变量的作用类比到此处就是monitor计数器的作用。</strong></p><h4 id="synchronized-使用方法"><a href="#synchronized-使用方法" class="headerlink" title="synchronized 使用方法"></a>synchronized 使用方法</h4><ol><li>修饰静态方法: 修饰静态方法是给类加锁,会作用于所有对象,因为静态方法属于类, 而不属于对象,不管有多少个对象,static方法都是共享的。</li><li>修饰实例方法: 修饰实例方法是给对象加锁,会作用于当前类的实例对象。</li><li>修饰代码块: 修饰代码块,根据代码块给定的对象加锁,线程想要进入代码块,只能获取指定的对象的锁。</li></ol><h4 id="Synchronized和ReentrantLock的区别"><a href="#Synchronized和ReentrantLock的区别" class="headerlink" title="Synchronized和ReentrantLock的区别"></a>Synchronized和ReentrantLock的区别</h4><ul><li>Synchronized是基于JVM层面的同步机制;而ReentrantLock是基于Java API层面提供的同步机制。</li><li>Synchronized和Reentrantlock都属于可重入锁。</li><li>ReentrantLock提供了比Synchronized更高级的功能:<ul><li>公平锁</li><li>更方便的线程间的通信(Condition)</li><li>等待可中断(在线程等待获取锁的时候可以被中断) </li></ul></li></ul><h4 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h4><p>乐观锁对共享的数据很乐观，认为不会发生线程安全的问题，从而不给数据加锁。 乐观锁适用于读多写少的环境。常见的例子就是mysql的更新使用version控制。</p><p><strong>CAS属于乐观锁。</strong></p><h4 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h4><p>悲观锁对共享的数据很悲观，认为无论什么时候都有可能发生线程安全的问题， 所以在每次读写数据的时候都会加锁。</p><p><strong>Synchronized属于悲观锁。</strong></p><h4 id="独占锁"><a href="#独占锁" class="headerlink" title="独占锁"></a>独占锁</h4><p>锁一次只能被一个线程占有使用。</p><p>Synchronized和ReetrantLock都是独占锁。    </p><h4 id="共享锁"><a href="#共享锁" class="headerlink" title="共享锁"></a>共享锁</h4><p>锁可以被多个线程持有。</p><p>对于ReentrantReadWriteLock而言,它的读锁是共享锁,写锁是独占锁。</p><h4 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h4><p>公平锁指根据线程在队列中的优先级获取锁,比如线程优先加入阻塞队列,那么线程就优先获取锁。</p><h4 id="非公平锁"><a href="#非公平锁" class="headerlink" title="非公平锁"></a>非公平锁</h4><p>非公平锁指在获取锁的时候,每个线程都会去争抢,并且都有机会获取到锁,无关线程的优先级。</p><h4 id="可重入锁-递归锁"><a href="#可重入锁-递归锁" class="headerlink" title="可重入锁(递归锁)"></a>可重入锁(递归锁)</h4><p>一个线程获取到锁后,如果继续遇到被相同锁修饰的资源,那么可以继续获取该锁。</p><p>Synchronized和Reentrantlock都是可重入锁。</p><h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><p>在线程获取偏向锁的时候, jvm会判断锁对象MarkWord里偏向线程的ID是否为当前线程ID。</p><p>如果是,则说明当前锁对象处于偏向状态。</p><p>如果不是,则jvm尝试CAS把对象的MarkWord的偏向线程ID设置为当前线程ID,</p><p>如果设置成功,那么对象偏向当前线程，并将当对象的锁标志位改为01。</p><p>如果设置失败，则说明多线程竞争，将撤销偏向锁，升级为轻量级锁。</p><p><strong>偏向锁适用于单线程无锁竞争环境(单线程环境)。</strong></p><p>hotspot偏向锁实现(faster_enter): <img src="file://E:/%E5%B0%9A%E7%A1%85%E8%B0%B7java/JVMzhouyang/framework-learning/img/jdk-jvm-juc/%E5%81%8F%E5%90%91%E9%94%81%E5%AE%9E%E7%8E%B0.png?lastModify=1596340467" alt="偏向锁实现"></p><h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h4><p>在线程获取对象锁时，jvm首先会判断对象是否为无锁状态(无锁状态标志位为01)。</p><p>如果对象是无锁状态，那么将在线程的栈帧中开辟一块空间用于存储对象的MarkWord， 然后将对象的MarkWord复制到栈帧空间去，并使用CAS更新对象的MarkWord为指向 线程栈帧的指针。</p><p>如果更新成功，那么当前线程获取锁成功，并修改对象的MarkWord标志位 为 00 。</p><p>如果更新失败，那么jvm会判断对象的MarkWord是否已经指向线程的栈帧。</p><p>如果已经指向，那么线程直接执行同步代码。否则，说明多个线程竞争，将inflate为重量级锁。</p><p><strong>轻量级锁适用于多线程无锁竞争环境(多线程轮流执行,并不会发生冲突)。</strong></p><p>hotspot轻量级锁实现(slow_enter): <img src="file://E:/%E5%B0%9A%E7%A1%85%E8%B0%B7java/JVMzhouyang/framework-learning/img/jdk-jvm-juc/%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%E5%AE%9E%E7%8E%B0.png?lastModify=1596340467" alt="轻量级锁实现">   </p><h4 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h4><p>在争夺锁的过程中，线程不会停止获取锁，而是通过CAS不断的判断线程是否符合获取锁的条件。</p><p><strong>AQS获取锁的核心就是CAS。</strong></p><h4 id="自适应自旋锁"><a href="#自适应自旋锁" class="headerlink" title="自适应自旋锁"></a>自适应自旋锁</h4><p>自旋锁意味着线程会不断的消耗cpu资源，短时间还行，长时间就意味着而资源的浪费。 所以自适应自旋锁会有一个自旋的生命周期,过了这个生命周期,线程将不再自旋。</p><p>网上有文章说这个生命周期依据前一个线程的自旋时间来决定，但是我暂且没有找到相关资料，不敢妄自揣测。</p><h4 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h4><p><strong>锁消除属于Java编译器对程序的一种优化机制。</strong> 锁消除是指当JVM的JIT编译器检测出一些已经加锁的代码不可能出现共享的数据存在竞争的问题， 会消除这样的锁。<strong>锁消除的依据来源于逃逸分析算法。</strong> 如果判断到一段代码，在堆上的数据不会逃逸出去被其他线程访问到， 那么就把它们当做栈上的数据，为线程私有的，自然无需同步加锁。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;每次线程进入此方法，创建的都是不同的StringBuffer临时对象,</span><br><span class="line">&#x2F;&#x2F;也就是说 StringBuffer 临时对象不会逃出方法t,作用于外部,</span><br><span class="line">&#x2F;&#x2F;所以根本不存在线程之间的竞争，那么JIT在编译时就会消除append方法的锁</span><br><span class="line">public String t(String s1, String s2,String s3)</span><br><span class="line">&#123;</span><br><span class="line">    return new StringBuffer().append(s1).append(s2)</span><br><span class="line">                .append(s3).toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h4><p>当虚拟机检测出一系列连续的操作都对同一个连续加锁， 那么它会把加锁的返回扩大至整个操作的序列的外部，保证只加锁一次。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public String t()</span><br><span class="line">&#123; </span><br><span class="line">    StringBuffer stringBuffer &#x3D; new StringBuffer();</span><br><span class="line">    for (int i &#x3D; 0 ; i &lt; 100 ; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F;append方法执行一百次,难道加100次锁?</span><br><span class="line">       stringBuffer.append(i);</span><br><span class="line">    &#125;</span><br><span class="line">    return stringBuffer.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;t方法经过优化后可能如下:</span><br><span class="line">public String t()</span><br><span class="line">&#123; </span><br><span class="line">    StringBuffer stringBuffer &#x3D; new StringBuffer();</span><br><span class="line">    &#x2F;&#x2F;把synchronized方法提升到for循环面，这样就避免了每次</span><br><span class="line">    &#x2F;&#x2F;append方法的同步</span><br><span class="line">    synchronized (stringBuffer)</span><br><span class="line">    &#123;</span><br><span class="line">       for (int i &#x3D; 0 ; i &lt; 100 ; ++i)</span><br><span class="line">       &#123;</span><br><span class="line">           stringBuffer.append(i);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return stringBuffer.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p><strong>死锁是指多个进程在执行过程中,循环等待彼此占有的资源而导致程序的无限期的阻塞的情况。</strong></p><p>产生死锁的条件:</p><ol><li>互斥条件: 一个资源在一段时间内只能被一个进程所持有。</li><li>不可抢占条件: 进程所持有的资源只能由进程自己主动释放,其他资源的申请者不能向进程持有者抢夺资源。</li><li>占有且申请条件: 进程已经持有一个资源后,又申请其他资源,但是其他资源已被其他线程所占有。</li><li>循环等待条件: 在条件3之上,进程1有进程2需要申请的资源,进程2有进程1需要申请的资源。那么这2个线程 不停等待彼此持有的资源,又不能释放已拥有的资源,陷入循环等待。</li></ol><p>死锁:</p><p><img src="file://E:/%E5%B0%9A%E7%A1%85%E8%B0%B7java/JVMzhouyang/framework-learning/img/jdk-jvm-juc/%E6%AD%BB%E9%94%81.png?lastModify=1596340467" alt="死锁"></p><h4 id="如何避免死锁"><a href="#如何避免死锁" class="headerlink" title="如何避免死锁?"></a>如何避免死锁?</h4><p>只要打破死锁产生的4个条件之一就行,但是真正能够被打破的条件只有第3和第4个条件。 因为第1和第2个条件都是锁的必要条件。</p><p>所以有如下解决死锁的方案:</p><ul><li><p>可以打破第3个条件: <strong>实现资源的有序分配。</strong> </p></li><li><p>可以打破第4个条件: <strong>设置等待超时时间。</strong></p><p>​    </p></li></ul><h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><p>volatile是JVM提供的轻量级的线程同步机制。它可以保证内存的可见性，禁止指令重排序。 但是volatile，并不能保证数据的原子性，所以它不合适作为线程同步的工具。</p><h4 id="volatile保证内存的可见性"><a href="#volatile保证内存的可见性" class="headerlink" title="volatile保证内存的可见性"></a>volatile保证内存的可见性</h4><p>可见性是指一个线程的对于共享数据的修改对其他线程是可见的。 jvm的内存模型是: <strong>线程总是从主内存读取变量到工作内存，然后在工作内存中进行修改， 在修改完变量后，才把变量同步到主内存中。</strong> 如果多个线程同时读取了一个变量到各自的内存中，其中一个线程对变量进行了修改，并同步回了主内存， 但其它线程仍然使用的是原来的旧值，这就造成了数据的不一致。</p><p><img src="file://E:/%E5%B0%9A%E7%A1%85%E8%B0%B7java/JVMzhouyang/framework-learning/img/jdk-jvm-juc/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.png?lastModify=1596340467" alt="Java内存模型"></p><p>解决这个问题的办法就是给变量加上volatile关键字修饰。 volatile使得被它修饰的变量在被线程修改后，那么线程就需要把修改后的变量重新同步到主内存， 且其他线程每次使用这个变量，都需要从主内存读取。</p><h4 id="volatile禁止指令重排序"><a href="#volatile禁止指令重排序" class="headerlink" title="volatile禁止指令重排序"></a>volatile禁止指令重排序</h4><p>指令重排序是编译器和cpu为了程序的高效运行的一种优化手段, <strong>指令重排序只能保证程序执行的结果是正确的，但是无法保证程序指令运行的顺序是否与代码的顺序一致, volatile就禁止了这种重排序。</strong></p><p>比如: </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. int a &#x3D; 1;</span><br><span class="line">2. int b &#x3D; 3;</span><br><span class="line">3. int c &#x3D; a + b;</span><br></pre></td></tr></table></figure><p>上面的代码在编译后,指令执行的顺序可能有: 1,2,3和2,1,3 这样程序实际执行的顺序可能与代码的顺序不符,但并不会影响程序最终的结果。</p><h4 id="volatile如何禁止指令重排序的"><a href="#volatile如何禁止指令重排序的" class="headerlink" title="volatile如何禁止指令重排序的?"></a>volatile如何禁止指令重排序的?</h4><p><strong>volatile通过提供内存屏障来防止指令重排序。 java内存模型会在每个volatile写操作前后都会插入store指令，将工作内存中的变量同步回主内存。 在每个volatile读操作前后都会插入load指令，从主内存中读取变量。</strong></p><h4 id="volatile不保证原子性"><a href="#volatile不保证原子性" class="headerlink" title="volatile不保证原子性"></a>volatile不保证原子性</h4><blockquote><p>比如: i++</p></blockquote><p>如果是多线程环境下，一个线程读取到i的值到工作内存，然后对i做出自增操作， 然后写回主内存，其它内存才知道i的值被修改了，这个过程本身就不是原子的。 所以不能拿volatile来带替synchronized,如果是多线程环境，仍然需要使用synchronized保证线程同步。</p><h3 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h3><p>CAS: Compare And Swap 比较成功并交换。 CAS体现的是一种乐观锁的机制。 <strong>CAS涉及到3个元素: 指定的内存地址,期盼值和目标值。</strong> 将指定内存地址的值与期盼值相比较，如果比较成功就将内存地址的值修改为目标值。</p><h4 id="CAS在JAVA中的底层实现-Atomic原子类实现"><a href="#CAS在JAVA中的底层实现-Atomic原子类实现" class="headerlink" title="CAS在JAVA中的底层实现(Atomic原子类实现)"></a>CAS在JAVA中的底层实现(Atomic原子类实现)</h4><p>CAS在Java中的实现是 juc的atomic包下的Atomicxx原子类。</p><p>而这些Atomic原子类的核心是: <Unsafe>类 Unsafe类是个final类，它的核心方法都是native的， 因为Java无法像C/C++一样使用指针来操作内存, Unsafe类就解决了这个问题。</p><blockquote><p>拿incrementAndGet方法来说， Unsafe首先调用getAndAddInt方法, 它会根据当前Atomic的value在内存中的地址，获取到当前对象的值, 然后再重复此操作，把之前获得的值与第二次获得的值进行比较， 如果成功，就把内存地址的值更新为新值，否则就do while循环重复比较。</p></blockquote><p><strong>并且有个重要的细节就是,Atomic原子类内部的value值都是由volatile修饰的, 这就使得Atomic的value值是对其他线程可见的。</strong></p><h4 id="CAS的缺点"><a href="#CAS的缺点" class="headerlink" title="CAS的缺点"></a>CAS的缺点</h4><ul><li>循环时间开销大: 我在看源码的时候，发现Atomic的CAS操作并没有进行CAS失败的退出处理， 只是单纯的循环比较并交换，这就让我很担心它的性能问题， 如果长时间不成功，那会是很可怕的一件事请，至少cpu的负荷会很大。</li><li>只能保证一个共享变量的原子操作: Atomic原子类只能保证一个变量的原子操作， 如果是多数据的话，还是考虑用互斥锁来实现数据的同步吧</li><li>ABA问题: ABA问题是指如果一个线程进行CAS操作并成功了，却不代表这个过程就是没有问题的。</li></ul><blockquote><blockquote><p>假设2个线程读取了同一份数据，线程1修改了这个值并把它改回了原值，并同步到主内存中， 另一个线程准备进行CAS操作,当它发现原值和期盼的值是一样的，那么CAS仍然成功。</p></blockquote></blockquote><h4 id="解决ABA问题"><a href="#解决ABA问题" class="headerlink" title="解决ABA问题"></a>解决ABA问题</h4><p>在juc的atomic包中提供了 AtomicStampedReference 类, 这个类较普通的原子类新增了一个stamp字段，它的作用相当于version。 每次修改这个引用的值，也都会修改stamp的值， 当发现stamp的值与期盼的stamp不一样，也会修改失败. 这就类似于以version实现乐观锁一样。                      </p><h4 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h4><p>ThreadLocal为每个线程都提供了一份相同的变量的副本， 每个线程都可以修改这个副本，但不用担心与其他线程发生数据冲突， 实现了线程之间的数据隔离。</p><p>ThreadLocal的原理还得从Thread线程类说起， <strong>每个Thread类内部都有一个ThreadLocalMap，当使用ThreadLocal的get和remove操作的时候， 就是使用每个线程的ThreadLocalMap的get和remove。</strong></p><h4 id="ThreadLocal引发的内存泄露"><a href="#ThreadLocal引发的内存泄露" class="headerlink" title="ThreadLocal引发的内存泄露"></a>ThreadLocal引发的内存泄露</h4><p><strong>在ThreadLocalMap中，key是使用弱引用的ThreadLocal存储的。</strong> 弱引用是只要垃圾回收器开始回收，无论内存是否充足，都会回收掉弱引用对象，如此一来， 当ThreadLocal被回收掉,那么ThreadLocalMap将可能出现Null Key 的 value。但是也不必太过担心， 因为设计者已经想到了这点，所以ThreadLocal会自动处理key 为 null的 value。</p><h4 id="线程池的好处"><a href="#线程池的好处" class="headerlink" title="线程池的好处"></a>线程池的好处</h4><blockquote><p>http连接池，数据库连接池，线程池等都是利用了池化技术。 如果一个资源需要多次使用并且很昂贵，那么使用new创建的对象或资源，可能会带来较大的消耗。</p></blockquote><p>池化技术的好处在于</p><ol><li>方便资源的管理，无需显示的使用new创建。</li><li>降低了资源的消耗，在池子里的资源可以重复利用</li><li>提供了任务的响应速度，任务可以很快的被分配资源进行处理。</li></ol><h4 id="线程池构造参数"><a href="#线程池构造参数" class="headerlink" title="线程池构造参数"></a>线程池构造参数</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> new ThreadPoolExecutor</span><br><span class="line">(int corePoolSize,</span><br><span class="line"></span><br><span class="line"> int maximumPoolSize, </span><br><span class="line"></span><br><span class="line"> long keepAliveTime,</span><br><span class="line"></span><br><span class="line"> TimeUnit unit,</span><br><span class="line"></span><br><span class="line"> BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="line"></span><br><span class="line"> ThreadFactory threadFactory,</span><br><span class="line"></span><br><span class="line"> RejectedExecutionHandler handler)</span><br></pre></td></tr></table></figure><ol><li>corePoolSize: 线程池的核心线程数(常驻线程数),也就是线程池的最小线程数,这部分线程不会被回收.</li><li>maximumPoolSize: 线程池最大线程数,线程池中允许同时执行的最大线程数量</li><li>keepAliveTime: 当线程池中的线程数量超过corePoolSize，但此时没有任务执行， 那么空闲的线程会保持keepAliveTime才会被回收，corePoolSize的线程不会被回收。</li><li>unit: KeepAliveTime的时间单位</li><li>workQueue: 当线程池中的线程达到了corePoolSize的线程数量， 并仍然有新任务，那么新任务就会被放入workQueue。          </li><li>threadFactory: 创建工作线程的工厂,也就是如何创建线程的,一般采用默认的</li><li>handler: 拒绝策略，当线程池中的工作线程达到了最大数量， 并且阻塞队列也已经满了，那么拒绝策略会决定如何处理新的任务。ThreadPoolExecutor 提供了四种策略:<ul><li>AbortPolicy(是线程池的默认拒绝策略): 如果使用此拒绝策略，那么将对新的任务抛出RejectedExecutionException异常，来拒绝任务。</li><li>DiscardPolicy: 如果使用此策略，那么会拒绝执行新的任务，但不会抛出异常。</li><li>DiscardOldestPolicy: 如果使用此策略，那么不会拒绝新的任务，但会抛弃阻塞队列中等待最久的那个线程。     </li><li>CallerRunsPolicy: 如果使用此策略，不会拒绝新的任务，但会让调用者执行线程。 也就是说哪个线程发出的任务，哪个线程执行。</li></ul></li></ol><h4 id="阿里巴巴开发者手册不建议开发者使用Executors创建线程池"><a href="#阿里巴巴开发者手册不建议开发者使用Executors创建线程池" class="headerlink" title="阿里巴巴开发者手册不建议开发者使用Executors创建线程池"></a>阿里巴巴开发者手册不建议开发者使用Executors创建线程池</h4><p><strong>newFixedThreadPool和newSingleThreadPoolExecutor都是创建固定线程的线程池, 尽管它们的线程数是固定的，但是它们的阻塞队列的长度却是Integer.MAX_VALUE的,所以， 队列的任务很可能过多，导致OOM。</strong></p><p><strong>newCacheThreadPool和newScheduledThreadPool创建出来的线程池的线程数量却是Integer.MAX_VALUE的， 如果任务数量过多,也很可能发生OOM。</strong></p><h3 id="AQS-AbstractQueuedSynchronizer"><a href="#AQS-AbstractQueuedSynchronizer" class="headerlink" title="AQS(AbstractQueuedSynchronizer)"></a>AQS(AbstractQueuedSynchronizer)</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AQS是Doug Lea大师为JDK编写的一套基于API层面的抽象队列同步器.</span><br><span class="line">AbstractQueuedSynchronizer,抽象队列同步器.</span><br><span class="line">Lock,CountDownLatch等等这些并发工具都是基于AQS来实现的。</span><br><span class="line">由此可以看出Doug Lea大师的功力已经臻至化境</span><br></pre></td></tr></table></figure><h4 id="AQS概述"><a href="#AQS概述" class="headerlink" title="AQS概述"></a>AQS概述</h4><p><strong>AQS的核心思想是如果被请求的资源空闲，那么就将当前请求资源的线程设置为有效的工作线程; 如果请求的资源被其他线程所占有， 那么就使用CLH线程阻塞队列来提供阻塞线程并唤线程分配资源的机制。 在CLH队列中，每个请求资源的线程都会被封装成队列中的一个节点。</strong></p><p><strong>在AQS内部有一个int类型的state表示线程同步状态， 当线程lock获取到锁后，该state计数就加1,unlock就减1， 这就是为什么解锁次数要对应加锁次数的原因。</strong></p><p><strong>AQS主要实现技术为:CLH队列(Craig,Landin and Hagersten)， 自旋CAS，park(阻塞线程)以及unparkSuccessor(唤醒阻塞队列中的后继线程)。</strong>     </p><h4 id="AQS的两种共享资源的访问方式"><a href="#AQS的两种共享资源的访问方式" class="headerlink" title="AQS的两种共享资源的访问方式"></a>AQS的两种共享资源的访问方式</h4><blockquote><p>AQS定义了两种共享资源方式.</p></blockquote><ol><li>独占式(Exclusive): <strong>同一时间只有一个线程可以访问共享资源,也就是独占锁。</strong> 如:Synchronized,ReentrantLock。 <strong>对于独占式锁的实现,在AQS中对应tryAcquire获取锁和tryRelease释放锁。</strong>       </li></ol><ul><li>共享式(Share): <strong>同一时间允许多个线程同时访问共享资源,也就是共享锁。</strong> CountDownLatch,Semaphore,ReentrantReadWriteLock的ReadLock都是共享锁。 <strong>对于共享式锁的实现,在AQS中对应tryAcquireShare获取锁和tryReleaseShare释放锁。</strong></li></ul><h4 id="lock-tryLock和lockInterruptibly区别"><a href="#lock-tryLock和lockInterruptibly区别" class="headerlink" title="lock,tryLock和lockInterruptibly区别"></a>lock,tryLock和lockInterruptibly区别</h4><p><strong>PS: AQS中的锁计数指的是 state 变量。</strong></p><ul><li>lock: 如果线程获取到了锁或线程已经拥有了锁就更改锁计数， 否则线程就加入阻塞队列并一直CAS自旋获取。</li><li>tryLock: 线程尝试获取锁，如果线程获取到了锁或线程已经拥有了锁就更改锁计数，否则返回false。</li><li>lockInterruptibly: 如果线程在获取锁之前被设置了中断状态，那么当线程获取锁时就会响应中断状态， 抛出InterruptedException异常。如果获取不到就加入阻塞队列并自旋获取，并且阻塞自旋期间还会响应中断， 也就是说在阻塞自旋期间可能抛出InterruptedException异常。 <strong>所以lockInterruptibly优先响应中断，而不是优先获取锁。</strong>  如果线程获取到了锁或线程已经拥有了锁才更改锁计数。</li></ul><h4 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h4><blockquote><p>CountDownLatch允许count个线程阻塞在一个地方，直至所有线程的任务都执行完毕。</p></blockquote><p>CountDownLatch是共享锁的一种实现,<strong>它默认构造AQS的state为count。 当线程使用countDown方法时,其实使用了tryReleaseShared方法以CAS的操作来减少state, 直至state为0就代表所有的线程都调用了countDown方法。</strong> 假如某线程A调用await方法时，如果state不为0，就代表还有线程未执行countDown方法， 那么就把线程A放入阻塞队列Park，并自旋CAS判断state == 0。 直至最后一个线程调用了countDown，使得state == 0， 于是阻塞的线程判断成功，并被唤醒，就继续往下执行。</p><h4 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h4><blockquote><p>Semaphore允许一次性最多(不是同时)permits个线程执行任务。</p></blockquote><p>Semaphore与CountDownLatch一样，也是共享锁的一种实现。 <strong>它默认构造AQS的state为permits。 当执行任务的线程数量超出permits,那么多余的线程将会被放入阻塞队列Park,并自旋判断state是否大于0。 只有当state大于0的时候，阻塞的线程才有机会继续执行,此时先前执行任务的线程继续执行release方法， release方法使得state的变量会加1，那么自旋的线程便会判断成功。</strong></p><p>如此，<strong>每次只有不超过permits个的线程能自旋成功，便限制了执行任务线程的数量。</strong> 所以这也是我为什么说它可能不是permits个线程同时执行， 因为只要state&gt;0,线程就有机会执行.</p><h4 id="CycliBarrier"><a href="#CycliBarrier" class="headerlink" title="CycliBarrier"></a>CycliBarrier</h4><p>CycliBarrier的功能与CountDownLatch相似，但是<strong>CountDownLatch的实现是基于AQS的， 而CycliBarrier是基于ReentrantLock(ReentrantLock也属于AQS同步器)和Condition的。</strong></p><p>CountDownLatch虽然可以令多个线程阻塞在同一代码处，但只能await一次就不能使用了。 而CycliBarrier有Generation代的概念，一个代，就代表CycliBarrier的一个循环， 这也是CycliBarrier支持重复await的原因。 </p><h4 id="ReentrantReadWriteLock如何区分读写锁的"><a href="#ReentrantReadWriteLock如何区分读写锁的" class="headerlink" title="ReentrantReadWriteLock如何区分读写锁的?"></a>ReentrantReadWriteLock如何区分读写锁的?</h4><p><strong>Sync既有写锁，又有读锁，因此一个state不够用， 所以使用state的高16位表示读锁，低16位表示写锁.</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> ReentrantReadWriteLock部分源码:</span><br><span class="line"></span><br><span class="line"> static final int SHARED_SHIFT   &#x3D; 16;</span><br><span class="line"> static final int SHARED_UNIT    &#x3D; (1 &lt;&lt; SHARED_SHIFT);</span><br><span class="line"> static final int MAX_COUNT      &#x3D; (1 &lt;&lt; SHARED_SHIFT) - 1;</span><br><span class="line"> static final int EXCLUSIVE_MASK &#x3D; (1 &lt;&lt; SHARED_SHIFT) - 1;</span><br><span class="line"></span><br><span class="line"> &#x2F;** Returns the number of shared holds represented in count. *&#x2F;</span><br><span class="line"> static int sharedCount(int c)    &#123; return c &gt;&gt;&gt; SHARED_SHIFT; &#125;</span><br><span class="line"> &#x2F;** Returns the number of exclusive holds represented in count. *&#x2F;</span><br><span class="line"> static int exclusiveCount(int c) &#123; return c &amp; EXCLUSIVE_MASK; &#125;</span><br><span class="line">剩下的就读源码吧。</span><br></pre></td></tr></table></figure><p>其实吧，在我读了几遍源码后,才发现jdk的源码不算特别难阅读。</p><p>但是像我在读SpringBoot的源码时，我就只能分析个大概。</p><p>主要是Jdk的源码之间并没有什么耦合性，你看一个jdk的类，不像Spring的源码那样绕来绕去， 各种设计模式搞得你头晕。 所以我建议阅读源码可以从jdk的源码开始，前提是你需要一定的基础才能看得懂。 比如我这个版本(11)就发现AQS的部分源码与之前版本的源码不同。 这个版本的AQS使用了: VarHandle 这个类来设置Node类内部的属性， 而之前都是直接使用构造方法来构造Node的。 并且AQS使用的是LockSupport来阻塞线程的，LockSupport仍然使用的是Unsafe类来进行操作的, 这些都属于java与c/c++交互的类,所以你如果没有基础，会诧异,jdk还有这种东西呀 ^-^…            </p><h2 id="Java集合"><a href="#Java集合" class="headerlink" title="Java集合"></a>Java集合</h2><h4 id="HashMap的特点"><a href="#HashMap的特点" class="headerlink" title="HashMap的特点"></a>HashMap的特点</h4><ul><li>HashMap在Jdk8之前使用拉链法实现,jdk8之后使用拉链法+红黑树实现。</li><li>HashMap是线程不安全的,并允许null key 和 null value。**</li><li>HashMap在我当前的jdk版本(11)的默认容量为0,在第一次添加元素的时候才初始化容量为 16, 之后才扩容为原来的2倍。</li><li>HashMap的扩容是根据 threshold决定的 : threshold = loadFactor * capacity。  当 size 大于 threshold 时,扩容。</li><li><strong>当每个桶的元素数量达到默认的阈值TREEIFY_THRESHOLD(8)时，HashMap会判断当前数组的 长度是否大于MIN_TREEIFY_CAPACITY(64),如果大于，那么这个桶的链表将会转为红黑树，否则HashMap将会扩容。 当红黑树节点的数量小于等于默认的阈值UNTREEIFY_THRESHOLD(6)时，那么在扩容的时候，这个桶的红黑树将转为链表。</strong></li></ul><h4 id="HashMap的长度-容量-为什么要设计成2的幂？"><a href="#HashMap的长度-容量-为什么要设计成2的幂？" class="headerlink" title="HashMap的长度(容量)为什么要设计成2的幂？"></a>HashMap的长度(容量)为什么要设计成2的幂？</h4><blockquote><p>这就不得不佩服大师们的设计。</p></blockquote><p>想想看，一个对象的hashcode是很大的，当HashMap的容量仅为16,32时， 如何根据hashcode来确定key在数组中的下标。 一个好的办法就是取余: hashcode % length。 这样就能确保，key的下标是永远不会超过数组的长度的。 但是想想，除了取余有没有更好的办法，</p><p>当然有:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hash % length &#x3D;&#x3D; hash &amp; (length - 1)</span><br></pre></td></tr></table></figure><p>为什么上面这个性能超高的等式成立，当然是有条件的，</p><p><strong>只有当length为2的幂的时候这样的等式才成立,</strong> 这就明白了为什么使用2的幂来定义HashMap的长度。</p><h4 id="HashTable的特点"><a href="#HashTable的特点" class="headerlink" title="HashTable的特点"></a>HashTable的特点</h4><ul><li>HashTable底层使用拉链法实现。</li><li>HashTable就像Vector一样,也是jdk1就存在的很古老的一个类，它是线程安全的， 实现线程安全的手段是使用synchronized。</li><li>HashTable的默认容量为16，每次扩容为原来的2倍+1。</li><li>HashTable不允许null key 和 null value。</li></ul><h4 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h4><p><strong>TreeMap使用红黑树实现,不允许null key,允许自然排序Comparable和比较器Comparator排序。</strong></p><h4 id="ArrayList的特点"><a href="#ArrayList的特点" class="headerlink" title="ArrayList的特点"></a>ArrayList的特点</h4><ul><li>ArrayList底层使用Object数组实现。</li><li>ArrayList的容量默认为0,只有在第一次执行add操作时才会初始化容量为10，正常的扩容是为原来的1/2倍。</li><li>由于ArrayList采用数组实现,它的容量是固定的,所以当添加新元素的时候,如果超出了数组的容量, 那么此时add操作的时间复杂度将会是O(n-1)。</li><li>ArrayList实现了RandomAccess接口，该接口没有具体的规范，只是一个标记， 这代表ArrayList支持快速的随机访问。</li><li>ArrayList在内存空间利用率上肯定是不如LinkedList的， 因为数组是一片固定的连续的内存空间，一旦分配就无法改变， 所以难免会有空间不足或空间使用率很低的情况。</li></ul><h4 id="Vector的特点"><a href="#Vector的特点" class="headerlink" title="Vector的特点"></a>Vector的特点</h4><ol><li>ArrayList是线程不安全的，Vector是线程安全的， 但Vector实现线程安全的手段是synchronized。这就好比HashMap与HashTable的区别。</li><li>Vector默认容量为10。</li><li>Vector是当它的扩容增量大于0时，会扩容为原来的容量+扩容增量，否则扩容为原来的2倍。</li></ol><h4 id="LinkedList的特点"><a href="#LinkedList的特点" class="headerlink" title="LinkedList的特点"></a>LinkedList的特点</h4><ul><li>LinkedList底层使用<strong>双端链表</strong>实现。</li><li>LinkedList的add操作只需要改变尾节点的引用就行了。 但是如果需要在指定位置进行add操作的话，那么时间复杂度也是比较高的,为O(n)， 因为需要从头节点或尾节点遍历到需要操作的节点。</li><li>LinkedList的空间利用率虽然很高，但是它的每个Node可以说也是占用了较大空间的， 因为每个Node需要保存它的前继和后继节点。</li><li>LinkedList不仅是List，还是Queue，Deque，还可作为Stack使用。</li></ul><p><strong>PS: 双端链表与双向链表的区别: 双端链表:每个Node都保存了前后2个节点的引用，双向链表的first节点的前一个节点为null, last节点的后一个节点为null。</strong></p><p><strong>双向链表: 每个Node都保存了前后2个节点的引用， 双向链表的first节点的前一个节点指向last节点， last节点的最后一个节点指向first节点。</strong></p><h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><p>为啥不单独说HashSet，我目前看到的JDK所有的Set,都是使用Map实现的, 除了CopyOnWriteArraySet(底层是CopyOnWriteArrayList)。</p><p>TreeSet –&gt; TreeMap</p><p>LinkedHashSet –&gt; LinkedHashMap</p><p>HashSet –&gt; HashMap</p><p>ConcurrentSkipListSet –&gt; ConcurrentSkipListMap</p><p>Set是如何保证元素不会重复,这个得看各自Map的实现了。</p><p>拿HashMap来讲，它先判断key的hash是否相等，然后才使用equals判断2个对象是否相等。</p><h4 id="ConcurrentModificationException异常"><a href="#ConcurrentModificationException异常" class="headerlink" title="ConcurrentModificationException异常"></a>ConcurrentModificationException异常</h4><p>ConcurrentModificationException可以从名字看出是并发修改的异常。</p><p>但我要说的是<strong>这个异并不是在修改的时候会抛出的，而是在调用迭代器遍历集合的时候才会抛出。</strong></p><p>而集合类的大部分toString方法，都是使用迭代器遍历的。<strong>所以如果多线程修改集合后， 接着就遍历集合，那么很有可能会抛出ConcurrentModificationException。</strong></p><p><strong>在ArrayList，HashMap等非线程安全的集合内部都有一个modCount变量， 这个变量是在集合被修改时(删除，新增)，都会被修改。</strong></p><p>如果是多线程对同一个集合做出修改操作，就可能会造成modCount与实际的操作次数不符， 那么最终在调用集合的迭代方法时，modCount与预期expectedModeCount比较， expectedModCount是在迭代器初始化时使用modCount赋值的， <strong>如果发现modCount与expectedModeCount不一致，就说明在使用迭代器遍历集合期间， 有其他线程对集合进行了修改,所以就会抛出ConcurrentModificationException异常。</strong></p><h4 id="线程安全的-List"><a href="#线程安全的-List" class="headerlink" title="线程安全的 List"></a>线程安全的 List</h4><ol><li>使用集合工具类Collections的 synchronizedList把普通的List转为线程安全的List.(不推荐)</li><li>使用Vector.(不推荐)</li><li>使用CopyOnWriteArrayList,推荐使用此种方法，因为以上2种全部都是单纯的Synchronized加锁.</li></ol><h4 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h4><p>CopyOnWriteArrayList是线程安全的ArrayList，可以被称为写时复制的ArrayList。 CopyOnWriteArrayList底层仍然使用数组实现， 但是它的修改操作(增删改)采用synchronized关键字保证并发的安全性， 然后<strong>在进行修改的时候复制原来的数组到一个新副本，对新副本进行修改，修改完后再设置原数组。</strong> 这样就不会让写操作影响读操作了。 </p><p><strong>但是CopyOnWriteArrayList不容忽视的缺点就是修改操作比较消耗内存空间，所以它适用于读多写少的环境。</strong></p><h4 id="线程安全的Set"><a href="#线程安全的Set" class="headerlink" title="线程安全的Set"></a>线程安全的Set</h4><ol><li>使用集合工具类的Collections的synchronizedSet把普通的set转为线程安全的set(不推荐)</li><li>使用CopyOnWriteArraySet,此set适用于读多写少的情况，它的底层采用CopyOnWriteArrayList实现.</li><li>使用ConcurrentSkipListSet，底层采用ConcurrentSkipListMap实现</li></ol><h4 id="线程安全的Map"><a href="#线程安全的Map" class="headerlink" title="线程安全的Map"></a>线程安全的Map</h4><ol><li>使用集合工具类Collections的synchronizedMap把普通map转为线程安全的map(不推荐)</li><li>HashTable(不推荐)</li><li>使用ConcurrentHashMap(常用)</li><li>ConcurrentSkipListMap(跳表map,推荐)</li></ol><h4 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h4><p>ConcurrentHashMap使用数组+链表/红黑树实现,其扩容机制与HashMap一样。</p><p><strong>但是ConcurrentHashMap控制并发的方法改为了CAS+synchronized, synchronized锁的只是链表的首节点或红黑树的首节点。</strong></p><p><strong>PS:我只看了常用的put,get,remove等核心方法的源码. 整个ConcurrentHashMap的实现用”复杂”来形容一点也不为过, 你只要想到它内部有52个内部类就知道有多复杂了,但如果不考虑并发CAS这部分， ConcurrentHashMap和普通的HashMap的差别是不大的。</strong></p><h4 id="ConcurrentSkipListMap"><a href="#ConcurrentSkipListMap" class="headerlink" title="ConcurrentSkipListMap"></a>ConcurrentSkipListMap</h4><p>ConcurrentSkipListMap是基于跳表这种数据结构实现的。 跳表比较特殊，它由多个层次的链表组成，每层链表又有多个索引节点连接， 每层链表的元素也都是有序的。处于上层索引的链表都是下层链表的子集。 跳表与普通链表相比查找元素的效率更高。</p><p><img src="file://E:/%E5%B0%9A%E7%A1%85%E8%B0%B7java/JVMzhouyang/framework-learning/img/jdk-jvm-juc/%E8%B7%B3%E8%A1%A8.png?lastModify=1596340467" alt="跳表"></p><h2 id="Java-IO"><a href="#Java-IO" class="headerlink" title="Java IO"></a>Java IO</h2><h3 id="操作系统的内核"><a href="#操作系统的内核" class="headerlink" title="操作系统的内核"></a>操作系统的内核</h3><p>操作系统的内核是操作系统的核心部分。 它负责系统的内存管理，硬件设备的管理，文件系统的管理以及应用程序的管理。</p><p><strong>IO图源: <a href="https://www.jianshu.com/p/85e931636f27" target="_blank" rel="noopener">简书</a> (如有侵权,请联系俺,俺会立刻删除)</strong></p><h4 id="操作系统的用户态与内核态"><a href="#操作系统的用户态与内核态" class="headerlink" title="操作系统的用户态与内核态"></a>操作系统的用户态与内核态</h4><p>unix与linux的体系架构：分为用户态与内核态。 用户态与内核态与内核态是操作系统对执行权限进行分级后的不同的运行模式。</p><p><img src="file://E:/%E5%B0%9A%E7%A1%85%E8%B0%B7java/JVMzhouyang/framework-learning/img/jdk-jvm-juc/%E7%94%A8%E6%88%B7%E6%80%81%E4%B8%8E%E5%86%85%E6%A0%B8%E6%80%81.png?lastModify=1596340467" alt="用户态与内核态"></p><h4 id="为什么要有用户态与内核态"><a href="#为什么要有用户态与内核态" class="headerlink" title="为什么要有用户态与内核态?"></a>为什么要有用户态与内核态?</h4><p>在cpu的所有指令中，有些指令是非常危险的，如果使用不当，将会造成系统崩溃等后果。 为了避免这种情况发生，cpu将指令划分为<strong>特权级(内核态)指令</strong>和<strong>非特权级(用户态)指令。</strong></p><p><strong>对于那些危险的指令只允许内核及其相关模块调用，对于那些不会造成危险的指令，就允许用户应用程序调用。</strong></p><ul><li>内核态(核心态,特权态): <strong>内核态是操作系统内核运行的模式。</strong> 内核态控制计算机的硬件资源，如硬件设备，文件系统等等，并为上层应用程序提供执行环境。</li><li>用户态: <strong>用户态是用户应用程序运行的状态。</strong> 应用程序必须依托于内核态运行,因此用户态的态的操作权限比内核态是要低的， 如磁盘，文件等，访问操作都是受限的。</li><li>系统调用: 系统调用是操作系统为应用程序提供能够访问到内核态的资源的接口。</li></ul><h4 id="用户态切换到内核态的几种方式"><a href="#用户态切换到内核态的几种方式" class="headerlink" title="用户态切换到内核态的几种方式"></a>用户态切换到内核态的几种方式</h4><ul><li>系统调用: 系统调用是用户态主动要求切换到内核态的一种方式， 用户应用程序通过操作系统调用内核为上层应用程序开放的接口来执行程序。</li><li>异常: 当cpu在执行用户态的应用程序时，发生了某些不可知的异常。 于是当前用户态的应用进程切换到处理此异常的内核的程序中去。</li><li>硬件设备的中断: 当硬件设备完成用户请求后，会向cpu发出相应的中断信号， 这时cpu会暂停执行下一条即将要执行的指令，转而去执行与中断信号对应的应用程序， 如果先前执行的指令是用户态下程序的指令，那么这个转换过程也是用户态到内核台的转换。</li></ul><h4 id="阻塞和非阻塞"><a href="#阻塞和非阻塞" class="headerlink" title="阻塞和非阻塞"></a>阻塞和非阻塞</h4><ol><li>阻塞: 一个线程调用一个方法计算 1 - 100 的和，如果该方法没有返回， 那么调用的线程就一直等待该方法返回，不继续往下执行。</li><li>非阻塞: 一个线程调用一个方法计算 1 - 100的和，如果该方法没有返回， 调用者线程也无需一直等待该方法返回，可以执行其他任务，但是线程仍然需要不断检查方法是否返回。</li></ol><p><strong>结论: 阻塞与非阻塞针对调用者的立场而言。</strong></p><h4 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h4><ol><li>同步: 一个线程调用一个方法计算 1 - 100 的和，如果方法没有计算完，就不返回。</li><li>异步: 一个线程调用一个方法计算 1 - 100 的和，该方法立刻返回，但是由于方法没有返回结果， 所以就需要被调用的这个方法来通知调用线程 1 - 100的结果， 或者线程在调用方法的时候指定一个回调函数来告诉被调用的方法执行完后就执行回调函数。</li></ol><p><strong>结论:同步和异步是针对被调用者的立场而言的。</strong></p><h3 id="Linux-IO模型"><a href="#Linux-IO模型" class="headerlink" title="Linux IO模型"></a>Linux IO模型</h3><p>Linux下共有5种IO模型:</p><ol><li>阻塞IO</li><li>非阻塞IO</li><li>IO多路复用</li><li>信号驱动IO</li><li>异步IO</li></ol><h4 id="阻塞IO"><a href="#阻塞IO" class="headerlink" title="阻塞IO"></a>阻塞IO</h4><p>阻塞IO是很常见的一种IO模型。 在这种模型中，<strong>用户态的应用程序会执行一个操作系统的调用， 检查内核的数据是否准备好。如果内核的数据已经准备好， 就把数据复制到用户应用进程。如果内核没有准备好数据， 那么用户应用进程(线程)就阻塞，直到内核准备好数据并把数据从 内核复制到用户应用进程，</strong> 最后应用程序再处理数据。</p><p><img src="file://E:/%E5%B0%9A%E7%A1%85%E8%B0%B7java/JVMzhouyang/framework-learning/img/jdk-jvm-juc/BIO%E5%8E%9F%E7%90%86.png?lastModify=1596340467" alt="BIO原理"></p><p><strong>阻塞IO是同步阻塞的。</strong></p><ol><li>阻塞IO的同步体现在: <strong>内核只有准备好数据并把数据复制到用户应用进程才会返回。</strong></li><li>阻塞IO的阻塞体现在:<strong>用户应用进程等待内核准备数据和把数据从用户态拷贝到内核态的这2段时间。</strong> 当然,如果是本地磁盘IO,内核准备数据的时间可能会很短。 但网络IO就不一样了，因为服务端不知道客户端何时发送数据， 内核就仍需要等待socket数据，时间就可能会很长。</li></ol><blockquote><p><strong>阻塞IO的优点是对于数据是能够保证无延时的，因为应用程序进程会一直阻塞直到IO完成。</strong> 但应用程序的阻塞就意味着应用程序进程无法执行其他任务， 这会大大降低程序性能。一个不太可行的办法是为每个客户端socket都分配一个线程， 这样就会提升server处理请求的能力。不过操作系统的线程资源是有限的， 如果请求过多，可能造成线程资源耗尽，系统卡死等后果。</p></blockquote><h4 id="非阻塞IO-网络IO模型"><a href="#非阻塞IO-网络IO模型" class="headerlink" title="非阻塞IO(网络IO模型)"></a>非阻塞IO(网络IO模型)</h4><p>在非阻塞IO模型中，用户态的应用程序也会执行一个操作系统的调用， 检查内核的数据是否准备完成。<strong>如果内核没有准备好数据, 内核会立刻返回结果,用户应用进程不用一直阻塞等待内核准备数据， 而是可以执行其他任务,但仍需要不断的向内核发起系统调用，检测数据是否准备好， 这个过程就叫轮询。</strong> 轮询直到内核准备好数据，然后内核把数据拷贝到用户应用进程， 再进行数据处理。</p><p><img src="file://E:/%E5%B0%9A%E7%A1%85%E8%B0%B7java/JVMzhouyang/framework-learning/img/jdk-jvm-juc/NIO%E5%8E%9F%E7%90%86.png?lastModify=1596340467" alt="NIO原理"></p><p>非阻塞IO的非阻塞体现在: <strong>用户应用进程不用阻塞在对内核的系统调用上</strong></p><blockquote><p>非阻塞IO的优点在于用户应用进程在轮询阶段可以执行其它任务。 但这也是它的缺点，轮询就代表着用户应用进程不是时刻都会发起系统调用。 <strong>可能数据准备好了，而用户应用进程可能等待其它任务执行完毕才会发起系统调用， 这就意味着数据可能会被延时获取。</strong></p></blockquote><h4 id="IO多路复用-网络IO模型"><a href="#IO多路复用-网络IO模型" class="headerlink" title="IO多路复用(网络IO模型)"></a>IO多路复用(网络IO模型)</h4><p>在IO多路复用模型中,<strong>用户应用进程会调用操作系统的select/poll/epoll函数, 它会使内核同步的轮询指定的socket， (在NIO,socket就是注册到Selector上的SocketChannel,可以允许多个) 直至监听的socket有数据可读或可写，select/poll/epoll函数才会返回, 用户应用进程也会阻塞的等待select/poll/epoll函数返回。</strong> 当select/poll/epoll函数返回后，即某个socket有事件发生了，用户应用进程就会 发起系统调用，处理事件，将socket数据复制到用户进程内，然后进行数据处理。</p><p><img src="file://E:/%E5%B0%9A%E7%A1%85%E8%B0%B7java/JVMzhouyang/framework-learning/img/jdk-jvm-juc/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E5%8E%9F%E7%90%86.png?lastModify=1596340467" alt="IO多路复用原理"></p><p><strong>IO多路复用模型是同步阻塞的</strong></p><ol><li>IO多路复用模型的同步体现在: <strong>select函数只有监听到某个socket有事件才会返回。</strong></li><li>IO多路复用模型的阻塞体现在: <strong>用户应用进程会阻塞在对select函数上的调用上。</strong></li></ol><blockquote><p><strong>IO多路复用的优点在于内核可以处理多个socket， 相当于一个用户进程(线程)就可以处理多个socket连接。</strong> 这样不仅降低了系统的开销，并且对于需要高并发的应用是非常有利的。 而非阻塞IO和阻塞IO的一个用户应用进程只能处理一个socket， 要想处理多socket，只能新开进程或线程，但这样很消耗系统资源。</p></blockquote><p><strong>PS:  在IO多路复用模型中, socket一般应该为非阻塞的， 这就是Java中NIO被称为非阻塞IO的原因。 但实际上NIO属于IO多路复用，它是同步阻塞的IO。 具体原因见 <a href="https://www.zhihu.com/question/37271342" target="_blank" rel="noopener">知乎讨论</a></strong></p><p><strong>PS: select/poll/epoll函数是IO多路复用模型的基础，所以如果想 深入了解IO多路复用模型，就需要了解这3个函数以及它们的优缺点。</strong></p><h4 id="信号驱动IO-网络IO模型"><a href="#信号驱动IO-网络IO模型" class="headerlink" title="信号驱动IO(网络IO模型)"></a>信号驱动IO(网络IO模型)</h4><p>在信号驱动IO模型中，<strong>用户应用进程发起sigaction系统调用,内核收到并立即返回。 用户应用进程可以继续执行其他任务，不会阻塞。当内核准备好数据后向用户应用进程 发送SIGIO信号，应用进程收到信号后，发起系统调用， 将数据从内核拷贝到用户进程，</strong> 然后进行数据处理。</p><p><img src="file://E:/%E5%B0%9A%E7%A1%85%E8%B0%B7java/JVMzhouyang/framework-learning/img/jdk-jvm-juc/%E4%BF%A1%E5%8F%B7%E9%A9%B1%E5%8A%A8IO%E5%8E%9F%E7%90%86.png?lastModify=1596340467" alt="信号驱动IO原理"></p><p>个人感觉在内核收到系统调用就立刻返回这一点很像异步IO的方式了，不过 与异步IO仍有很大差别。</p><h4 id="异步IO"><a href="#异步IO" class="headerlink" title="异步IO"></a>异步IO</h4><p>在异步IO模型中，<strong>用户进程发起aio_read系统调用，无论内核的数据是否准备好， 都会立即返回。用户应用进程不会阻塞,可以继续执行其他任务。当内核准备好数据, 会直接把数据复制到用户应用进程。最后内核会通知用户应用进程IO完成。</strong></p><p><img src="file://E:/%E5%B0%9A%E7%A1%85%E8%B0%B7java/JVMzhouyang/framework-learning/img/jdk-jvm-juc/%E5%BC%82%E6%AD%A5IO%E5%8E%9F%E7%90%86.png?lastModify=1596340467" alt="异步IO原理"></p><p><strong>异步IO的异步体现在:内核不用等待数据准备好就立刻返回， 所以内核肯定需要在IO完成后通知用户应用进程。</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">弄清楚了阻塞与非阻塞，同步与异步和上面5种IO模型，相信再看</span><br><span class="line">Java中的IO模型，也只是换汤不换药。</span><br></pre></td></tr></table></figure><ul><li>BIO : 阻塞IO</li><li>NIO : IO多路复用</li><li>AIO : 异步IO</li></ul><p>本来打算写Java中的IO模型的，发现上面几乎讲完了(剩API使用吧)，没啥要写的了， 所以暂时就这样吧。如果各位同学有好的建议，欢迎pr或issue。</p><p><strong>PS: 我此处写的IO模型大部分是借鉴于网上的资料，如有错误，请各位同学指出。</strong></p><h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><h3 id="JVM运行时内存分区"><a href="#JVM运行时内存分区" class="headerlink" title="JVM运行时内存分区"></a>JVM运行时内存分区</h3><blockquote><p>以HotSpot为例:</p></blockquote><ul><li>JDK8之前: <ul><li>线程私有的部分有:程序计数器(PC寄存器),JAVA虚拟机栈,本地方法栈(native)。</li><li>线程共享部分有: GC堆,永久代(是方法区的一种实现)。</li></ul></li></ul><p><img src="file://E:/%E5%B0%9A%E7%A1%85%E8%B0%B7java/JVMzhouyang/framework-learning/img/jdk-jvm-juc/jdk8%E4%B9%8B%E5%89%8D%E7%9A%84JVM%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA.png?lastModify=1596340467" alt="jdk8之前的jvm内存分区"></p><ul><li>JDK8之后:<ul><li>线程私有的部分不变, 线程共享部分的永久代改为了元空间(MetaSpace) (永久代和元空间都是方法区的实现),字符串常量池也移动到了heap空间</li></ul></li></ul><p><img src="file://E:/%E5%B0%9A%E7%A1%85%E8%B0%B7java/JVMzhouyang/framework-learning/img/jdk-jvm-juc/jdk8%E4%B9%8B%E5%90%8E%E7%9A%84jvm%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA.png?lastModify=1596340467" alt="jdk8之后的jvm内存分区">         </p><h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><p>程序计数器是一块较小的内存空间，<strong>它的作用是作为当前线程执行的字节码的行号计数器。 当字节码解释器工作时，通过改变行号计数器的值来选取下一条要执行的字节码指令。</strong> 分支，循环，跳转，异常处理，线程恢复等功能都需要依赖程序计数器完成。</p><p><strong>程序计数器是属于线程私有的部分。 当cpu在多个线程之间切换执行时，需要记录下当前线程执行的字节码的位置， 以便下次切换回当前线程时，能够继续执行字节码指令， 所以每个线程都需要有自己的程序计数器。</strong></p><h4 id="程序计数器的特点"><a href="#程序计数器的特点" class="headerlink" title="程序计数器的特点"></a>程序计数器的特点</h4><ol><li>如果当前线程执行的是java方法，那么程序计数器记录的是字节码指令的地址。</li><li>如果当前线程执行的native方法，那么程序计数器记录的值为空(undefined)。</li><li>程序计数器这部分内存区域是JVM中唯一不会出现OOM错误的区域</li><li>程序计数器的生命周期与线程相同,即程序计数器随着线程创建而创建， 随着线程的销毁而销毁。</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">使用 javap -c 反编译class文件后的代码如下,</span><br><span class="line">红框里的就是字节码的偏移地址:</span><br></pre></td></tr></table></figure><p><img src="file://E:/%E5%B0%9A%E7%A1%85%E8%B0%B7java/JVMzhouyang/framework-learning/img/jdk-jvm-juc/JVM%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8.png?lastModify=1596340467" alt="JVM程序计数器">      </p><h4 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h4><p>Java虚拟机栈与程序计数器一样，都是线程私有的部分，生命周期也跟线程一样。</p><p><strong>Java虚拟机栈描述的是Java方法运行时的内存模型，它由一个一个的栈帧组成。</strong></p><h4 id="栈帧"><a href="#栈帧" class="headerlink" title="栈帧"></a>栈帧</h4><p><strong>栈帧是用于支持Java方法运行时的数据结构。 栈帧包含了局部变量表，操作数栈，动态连接，方法出口等信息。 每个方法执行时，都会在java虚拟机栈中创建一个栈帧。 对方法的调用和返回，就对应着栈帧的入栈和出栈的过程。</strong></p><p>Java虚拟机栈: <img src="file://E:/%E5%B0%9A%E7%A1%85%E8%B0%B7java/JVMzhouyang/framework-learning/img/jdk-jvm-juc/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88.png?lastModify=1596340467" alt="Java虚拟机栈">               </p><h4 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h4><p><strong>局部变量表用于存储方法参数和方法内定义的局部变量。 局部变量表存放了各种已知的数据类型的变量。</strong> 一个局部变量的类型可以是基本数据类型 (int,short,float,double,boolean,long,byte,char)或引用类型(reference)。 在Java代码被编译成class字节码后，方法Code属性的locals就确定了方法的局部变量表的大小。 局部变量表以slot为最小单位，一个slot代表4个字节，也就是32位长度的大小。</p><h4 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h4><p>操作数栈是一个后进先出(LIFO)的数据结构。 <strong>它存储的是方法在进行数据运算时的元素。</strong> 和局部变量表一样，操作数栈的每个元素的类型也可以是基本数据类型和引用类型。 操作数栈的深度不会超过 Code属性的stack值。</p><p>使用javap -c 反编译class文件后可以得到的字节码指令如下:</p><p><img src="file://E:/%E5%B0%9A%E7%A1%85%E8%B0%B7java/JVMzhouyang/framework-learning/img/jdk-jvm-juc/%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8.png?lastModify=1596340467" alt="局部变量表"></p><h4 id="动态连接"><a href="#动态连接" class="headerlink" title="动态连接"></a>动态连接</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">了解动态连接首先需要了解符号引用和直接引用</span><br></pre></td></tr></table></figure><ul><li>符号引用: 符号引用存于Class文件常量池。分为类的全限定名，方法名和描述符，字段名和描述符。</li><li>直接引用: 指向目标的指针，可以简单理解为目标的内存地址(如指向类的字段的内存地址)。</li></ul><p>Class文件常量池如下(javap -c 反编译class文件后的字节码):</p><p><img src="file://E:/%E5%B0%9A%E7%A1%85%E8%B0%B7java/JVMzhouyang/framework-learning/img/jdk-jvm-juc/Class%E6%96%87%E4%BB%B6%E5%B8%B8%E9%87%8F%E6%B1%A0.png?lastModify=1596340467" alt="Class文件常量池"></p><p><strong>在虚拟机栈中，每个栈帧都包含了一个该栈帧所属方法的符号引用， 持有这个符号引用的目的是为了支持方法调用过程中的动态连接。 这些符号引用有的一部分会在JVM类解析阶段就会转为直接引用，这部分转换成为静态解析。 还有一部分会在运行时转为直接引用，这部分称为动态连接。</strong></p><h4 id="方法出口"><a href="#方法出口" class="headerlink" title="方法出口"></a>方法出口</h4><p>当方法执行时，有2种方式可以退出该方法。</p><ol><li>正常退出: 当方法执行时，执行到return指令，该方法就会正常退出。 一般来说，方法正常退出时，调用线程的程序计数器的值可以作为方法返回的地址， 栈帧中可能会保存这个计数器的值。</li><li>异常退出: 在方法执行过程中遇到了异常，并且方法内部没有处理这个异常，就会导致方法退出。 方法异常退出时，返回地址需要通过异常处理器表来确定的，栈帧中不会保存这部分值。</li></ol><p><strong>无论何种退出方式，在方法退出后，都需要回到方法被调用的位置，程序才能继续执行。</strong></p><h4 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h4><p>本地方法栈与虚拟机栈的作用是相似的， 不过<strong>虚拟机栈是为执行Java方法提供服务的， 本地方法栈视为执行native方法提供服务的。</strong> 在本地方法执行的时候，也会在本地方法栈中创建栈帧， 用于存放该本地方法的局部变量表，操作数栈，动态连接和方法返回地址等信息。</p><h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4><p><strong>堆是JVM中内存占用最大的一块区域，它是所有线程共享的一块区域。 堆的作用是为对象分配内存并存储和回收它们。 堆是垃圾回收的主要区域，所以堆区也被成为GC堆。</strong></p><p>堆区可以划分为 <strong>新生代(Young Generation),老年代(Old Generation)</strong> 和 永久代(Permanent Generation),但永久代已被元空间代替, <strong>元空间存储的是类的元信息，几乎不可能发生GC。</strong></p><p>新生代再细分可以分为: <strong>Eden空间，From Survivor空间和To Survivor空间。</strong></p><p>缺省状态下新生代占堆区的 1/3,老年代占堆区的2/3， eden空间占新生代的80%,2个Survivor空间栈新生代的20%, FromSurvivor和ToSurvivor的空间占比为1:1。</p><p>(通过-XX:NewRatio参数可以调整新生代和老年代的空间占比) (通过-XX:SurvivorRatio参数可以调整eden和survivor的空间占比)</p><p><strong>发生在新生代的GC叫做Young GC或Minor GC, 发生在老年代的GC叫做Old GC或Major GC</strong></p><p>堆: <img src="file://E:/%E5%B0%9A%E7%A1%85%E8%B0%B7java/JVMzhouyang/framework-learning/img/jdk-jvm-juc/%E5%A0%86%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA.png?lastModify=1596340467" alt="堆内存分区"></p><p><strong>PS: FromSurvivor和ToSurvivor这两块内存空间并不是固定的， 在进行GC的时候，这两块内存会轮流替换使用。这部分内容参考GC部分。</strong></p><p><strong>PS: 有的文章说 Full GC与Major GC一样是属于对老年代的GC， 也有的文章说 Full GC 是对整个堆区的GC，所以这点需要各位同学自行分辨Full GC语义。 见: <a href="https://www.zhihu.com/question/41922036" target="_blank" rel="noopener">知乎讨论</a></strong></p><h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h4><p>方法区在JVM规范里也是各个<strong>线程共享的一部分区域， 它用于存储已被jvm加载的类的元信息，运行时常量池等数据。</strong></p><p>HotSpot虚拟机对于方法区的实现在jdk8之前为永久代，在jdk8之后， HotSpot移除了永久代，新增了元空间。</p><p>元空间使用的是本地内存，所以元空间仅受本地物理内存的限制。 元空间存储着已被加载的类的方法描述，字段描述，运行时常量池等信息。</p><p><strong>字符串常量池在jdk7已经从永久代转移到了堆内存之中。</strong></p><p><strong>无论是永久代还是元空间，都有可能发生OOM。</strong></p><h3 id="JavaVirtualMachineError"><a href="#JavaVirtualMachineError" class="headerlink" title="JavaVirtualMachineError"></a>JavaVirtualMachineError</h3><h4 id="StackOverflowError"><a href="#StackOverflowError" class="headerlink" title="StackOverflowError"></a>StackOverflowError</h4><p>当前线程执行或请求的栈的大小超过了Java 虚拟机栈的最大空间(比如递归嵌套调用太深),就可能出现StackOverflowError错误           </p><h4 id="OutOfMemoryError"><a href="#OutOfMemoryError" class="headerlink" title="OutOfMemoryError"></a>OutOfMemoryError</h4><p>发生OOM的情况:              </p><ul><li>java heap space </li></ul><blockquote><p>当需要为对象分配内存时，堆空间占用已经达到最大值， 无法继续为对象分配内存，可能会出现OOM: java heap space错误。 </p></blockquote><ul><li>Requested array size exceeds VM limit</li></ul><blockquote><p>当为数组分配内存时，数组需要的容量超过了虚拟机的限制范围， 就会抛出OOM: Requested array size exceeds VM limit。 根据我的测试，Integer.MAX_VALUE - 2 是虚拟机能为数组分配的最大容量    </p></blockquote><ul><li>GC overhead limit exceed</li></ul><blockquote><p>垃圾回收器花费了很长时间GC,但是GC回收的内存非常少, 就可能抛出OOM:GC overhead limit exceed 错误。</p><p>但是这点在我的机器上测试不出来,可能与jdk版本或gc收集器或Xmx分配内存的大小有关, 一直抛出的是java heap space</p></blockquote><ul><li>Direct buffer memory</li></ul><blockquote><p>当程序分配了超额的本地物理内存(native memory/ direct buffer)， minor gc(young gc)并不会回收这部分内存， 只有 full gc才会回收直接内存，如果不发生full  gc， 但直接内存却被使用完了，那么可能会发生 OOM: Direct buffer memory。</p></blockquote><ul><li>unable to create new native thread </li></ul><blockquote><p>操作系统的线程资源是有限的， 如果程序创建的线程资源太多(无需超过平台限制的线程资源上限)， 就可能发生 OOM: unable to create new native thread 错误。 </p></blockquote><ul><li>Metaspace</li></ul><blockquote><p>当加载到元空间中的类的信息太多，就有可能导致 OOM : Metaspace。 <strong>使用cglib的库，可以动态生成class，所以可以使用cglib测试此错误。</strong></p></blockquote><h3 id="简单了解类文件结构"><a href="#简单了解类文件结构" class="headerlink" title="简单了解类文件结构"></a>简单了解类文件结构</h3><p>Class文件结构如下:</p><p><img src="file://E:/%E5%B0%9A%E7%A1%85%E8%B0%B7java/JVMzhouyang/framework-learning/img/jdk-jvm-juc/Class%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%841.png?lastModify=1596340467" alt="Class文件结构1"></p><p>使用vim -b filename 以二进制模式编辑class文件， 然后输入 <strong>:%!xxd</strong> 即可查看十六进制的Class文件,如下:</p><p><img src="file://E:/%E5%B0%9A%E7%A1%85%E8%B0%B7java/JVMzhouyang/framework-learning/img/jdk-jvm-juc/Class%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%842.png?lastModify=1596340467" alt="Class文件结构2"></p><p>当然，最直观的方法是对 class 文件使用 javap -c命令进行详细查看。</p><h3 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h3><p>当java源代码文件被javac编译成class文件后，并不能直接运行， 而是需要经过加载，连接和初始化这几个阶段后才能使用。 在使用完类或JVM被销毁后，JVM会将类卸载掉。</p><p><img src="file://E:/%E5%B0%9A%E7%A1%85%E8%B0%B7java/JVMzhouyang/framework-learning/img/jdk-jvm-juc/%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png?lastModify=1596340467" alt="类的生命周期"></p><h4 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h4><p>类加载过程需要经过3个阶段:</p><ol><li>加载</li><li>连接</li><li>初始化</li></ol><p>其中连接又可分为3个阶段: 验证 ， 准备 ， 解析。</p><h4 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h4><p><strong>在加载阶段，类加载器将类的class文件的二进制数据读取到内存， 并保存到方法区，并在堆区生成该类的Class对象。</strong></p><p>通常有多种方式可以获取类的二进制数据:</p><ul><li>通过javac编译器编译java源文件，读取在本地磁盘上生成的class文件。</li><li>从Jar，ZIP等归档文件中读取class文件。</li><li>通过网络读取类的字节流。</li><li>通过动态生成字节码的技术(如使用动态代理，cglib)来生成class。</li></ul><p><strong>PS:数组由数组元素的类型的类加载器在java程序运行时加载，这是ClassLoader类的部分注释:</strong></p><p><img src="file://E:/%E5%B0%9A%E7%A1%85%E8%B0%B7java/JVMzhouyang/framework-learning/img/jdk-jvm-juc/ClassLoader%E9%83%A8%E5%88%86%E6%B3%A8%E9%87%8A.png?lastModify=1596340467" alt="ClassLoader部分注释"></p><p><strong>见: <a href="https://github.com/guang19/framework-learning/blob/master/jdk-jvm-juc/src/main/java/com/github/guang19/jvm/classloader/ArrayClassLoaderTest.java" target="_blank" rel="noopener">测试</a></strong></p><h4 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h4><p>1.验证 <strong>验证阶段是为了确保类的字节流符合虚拟机规范，并且不会对虚拟机造成恶意损害。</strong> JVM会对字节流进行如下验证:</p><ul><li>文件格式验证:会验证class文件是否符合虚拟机规范，如是否以0×CAFEBABE开头， 主次版本号是否在虚拟机规定范围类，常量池中的类型是否有JVM不支持的类型。</li><li>元数据验证: 会对类的元信息进行语义分析，确保符合Java语法规范。</li><li>字节码验证: 通过分析数据流和控制流，确保类的方法体的程序语义是合法的， 符合逻辑的。</li><li>符号引用验证: 确保常量池中的符号引用能在解析阶段正常解析。</li></ul><p>2.准备: 准备阶段会为类的静态变量初始化零值，如(0,0L,null,false).</p><p>3.解析: 解析阶段会将常量池中的符号引用转为直接引用。 符号引用包括类的全限定名，方法名和描述符，字段名和描述符。   直接引用是指向目标的指针，可以简单理解为目标的内存地址。</p><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><blockquote><p>初始化阶段是类加载过程的最后一个阶段。</p></blockquote><p>在这个阶段,<strong>只有主动使用类才会初始化类，总共有8种情况会涉及到主动使用类。</strong></p><ol><li>当jvm执行new指令时会初始化类，即当程序创建一个类的实例对象。</li><li>当jvm执行getstatic指令时会初始化类，即程序访问类的静态变量(不是静态常量，常量归属于运行时常量池)。</li><li>当jvm执行putstatic指令时会初始化类，即程序给类的静态变量赋值。</li><li>当jvm执行invokestatic指令时会初始化类，即程序调用类的静态方法。</li><li>当使用反射主动访问这个类时,也会初始化类,如Class.forname(“…”),newInstance()等等。</li><li>当初始化一个子类的时候，会先初始化这个子类的所有父类，然后才会初始化这个子类。</li><li>当一个类是启动类时，即这个类拥有main方法，那么jvm会首先初始化这个类。</li><li>MethodHandle和VarHandle可以看作是轻量级的反射调用机制，而要想使用这2个调用， 就必须先使用findStatic/findStaticVarHandle来初始化要调用的类。</li></ol><p><strong>PS:见:<a href="https://github.com/guang19/framework-learning/blob/master/jdk-jvm-juc/src/main/java/com/github/guang19/jvm/classloader/LoadClass.java" target="_blank" rel="noopener">测试</a></strong></p><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>在类被初始化完成后，就可以使用类了。</p><h4 id="类的卸载"><a href="#类的卸载" class="headerlink" title="类的卸载"></a>类的卸载</h4><p>类被卸载(Class对象被GC掉)需要满足3个条件:</p><ol><li>该类的实例对象都已被GC，也就是说堆中不存在该类的实例对象。</li><li>该类没有在其它任何地方被使用。</li><li>加载该类的类加载器实例已被GC。</li></ol><p><strong>在JVM的生命周期中，被JVM自带的类加载器所加载的类是不会被卸载的。 而被我们自定义的类加载器所加载的类是可能会被卸载的。</strong></p><p>其实只要想通一点就好了，<strong>jdk自带的BootstrapClassLoader， PlatformClassLoader和AppClassLoader负责加载jdk提供的类， 它们(类加载器)的实例肯定不会被回收，其中BootstrapClassLoader在java中更是不能被获取到。 而我们自定义的类加载器的实例是可以被GC掉的， 所以被我们自定义类加载器加载的类是可以被GC掉的。</strong></p><p><img src="file://E:/%E5%B0%9A%E7%A1%85%E8%B0%B7java/JVMzhouyang/framework-learning/img/jdk-jvm-juc/%E7%B1%BB%E5%8D%B8%E8%BD%BD.png?lastModify=1596340467" alt="类卸载"></p><p><strong>PS:使用-XX:+TraceClassUnloading 或 -Xlog:class+unload=info可以打印类卸载的信息。</strong></p><h4 id="Java中类加载器有多少个"><a href="#Java中类加载器有多少个" class="headerlink" title="Java中类加载器有多少个"></a>Java中类加载器有多少个</h4><ol><li>BootstrapClassLoader(用于加载Java基础核心类库。由c/c++编写，Java获取不到)。</li><li>PlatformClassLoader (jdk9之后才有此类加载器，jdk8之前是扩展加载器ExtensionClassLoader 。PlatformClassLoader加载平台相关的模块，ExtensionClassLoader加载jdk扩展的模块)。</li><li>AppClassLoader。(应用程序类加载器，负责加载我们程序的classpath下的jar和类)。</li><li>自定义类加载器。</li></ol><h4 id="类加载器的命名空间"><a href="#类加载器的命名空间" class="headerlink" title="类加载器的命名空间"></a>类加载器的命名空间</h4><p><strong>每个类加载器实例都有自己的命名空间，命名空间由该加载器及其所有父加载器加载的所有的类组成。</strong></p><ul><li>在同一个命名空间中(<strong>一个类加载器实例</strong>)，不会出现全限定名(包括包名)相同的2个类(<strong>不会加载2个相同名称的类</strong>)。</li><li>在不同的命名空间中(<strong>多个类加载器实例</strong>)，可能会出现全限定名(包括包名)相同的2个类(<strong>可能加载2个相同名称的类</strong>)。</li></ul><p><strong>PS:见:<a href="https://github.com/guang19/framework-learning/blob/master/jdk-jvm-juc/src/main/java/com/github/guang19/jvm/classloader/MyClassLoader.java" target="_blank" rel="noopener">测试</a></strong></p><h4 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h4><h4 id="为什么需要双亲委派机制"><a href="#为什么需要双亲委派机制" class="headerlink" title="为什么需要双亲委派机制?"></a>为什么需要双亲委派机制?</h4><p><strong>双亲委派机制是为了防止类被重复加载，避免核心API遭到恶意破坏。</strong> 如Object类，它由BootstrapClassLoader在JVM启动时加载。 如果没有双亲委派机制，那么Object类就可以被重写，其带来的后果将无法想象。</p><h4 id="双亲委派机制的实现原理"><a href="#双亲委派机制的实现原理" class="headerlink" title="双亲委派机制的实现原理?"></a>双亲委派机制的实现原理?</h4><p>每个类都有其对应的类加载器。</p><p>双亲委派机制是指在加载一个类的时候，JVM会判断这个类是否已经被其类加载器加载过了。 如果已经加载过了，那么直接返回这个类。 <strong>如果没有加载，就使用这个类对应的加载器的父类加载器判断， 一层一层的往上判断，最终会由BootstrapClassLoader判断。</strong> 如果BootstrapClassLoader判断都没有加载这个类, <strong>那么就由BootstrapClassLoader尝试加载。 如果BootstrapClassLoader加载失败了， 就由BootstrapClassLoader的子类加载器们加载。</strong></p><p><strong>在jdk9之后，由于模块化的到来，双亲委派机制也变化了一点: 如果类没有被加载，那么会根据类名找到这个类的模块。 如果找到了这个类的模块， 就由这个类的模块加载，否则仍然使用父类加载器加载。</strong></p><p><img src="file://E:/%E5%B0%9A%E7%A1%85%E8%B0%B7java/JVMzhouyang/framework-learning/img/jdk-jvm-juc/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6.png?lastModify=1596340467" alt="双亲委派机制"></p><p>可以看出:在加载一个类时，是由下自上判断类是否被加载的。如果类没有被加载， 就由上自下尝试加载类。</p><h3 id="JVM常量池"><a href="#JVM常量池" class="headerlink" title="JVM常量池"></a>JVM常量池</h3><p>Jvm常量池分为:</p><ol><li>Class常量池(静态常量池)</li><li>运行时常量池</li><li>字符串常量池(全局常量池)</li><li>包装类型缓存池</li></ol><h4 id="Class常量池-静态常量池"><a href="#Class常量池-静态常量池" class="headerlink" title="Class常量池(静态常量池)"></a>Class常量池(静态常量池)</h4><p>当Java源文件被编译后，就会生成Class字节码文件。</p><p><strong>Class常量池就存在于Class文件中(Class文件的Constant Pool中)。</strong></p><p><strong>Class文件常量池主要存放两大常量:字面量和符号引用。</strong></p><ol><li>字面量: 字面量分为文本字符串(如: “abc”,1等)和用final修饰的成员变量(实例变量和静态变量)</li><li>符号引用: 符号引用包括三种：类的全限定名，方法名和描述符，字段名和描述符。</li></ol><p><img src="file://E:/%E5%B0%9A%E7%A1%85%E8%B0%B7java/JVMzhouyang/framework-learning/img/jdk-jvm-juc/Class%E6%96%87%E4%BB%B6%E5%B8%B8%E9%87%8F%E6%B1%A0.png?lastModify=1596340467" alt="Class文件常量池"></p><h4 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><p><strong>运行是常量池是在类加载阶段，将class二进制数据加载到内存， 并将数据保存到方法区,其中class文件中的常量池将保存到 运行时常量池(数据都在方法区，常量池肯定也在方法区)。 也就是说一个Class文件常量池对应一个运行时常量池。</strong></p><h4 id="字符串常量池-全局常量池"><a href="#字符串常量池-全局常量池" class="headerlink" title="字符串常量池(全局常量池)"></a>字符串常量池(全局常量池)</h4><p>字符串常量池在jdk7之前都是存于永久代(永久代)之中,jdk7以后存于 堆区之中。</p><h4 id="包装类型缓存池"><a href="#包装类型缓存池" class="headerlink" title="包装类型缓存池"></a>包装类型缓存池</h4><p>包装类缓存池并不是所有的包装类都有，并且缓存池缓存的是一定范围内的数据。 拥有包装类型缓存池的类有:Integer,Byte,Character,Long,Short， 而Float，Double，Boolean都不具有缓存池。</p><p><strong>包装类的缓存池缓存的范围基本都为: -128 - 127之间， Character的缓存范围为 0 - 127。</strong></p><h2 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h2><h3 id="判断对象存活的方法"><a href="#判断对象存活的方法" class="headerlink" title="判断对象存活的方法"></a>判断对象存活的方法</h3><p>在垃圾回收器对堆内存回收前，需要判断对象是否存活。</p><ul><li>引用计数算法: 给每个对象添加一个引用计数器,每当对象被引用, 对象的引用计数器就加1,当引用失效时,引用计数器就减1。 直到引用计数器为0,就代表对象不再被引用。</li><li>可达性算法: 通过GC ROOT的对象节点往下搜索,节点走过的路径被称为引用链。 如果一个对象不处于任何引用链,那么就可以判断此对象是不可达的。</li></ul><h4 id="引用计数法缺点"><a href="#引用计数法缺点" class="headerlink" title="引用计数法缺点"></a>引用计数法缺点</h4><p>引用计数的主要缺陷是很难解决循环引用的问题: 也就是当2个对象互相引用的时候,除了彼此, 没有其它对象再引用这2个对象,那么他们的引用计数都为1,就无法被回收。                </p><h4 id="什么是GC-Root"><a href="#什么是GC-Root" class="headerlink" title="什么是GC Root ?"></a>什么是GC Root ?</h4><p>上面说通过GC Root对象搜索引用链,那么GC Root对象是什么对象, 或者说什么样的对象是GC Root对象。 可以作为GC Root对象的有: </p><ol><li>虚拟机栈和本地方法栈区中的引用对象(stack)</li><li>方法区中类的静态属性引用的对象(static)</li><li>方法区中的常量引用的对象(final)   </li></ol><p><img src="file://E:/%E5%B0%9A%E7%A1%85%E8%B0%B7java/JVMzhouyang/framework-learning/img/jdk-jvm-juc/%E5%8F%AF%E8%BE%BE%E6%80%A7%E7%AE%97%E6%B3%95.png?lastModify=1596340467" alt="可达性算法">              </p><h3 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h3><p>常见的垃圾回收算法主要有以下4种:</p><ol><li>复制算法</li><li>标记-清除算法</li><li>标记-整理算法</li><li>分代收集算法</li></ol><h4 id="复制算法-Copying"><a href="#复制算法-Copying" class="headerlink" title="复制算法(Copying)"></a>复制算法(Copying)</h4><p>将堆内存分为2块大小相等的内存空间， 每次只使用其中的一块内存，另一块则空闲。 当其中一块内存使用完后， 就将仍然存活的对象复制到另一块空闲内存空间，再清理已使用的内存。</p><p><strong>复制算法的优点是不会产生连续的内存碎片，速度也很高效。 但是缺点更明显:每次只使用内存的一半，就代表可使用的内存减少了1/2，代价很高昂。</strong></p><p><strong>复制算法一般用于新生代。 因为新生代的GC非常频繁，每次GC的对象较多，存活的对象较少。 所以采用复制算法效率更高，复制时只需要复制少量存活的对象。</strong>          <img src="file://E:/%E5%B0%9A%E7%A1%85%E8%B0%B7java/JVMzhouyang/framework-learning/img/jdk-jvm-juc/%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95.png?lastModify=1596340467" alt="复制算法">                  </p><h4 id="标记-清除算法-Mark-Sweep"><a href="#标记-清除算法-Mark-Sweep" class="headerlink" title="标记-清除算法(Mark-Sweep)"></a>标记-清除算法(Mark-Sweep)</h4><p>标记-清除算法分为2个步骤：标记和清除。</p><p>首先标记出所有可达(存活)的对象，在标记完成后， 统一回收所有未被标记(不可达)的对象。</p><p>标记-清除算法的缺点主要有2个:</p><ol><li><strong>标记和清除2个阶段的耗时都比较长，可以总结为效率较低。</strong></li><li><strong>对象在内存中的分布可能是不连续的，分散的，标记-清除后可能造成不连续的内存碎片。</strong> 当内存碎片过多后，后续想要分配较大的对象时，无法找到足够大的内存碎片， 可能又需要触发GC。</li></ol><p><strong>标记-清除算法一般用于老年代。</strong> 因为老年代中的对象存活率较高，几乎很少被回收， 所以标记-清除和标记-整理算法GC的时间不会太长， GC的对象相比新生代更少。</p><p><img src="file://E:/%E5%B0%9A%E7%A1%85%E8%B0%B7java/JVMzhouyang/framework-learning/img/jdk-jvm-juc/%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95.png?lastModify=1596340467" alt="标记-清除算法">      </p><h4 id="标记-整理算法-Mark-Compact"><a href="#标记-整理算法-Mark-Compact" class="headerlink" title="标记-整理算法(Mark-Compact)"></a>标记-整理算法(Mark-Compact)</h4><p>标记-整理算法是对标记-清除算法的一种改进。</p><p>标记-整理算法与标记-清除算法的在标记阶段是相同的， 都是首先标记出所有可达(存活)的对象。 但<strong>标记之后并不直接清理未被标记(不可达)的对象， 而是使被标记(存活)的对象向内存一端移动，然后清理掉这一端外的内存。</strong>          <strong>标记-整理算法的优点是: 几乎不会如标记-清除算法那样产生不连续的内存碎片。 但，所谓慢工出细活,标记-整理的效率是比标记-清除要低的。</strong>         </p><p><strong>标记-整理算法和标记-清除算法一样，一般用于老年代。</strong></p><p><img src="file://E:/%E5%B0%9A%E7%A1%85%E8%B0%B7java/JVMzhouyang/framework-learning/img/jdk-jvm-juc/%E6%A0%87%E8%AE%B0-%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95.png?lastModify=1596340467" alt="标记-整理算法">                  </p><h4 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h4><p><strong>分代收集算法并不是指某一种具体的垃圾收集算法， 而是将复制，标记-清除，标记-整理等算法合理运用到堆区的不同空间。</strong> 比如新生代使用复制算法，老年代使用标记清除或标记整理算法。</p><p>现代的几乎所有的JVM都使用分代收集，毕竟每种算法都有优缺点， 结合它们的特点，对不同的环境采用不同的算法是非常明智的选择。</p><h4 id="内存分配与垃圾回收策略"><a href="#内存分配与垃圾回收策略" class="headerlink" title="内存分配与垃圾回收策略"></a>内存分配与垃圾回收策略</h4><ol><li>对象优先在eden区域被分配</li><li>大对象将直接进入老年代 (大对象是指需要大量连续的内存空间的对象，如长字符串，大数组等。)</li><li>长期存活的对象将进入老年代</li></ol><h4 id="一次GC的过程"><a href="#一次GC的过程" class="headerlink" title="一次GC的过程"></a>一次GC的过程</h4><p>对象优先在eden区被分配，当eden区内存不足时， JVM发起Minor GC。Minor GC的范围包括eden和From Survivor:</p><p>首先JVM会根据可达性算法标记出所有存活的对象。</p><p>如果存活的对象中，有的对象的年龄已经达到晋升阈值 (阈值是动态计算的，可以通过-XX:MaxTenuringThreshold设置最大年龄阈值)， 那么将已经达到阈值的对象复制到老年代中。</p><p>如果To Survivor空间不足以存放剩余存活对象， 则直接将存活的对象提前复制到老年代。 如果老年代也没有足够的空间存放存活的对象， 那么将触发Full GC(GC整个堆，包括新生代和老年代)。</p><p>如果To Survivor可以存放存活的对象， 那么将对象复制到To Survivor空间，并清理eden和From Survivor。</p><p>此时From Survivor为空， 那么From Survivor就成为了下一次的To Survivor， 此时To Survivor存放着存活的对象，就成为了下一次的From Survivor。 这样From Survivor与To Survivor就是不断交替复制的使用。</p><p><strong>老年代的空间比新生代的空间要大， 所以老年代的Major GC要比Minor GC耗时更长。 根据垃圾回收器的不同，老年代的GC算法也不同。</strong></p><h4 id="动态年龄阈值"><a href="#动态年龄阈值" class="headerlink" title="动态年龄阈值"></a>动态年龄阈值</h4><p>JVM并不要求对象年龄一定要达到 MaxTenuringThreshold 才会 晋升到老年代，晋升的年龄阈值是动态计算的。￼￼￼￼￼ 如果在Survivor中，某个相同年龄阶段的所有对象大小的总和 大于Survivor区域的一半，则大于等于这个年龄的所有对象 可以直接进入老年代，无需等到MaxTenuringThreshold。</p><h3 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h3><p><strong>如果说垃圾回收算法是JVM对GC算法的方法论，那么垃圾回收器就是对GC算法的实现。</strong></p><p>垃圾回收器主要分为以下几种收集器:</p><ul><li>Serial收集器</li><li>Parallel Scanvel收集器</li><li>ParNew收集器</li><li>CMS收集器</li><li>G1收集器</li></ul><h4 id="Serial串行收集器"><a href="#Serial串行收集器" class="headerlink" title="Serial串行收集器"></a>Serial串行收集器</h4><p>Serial收集器为单线程环境设计,并只使用一个线程进行垃圾回收。 在回收时，会暂停用户线程,并不适用于并发环境。</p><p>Serial收集器在单线程环境中是很高效的,它没有多线程切换的消耗。     </p><p><strong>Serial收集器采用复制算法</strong>       </p><h4 id="Serial-Old-串行收集器-老年代版本"><a href="#Serial-Old-串行收集器-老年代版本" class="headerlink" title="Serial Old 串行收集器(老年代版本)"></a>Serial Old 串行收集器(老年代版本)</h4><p>它是 Serial收集器的老年代使用的GC收集器，同样是一个单线程的垃圾收集器。 </p><p><strong>Serial Old收集器采用的是标记-整理算法。</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;** 开启串行收集器使用 -XX:+UseSerialGC , </span><br><span class="line">  * 这样默认新生代使用 Serial 收集器,</span><br><span class="line">  * 老年代使用 Serial Old 收集器. </span><br><span class="line">  *</span><br><span class="line">  * 设置VM参数:</span><br><span class="line">  *</span><br><span class="line">  * -XX:+Xlogs:gc* 打印gc信息</span><br><span class="line">  * -XX:+PrintCommandLineFlags  打印java版本信息</span><br><span class="line">  * -XX:+UseSerialGC 使用串行GC</span><br><span class="line">  *&#x2F;                      </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;如果程序正常运行,日志会显示 :</span><br><span class="line">&#x2F;&#x2F; 新生代的信息为:  def new generation.....</span><br><span class="line">&#x2F;&#x2F; 老年代的信息为:  tenured generation.....</span><br></pre></td></tr></table></figure><h4 id="Parallel-Scavenge-并行多线程收集器"><a href="#Parallel-Scavenge-并行多线程收集器" class="headerlink" title="Parallel Scavenge 并行多线程收集器"></a>Parallel Scavenge 并行多线程收集器</h4><p>Parallel Scavenge是并行收集器，它使用多个垃圾回收线程一起工作, 但是仍然会暂停用户线程。</p><p>Parallel Scavenge与其它垃圾回收器不同的是它<strong>更关注于达到可控制的吞吐量。</strong></p><p>吞吐量是CPU运行用户应用程序代码的时间与CPU总消耗的时间的比值:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">吞吐量 &#x3D; 应用程序代码运行时间 &#x2F; (应用程序代码运行时间 + GC时间)</span><br></pre></td></tr></table></figure><p><strong>Parallel Scavenge收集器采用复制算法</strong></p><h4 id="Parallel-Old-并行收集器-老年代版本"><a href="#Parallel-Old-并行收集器-老年代版本" class="headerlink" title="Parallel Old 并行收集器(老年代版本)"></a>Parallel Old 并行收集器(老年代版本)</h4><p>它是 Parallel Scavenge 的老年代版本,同样是一个并行多线程的收集器。</p><p><strong>Parallel Old收集器采用标记-整理算法。</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * </span><br><span class="line"> * 设置 Parallel Scavenge 收集器的参数:</span><br><span class="line"> *</span><br><span class="line"> * -XX:+UseParallelGC</span><br><span class="line"> * </span><br><span class="line"> * ParallelGC老年代默认使用的 Parallel Old GC 回收器</span><br><span class="line"> * </span><br><span class="line"> * 并行收集器打印的新生代的信息为:</span><br><span class="line"> *  PSYoungGen ....</span><br><span class="line"> *  </span><br><span class="line"> *  老年代的信息为:</span><br><span class="line"> *  ParOldGen ....</span><br><span class="line"> * </span><br><span class="line"> *&#x2F;</span><br></pre></td></tr></table></figure><h4 id="ParNew-多线程收集器"><a href="#ParNew-多线程收集器" class="headerlink" title="ParNew 多线程收集器"></a>ParNew 多线程收集器</h4><p>它可以看做是多线程版的Serial收集器。 除了多线程外，ParNew收集器与Serial收集器几乎没啥区别。</p><p><strong>PS:目前只有Serial和ParNew能作为CMS收集器的新生代收集器。</strong>          <strong>ParNew收集器采用复制算法</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">  * </span><br><span class="line">  * 设置ParNewGC回收器的参数为:</span><br><span class="line">  * -XX:+UseConcMarkSweepGC</span><br><span class="line">  * </span><br><span class="line">  *&#x2F;</span><br></pre></td></tr></table></figure><h4 id="CMS-并发标记清除收集器"><a href="#CMS-并发标记清除收集器" class="headerlink" title="CMS 并发标记清除收集器"></a>CMS 并发标记清除收集器</h4><p>Concurrent Mark Sweep,并发标记-清除垃圾回收器。 它是一款老年代的收集器，是<strong>以达到最短回收停顿时间目标的收集器。</strong></p><p><strong>见名知意,CMS收集器使用的是标记-清除算法。 CMS在垃圾回收过程中，用户线程可以同时工作，无需暂停。</strong></p><p><strong>因为CMS收集器采用的是标记-清除算法，所以回收时可能会产生不连续的内存碎片。</strong></p><p><strong>PS: CMS收集器在jdk14中被删除了。</strong></p><h4 id="CMS收集器回收过程"><a href="#CMS收集器回收过程" class="headerlink" title="CMS收集器回收过程"></a>CMS收集器回收过程</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在jdk14中，CMS被删除了。但是仍然有必要学习它。</span><br></pre></td></tr></table></figure><ul><li>初始标记(Stop The World，此阶段会暂停用户线程): 只标记与GC ROOT直接关联的对象。</li><li>并发标记: 对第一个阶段已经标记的对象进行Tracing，标记所有可达的对象。</li><li>重新标记(Stop The World,此阶段会暂停用户线程): 在第二个阶段，由于用户程序的运行， 可能有些对象之间的引用关系受到了影响，所以需要对这部分对象进行重新标记调整。</li><li>并发清除: 清除所有未被标记的对象。    </li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> *</span><br><span class="line"> * 设置 CMS 收集器参数:</span><br><span class="line"> * -XX:+UseConcMarkSweepGC</span><br><span class="line"> *</span><br><span class="line"> * 使用ConcMarkSweepGC收集器后,它的新生代使用的是:</span><br><span class="line"> * ParNew收集器.</span><br><span class="line"> *</span><br><span class="line"> * 当ConcMarkSweepGC收集器出现异常时,会将CMS替换成Serial Old收集器</span><br><span class="line"> *</span><br><span class="line"> * CMS回收分为4个阶段:</span><br><span class="line"> *</span><br><span class="line"> * 初始标记:    (Stop the world 暂停用户线程)</span><br><span class="line"> * 标记与GC Root直接可达的对象.      </span><br><span class="line"> *</span><br><span class="line"> * 并发标记:  </span><br><span class="line"> * 从第一步标记的可达的对象开始,并发的标记所有可达的对象 </span><br><span class="line"> *</span><br><span class="line"> * 重新标记:    (Stop the world 暂停用户线程)</span><br><span class="line"> * 在第二部的并发标记阶段,由于程序运行导致对象间引用的关系发生变化,</span><br><span class="line"> * 就需要重新标记</span><br><span class="line"> *</span><br><span class="line"> * 并发清除:     </span><br><span class="line"> * 这个阶段不暂停用户线程,并且并发的去清除未被标记的对象</span><br><span class="line"> * </span><br><span class="line"> *&#x2F;</span><br></pre></td></tr></table></figure><h4 id="G1-收集器"><a href="#G1-收集器" class="headerlink" title="G1 收集器"></a>G1 收集器</h4><p>G1收集器可以说是目前最前沿的一款收集器，它是一款面向服务端的收集器。 G1收集器<strong>无需配合其他收集器就可以管理整个堆内存。</strong> jdk9开始，G1成为jdk默认使用的垃圾回收器。</p><h4 id="G1回收器的特点"><a href="#G1回收器的特点" class="headerlink" title="G1回收器的特点"></a>G1回收器的特点</h4><ul><li>并行和并发: G1能够充分利用多核cpu的优势，使垃圾回收与用户线程同时运行。</li><li>可预测的停顿: 降低GC停顿时间是CMS与G1收集器的共同目标。但是除了降低GC停顿时间， G1收集器还可以建立可预测的停顿时间模型。(…太np了 =_=)</li><li>空间整合: 个人认为这是G1收集器不同于其他收集器的最大亮点了。 在其他收集器中，堆区基本都分为新生代和老年代。 而在G1收集器中虽然仍然保留了新生代和老年代的概念，但已经不再是物理上的分隔了。 <strong>在G1收集器的堆内存模型中，内存被分割成了一块一块大小相等的Region， 在这些Region中，Region的类型也不同，有eden，survivor，old，humongous之分。 当有大对象时，对象会被分配到Humongous Region之中。</strong></li></ul><p><img src="file://E:/%E5%B0%9A%E7%A1%85%E8%B0%B7java/JVMzhouyang/framework-learning/img/jdk-jvm-juc/G1%E6%94%B6%E9%9B%86%E5%99%A8Region.png?lastModify=1596340467" alt="G1收集器Region"></p><h4 id="G1收集器回收过程"><a href="#G1收集器回收过程" class="headerlink" title="G1收集器回收过程"></a>G1收集器回收过程</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">G1收集器与CMS收集器的回收过程相似</span><br></pre></td></tr></table></figure><ul><li>初始标记(Stop The World,此阶段会暂停用户线程): 只标记与GC ROOT直接关联的对象。</li><li>并发标记: 对第一个阶段标记的对象Tracing，标记所有可达的对象。</li><li>最终标记(Stop The World,此阶段会暂停用户线程): 在并发标记阶段，由于用户线程执行， 可能导致被标记对象之间的引用关系发生影响，需要对这些对象进行重新标记调整。</li><li>筛选回收: 不同于CMS的并发清除，G1收集器首先会对所有Region的回收价值和回收成本进行排序, 然后再进行回收。这样可以在有限的时间内获得最大的回收率。</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> *</span><br><span class="line"> * 因为我的机器的jdk版本是11,所以无需指定垃圾回收器</span><br><span class="line"> * 指定G1回收器的参数是: -XX:+UseG1GC</span><br><span class="line"> *</span><br><span class="line"> * 1:初始标记:(Stop the world 暂停用户线程)</span><br><span class="line"> *   标记所有与GC Root直接可达的对象</span><br><span class="line"> *</span><br><span class="line"> * 2:并发标记</span><br><span class="line"> *  从第一个阶段标记的对象开始,trace标记</span><br><span class="line"> *</span><br><span class="line"> * 4:最终标记:(Stop the world 暂停用户线程)</span><br><span class="line"> *  在第二步并发标记的阶段,由于程序执行,</span><br><span class="line"> *  导致被标记对象之间的引用关系发生变化,所以需要重新调整标记</span><br><span class="line"> *</span><br><span class="line"> * 5:筛选回收:</span><br><span class="line"> *  和CMS的并发回收不一样,</span><br><span class="line"> *  G1收集器首先会对所有Region的回收价值和回收成本进行排序,</span><br><span class="line"> *  然后再进行回收。</span><br><span class="line"> *  这样可以保证在有限的时间内获得最大的回收率.</span><br><span class="line"> *</span><br><span class="line"> *&#x2F;</span><br></pre></td></tr></table></figure><h2 id="JVM调优相关"><a href="#JVM调优相关" class="headerlink" title="JVM调优相关"></a>JVM调优相关</h2><h3 id="JVM常见参数"><a href="#JVM常见参数" class="headerlink" title="JVM常见参数"></a>JVM常见参数</h3><h4 id="堆栈相关"><a href="#堆栈相关" class="headerlink" title="堆栈相关"></a>堆栈相关</h4><ul><li>-Xss</li></ul><blockquote><p>调整线程栈大小。</p></blockquote><ul><li>-Xms</li></ul><blockquote><p>设置堆内存初始化大小。</p></blockquote><ul><li>-Xmx / -XX:MaxHeapSize=?</li></ul><blockquote><p>设置堆内存最大值。</p></blockquote><ul><li>-Xmn / -XX:NewSize=?</li></ul><blockquote><p>设置新生代大小。</p></blockquote><ul><li>-XX:NewRatio=?</li></ul><blockquote><p>设置老年代与新生代的空间占比。 如: -XX:NewRatio=2,那么老年代:新生代=2:1。</p></blockquote><ul><li>-XX:SurvivorRatio=?</li></ul><blockquote><p>设置eden与survivor的空间占比。 如: -XX:SurvivorRatio=2,那么eden:from survivor:to survivor=2:1:1</p></blockquote><ul><li>-XX:MetaspaceSize=? / -XX:PerGenSize=?</li></ul><blockquote><p>-XX:MetaspaceSize=9m 设置元空间的初始化大小为9m,此参数只在jdk8以后的版本有效。</p><p>-XX:PerGenSize=9m 设置永久代的初始化大小为9m，此参数只在jdk8以前的版本有效。</p></blockquote><ul><li>-XX:MaxMetaspaceSize=? / -XX:MaxPerGenSize=?</li></ul><blockquote><p>-XX:MaxMetaspaceSize=50m 设置元空间最大值为50m,此参数只在jdk8以后的版本有效。</p><p>-XX:MaxPerGenSize=50m 设置永久代的最大值为50m,此参数只在jdk8以前的版本有效。</p></blockquote><ul><li>-XX:+HeapDumpOnOutOfMemoryError</li></ul><blockquote><p>此参数使程序发生OOM时，dump错误堆栈信息。</p></blockquote><ul><li>-XX:HeapDumpPath=?</li></ul><blockquote><p>-XX:HeapDumpPath=/home/log 此参数指定发生OOM时，dump错误堆栈信息存放的日志文件或目录。 此参数只在 -XX:+HeapDumpOnOutOfMemoryError 开启时生效。</p></blockquote><h4 id="GC相关"><a href="#GC相关" class="headerlink" title="GC相关"></a>GC相关</h4><ul><li>-XX:+PrintGCDetails / -Xlog:gc*</li></ul><blockquote><p>打印GC的日志信息。 -Xlog:gc* 在我使用的版本(jdk11)是更受推荐的。</p></blockquote><ul><li>-XX:+TraceClassUnloading / -Xlog:class+unload=info</li></ul><blockquote><p>打印类卸载的日志信息。 -Xlog:class+unload=info 在我使用的版本(jdk11)是更受推荐的。</p></blockquote><ul><li>-XX:+UseSerialGC</li></ul><blockquote><p>使用Serial串行回收器。</p></blockquote><ul><li>-XX:+UseParallelGC</li></ul><blockquote><p>使用Parallel并行回收器。</p></blockquote><ul><li>-XX:ParallelGCThreads=?</li></ul><blockquote><p>设置并行收集的线程数,如-XX:ParallelGCThreads=5。</p></blockquote><ul><li>-XX:+UseConcMarkSweepGC</li></ul><blockquote><p>使用CMS收集器，它默认的新生代搜集器为ParNew。 可以与参数: -XX:+UseSerialGC 一起使用，就替换掉了ParNew， 使用Serial作为CMS的新生代收集器。</p></blockquote><ul><li>-XX:+UseG1GC</li></ul><blockquote><p>使用G1收集器。</p></blockquote><ul><li>-XX:MaxTenuringThreshold=?</li></ul><blockquote><p>设置新生代对象晋升到老年代的最大年龄阈值。</p></blockquote><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ul><li>-server / -client</li></ul><blockquote><p>-server:以服务端模式运行应用程序，server模式适用于服务端应用程序。 JVM在此模式下，会对服务端运行效率做很大优化。</p><p>-client:以客户端模式运行应用程序，client模式适用于客户端桌面程序(GUI)。 JVM在此模式下，会对客户端运行做很大优化。</p></blockquote><h3 id="Java常用调优命令和工具"><a href="#Java常用调优命令和工具" class="headerlink" title="Java常用调优命令和工具"></a>Java常用调优命令和工具</h3><ul><li>jps(个人认为非常重要)</li></ul><blockquote><p>jps 命令类似于 linux的 ps 命令，不过ps命令是用于查看系统进程的， 而jps用于查看当前系统运行的java进程。</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jps -q 只输出java进程id</span><br><span class="line">jps -l 输出java进程main函数的详细路径</span><br><span class="line">jps -v 输出java进程时指定的jvm参数</span><br><span class="line">jps -m 输出java进程执行时main函数的参数</span><br></pre></td></tr></table></figure><ul><li>jstat</li></ul><blockquote><p>jstat用于查看java进程的运行状态.</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jstat -class pid    用于查看java进程类的情况</span><br><span class="line">jstat -compiler pid 用于查看java进程编译的情况</span><br><span class="line">jstat -gc pid       用于查看java进程gc的情况</span><br></pre></td></tr></table></figure><ul><li>jinfo</li></ul><blockquote><p>jinfo 查看正在运行的java进程的jvm参数</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jinfo -flag MetaspaceSize pid  查看java进程的jvm的元空间大小</span><br><span class="line">jinfo -flag MaxHeapSize pid    查看java进程的jvm的最大堆的大小</span><br><span class="line">...</span><br></pre></td></tr></table></figure><ul><li>jmap</li></ul><blockquote><p>jmap 既可以dump java程序的快照，也可以查看对象的统计信息。</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jmap -heap pid               查看java进程堆的信息</span><br><span class="line">jmap -histo pid              查看java进程对象的信息</span><br><span class="line">jmap -dump:file&#x3D;filename pid 生成java进程jvm的堆快照到指定文件</span><br></pre></td></tr></table></figure><ul><li>jstack</li></ul><blockquote><p>jstack用于分析java线程栈信息</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jstack pid</span><br></pre></td></tr></table></figure><ul><li>jconsole</li></ul><blockquote><p>jconsole 是jdk提供的对java程序进行分析的GUI界面工具。</p></blockquote><h2 id="Jdk新特性"><a href="#Jdk新特性" class="headerlink" title="Jdk新特性"></a>Jdk新特性</h2><p>总结的不全，还请各位同学补充。</p><h3 id="Jdk8新特性"><a href="#Jdk8新特性" class="headerlink" title="Jdk8新特性"></a>Jdk8新特性</h3><ul><li>Lambda / 方法引用</li><li>接口新增default方法</li><li>Stream API</li><li>Optional API</li><li>新的时间API(java.time强烈推荐使用)</li><li>内置Base64工具</li></ul><h3 id="Jdk9新特性"><a href="#Jdk9新特性" class="headerlink" title="Jdk9新特性"></a>Jdk9新特性</h3><p>PS: jdk9应该是继jdk8之后，又一个重要的版本，后续jdk的迭代，都是基于jdk9来完成的。</p><ul><li>模块化: 模块化是jdk9或者说jdk8之后最大的改进，在jdk8及以前，jvm启动时，需要加载非常多的不需要的外部扩展类库，导致程序消耗的内存非常大， 并且在打包后，应用的归档包也是比较庞大。但是在模块化系统中，jvm只需要加载每个模块需要的类库，这就大大减少了jvm的开销。模块化的好处 当然不止我所说的这些，其中奥妙，还请各位同学实践出真知。</li><li>集合的工厂方法</li><li>try语句升级</li><li>接口新增private方法</li><li>响应式流(Doug Lea大师编写的，个人认为很重要，也是Webflux的基础)</li><li>JShell 交互式编程环境</li><li>String改为byte数组实现(记住这个特性)</li></ul><p>PS: String类在jdk9后的每个版本，好像都会新增一些API，这个不再重复。</p><h3 id="Jdk10新特性"><a href="#Jdk10新特性" class="headerlink" title="Jdk10新特性"></a>Jdk10新特性</h3><ul><li>var类型推断: 这一功能在其他语言中早有实现，比如我接触过的c++的auto,js中的var(当然，js并不是强类型语言)。 其实我个人认为此特性意义不是特别重大，因为java本身就是强类型语言，var只能使用于局部变量推断。如果大量使用var, 反而可能造成代码可读性下降。</li><li>集合工厂方法，使用集合工厂创建的集合是不可变的集合</li><li>移除javah(在编写本地jni库时，需要javah生成c/c++头文件，javah被移除了，说明另有他法来解决这个问题)。</li></ul><p>jdk10的特性还是有很多的，但是并没有像模块化这样大的改动。</p><h3 id="Jdk11新特性"><a href="#Jdk11新特性" class="headerlink" title="Jdk11新特性"></a>Jdk11新特性</h3><ul><li>java命令直接可以编译并运行java源文件</li><li>HttpClient: 长期以来，java类库之中只有一个HttpUrlConnection可以使用，且HttpUrlConnection使用起来较为麻烦。</li><li>Javascript引擎更换: Javascript引擎由Nashorn改为GraalVM。</li><li>String类新增了许多好用的API，如: strip,isBlank等。</li></ul><h3 id="Jdk12新特性"><a href="#Jdk12新特性" class="headerlink" title="Jdk12新特性"></a>Jdk12新特性</h3><ul><li>switch语法糖</li><li>Unicode11支持</li></ul><p>…</p><h3 id="Jdk13新特性"><a href="#Jdk13新特性" class="headerlink" title="Jdk13新特性"></a>Jdk13新特性</h3><ul><li>文本块</li><li>Socket API被重新实现</li></ul><h3 id="Jdk14新特性"><a href="#Jdk14新特性" class="headerlink" title="Jdk14新特性"></a>Jdk14新特性</h3><ul><li>instanceof 模式匹配</li><li>Record结构(实用)</li><li><strong>CMS收集器被删除了。</strong></li><li>Parallel Scavenge 和 Serial Old这对组合被弃用了。(我觉着也是，本来Parallel Scavenge和Parallel Old， Serial和Serial Old这两对收集器各自搭配的挺好，Parallel Scavenge非要脚踏两只船)</li></ul><p>展望: ZGC是11中引入的一款新的垃圾回收器。G1收集器本身已经很高效了，但是停顿时间这一块缺陷是所有收集器的缺点， 而ZGC不仅对停顿时间这个缺点做了大量优化，也提供了非常多当高级功能。 似乎ZGC的到来，是要主宰Java GC的未来了。。。</p><p>关于ZGC可以参考这篇文章: <a href="https://juejin.im/entry/5b86a276f265da435c4402d4" target="_blank" rel="noopener"><a href="https://juejin.im/entry/5b86a276f265da435c4402d4" target="_blank" rel="noopener">ZGC - 掘金</a></a></p>]]></content>
    
    <summary type="html">
    
      JVM和JUC复习
    
    </summary>
    
    
      <category term="java" scheme="https://SomunsTao.github.io/categories/java/"/>
    
    
      <category term="java" scheme="https://SomunsTao.github.io/tags/java/"/>
    
  </entry>
  
</feed>
