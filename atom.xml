<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Somuns ` Tao</title>
  
  <subtitle>Java Blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://somunstao.github.io/"/>
  <updated>2020-05-01T02:17:04.419Z</updated>
  <id>https://somunstao.github.io/</id>
  
  <author>
    <name>陈涛</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SpringBoot：自动配置解析</title>
    <link href="https://somunstao.github.io/2020/05/03/SpringBoot21%EF%BC%9A%20%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE/"/>
    <id>https://somunstao.github.io/2020/05/03/SpringBoot21%EF%BC%9A%20%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE/</id>
    <published>2020-05-02T16:00:00.000Z</published>
    <updated>2020-05-01T02:17:04.419Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://p99.pstatp.com/large/pgc-image/15367619528862cca2a0df9" alt="img"></p><p>原文链接：<a href="https://www.cnblogs.com/leihuazhe/p/7743479.html" target="_blank" rel="noopener">https://www.cnblogs.com/leihuazhe/p/7743479.html</a></p><hr><hr><blockquote><p>SpringBoot 自动配置主要通过 <code>@EnableAutoConfiguration</code>, <code>@Conditional</code>, <code>@EnableConfigurationProperties</code> 或者 <code>@ConfigurationProperties</code> 等几个注解来进行自动配置完成的。</p><p><code>@EnableAutoConfiguration</code> 开启自动配置，主要作用就是调用 <code>Spring-Core</code> 包里的 <code>loadFactoryNames()</code>，将 <code>autoconfig</code> 包里的已经写好的自动配置加载进来。</p><p><code>@Conditional</code> 条件注解，通过判断类路径下有没有相应配置的 <code>jar</code> 包来确定是否加载和自动配置这个类。</p><p><code>@EnableConfigurationProperties</code> 的作用就是，给自动配置提供具体的配置参数，只需要写在 <code>application.properties</code> 中，就可以通过映射写入配置类的 <code>POJO</code> 属性中。</p></blockquote><h3 id="EnableAutoConfiguration"><a href="#EnableAutoConfiguration" class="headerlink" title="@EnableAutoConfiguration"></a>@EnableAutoConfiguration</h3><p>@Enable*注释并不是<code>SpringBoot</code>新发明的注释，Spring 3框架就引入了这些注释，用这些注释替代XML配置文件。比如：<br><code>@EnableTransactionManagement</code>注释，它能够声明事务管理<br><code>@EnableWebMvc</code>注释，它能启用Spring MVC<br><code>@EnableScheduling</code>注释，它可以初始化一个调度器。</p><h4 id="这些注释事实上都是简单的配置，通过-Import注释导入。"><a href="#这些注释事实上都是简单的配置，通过-Import注释导入。" class="headerlink" title="这些注释事实上都是简单的配置，通过@Import注释导入。"></a><strong>这些注释事实上都是简单的配置，通过<code>@Import</code>注释导入</strong>。</h4><h5 id="从启动类的-SpringBootApplication进入，在里面找到了-EnableAutoConfiguration"><a href="#从启动类的-SpringBootApplication进入，在里面找到了-EnableAutoConfiguration" class="headerlink" title="从启动类的@SpringBootApplication进入，在里面找到了@EnableAutoConfiguration,"></a>从启动类的@SpringBootApplication进入，在里面找到了@EnableAutoConfiguration,</h5><p><img src="http://pic.hzways.com/1.png" alt="1.png"></p><p><img src="http://pic.hzways.com/2.png" alt="2.png"></p><h5 id="EnableAutoConfiguration里通过-Import导入了EnableAutoConfigurationImportSelector"><a href="#EnableAutoConfiguration里通过-Import导入了EnableAutoConfigurationImportSelector" class="headerlink" title="@EnableAutoConfiguration里通过@Import导入了EnableAutoConfigurationImportSelector,"></a>@EnableAutoConfiguration里通过@Import导入了<code>EnableAutoConfigurationImportSelector</code>,</h5><p><img src="http://pic.hzways.com/3.png" alt="3.png"></p><h5 id="进入他的父类AutoConfigurationImportSelector"><a href="#进入他的父类AutoConfigurationImportSelector" class="headerlink" title="进入他的父类AutoConfigurationImportSelector"></a>进入他的父类<code>AutoConfigurationImportSelector</code></h5><p><img src="http://pic.hzways.com/4.png" alt="4.png"></p><h5 id="找到selectImports-方法，他调用了getCandidateConfigurations-方法，在这里，这个方法又调用了Spring-Core包中的loadFactoryNames-方法。这个方法的作用是，会查询META-INF-spring-factories文件中包含的JAR文件。"><a href="#找到selectImports-方法，他调用了getCandidateConfigurations-方法，在这里，这个方法又调用了Spring-Core包中的loadFactoryNames-方法。这个方法的作用是，会查询META-INF-spring-factories文件中包含的JAR文件。" class="headerlink" title="找到selectImports()方法，他调用了getCandidateConfigurations()方法，在这里，这个方法又调用了Spring Core包中的loadFactoryNames()方法。这个方法的作用是，会查询META-INF/spring.factories文件中包含的JAR文件。"></a>找到<code>selectImports()</code>方法，他调用了<code>getCandidateConfigurations()</code>方法，在这里，这个方法又调用了Spring Core包中的<code>loadFactoryNames()</code>方法。这个方法的作用是，会查询<code>META-INF/spring.factories</code>文件中包含的<code>JAR</code>文件。</h5><p><img src="http://pic.hzways.com/5.png" alt="5.png"></p><h5 id="当找到spring-factories文件后，SpringFactoriesLoader将查询配置文件命名的属性。"><a href="#当找到spring-factories文件后，SpringFactoriesLoader将查询配置文件命名的属性。" class="headerlink" title="当找到spring.factories文件后，SpringFactoriesLoader将查询配置文件命名的属性。"></a>当找到spring.factories文件后，SpringFactoriesLoader将查询配置文件命名的属性。</h5><p><img src="http://pic.hzways.com/6.png" alt="6.png"></p><p><img src="http://pic.hzways.com/7.png" alt="7.png"></p><h5 id="Jar文件在org-springframework-boot-autoconfigure的spring-factories"><a href="#Jar文件在org-springframework-boot-autoconfigure的spring-factories" class="headerlink" title="Jar文件在org.springframework.boot.autoconfigure的spring.factories"></a><code>Jar</code>文件在<code>org.springframework.boot.autoconfigure的spring.factories</code></h5><p><img src="http://pic.hzways.com/8.png" alt="8.png"></p><h5 id="spring-factories内容如下-截取部分-在这个文件中，可以看到一系列Spring-Boot自动配置的列表"><a href="#spring-factories内容如下-截取部分-在这个文件中，可以看到一系列Spring-Boot自动配置的列表" class="headerlink" title="spring.factories内容如下(截取部分),在这个文件中，可以看到一系列Spring Boot自动配置的列表"></a><code>spring.factories</code>内容如下(截取部分),在这个文件中，可以看到一系列Spring Boot自动配置的列表</h5><figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="meta">org.springframework.boot.autoconfigure.EnableAutoConfiguration</span>=<span class="string">\</span></span><br><span class="line">org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.cloud.CloudAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.context.MessageSourceAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.couchbase.CouchbaseAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.dao.PersistenceExceptionTranslationAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.cassandra.CassandraDataAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.cassandra.CassandraRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.couchbase.CouchbaseDataAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.couchbase.CouchbaseRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchDataAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.jpa.JpaRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.ldap.LdapDataAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.ldap.LdapRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.mongo.MongoDataAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.mongo.MongoRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.neo4j.Neo4jDataAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.neo4j.Neo4jRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.solr.SolrRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.redis.RedisRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.rest.RepositoryRestMvcAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.web.SpringDataWebAutoConfiguration,\</span><br></pre></td></tr></table></figure><h3 id="下面我们来看自动配置redis的细节，RedisAutoConfiguration："><a href="#下面我们来看自动配置redis的细节，RedisAutoConfiguration：" class="headerlink" title="下面我们来看自动配置redis的细节，RedisAutoConfiguration："></a>下面我们来看自动配置redis的细节，RedisAutoConfiguration：</h3><h3 id="RedisAutoConfiguration"><a href="#RedisAutoConfiguration" class="headerlink" title="RedisAutoConfiguration"></a>RedisAutoConfiguration</h3><p><img src="http://pic.hzways.com/redis.png" alt="redis.png"></p><p>这个类进行了简单的Spring配置，声明了Redis所需典型Bean，和其它很多类一样，重度依赖于Spring Boot注释：<br>1）@ConditionOnClass激活一个配置，当类路径中存在这个类时才会配置该类<br>2）@EnableConfigurationProperties自动映射一个POJO到Spring Boot配置文件（默认是application.properties文件）的属性集。<br>3）@ConditionalOnMissingBean启用一个Bean定义，但必须是这个Bean之前未定义过才有效。<br>还可以使用@ AutoConfigureBefore注释、@AutoConfigureAfter注释来定义这些配置类的载入顺序。</p><h4 id="着重了解-Conditional注释，Spring-4框架的新特性"><a href="#着重了解-Conditional注释，Spring-4框架的新特性" class="headerlink" title="着重了解@Conditional注释，Spring 4框架的新特性"></a>着重了解@Conditional注释，Spring 4框架的新特性</h4><p>此注释使得只有在特定条件满足时才启用一些配置。SrpingBoot的AutoConfig大量使用了@Conditional，它会根据运行环境来动态注入Bean。这里介绍一些@Conditional的使用和原理，并自定义@Conditional来自定义功能。</p><ul><li>@Conditional是SpringFramework的功能，SpringBoot在它的基础上定义了</li><li>@ConditionalOnClass，@ConditionalOnProperty等一系列的注解来实现更丰富的内容。</li></ul><h4 id="具体几个-Conditon-注解的含义"><a href="#具体几个-Conditon-注解的含义" class="headerlink" title="具体几个@Conditon*注解的含义"></a>具体几个@Conditon*注解的含义</h4><h6 id="ConditionalOnBean"><a href="#ConditionalOnBean" class="headerlink" title="@ConditionalOnBean"></a>@ConditionalOnBean</h6><p>仅仅在当前上下文中存在某个对象时，才会实例化一个Bean</p><h6 id="ConditionalOnClass"><a href="#ConditionalOnClass" class="headerlink" title="@ConditionalOnClass"></a>@ConditionalOnClass</h6><p>某个class位于类路径上，才会实例化一个Bean)，该注解的参数对应的类必须存在，否则不解析该注解修饰的配置类</p><h6 id="ConditionalOnExpression"><a href="#ConditionalOnExpression" class="headerlink" title="@ConditionalOnExpression"></a>@ConditionalOnExpression</h6><p>当表达式为true的时候，才会实例化一个Bean</p><h6 id="ConditionalOnMissingBean"><a href="#ConditionalOnMissingBean" class="headerlink" title="@ConditionalOnMissingBean"></a>@ConditionalOnMissingBean</h6><p>仅仅在当前上下文中不存在某个对象时，才会实例化一个Bean，该注解表示，如果存在它修饰的类的bean，则不需要再创建这个bean，可以给该注解传入参数例如@ConditionOnMissingBean(name = “example”)，这个表示如果name为“example”的bean存在，这该注解修饰的代码块不执行</p><h6 id="ConditionalOnMissingClass"><a href="#ConditionalOnMissingClass" class="headerlink" title="@ConditionalOnMissingClass"></a>@ConditionalOnMissingClass</h6><p>某个class类路径上不存在的时候，才会实例化一个Bean</p><h6 id="ConditionalOnNotWebApplication"><a href="#ConditionalOnNotWebApplication" class="headerlink" title="@ConditionalOnNotWebApplication"></a>@ConditionalOnNotWebApplication</h6><p>不是web应用时，才会执行</p><hr><h3 id="2-Properties系列注释"><a href="#2-Properties系列注释" class="headerlink" title="2.Properties系列注释"></a>2.Properties系列注释</h3><p>@EnableConfigurationProperties<br>@ConfigurationProperties(prefix = “may”)</p><p>在需要注入配置的类上加上这个注解，prefix的意思是，以该前缀打头的配置，以下是例子</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"may"</span>)  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> String name;  </span><br><span class="line">    <span class="keyword">private</span> String gender;  </span><br><span class="line">    </span><br><span class="line">   <span class="comment">//省略setter,getter方法</span></span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>application.yml中的配置</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">may</span><br><span class="line">   name: youjie</span><br><span class="line">   gender: man</span><br></pre></td></tr></table></figure><p>如果不用系统初始的application.yml配置类，而是使用自己的如youjie.yml，可以如下配置</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"may"</span>,locations = <span class="string">"classpath:youjie.yml"</span>)  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User2</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> String name;  </span><br><span class="line">    <span class="keyword">private</span> String gender;  </span><br><span class="line">    </span><br><span class="line">   <span class="comment">//省略setter,getter方法</span></span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>过时：由于Spring-boot 1.5.2版本移除了，locations这个属性,因此上述这种方式在最新的版本中过时。<br>@PropertySource</p><p>Spring-boot 1.5.2版本之后，采用下面这种方式</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="comment">//@PropertySource只能加载.properties文件，需要将上面的yml文件，改为.properties文件</span></span><br><span class="line"><span class="meta">@PropertySource</span>(<span class="string">"classpath:may.properties"</span>)</span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix=<span class="string">"may"</span>) </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User2</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">private</span> String name;  </span><br><span class="line">        <span class="keyword">private</span> String gender;  </span><br><span class="line">        </span><br><span class="line">       <span class="comment">//省略setter,getter方法</span></span><br><span class="line">      </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>@EnableConfigurationProperties</p><p>最后注意在spring Boot入口类加上@EnableConfigurationProperties</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span>  </span><br><span class="line"><span class="meta">@EnableConfigurationProperties</span>(&#123;User<span class="class">.<span class="keyword">class</span>,<span class="title">User2</span>.<span class="title">class</span>&#125;)  </span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">DemoApplication</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        SpringApplication.run(DemoApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实这里@EnableConfigurationProperties({User.class,User2.class}) 可以省略</p><p><img src="http://pic.hzways.com/config.png" alt="config.png"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>SpringBoot 的 自动配置得益于 SpringFramework 强大的支撑，框架早已有很多工具和注解可以自动装配 Bean 。SpringBoot 通过 一个封装，将市面上通用的组件直接写好了配置类。当我们程序去依赖了这些组件的 jar 包后，启动 SpringBoot应用，于是自动加载开始了。</p><p>我们也可以定义自己的自动装配组件，依赖之后，Spring直接可以加载我们定义的 starter 。笔者将在后续文章中进行编码和解读。</p>]]></content>
    
    <summary type="html">
    
      you can &quot;just run&quot;
    
    </summary>
    
    
      <category term="SpringBoot" scheme="https://SomunsTao.github.io/categories/SpringBoot/"/>
    
    
      <category term="SpringBoot" scheme="https://SomunsTao.github.io/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot：启动原理解析</title>
    <link href="https://somunstao.github.io/2020/05/03/SpringBoot21%EF%BC%9A%E5%90%AF%E5%8A%A8%E5%8E%9F%E7%90%86/"/>
    <id>https://somunstao.github.io/2020/05/03/SpringBoot21%EF%BC%9A%E5%90%AF%E5%8A%A8%E5%8E%9F%E7%90%86/</id>
    <published>2020-05-02T16:00:00.000Z</published>
    <updated>2020-05-01T05:05:32.289Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://p99.pstatp.com/large/pgc-image/15367619528862cca2a0df9" alt="img"></p><p>原文链接：<a href="https://www.cnblogs.com/xiaoxi/p/7999885.html" target="_blank" rel="noopener">https://www.cnblogs.com/xiaoxi/p/7999885.html</a></p><p>原作者：平凡希</p><hr><hr><h1 id="spring-boot：启动原理解析"><a href="#spring-boot：启动原理解析" class="headerlink" title="spring boot：启动原理解析"></a><a href="https://www.cnblogs.com/xiaoxi/p/7999885.html" target="_blank" rel="noopener">spring boot：启动原理解析</a></h1><p>我们开发任何一个Spring Boot项目，都会用到如下的启动类</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 @SpringBootApplication</span><br><span class="line">2 public class Application &#123;</span><br><span class="line">3     public static void main(String[] args) &#123;</span><br><span class="line">4         SpringApplication.run(Application.class, args);</span><br><span class="line">5     &#125;</span><br><span class="line">6 &#125;</span><br></pre></td></tr></table></figure><p>从上面代码可以看出，Annotation定义（@SpringBootApplication）和类定义（SpringApplication.run）最为耀眼，所以要揭开SpringBoot的神秘面纱，我们要从这两位开始就可以了。</p><p><strong>一、SpringBootApplication背后的秘密</strong></p><p>@SpringBootApplication注解是Spring Boot的核心注解，它其实是一个组合注解：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 1 @Target(ElementType.TYPE)</span><br><span class="line"> 2 @Retention(RetentionPolicy.RUNTIME)</span><br><span class="line"> 3 @Documented</span><br><span class="line"> 4 @Inherited</span><br><span class="line"> 5 @SpringBootConfiguration</span><br><span class="line"> 6 @EnableAutoConfiguration</span><br><span class="line"> 7 @ComponentScan(excludeFilters &#x3D; &#123;</span><br><span class="line"> 8         @Filter(type &#x3D; FilterType.CUSTOM, classes &#x3D; TypeExcludeFilter.class),</span><br><span class="line"> 9         @Filter(type &#x3D; FilterType.CUSTOM, classes &#x3D; AutoConfigurationExcludeFilter.class) &#125;)</span><br><span class="line">10 public @interface SpringBootApplication &#123;</span><br><span class="line">11 ...</span><br><span class="line">12 &#125;</span><br></pre></td></tr></table></figure><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>虽然定义使用了多个Annotation进行了原信息标注，但实际上重要的只有三个Annotation：</p><ul><li>@Configuration（@SpringBootConfiguration点开查看发现里面还是应用了@Configuration）</li><li>@EnableAutoConfiguration</li><li>@ComponentScan</li></ul><p>即 @SpringBootApplication = (默认属性)@Configuration + @EnableAutoConfiguration + @ComponentScan。</p><p>所以，如果我们使用如下的SpringBoot启动类，整个SpringBoot应用依然可以与之前的启动类功能对等：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 @Configuration</span><br><span class="line">2 @EnableAutoConfiguration</span><br><span class="line">3 @ComponentScan</span><br><span class="line">4 public class Application &#123;</span><br><span class="line">5     public static void main(String[] args) &#123;</span><br><span class="line">6         SpringApplication.run(Application.class, args);</span><br><span class="line">7     &#125;</span><br><span class="line">8 &#125;</span><br></pre></td></tr></table></figure><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>每次写这3个比较累，所以写一个@SpringBootApplication方便点。接下来分别介绍这3个Annotation。</p><p><strong>1、@Configuration</strong></p><p>   这里的@Configuration对我们来说不陌生，它就是JavaConfig形式的Spring Ioc容器的配置类使用的那个@Configuration，SpringBoot社区推荐使用基于JavaConfig的配置形式，所以，这里的启动类标注了@Configuration之后，本身其实也是一个IoC容器的配置类。</p><p>举几个简单例子回顾下，XML跟config配置方式的区别：</p><p><strong>（1）表达形式层面</strong></p><p>基于XML配置的方式是这样：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 &lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">2 &lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">3        xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">4        xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans-3.0.xsd&quot;</span><br><span class="line">5        default-lazy-init&#x3D;&quot;true&quot;&gt;</span><br><span class="line">6     &lt;!--bean定义--&gt;</span><br><span class="line">7 &lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>而基于JavaConfig的配置方式是这样：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 @Configuration</span><br><span class="line">2 public class MockConfiguration&#123;</span><br><span class="line">3     &#x2F;&#x2F;bean定义</span><br><span class="line">4 &#125;</span><br></pre></td></tr></table></figure><p>任何一个标注了@Configuration的Java类定义都是一个JavaConfig配置类。</p><p><strong>（2）注册bean定义层面</strong></p><p>基于XML的配置形式是这样：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 &lt;bean id&#x3D;&quot;mockService&quot; class&#x3D;&quot;..MockServiceImpl&quot;&gt;</span><br><span class="line">2     ...</span><br><span class="line">3 &lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure><p>而基于JavaConfig的配置形式是这样的：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 @Configuration</span><br><span class="line">2 public class MockConfiguration&#123;</span><br><span class="line">3     @Bean</span><br><span class="line">4     public MockService mockService()&#123;</span><br><span class="line">5         return new MockServiceImpl();</span><br><span class="line">6     &#125;</span><br><span class="line">7 &#125;</span><br></pre></td></tr></table></figure><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>任何一个标注了@Bean的方法，其返回值将作为一个bean定义注册到Spring的IoC容器，方法名将默认成该bean定义的id。</p><p><strong>（3）表达依赖注入关系层面</strong></p><p>为了表达bean与bean之间的依赖关系，在XML形式中一般是这样：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 &lt;bean id&#x3D;&quot;mockService&quot; class&#x3D;&quot;..MockServiceImpl&quot;&gt;</span><br><span class="line">2     &lt;propery name &#x3D;&quot;dependencyService&quot; ref&#x3D;&quot;dependencyService&quot; &#x2F;&gt;</span><br><span class="line">3 &lt;&#x2F;bean&gt;</span><br><span class="line">4 </span><br><span class="line">5 &lt;bean id&#x3D;&quot;dependencyService&quot; class&#x3D;&quot;DependencyServiceImpl&quot;&gt;&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure><p>而基于JavaConfig的配置形式是这样的：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 1 @Configuration</span><br><span class="line"> 2 public class MockConfiguration&#123;</span><br><span class="line"> 3     @Bean</span><br><span class="line"> 4     public MockService mockService()&#123;</span><br><span class="line"> 5         return new MockServiceImpl(dependencyService());</span><br><span class="line"> 6     &#125;</span><br><span class="line"> 7     </span><br><span class="line"> 8     @Bean</span><br><span class="line"> 9     public DependencyService dependencyService()&#123;</span><br><span class="line">10         return new DependencyServiceImpl();</span><br><span class="line">11     &#125;</span><br><span class="line">12 &#125;</span><br></pre></td></tr></table></figure><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>如果一个bean的定义依赖其他bean，则直接调用对应的JavaConfig类中依赖bean的创建方法就可以了。</p><hr><p>@Configuration：提到@Configuration就要提到他的搭档@Bean。使用这两个注解就可以创建一个简单的spring配置类，可以用来替代相应的xml配置文件。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 &lt;beans&gt; </span><br><span class="line">2     &lt;bean id &#x3D; &quot;car&quot; class&#x3D;&quot;com.test.Car&quot;&gt; </span><br><span class="line">3         &lt;property name&#x3D;&quot;wheel&quot; ref &#x3D; &quot;wheel&quot;&gt;&lt;&#x2F;property&gt; </span><br><span class="line">4     &lt;&#x2F;bean&gt; </span><br><span class="line">5     &lt;bean id &#x3D; &quot;wheel&quot; class&#x3D;&quot;com.test.Wheel&quot;&gt;&lt;&#x2F;bean&gt; </span><br><span class="line">6 &lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure><p>相当于：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 1 @Configuration </span><br><span class="line"> 2 public class Conf &#123; </span><br><span class="line"> 3     @Bean </span><br><span class="line"> 4     public Car car() &#123; </span><br><span class="line"> 5         Car car &#x3D; new Car(); </span><br><span class="line"> 6         car.setWheel(wheel()); </span><br><span class="line"> 7         return car; </span><br><span class="line"> 8     &#125;</span><br><span class="line"> 9     </span><br><span class="line">10     @Bean </span><br><span class="line">11     public Wheel wheel() &#123; </span><br><span class="line">12         return new Wheel(); </span><br><span class="line">13     &#125; </span><br><span class="line">14 &#125;</span><br></pre></td></tr></table></figure><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>@Configuration的注解类标识这个类可以使用Spring IoC容器作为bean定义的来源。</p><p>@Bean注解告诉Spring，一个带有@Bean的注解方法将返回一个对象，该对象应该被注册为在Spring应用程序上下文中的bean。</p><p><strong>2、@ComponentScan</strong></p><p>   @ComponentScan这个注解在Spring中很重要，它对应XML配置中的元素，@ComponentScan的功能其实就是自动扫描并加载符合条件的组件（比如@Component和@Repository等）或者bean定义，最终将这些bean定义加载到IoC容器中。</p><p>   我们可以通过basePackages等属性来细粒度的定制@ComponentScan自动扫描的范围，如果不指定，则默认Spring框架实现会从声明@ComponentScan所在类的package进行扫描。</p><p>注：所以SpringBoot的启动类最好是放在root package下，因为默认不指定basePackages。</p><p><strong>3、@EnableAutoConfiguration</strong></p><p>  个人感觉@EnableAutoConfiguration这个Annotation最为重要，所以放在最后来解读，大家是否还记得Spring框架提供的各种名字为@Enable开头的Annotation定义？比如@EnableScheduling、@EnableCaching、@EnableMBeanExport等，@EnableAutoConfiguration的理念和做事方式其实一脉相承，简单概括一下就是，<strong>借助@Import的支持，收集和注册特定场景相关的bean定义。</strong></p><ul><li>@EnableScheduling是通过@Import将Spring调度框架相关的bean定义都加载到IoC容器。</li><li>@EnableMBeanExport是通过@Import将JMX相关的bean定义加载到IoC容器。</li></ul><p>而@EnableAutoConfiguration也是借助@Import的帮助，将所有符合自动配置条件的bean定义加载到IoC容器，仅此而已！</p><p>  @EnableAutoConfiguration会根据类路径中的jar依赖为项目进行自动配置，如：添加了spring-boot-starter-web依赖，会自动添加Tomcat和Spring MVC的依赖，Spring Boot会对Tomcat和Spring MVC进行自动配置。</p><p><img src="https://images2017.cnblogs.com/blog/249993/201712/249993-20171207162607144-677920507.png" alt="img"></p><p> @EnableAutoConfiguration作为一个复合Annotation，其自身定义关键信息如下：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 1 @SuppressWarnings(&quot;deprecation&quot;)</span><br><span class="line"> 2 @Target(ElementType.TYPE)</span><br><span class="line"> 3 @Retention(RetentionPolicy.RUNTIME)</span><br><span class="line"> 4 @Documented</span><br><span class="line"> 5 @Inherited</span><br><span class="line"> 6 @AutoConfigurationPackage</span><br><span class="line"> 7 @Import(EnableAutoConfigurationImportSelector.class)</span><br><span class="line"> 8 public @interface EnableAutoConfiguration &#123;</span><br><span class="line"> 9     ...</span><br><span class="line">10 &#125;</span><br></pre></td></tr></table></figure><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>  其中，最关键的要属@Import(EnableAutoConfigurationImportSelector.class)，借助EnableAutoConfigurationImportSelector，@EnableAutoConfiguration可以帮助SpringBoot应用将所有符合条件的@Configuration配置都加载到当前SpringBoot创建并使用的IoC容器。就像一只“八爪鱼”一样，借助于Spring框架原有的一个工具类：SpringFactoriesLoader的支持，@EnableAutoConfiguration可以智能的自动配置功效才得以大功告成！</p><p><img src="https://images2017.cnblogs.com/blog/249993/201712/249993-20171207163759488-1739516792.png" alt="img"></p><p><strong>自动配置幕后英雄：SpringFactoriesLoader详解</strong></p><p>SpringFactoriesLoader属于Spring框架私有的一种扩展方案，其主要功能就是从指定的配置文件META-INF/spring.factories加载配置。</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 1 public abstract class SpringFactoriesLoader &#123;</span><br><span class="line"> 2     &#x2F;&#x2F;...</span><br><span class="line"> 3     public static &lt;T&gt; List&lt;T&gt; loadFactories(Class&lt;T&gt; factoryClass, ClassLoader classLoader) &#123;</span><br><span class="line"> 4         ...</span><br><span class="line"> 5     &#125;</span><br><span class="line"> 6 </span><br><span class="line"> 7 </span><br><span class="line"> 8     public static List&lt;String&gt; loadFactoryNames(Class&lt;?&gt; factoryClass, ClassLoader classLoader) &#123;</span><br><span class="line"> 9         ....</span><br><span class="line">10     &#125;</span><br><span class="line">11 &#125;</span><br></pre></td></tr></table></figure><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>配合@EnableAutoConfiguration使用的话，它更多是提供一种配置查找的功能支持，即根据@EnableAutoConfiguration的完整类名org.springframework.boot.autoconfigure.EnableAutoConfiguration作为查找的Key，获取对应的一组@Configuration类。</p><p><img src="https://images2017.cnblogs.com/blog/249993/201712/249993-20171208161556484-1145877030.jpg" alt="img"></p><p>上图就是从SpringBoot的autoconfigure依赖包中的META-INF/spring.factories配置文件中摘录的一段内容，可以很好地说明问题。</p><p>所以，@EnableAutoConfiguration自动配置的魔法骑士就变成了：<strong>从classpath中搜寻所有的META-INF/spring.factories配置文件，并将其中org.springframework.boot.autoconfigure.EnableutoConfiguration对应的配置项通过反射（Java Refletion）实例化为对应的标注了@Configuration的JavaConfig形式的IoC容器配置类，然后汇总为一个并加载到IoC容器。</strong></p><p><strong>二、深入探索SpringApplication执行流程</strong></p><p>SpringApplication的run方法的实现是我们本次旅程的主要线路，该方法的主要流程大体可以归纳如下：</p><p>1） 如果我们使用的是SpringApplication的静态run方法，那么，这个方法里面首先要创建一个SpringApplication对象实例，然后调用这个创建好的SpringApplication的实例方法。在SpringApplication实例初始化的时候，它会提前做几件事情：</p><ul><li>根据classpath里面是否存在某个特征类（org.springframework.web.context.ConfigurableWebApplicationContext）来决定是否应该创建一个为Web应用使用的ApplicationContext类型。</li><li>使用SpringFactoriesLoader在应用的classpath中查找并加载所有可用的ApplicationContextInitializer。</li><li>使用SpringFactoriesLoader在应用的classpath中查找并加载所有可用的ApplicationListener。</li><li>推断并设置main方法的定义类。</li></ul><p>2） SpringApplication实例初始化完成并且完成设置后，就开始执行run方法的逻辑了，方法执行伊始，首先遍历执行所有通过SpringFactoriesLoader可以查找到并加载的SpringApplicationRunListener。调用它们的started()方法，告诉这些SpringApplicationRunListener，“嘿，SpringBoot应用要开始执行咯！”。</p><p>3） 创建并配置当前Spring Boot应用将要使用的Environment（包括配置要使用的PropertySource以及Profile）。</p><p>4） 遍历调用所有SpringApplicationRunListener的environmentPrepared()的方法，告诉他们：“当前SpringBoot应用使用的Environment准备好了咯！”。</p><p>5） 如果SpringApplication的showBanner属性被设置为true，则打印banner。</p><p>6） 根据用户是否明确设置了applicationContextClass类型以及初始化阶段的推断结果，决定该为当前SpringBoot应用创建什么类型的ApplicationContext并创建完成，然后根据条件决定是否添加ShutdownHook，决定是否使用自定义的BeanNameGenerator，决定是否使用自定义的ResourceLoader，当然，最重要的，将之前准备好的Environment设置给创建好的ApplicationContext使用。</p><p>7） ApplicationContext创建好之后，SpringApplication会再次借助Spring-FactoriesLoader，查找并加载classpath中所有可用的ApplicationContext-Initializer，然后遍历调用这些ApplicationContextInitializer的initialize（applicationContext）方法来对已经创建好的ApplicationContext进行进一步的处理。</p><p>8） 遍历调用所有SpringApplicationRunListener的contextPrepared()方法。</p><p>9） 最核心的一步，将之前通过@EnableAutoConfiguration获取的所有配置以及其他形式的IoC容器配置加载到已经准备完毕的ApplicationContext。</p><p>10） 遍历调用所有SpringApplicationRunListener的contextLoaded()方法。</p><p>11） 调用ApplicationContext的refresh()方法，完成IoC容器可用的最后一道工序。</p><p>12） 查找当前ApplicationContext中是否注册有CommandLineRunner，如果有，则遍历执行它们。</p><p>13） 正常情况下，遍历执行SpringApplicationRunListener的finished()方法、（如果整个过程出现异常，则依然调用所有SpringApplicationRunListener的finished()方法，只不过这种情况下会将异常信息一并传入处理）</p><p>去除事件通知点后，整个流程如下：</p><p><img src="https://images2017.cnblogs.com/blog/249993/201712/249993-20171212151321051-993064506.jpg" alt="img"></p><hr><p>本文以调试一个实际的SpringBoot启动程序为例，参考流程中主要类类图，来分析其启动逻辑和自动化配置原理。</p><p><img src="https://images2017.cnblogs.com/blog/249993/201712/249993-20171213142128051-351399772.png" alt="img"></p><p><strong>总览：</strong>   </p><p>  上图为SpringBoot启动结构图，我们发现启动流程主要分为三个部分，第一部分进行SpringApplication的初始化模块，配置一些基本的环境变量、资源、构造器、监听器，第二部分实现了应用具体的启动方案，包括启动流程的监听模块、加载配置环境模块、及核心的创建上下文环境模块，第三部分是自动化配置模块，该模块作为springboot自动配置核心，在后面的分析中会详细讨论。在下面的启动程序中我们会串联起结构中的主要功能。</p><p><strong>启动：</strong></p><p>   每个SpringBoot程序都有一个主入口，也就是main方法，main里面调用SpringApplication.run()启动整个spring-boot程序，该方法所在类需要使用@SpringBootApplication注解，以及@ImportResource注解(if need)，@SpringBootApplication包括三个注解，功能如下：</p><p>@EnableAutoConfiguration：SpringBoot根据应用所声明的依赖来对Spring框架进行自动配置。</p><p>@SpringBootConfiguration(内部为@Configuration)：被标注的类等于在spring的XML配置文件中(applicationContext.xml)，装配所有bean事务，提供了一个spring的上下文环境。</p><p>@ComponentScan：组件扫描，可自动发现和装配Bean，默认扫描SpringApplication的run方法里的Booter.class所在的包路径下文件，所以最好将该启动类放到根包路径下。</p><p><img src="https://images2017.cnblogs.com/blog/249993/201712/249993-20171213143558363-1466265945.png" alt="img"></p><p><strong>SpringBoot启动类</strong></p><p>首先进入run方法</p><p><img src="https://images2017.cnblogs.com/blog/249993/201712/249993-20171213144051754-1827098906.png" alt="img"></p><p>run方法中去创建了一个SpringApplication实例，在该构造方法内，我们可以发现其调用了一个初始化的initialize方法</p><p><img src="https://images2017.cnblogs.com/blog/249993/201712/249993-20171213144232926-834887500.png" alt="img"></p><p><img src="https://images2017.cnblogs.com/blog/249993/201712/249993-20171213144259160-129693850.png" alt="img"></p><p>这里主要是为SpringApplication对象赋一些初值。构造函数执行完毕后，我们回到run方法</p><p><img src="https://images2017.cnblogs.com/blog/249993/201712/249993-20171213144447066-1033381024.png" alt="img"></p><p>该方法中实现了如下几个关键步骤：</p><p>1.创建了应用的监听器SpringApplicationRunListeners并开始监听</p><p>2.加载SpringBoot配置环境(ConfigurableEnvironment)，如果是通过web容器发布，会加载StandardEnvironment，其最终也是继承了ConfigurableEnvironment，类图如下</p><p><img src="https://images2017.cnblogs.com/blog/249993/201712/249993-20171213144808707-1335729370.png" alt="img"></p><p>可以看出，*Environment最终都实现了PropertyResolver接口，我们平时通过environment对象获取配置文件中指定Key对应的value方法时，就是调用了propertyResolver接口的getProperty方法</p><p>3.配置环境(Environment)加入到监听器对象中(SpringApplicationRunListeners)</p><p>4.创建run方法的返回对象：ConfigurableApplicationContext(应用配置上下文)，我们可以看一下创建方法：</p><p><img src="https://images2017.cnblogs.com/blog/249993/201712/249993-20171213145353394-1416082242.png" alt="img"></p><p>方法会先获取显式设置的应用上下文(applicationContextClass)，如果不存在，再加载默认的环境配置（通过是否是web environment判断），默认选择AnnotationConfigApplicationContext注解上下文（通过扫描所有注解类来加载bean），最后通过BeanUtils实例化上下文对象，并返回。</p><p>ConfigurableApplicationContext类图如下：</p><p><img src="https://images2017.cnblogs.com/blog/249993/201712/249993-20171213154313488-1411301156.png" alt="img"></p><p>主要看其继承的两个方向：</p><p>LifeCycle：生命周期类，定义了start启动、stop结束、isRunning是否运行中等生命周期空值方法</p><p>ApplicationContext：应用上下文类，其主要继承了beanFactory(bean的工厂类)</p><p>5.回到run方法内，prepareContext方法将listeners、environment、applicationArguments、banner等重要组件与上下文对象关联</p><p>6.接下来的refreshContext(context)方法(初始化方法如下)将是实现spring-boot-starter-*(mybatis、redis等)自动化配置的关键，包括spring.factories的加载，bean的实例化等核心工作。</p><p><img src="https://images2017.cnblogs.com/blog/249993/201712/249993-20171213154943754-336827902.png" alt="img"></p><p>   配置结束后，Springboot做了一些基本的收尾工作，返回了应用环境上下文。回顾整体流程，Springboot的启动，主要创建了配置环境(environment)、事件监听(listeners)、应用上下文(applicationContext)，并基于以上条件，在容器中开始实例化我们需要的Bean，至此，通过SpringBoot启动的程序已经构造完成，接下来我们来探讨自动化配置是如何实现。</p><hr><p><strong>自动化配置：</strong></p><p>之前的启动结构图中，我们注意到无论是应用初始化还是具体的执行过程，都调用了SpringBoot自动配置模块。</p><p><img src="https://images2017.cnblogs.com/blog/249993/201712/249993-20171219161544990-1859845219.png" alt="img"></p><p>SpringBoot自动配置模块</p><p>  该配置模块的主要使用到了SpringFactoriesLoader，即Spring工厂加载器，该对象提供了loadFactoryNames方法，入参为factoryClass和classLoader，即需要传入上图中的工厂类名称和对应的类加载器，方法会根据指定的classLoader，加载该类加器搜索路径下的指定文件，即spring.factories文件，传入的工厂类为接口，而文件中对应的类则是接口的实现类，或最终作为实现类，所以文件中一般为如下图这种一对多的类名集合，获取到这些实现类的类名后，loadFactoryNames方法返回类名集合，方法调用方得到这些集合后，再通过反射获取这些类的类对象、构造方法，最终生成实例。</p><p><img src="https://images2017.cnblogs.com/blog/249993/201712/249993-20171219162725615-751500087.png" alt="img"></p><p>工厂接口与其若干实现类接口名称</p><p>下图有助于我们形象理解自动配置流程。</p><p><img src="https://images2017.cnblogs.com/blog/249993/201712/249993-20171219162844787-1104034109.png" alt="img"></p><p>SpringBoot自动化配置关键组件关系图 </p><p>  mybatis-spring-boot-starter、spring-boot-starter-web等组件的META-INF文件下均含有spring.factories文件，自动配置模块中，SpringFactoriesLoader收集到文件中的类全名并返回一个类全名的数组，返回的类全名通过反射被实例化，就形成了具体的工厂实例，工厂实例来生成组件具体需要的bean。</p><p>之前我们提到了EnableAutoConfiguration注解，其类图如下：</p><p><img src="https://images2017.cnblogs.com/blog/249993/201712/249993-20171219163356100-1697141132.png" alt="img"></p><p>可以发现其最终实现了ImportSelector(选择器)和BeanClassLoaderAware(bean类加载器中间件)，重点关注一下AutoConfigurationImportSelector的selectImports方法。</p><p><img src="https://images2017.cnblogs.com/blog/249993/201712/249993-20171219163452318-1362759499.png" alt="img"></p><p>  该方法在springboot启动流程——bean实例化前被执行，返回要实例化的类信息列表。我们知道，如果获取到类信息，spring自然可以通过类加载器将类加载到jvm中，现在我们已经通过spring-boot的starter依赖方式依赖了我们需要的组件，那么这些组建的类信息在select方法中也是可以被获取到的，不要急我们继续向下分析。</p><p><img src="https://images2017.cnblogs.com/blog/249993/201712/249993-20171219164025334-1624354890.png" alt="img"></p><p>该方法中的getCandidateConfigurations方法，通过方法注释了解到，其返回一个自动配置类的类名列表，方法调用了loadFactoryNames方法，查看该方法</p><p><img src="https://images2017.cnblogs.com/blog/249993/201712/249993-20171219164224912-643901744.png" alt="img"></p><p>  在上面的代码可以看到自动配置器会根据传入的factoryClass.getName()到项目系统路径下所有的spring.factories文件中找到相应的key，从而加载里面的类。我们就选取这个mybatis-spring-boot-autoconfigure下的spring.factories文件</p><p><img src="https://images2017.cnblogs.com/blog/249993/201712/249993-20171219164557240-1466961312.png" alt="img"></p><p>进入org.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration中，主要看一下类头：</p><p><img src="https://images2017.cnblogs.com/blog/249993/201712/249993-20171219164818162-646159475.png" alt="img"></p><p>发现Spring的@Configuration，俨然是一个通过注解标注的springBean，继续向下看，</p><p>@ConditionalOnClass({ SqlSessionFactory.class, SqlSessionFactoryBean.class})这个注解的意思是：当存在SqlSessionFactory.class, SqlSessionFactoryBean.class这两个类时才解析MybatisAutoConfiguration配置类，否则不解析这一个配置类，make sence，我们需要mybatis为我们返回会话对象，就必须有会话工厂相关类。</p><p>@CondtionalOnBean(DataSource.class)：只有处理已经被声明为bean的dataSource。</p><p>@ConditionalOnMissingBean(MapperFactoryBean.class)这个注解的意思是如果容器中不存在name指定的bean则创建bean注入，否则不执行（该类源码较长，篇幅限制不全粘贴）</p><p>   以上配置可以保证sqlSessionFactory、sqlSessionTemplate、dataSource等mybatis所需的组件均可被自动配置，@Configuration注解已经提供了Spring的上下文环境，所以以上组件的配置方式与Spring启动时通过mybatis.xml文件进行配置起到一个效果。通过分析我们可以发现，只要一个基于SpringBoot项目的类路径下存在SqlSessionFactory.class, SqlSessionFactoryBean.class，并且容器中已经注册了dataSourceBean，就可以触发自动化配置，意思说我们只要在maven的项目中加入了mybatis所需要的若干依赖，就可以触发自动配置，但引入mybatis原生依赖的话，每集成一个功能都要去修改其自动化配置类，那就得不到开箱即用的效果了。所以Spring-boot为我们提供了统一的starter可以直接配置好相关的类，触发自动配置所需的依赖(mybatis)如下：</p><p><img src="https://images2017.cnblogs.com/blog/249993/201712/249993-20171220160748068-2010633643.png" alt="img"></p><p>这里是截取的mybatis-spring-boot-starter的源码中pom.xml文件中所有依赖：</p><p><img src="https://images2017.cnblogs.com/blog/249993/201712/249993-20171220160934240-319846263.png" alt="img"></p><p> 因为maven依赖的传递性，我们只要依赖starter就可以依赖到所有需要自动配置的类，实现开箱即用的功能。也体现出Springboot简化了Spring框架带来的大量XML配置以及复杂的依赖管理，让开发人员可以更加关注业务逻辑的开发。</p>]]></content>
    
    <summary type="html">
    
      you can &quot;just run&quot;
    
    </summary>
    
    
      <category term="SpringBoot" scheme="https://SomunsTao.github.io/categories/SpringBoot/"/>
    
    
      <category term="SpringBoot" scheme="https://SomunsTao.github.io/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>Vue 13： VUE复习</title>
    <link href="https://somunstao.github.io/2020/04/23/Vue%2013%EF%BC%9A%20VUE%E5%A4%8D%E4%B9%A0/"/>
    <id>https://somunstao.github.io/2020/04/23/Vue%2013%EF%BC%9A%20VUE%E5%A4%8D%E4%B9%A0/</id>
    <published>2020-04-22T16:00:00.000Z</published>
    <updated>2020-08-01T15:19:56.696Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Vue实战"><a href="#Vue实战" class="headerlink" title="Vue实战"></a>Vue实战</h1><h2 id="1-Vue-引言"><a href="#1-Vue-引言" class="headerlink" title="1. Vue 引言"></a>1. Vue 引言</h2><blockquote><p><code>渐进式</code> JavaScript 框架   –摘自官网</p></blockquote><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 渐进式</span></span><br><span class="line"><span class="bullet">   1. </span>易用  html css javascript</span><br><span class="line"><span class="bullet">   2. </span>高效  开发前端页面 非常高效 </span><br><span class="line"><span class="bullet">   3. </span>灵活  开发灵活 多样性</span><br><span class="line"></span><br><span class="line"><span class="section"># 总结</span></span><br><span class="line"><span class="code">Vue 是一个javascript 框架</span></span><br><span class="line"></span><br><span class="line"><span class="section"># 后端服务端开发人员: </span></span><br><span class="line"><span class="code">Vue 渐进式javascript框架: 让我们通过操作很少的DOM,甚至不需要操作页面中任何DOM元素,就很容易的完成数据和视图绑定  双向绑定 MVVM  </span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">注意: 日后在使用Vue过程中页面中不要在引入Jquery框架</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">htmlcss---&gt;javascript -----&gt;jquery----&gt;angularjs -----&gt; Vue</span></span><br><span class="line"> </span><br><span class="line"> # Vue 作者</span><br><span class="line">  尤雨溪   国内的</span><br></pre></td></tr></table></figure><hr><h2 id="2-Vue入门"><a href="#2-Vue入门" class="headerlink" title="2. Vue入门"></a>2. Vue入门</h2><h3 id="2-1-下载Vuejs"><a href="#2-1-下载Vuejs" class="headerlink" title="2.1    下载Vuejs"></a>2.1    下载Vuejs</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//开发版本:</span></span><br><span class="line">&lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt;</span><br><span class="line">&lt;script src=<span class="string">"https://cdn.jsdelivr.net/npm/vue/dist/vue.js"</span>&gt;&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/生产版本:</span></span><br><span class="line"><span class="regexp">&lt;!-- 生产环境版本，优化了尺寸和速度 --&gt;</span></span><br><span class="line"><span class="regexp">&lt;script src="https:/</span><span class="regexp">/cdn.jsdelivr.net/</span>npm/vue<span class="string">"&gt;&lt;/script&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-2-Vue第一个入门应用"><a href="#2-2-Vue第一个入门应用" class="headerlink" title="2.2 Vue第一个入门应用"></a>2.2 Vue第一个入门应用</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">       &#123;&#123; msg &#125;&#125;  &#123;&#123;username&#125;&#125; &#123;&#123;pwd&#125;&#125;</span><br><span class="line"></span><br><span class="line">       <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">span</span>&gt;</span></span><br><span class="line">           &#123;&#123; username &#125;&#125;</span><br><span class="line">           <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123; msg &#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!--引入vue.js--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/vue/dist/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">       <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">           el:<span class="string">"#app"</span>,  <span class="comment">//element 用来给Vue实例定义一个作用范围</span></span></span><br><span class="line"><span class="actionscript">           data:&#123;      <span class="comment">//用来给Vue实例定义一些相关数据</span></span></span><br><span class="line"><span class="actionscript">               msg:<span class="string">"百知欢迎你,期待你的加入!"</span>,</span></span><br><span class="line"><span class="actionscript">               username:<span class="string">"hello Vue!"</span>,</span></span><br><span class="line"><span class="actionscript">               pwd :<span class="string">"12345"</span>,</span></span><br><span class="line">           &#125;,</span><br><span class="line">       &#125;);</span><br><span class="line">   <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 总结:</span></span><br><span class="line"><span class="code">1.vue实例(对象)中el属性: 代表Vue的作用范围  日后在Vue的作用范围内都可以使用Vue的语法</span></span><br><span class="line"><span class="code">2.vue实例(对象)中data属性: 用来给Vue实例绑定一些相关数据, 绑定的数据可以通过&#123;&#123;变量名&#125;&#125;在Vue作用范围内取出</span></span><br><span class="line"><span class="code">3.在使用&#123;&#123;&#125;&#125;进行获取data中数据时,可以在&#123;&#123;&#125;&#125;中书写表达式,运算符,调用相关方法,以及逻辑运算等</span></span><br><span class="line"><span class="code">4.el属性中可以书写任意的CSS选择器[jquery选择器],但是在使用Vue开发是推荐使用 id选择器</span></span><br></pre></td></tr></table></figure><hr><h2 id="3-v-text和v-html"><a href="#3-v-text和v-html" class="headerlink" title="3. v-text和v-html"></a>3. v-text和v-html</h2><h3 id="3-1-v-text"><a href="#3-1-v-text" class="headerlink" title="3.1 v-text"></a>3.1 v-text</h3><blockquote><p><code>v-text</code>:用来获取data中数据将数据以文本的形式渲染到指定标签内部             类似于javascript 中 innerText</p></blockquote><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span> <span class="attr">class</span>=<span class="string">"aa"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span> &gt;</span>&#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-text</span>=<span class="string">"message"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--引入vue.js--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/vue/dist/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">      <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">          el:<span class="string">"#app"</span>,</span></span><br><span class="line">          data:&#123;</span><br><span class="line"><span class="actionscript">              message:<span class="string">"百知欢迎您"</span></span></span><br><span class="line">          &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 总结</span></span><br><span class="line"><span class="code">1.&#123;&#123;&#125;&#125;(插值表达式)和v-text获取数据的区别在于 </span></span><br><span class="line"><span class="code">a.使用v-text取值会将标签中原有的数据覆盖 使用插值表达式的形式不会覆盖标签原有的数据</span></span><br><span class="line"><span class="code">b.使用v-text可以避免在网络环境较差的情况下出现插值闪烁</span></span><br></pre></td></tr></table></figure><h3 id="3-2-v-html"><a href="#3-2-v-html" class="headerlink" title="3.2 v-html"></a>3.2 v-html</h3><blockquote><p><code>v-html</code>:用来获取data中数据将数据中含有的html标签先解析在渲染到指定标签的内部  类似于javascript中 innerHTML</p></blockquote><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span> <span class="attr">class</span>=<span class="string">"aa"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-text</span>=<span class="string">"message"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-html</span>=<span class="string">"message"</span>&gt;</span>xxxxxx<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--引入vue.js--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/vue/dist/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">            el:<span class="string">"#app"</span>,</span></span><br><span class="line">            data:&#123;</span><br><span class="line"><span class="handlebars"><span class="xml">                message:"<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">''</span>&gt;</span>百知欢迎您<span class="tag">&lt;/<span class="name">a</span>&gt;</span>"</span></span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h2 id="4-vue中事件绑定-v-on"><a href="#4-vue中事件绑定-v-on" class="headerlink" title="4.vue中事件绑定(v-on)"></a>4.vue中事件绑定(v-on)</h2><h3 id="4-1-绑定事件基本语法"><a href="#4-1-绑定事件基本语法" class="headerlink" title="4.1 绑定事件基本语法"></a>4.1 绑定事件基本语法</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h2</span> <span class="attr">v-text</span>=<span class="string">"message"</span>&gt;</span><span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h2</span>&gt;</span>年龄:&#123;&#123; age &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"点我改变年龄"</span> <span class="attr">v-on:click</span>=<span class="string">"changeage"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--引入vue.js--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/vue/dist/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">      <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">          el:<span class="string">"#app"</span>,</span></span><br><span class="line">          data:&#123;</span><br><span class="line"><span class="actionscript">              message:<span class="string">"hello 欢迎来到百知课堂!"</span>,</span></span><br><span class="line">              age:23,</span><br><span class="line">          &#125;,</span><br><span class="line"><span class="actionscript">          methods:&#123;  <span class="comment">//methods 用来定义vue中时间</span></span></span><br><span class="line"><span class="actionscript">              changeage:<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="actionscript">                  alert(<span class="string">'点击触发'</span>);</span></span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 总结:</span></span><br><span class="line"><span class="code">事件  事件源:发生事件dom元素  事件: 发生特定的动作  click....  监听器  发生特定动作之后的事件处理程序 通常是js中函数</span></span><br><span class="line"><span class="code">1.在vue中绑定事件是通过v-on指令来完成的 v-on:事件名 如  v-on:click</span></span><br><span class="line"><span class="code">2.在v-on:事件名的赋值语句中是当前时间触发调用的函数名</span></span><br><span class="line"><span class="code">3.在vue中事件的函数统一定义在Vue实例的methods属性中</span></span><br><span class="line"><span class="code">4.在vue定义的事件中this指的就是当前的Vue实例,日后可以在事件中通过使用this获取Vue实例中相关数据</span></span><br></pre></td></tr></table></figure><h3 id="4-2-Vue中事件的简化语法"><a href="#4-2-Vue中事件的简化语法" class="headerlink" title="4.2 Vue中事件的简化语法"></a>4.2 Vue中事件的简化语法</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123; age &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"通过v-on事件修改年龄每次+1"</span> <span class="attr">v-on:click</span>=<span class="string">"changeage"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"通过@绑定时间修改年龄每次-1"</span> @<span class="attr">click</span>=<span class="string">"editage"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--引入vue.js--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/vue/dist/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">      <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">         el:<span class="string">"#app"</span>,  <span class="comment">//element: 用来指定vue作用范围</span></span></span><br><span class="line">         data:&#123;</span><br><span class="line">             age:23,</span><br><span class="line"><span class="actionscript">         &#125;,    <span class="comment">//data   : 用来定义vue实例中相关数据</span></span></span><br><span class="line">         methods:&#123;</span><br><span class="line"><span class="actionscript">             changeage:<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="actionscript">                 <span class="keyword">this</span>.age++;</span></span><br><span class="line">             &#125;,</span><br><span class="line"><span class="actionscript">             editage:<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="actionscript">                 <span class="keyword">this</span>.age--;</span></span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line"><span class="actionscript">         &#125;  <span class="comment">//methods: 用来定义事件的处理函数</span></span></span><br><span class="line">      &#125;);</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 总结:</span></span><br><span class="line"><span class="code">1.日后在vue中绑定事件时可以通过@符号形式 简化  v-on 的事件绑定</span></span><br></pre></td></tr></table></figure><h3 id="4-3-Vue事件函数两种写法"><a href="#4-3-Vue事件函数两种写法" class="headerlink" title="4.3 Vue事件函数两种写法"></a>4.3 Vue事件函数两种写法</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123;count&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"改变count的值"</span> @<span class="attr">click</span>=<span class="string">"changecount"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--引入vue.js--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/vue/dist/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">      <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">         el:<span class="string">"#app"</span>,</span></span><br><span class="line">         data:&#123;</span><br><span class="line">             count:1,</span><br><span class="line">         &#125;,</span><br><span class="line">         methods:&#123;</span><br><span class="line">             /*changecount:function()&#123;</span><br><span class="line"><span class="actionscript">                 <span class="keyword">this</span>.count++;</span></span><br><span class="line">             &#125;*/</span><br><span class="line">             changecount()&#123;</span><br><span class="line"><span class="actionscript">                 <span class="keyword">this</span>.count++;</span></span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 总结:</span></span><br><span class="line"><span class="code">1.在Vue中事件定义存在两种写法  一种是 函数名:function()&#123;&#125;  推荐    一种是  函数名()&#123;&#125; 推荐</span></span><br></pre></td></tr></table></figure><h3 id="4-4-Vue事件参数传递"><a href="#4-4-Vue事件参数传递" class="headerlink" title="4.4 Vue事件参数传递"></a>4.4 Vue事件参数传递</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123;count&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"改变count为指定的值"</span> @<span class="attr">click</span>=<span class="string">"changecount(23,'xiaohei')"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--引入vue.js--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/vue/dist/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">      <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">         el:<span class="string">"#app"</span>,</span></span><br><span class="line">         data:&#123;</span><br><span class="line">             count:1,</span><br><span class="line">         &#125;,</span><br><span class="line">         methods:&#123;</span><br><span class="line"><span class="actionscript">             <span class="comment">//定义changecount</span></span></span><br><span class="line">             changecount(count,name)&#123;</span><br><span class="line"><span class="actionscript">                 <span class="keyword">this</span>.count = count;</span></span><br><span class="line">                 alert(name);</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">         &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 总结:</span></span><br><span class="line"><span class="code">1.在使用事件时,可以直接在事件调用出给事件进行参数传递,在事件定义出通过定义对应变量接收传递的参数</span></span><br></pre></td></tr></table></figure><hr><h2 id="5-v-show-v-if-v-bind"><a href="#5-v-show-v-if-v-bind" class="headerlink" title="5.v-show v-if v-bind"></a>5.v-show v-if v-bind</h2><h3 id="5-1-v-show"><a href="#5-1-v-show" class="headerlink" title="5.1 v-show"></a>5.1 v-show</h3><blockquote><p><code>v-show</code>:用来控制页面中某个标签元素是否展示        底层使用控制是 display 属性</p></blockquote><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        v-show: 用来控制标签展示还是隐藏的</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span> <span class="attr">v-show</span>=<span class="string">"false"</span>&gt;</span>百知教育欢迎你的加入!<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span> <span class="attr">v-show</span>=<span class="string">"show"</span>&gt;</span>百知教育欢迎你的加入这是vue中定义变量true!<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"展示隐藏标签"</span> @<span class="attr">click</span>=<span class="string">"showmsg"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--引入vue.js--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/vue/dist/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">        el:<span class="string">"#app"</span>,</span></span><br><span class="line">        data:&#123;</span><br><span class="line"><span class="actionscript">            show:<span class="literal">false</span>,</span></span><br><span class="line">        &#125;,</span><br><span class="line">        methods:&#123;</span><br><span class="line"><span class="actionscript">            <span class="comment">//定义时间</span></span></span><br><span class="line">            showmsg()&#123;</span><br><span class="line"><span class="actionscript">               <span class="keyword">this</span>.show =  !<span class="keyword">this</span>.show;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 总结</span></span><br><span class="line"><span class="code">1.在使用v-show时可以直接书写boolean值控制元素展示,也可以通过变量控制标签展示和隐藏</span></span><br><span class="line"><span class="code">2.在v-show中可以通过boolean表达式控制标签的展示课隐藏</span></span><br></pre></td></tr></table></figure><h3 id="5-2-v-if"><a href="#5-2-v-if" class="headerlink" title="5.2 v-if"></a>5.2 v-if</h3><blockquote><p><code>v-if</code>: 用来控制页面元素是否展示                底层控制是DOM元素    操作DOM</p></blockquote><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span> <span class="attr">v-if</span>=<span class="string">"false"</span>&gt;</span>百知教育<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span> <span class="attr">v-if</span>=<span class="string">"show"</span>&gt;</span>百知教育欢迎你的加入<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--引入vue.js--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/vue/dist/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">        el:<span class="string">"#app"</span>,</span></span><br><span class="line">        data:&#123;</span><br><span class="line"><span class="actionscript">            show:<span class="literal">false</span></span></span><br><span class="line">        &#125;,</span><br><span class="line">        methods:&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="5-3-v-bind"><a href="#5-3-v-bind" class="headerlink" title="5.3 v-bind"></a>5.3 v-bind</h3><blockquote><p><code>v-bind</code>: 用来绑定标签的属性从而通过vue动态修改标签的属性</p></blockquote><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">width</span>=<span class="string">"300"</span> <span class="attr">v-bind:title</span>=<span class="string">"msg"</span> <span class="attr">v-bind:class</span>=<span class="string">"&#123;aa:showCss&#125;"</span>  <span class="attr">src</span>=<span class="string">"baizhilogo.jpg"</span> <span class="attr">alt</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--引入vue.js--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/vue/dist/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">        el:<span class="string">"#app"</span>,</span></span><br><span class="line">        data:&#123;</span><br><span class="line"><span class="actionscript">            msg:<span class="string">"百知教育官方logo!!!!"</span>,</span></span><br><span class="line"><span class="actionscript">            showCss:<span class="literal">true</span>,</span></span><br><span class="line">        &#125;,</span><br><span class="line">        methods:&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="5-4-v-bind-简化写法"><a href="#5-4-v-bind-简化写法" class="headerlink" title="5.4 v-bind 简化写法"></a>5.4 v-bind 简化写法</h3><blockquote><p>​    vue为了方便我们日后绑定标签的属性提供了对属性绑定的简化写法如 <code>v-bind:属性名</code> 简化之后 <code>:属性名</code></p></blockquote><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">width</span>=<span class="string">"300"</span> <span class="attr">:title</span>=<span class="string">"msg"</span> <span class="attr">:class</span>=<span class="string">"&#123;aa:showCss&#125;"</span>  <span class="attr">:src</span>=<span class="string">"src"</span> <span class="attr">alt</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"动态控制加入样式"</span> @<span class="attr">click</span>=<span class="string">"addCss"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"改变图片"</span> @<span class="attr">click</span>=<span class="string">"changeSrc"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--引入vue.js--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/vue/dist/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">        el:<span class="string">"#app"</span>,</span></span><br><span class="line">        data:&#123;</span><br><span class="line"><span class="actionscript">            msg:<span class="string">"百知教育官方logo!!!!"</span>,</span></span><br><span class="line"><span class="actionscript">            showCss:<span class="literal">true</span>,</span></span><br><span class="line"><span class="actionscript">            src:<span class="string">"https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1583490365568&amp;di=52a82bd614cd4030f97ada9441bb2d0e&amp;imgtype=0&amp;src=http%3A%2F%2Fimg.kanzhun.com%2Fimages%2Flogo%2F20160714%2F820a68f65b4e4a3634085055779c000c.jpg"</span></span></span><br><span class="line">        &#125;,</span><br><span class="line">        methods:&#123;</span><br><span class="line">            addCss()&#123;</span><br><span class="line"><span class="actionscript">                <span class="keyword">this</span>.showCss= !<span class="keyword">this</span>.showCss;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            changeSrc()&#123;</span><br><span class="line"><span class="actionscript">                <span class="keyword">this</span>.src = <span class="string">"https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=1925088662,1336364220&amp;fm=26&amp;gp=0.jpg"</span>;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h2 id="6-v-for的使用"><a href="#6-v-for的使用" class="headerlink" title="6.v-for的使用"></a>6.v-for的使用</h2><blockquote><p><code>v-for</code>: 作用就是用来对对象进行遍历的(数组也是对象的一种)</p></blockquote><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123; user.name &#125;&#125; &#123;&#123; user.age &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">       通过v-for遍历对象</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-for</span>=<span class="string">"(value,key,index) in user"</span>&gt;</span></span><br><span class="line">        &#123;&#123;index&#125;&#125; : &#123;&#123;key&#125;&#125; : &#123;&#123;value&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        通过v-for遍历数组</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"a,index in arr"</span> &gt;</span></span><br><span class="line">            &#123;&#123;index&#125;&#125; &#123;&#123;a&#125;&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        通过v-for遍历数组中对象</span></span><br><span class="line"><span class="comment">        :key 便于vue内部做重用和排序</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"user,index in users"</span> <span class="attr">:key</span>=<span class="string">"user.id"</span>&gt;</span></span><br><span class="line">            &#123;&#123;index+1&#125;&#125; &#123;&#123; user.name &#125;&#125;  === &#123;&#123; user.age &#125;&#125; ==== &#123;&#123; user.content &#125;&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--引入vue--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/vue/dist/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">        el: <span class="string">"#app"</span>,</span></span><br><span class="line">        data: &#123;</span><br><span class="line"><span class="actionscript">            user:&#123;name:<span class="string">"小陈"</span>,age:<span class="number">23</span>&#125;,</span></span><br><span class="line"><span class="actionscript">            arr:[<span class="string">"北京校区"</span>, <span class="string">"天津校区"</span>, <span class="string">"河南校区"</span>],</span></span><br><span class="line">            users:[</span><br><span class="line"><span class="actionscript">                &#123;id:<span class="string">"1"</span>,name:<span class="string">"xiaochen"</span>,age:<span class="number">23</span>,content:<span class="string">"我曾经也是一个单纯的少年!"</span>&#125;,</span></span><br><span class="line"><span class="actionscript">                &#123;id:<span class="string">"2"</span>,name:<span class="string">"小白"</span>,age:<span class="number">23</span>,content:<span class="string">"我曾经是一个邪恶的少年!"</span>&#125;,</span></span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;&#125;</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 总结</span></span><br><span class="line"><span class="code">1.在使用v-for的时候一定要注意加入:key 用来给vue内部提供重用和排序的唯一key</span></span><br></pre></td></tr></table></figure><hr><h2 id="7-v-model-双向绑定"><a href="#7-v-model-双向绑定" class="headerlink" title="7 .v-model 双向绑定"></a>7 .v-model 双向绑定</h2><blockquote><p><code>v-model</code>: 作用用来绑定标签元素的值与vue实例对象中data数据保持一致,从而实现双向的数据绑定机制</p></blockquote><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model</span>=<span class="string">"message"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"改变Data中值"</span> @<span class="attr">click</span>=<span class="string">"changeValue"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--引入vue--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/vue/dist/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">        el: <span class="string">"#app"</span>,</span></span><br><span class="line">        data: &#123;</span><br><span class="line"><span class="actionscript">            message:<span class="string">""</span></span></span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line">            changeValue()&#123;</span><br><span class="line"><span class="actionscript">                <span class="keyword">this</span>.message=<span class="string">'百知教育!'</span>;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 总结</span></span><br><span class="line"><span class="code">1.使用v-model指令可以实现数据的双向绑定 </span></span><br><span class="line"><span class="code">2.所谓双向绑定 表单中数据变化导致vue实例data数据变化   vue实例中data数据的变化导致表单中数据变化 称之为双向绑定</span></span><br><span class="line"></span><br><span class="line"><span class="section"># MVVM架构  双向绑定机制</span></span><br><span class="line"><span class="code">Model: 数据  Vue实例中绑定数据</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">VM:   ViewModel  监听器</span></span><br><span class="line"></span><br><span class="line"><span class="code">View:  页面  页面展示的数据</span></span><br></pre></td></tr></table></figure><hr><h2 id="8-事件修饰符"><a href="#8-事件修饰符" class="headerlink" title="8. 事件修饰符"></a>8. 事件修饰符</h2><blockquote><p><code>修饰符</code>: 作用用来和事件连用,用来决定事件触发条件或者是阻止事件的触发机制</p></blockquote><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.常用的事件修饰符</span></span><br><span class="line"><span class="code">.stop</span></span><br><span class="line"><span class="code">.prevent</span></span><br><span class="line"><span class="code">.capture</span></span><br><span class="line"><span class="code">.self</span></span><br><span class="line"><span class="code">.once</span></span><br><span class="line"><span class="code">.passive</span></span><br></pre></td></tr></table></figure><h3 id="8-1-stop事件修饰符"><a href="#8-1-stop事件修饰符" class="headerlink" title="8.1 stop事件修饰符"></a>8.1 stop事件修饰符</h3><blockquote><p>用来阻止事件冒泡</p></blockquote><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"aa"</span> @<span class="attr">click</span>=<span class="string">"divClick"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--用来阻止事件冒泡--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"按钮"</span> @<span class="attr">click.stop</span>=<span class="string">"btnClick"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--引入vue--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/vue/dist/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">        el: <span class="string">"#app"</span>,</span></span><br><span class="line">        data: &#123;&#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line">            btnClick()&#123;</span><br><span class="line"><span class="actionscript">                alert(<span class="string">'button被点击了'</span>);</span></span><br><span class="line">            &#125;,</span><br><span class="line">            divClick()&#123;</span><br><span class="line"><span class="actionscript">                alert(<span class="string">'div被点击了'</span>);</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="8-2-prevent-事件修饰符"><a href="#8-2-prevent-事件修饰符" class="headerlink" title="8.2 prevent 事件修饰符"></a>8.2 prevent 事件修饰符</h3><blockquote><p>用来阻止标签的默认行为</p></blockquote><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--用来阻止事件的默认行为--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://www.baizhibest.com/"</span> @<span class="attr">click.prevent</span>=<span class="string">"aClick"</span>&gt;</span>百知教育<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="8-3-self-事件修饰符"><a href="#8-3-self-事件修饰符" class="headerlink" title="8.3 self 事件修饰符"></a>8.3 self 事件修饰符</h3><blockquote><p>用来针对于当前标签的事件触发     ===========&gt; 只触发自己标签的上特定动作的事件     只关心自己标签上触发的事件 不监听事件冒泡</p></blockquote><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--只触发标签自身的事件--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"aa"</span> @<span class="attr">click.self</span>=<span class="string">"divClick"</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--用来阻止事件冒泡--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"按钮"</span> @<span class="attr">click.stop</span>=<span class="string">"btnClick"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"按钮1"</span> @<span class="attr">click</span>=<span class="string">"btnClick1"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="8-4-once-事件修饰符"><a href="#8-4-once-事件修饰符" class="headerlink" title="8.4 once 事件修饰符"></a>8.4 once 事件修饰符</h3><blockquote><p>once 一次 作用:  就是让指定事件只触发一次</p></blockquote><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">.prevent : 用来阻止事件的默认行为</span></span><br><span class="line"><span class="comment">.once    : 用来只执行一次特定的事件</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://www.baizhibest.com/"</span> @<span class="attr">click.prevent.once</span>=<span class="string">"aClick"</span>&gt;</span>百知教育<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h2 id="9-按键修饰符"><a href="#9-按键修饰符" class="headerlink" title="9. 按键修饰符"></a>9. 按键修饰符</h2><blockquote><p>作用: 用来与键盘中按键事件绑定在一起,用来修饰特定的按键事件的修饰符</p></blockquote><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 按键修饰符</span></span><br><span class="line"><span class="code">.enter</span></span><br><span class="line"><span class="code">.tab</span></span><br><span class="line"><span class="code">.delete (捕获“删除”和“退格”键)</span></span><br><span class="line"><span class="code">.esc</span></span><br><span class="line"><span class="code">.space</span></span><br><span class="line"><span class="code">.up</span></span><br><span class="line"><span class="code">.down</span></span><br><span class="line"><span class="code">.left</span></span><br><span class="line"><span class="code">.right</span></span><br></pre></td></tr></table></figure><h3 id="9-1-enter-回车键"><a href="#9-1-enter-回车键" class="headerlink" title="9.1 enter 回车键"></a>9.1 enter 回车键</h3><blockquote><p>用来在触发回车按键之后触发的事件</p></blockquote><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model</span>=<span class="string">"msg"</span> @<span class="attr">keyup.enter</span>=<span class="string">"keyups"</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="9-2-tab-键"><a href="#9-2-tab-键" class="headerlink" title="9.2 tab 键"></a>9.2 tab 键</h3><blockquote><p>用来捕获到tab键执行到当前标签是才会触发</p></blockquote><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> @<span class="attr">keyup.tab</span>=<span class="string">"keytabs"</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h2 id="10-Axios-基本使用"><a href="#10-Axios-基本使用" class="headerlink" title="10. Axios 基本使用"></a>10. Axios 基本使用</h2><h3 id="10-1-引言"><a href="#10-1-引言" class="headerlink" title="10.1 引言"></a>10.1 引言</h3><blockquote><p><code>Axios</code> 是一个异步请求技术,核心作用就是用来在页面中发送异步请求,并获取对应数据在页面中渲染       页面局部更新技术  Ajax</p></blockquote><h3 id="10-2-Axios-第一个程序"><a href="#10-2-Axios-第一个程序" class="headerlink" title="10.2 Axios 第一个程序"></a>10.2 Axios 第一个程序</h3><p>中文网站:<a href="https://www.kancloud.cn/yunye/axios/234845" target="_blank" rel="noopener">https://www.kancloud.cn/yunye/axios/234845</a></p><p>安装: <a href="https://unpkg.com/axios/dist/axios.min.js" target="_blank" rel="noopener">https://unpkg.com/axios/dist/axios.min.js</a></p><h4 id="10-2-1-GET方式的请求"><a href="#10-2-1-GET方式的请求" class="headerlink" title="10.2.1 GET方式的请求"></a>10.2.1 GET方式的请求</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//发送GET方式请求</span></span><br><span class="line"> axios.get(<span class="string">"http://localhost:8989/user/findAll?name=xiaochen"</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>)</span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(response.data);</span><br><span class="line"> &#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(err);</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure><h4 id="10-2-2-POST方式请求"><a href="#10-2-2-POST方式请求" class="headerlink" title="10.2.2 POST方式请求"></a>10.2.2 POST方式请求</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//发送POST方式请求</span></span><br><span class="line">  axios.post(<span class="string">"http://localhost:8989/user/save"</span>,&#123;</span><br><span class="line">      username:<span class="string">"xiaochen"</span>,</span><br><span class="line">      age:<span class="number">23</span>,</span><br><span class="line">      email:<span class="string">"xiaochen@zparkhr.com"</span>,</span><br><span class="line">      phone:<span class="number">13260426185</span></span><br><span class="line">  &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>)</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(response.data);</span><br><span class="line">  &#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><h4 id="10-2-3-axios并发请求"><a href="#10-2-3-axios并发请求" class="headerlink" title="10.2.3 axios并发请求"></a>10.2.3 axios并发请求</h4><blockquote><p><code>并发请求</code>:  将多个请求在同一时刻发送到后端服务接口,最后在集中处理每个请求的响应结果</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.创建一个查询所有请求</span></span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">findAll</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> axios.get(<span class="string">"http://localhost:8989/user/findAll?name=xiaochen"</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//2.创建一个保存的请求</span></span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">save</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> axios.post(<span class="string">"http://localhost:8989/user/save"</span>,&#123;</span><br><span class="line">           username:<span class="string">"xiaochen"</span>,</span><br><span class="line">           age:<span class="number">23</span>,</span><br><span class="line">           email:<span class="string">"xiaochen@zparkhr.com"</span>,</span><br><span class="line">           phone:<span class="number">13260426185</span></span><br><span class="line">       &#125;);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//3.并发执行</span></span><br><span class="line">   axios.all([findAll(),save()]).then(</span><br><span class="line">       axios.spread(<span class="function"><span class="keyword">function</span>(<span class="params">res1,res2</span>)</span>&#123;  <span class="comment">//用来将一组函数的响应结果汇总处理</span></span><br><span class="line">           <span class="built_in">console</span>.log(res1.data);</span><br><span class="line">           <span class="built_in">console</span>.log(res2.data);</span><br><span class="line">       &#125;)</span><br><span class="line">   );<span class="comment">//用来发送一组并发请求</span></span><br></pre></td></tr></table></figure><hr><h2 id="11-Vue-生命周期"><a href="#11-Vue-生命周期" class="headerlink" title="11. Vue 生命周期"></a>11. Vue 生命周期</h2><blockquote><p><code>生命周期钩子</code>   ====&gt;  <code>生命周期函数</code></p></blockquote><p>![img](C:/Users/ASUS/Desktop/ vue资料/Vue实战笔记完整版/Vue实战.assets/lifecycle.png)</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># Vue生命周期总结</span></span><br><span class="line"><span class="code">1.初始化阶段</span></span><br><span class="line"><span class="code">beforeCreate()&#123; //1.生命周期中第一个函数,该函数在执行时Vue实例仅仅完成了自身事件的绑定和生命周期函数的初始化工作,Vue实例中还没有 Data el methods相关属性</span></span><br><span class="line"><span class="code">            console.log("beforeCreate: "+this.msg);</span></span><br><span class="line"><span class="code">        &#125;,</span></span><br><span class="line"><span class="code">        created()&#123; //2.生命周期中第二个函数,该函数在执行时Vue实例已经初始化了data属性和methods中相关方法</span></span><br><span class="line"><span class="code">            console.log("created: "+this.msg);</span></span><br><span class="line"><span class="code">        &#125;,</span></span><br><span class="line"><span class="code">        beforeMount()&#123;//3.生命周期中第三个函数,该函数在执行时Vue将El中指定作用范围作为模板编译</span></span><br><span class="line"><span class="code">            console.log("beforeMount: "+document.getElementById("sp").innerText);</span></span><br><span class="line"><span class="code">        &#125;,</span></span><br><span class="line"><span class="code">        mounted()&#123;//4.生命周期中第四个函数,该函数在执行过程中,已经将数据渲染到界面中并且已经更新页面</span></span><br><span class="line"><span class="code">            console.log("Mounted: "+document.getElementById("sp").innerText);</span></span><br><span class="line"><span class="code">        &#125;</span></span><br><span class="line"><span class="code">        </span></span><br><span class="line"><span class="code">2.运行阶段</span></span><br><span class="line"><span class="code"> beforeUpdate()&#123;//5.生命周期中第五个函数,该函数是data中数据发生变化时执行 这个事件执行时仅仅是Vue实例中data数据变化页面显示的依然是原始数据</span></span><br><span class="line"><span class="code">            console.log("beforeUpdate:"+this.msg);</span></span><br><span class="line"><span class="code">            console.log("beforeUpdate:"+document.getElementById("sp").innerText);</span></span><br><span class="line"><span class="code">        &#125;,</span></span><br><span class="line"><span class="code">        updated()&#123;    //6.生命周期中第六个函数,该函数执行时data中数据发生变化,页面中数据也发生了变化  页面中数据已经和data中数据一致</span></span><br><span class="line"><span class="code">            console.log("updated:"+this.msg);</span></span><br><span class="line"><span class="code">            console.log("updated:"+document.getElementById("sp").innerText);</span></span><br><span class="line"><span class="code">        &#125;,</span></span><br><span class="line"><span class="code">        </span></span><br><span class="line"><span class="code">3.销毁阶段</span></span><br><span class="line"><span class="code"> beforeDestory()&#123;//7.生命周期第七个函数,该函数执行时,Vue中所有数据 methods componet 都没销毁</span></span><br><span class="line"></span><br><span class="line"><span class="code">        &#125;,</span></span><br><span class="line"><span class="code">        destoryed()&#123; //8.生命周期的第八个函数,该函数执行时,Vue实例彻底销毁</span></span><br><span class="line"></span><br><span class="line"><span class="code">        &#125;</span></span><br></pre></td></tr></table></figure><hr><h2 id="12-Vue中组件-Component"><a href="#12-Vue中组件-Component" class="headerlink" title="12. Vue中组件(Component)"></a>12. Vue中组件(Component)</h2><h3 id="12-1-组件作用"><a href="#12-1-组件作用" class="headerlink" title="12.1 组件作用"></a>12.1 组件作用</h3><p>组件作用: 用来减少Vue实例对象中代码量,日后在使用Vue开发过程中,可以根据 不能业务功能将页面中划分不同的多个组件,然后由多个组件去完成整个页面的布局,便于日后使用Vue进行开发时页面管理,方便开发人员维护。</p><h3 id="12-2-组件使用"><a href="#12-2-组件使用" class="headerlink" title="12.2 组件使用"></a>12.2 组件使用</h3><h4 id="12-2-1-全局组件注册"><a href="#12-2-1-全局组件注册" class="headerlink" title="12.2.1 全局组件注册"></a>12.2.1 全局组件注册</h4><p><code>说明:全局组件注册给Vue实例,日后可以在任意Vue实例的范围内使用该组件</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.开发全局组件</span></span><br><span class="line">Vue.component(<span class="string">'login'</span>,&#123;</span><br><span class="line">        template:<span class="string">'&lt;div&gt;&lt;h1&gt;用户登录&lt;/h1&gt;&lt;/div&gt;'</span></span><br><span class="line">    &#125;);</span><br><span class="line"><span class="comment">//2.使用全局组件  在Vue实例范围内</span></span><br><span class="line">&lt;login&gt;&lt;<span class="regexp">/login&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 注意:</span></span><br><span class="line"><span class="code">1.Vue.component用来开发全局组件 参数1: 组件的名称  参数2: 组件配置&#123;&#125;  template:''用来书写组件的html代码  template中必须有且只有一个root元素</span></span><br><span class="line"><span class="code">2.使用时需要在Vue的作用范围内根据组件名使用全局组件</span></span><br><span class="line"><span class="code">3.如果在注册组件过程中使用 驼峰命名组件的方式 在使用组件时 必须将驼峰的所有单词小写加入-线进行使用</span></span><br></pre></td></tr></table></figure><h4 id="12-2-2-局部组件注册"><a href="#12-2-2-局部组件注册" class="headerlink" title="12.2.2 局部组件注册"></a>12.2.2 局部组件注册</h4><p><code>说明:通过将组件注册给对应Vue实例中一个components属性来完成组件注册,这种方式不会对Vue实例造成累加</code></p><ul><li>第一种开发方式</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//局部组件登录模板声明</span></span><br><span class="line">  <span class="keyword">let</span> login =&#123;   <span class="comment">//具体局部组件名称</span></span><br><span class="line">      template:<span class="string">'&lt;div&gt;&lt;h2&gt;用户登录&lt;/h2&gt;&lt;/div&gt;'</span></span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">      el: <span class="string">"#app"</span>,</span><br><span class="line">      data: &#123;&#125;,</span><br><span class="line">      methods: &#123;&#125;,</span><br><span class="line">      components:&#123;  <span class="comment">//用来注册局部组件</span></span><br><span class="line">          login:login  <span class="comment">//注册局部组件</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//局部组件使用 在Vue实例范围内</span></span><br><span class="line">&lt;login&gt;&lt;<span class="regexp">/login&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>第二种开发方式</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.声明局部组件模板  template 标签 注意:在Vue实例作用范围外声明</span></span><br><span class="line">  &lt;template id=<span class="string">"loginTemplate"</span>&gt;</span><br><span class="line">      &lt;h1&gt;用户登录&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>template&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.定义变量用来保存模板配置对象</span></span><br><span class="line">    <span class="keyword">let</span> login =&#123;   <span class="comment">//具体局部组件名称</span></span><br><span class="line">        template:<span class="string">'#loginTemplate'</span>  <span class="comment">//使用自定义template标签选择器即可</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.注册组件</span></span><br><span class="line">    <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">        el: <span class="string">"#app"</span>,</span><br><span class="line">        data: &#123;&#125;,</span><br><span class="line">        methods: &#123;&#125;,</span><br><span class="line">        components:&#123;  <span class="comment">//用来注册局部组件</span></span><br><span class="line">            login:login  <span class="comment">//注册局部组件</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"> <span class="comment">//4.局部组件使用 在Vue实例范围内</span></span><br><span class="line"> &lt;login&gt;&lt;<span class="regexp">/login&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="12-3-Prop的使用"><a href="#12-3-Prop的使用" class="headerlink" title="12.3 Prop的使用"></a>12.3 Prop的使用</h3><p><code>作用:props用来给组件传递相应静态数据或者是动态数据的</code></p><h4 id="12-3-1-通过在组件上声明静态数据传递给组件内部"><a href="#12-3-1-通过在组件上声明静态数据传递给组件内部" class="headerlink" title="12.3.1 通过在组件上声明静态数据传递给组件内部"></a>12.3.1 通过在组件上声明静态数据传递给组件内部</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.声明组件模板配置对象</span></span><br><span class="line">    <span class="keyword">let</span> login = &#123;</span><br><span class="line">        template:<span class="string">"&lt;div&gt;&lt;h1&gt;欢迎:&#123;&#123; userName &#125;&#125; 年龄:&#123;&#123; age &#125;&#125;&lt;/h1&gt;&lt;/div&gt;"</span>,</span><br><span class="line">        props:[<span class="string">'userName'</span>,<span class="string">'age'</span>]  <span class="comment">//props作用 用来接收使用组件时通过组件标签传递的数据</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.注册组件</span></span><br><span class="line">    <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">        el: <span class="string">"#app"</span>,</span><br><span class="line">        data: &#123;&#125;,</span><br><span class="line">        methods: &#123;&#125;,</span><br><span class="line">        components:&#123;</span><br><span class="line">            login <span class="comment">//组件注册</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.通过组件完成数据传递</span></span><br><span class="line">&lt;login user-name=<span class="string">"小陈"</span> age=<span class="string">"23"</span>&gt;&lt;<span class="regexp">/login&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 总结:</span></span><br><span class="line"><span class="code">1.使用组件时可以在组件上定义多个属性以及对应数据</span></span><br><span class="line"><span class="code">2.在组件内部可以使用props数组生命多个定义在组件上的属性名 日后可以在组件中通过&#123;&#123; 属性名 &#125;&#125; 方式获取组件中属性值</span></span><br></pre></td></tr></table></figure><h4 id="12-3-2-通过在组件上声明动态数据传递给组件内部"><a href="#12-3-2-通过在组件上声明动态数据传递给组件内部" class="headerlink" title="12.3.2 通过在组件上声明动态数据传递给组件内部"></a>12.3.2 通过在组件上声明动态数据传递给组件内部</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.声明组件模板对象</span></span><br><span class="line">    <span class="keyword">const</span> login = &#123;</span><br><span class="line">        template:<span class="string">'&lt;div&gt;&lt;h2&gt;欢迎: &#123;&#123; name &#125;&#125; 年龄:&#123;&#123; age &#125;&#125;&lt;/h2&gt;&lt;/div&gt;'</span>,</span><br><span class="line">        props:[<span class="string">'name'</span>,<span class="string">'age'</span>]</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//2.注册局部组件</span></span><br><span class="line">    <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">        el: <span class="string">"#app"</span>,</span><br><span class="line">        data: &#123;</span><br><span class="line">            username:<span class="string">"小陈陈"</span>,</span><br><span class="line">            age:<span class="number">23</span></span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;&#125;,</span><br><span class="line">        components:&#123;</span><br><span class="line">            login <span class="comment">//注册组件</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.使用组件</span></span><br><span class="line"> &lt;login :name=<span class="string">"username"</span> :age=<span class="string">"age"</span>&gt;&lt;<span class="regexp">/login&gt;  /</span><span class="regexp">/使用v-bind形式将数据绑定Vue实例中data属性,日后data属性发生变化,组件内部数据跟着变化</span></span><br></pre></td></tr></table></figure><h4 id="12-3-3-prop的单向数据流"><a href="#12-3-3-prop的单向数据流" class="headerlink" title="12.3.3 prop的单向数据流"></a>12.3.3 prop的单向数据流</h4><p><code>单向数据流:所有的 prop 都使得其父子 prop 之间形成了一个**单向下行绑定**：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。</code></p><blockquote><p>所有的 prop 都使得其父子 prop 之间形成了一个<strong>单向下行绑定</strong>：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流向难以理解。</p><p>额外的，每次父级组件发生更新时，子组件中所有的 prop 都将会刷新为最新的值。这意味着你<strong>不</strong>应该在一个子组件内部改变 prop。如果你这样做了，Vue 会在浏览器的控制台中发出警告。—摘自官网</p></blockquote><h3 id="12-4-组件中定义数据和事件使用"><a href="#12-4-组件中定义数据和事件使用" class="headerlink" title="12.4 组件中定义数据和事件使用"></a>12.4 组件中定义数据和事件使用</h3><h5 id="1-组件中定义属于组件的数据"><a href="#1-组件中定义属于组件的数据" class="headerlink" title="1. 组件中定义属于组件的数据"></a>1. 组件中定义属于组件的数据</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//组件声明的配置对象</span></span><br><span class="line">    <span class="keyword">const</span> login = &#123;</span><br><span class="line">        template:<span class="string">'&lt;div&gt;&lt;h1&gt;&#123;&#123; msg &#125;&#125; 百知教育&lt;/h1&gt;&lt;ul&gt;&lt;li v-for="item,index in lists"&gt;&#123;&#123; index &#125;&#125;&#123;&#123; item &#125;&#125;&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;'</span>,</span><br><span class="line">        data()&#123;   <span class="comment">//使用data函数方式定义组件的数据   在templatehtml代码中通过插值表达式直接获取</span></span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                msg:<span class="string">"hello"</span>,</span><br><span class="line">                lists:[<span class="string">'java'</span>,<span class="string">'spring'</span>,<span class="string">'springboot'</span>]</span><br><span class="line">            &#125;<span class="comment">//组件自己内部数据</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="2-组件中事件定义"><a href="#2-组件中事件定义" class="headerlink" title="2.组件中事件定义"></a>2.组件中事件定义</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> login=&#123;</span><br><span class="line">       template:<span class="string">'&lt;div&gt;&lt;input type="button" value="点我触发组件中事件" @click="change"&gt;&lt;/div&gt;'</span>,</span><br><span class="line">       data()&#123;</span><br><span class="line">           <span class="keyword">return</span> &#123;</span><br><span class="line">               name:<span class="string">'小陈'</span></span><br><span class="line">           &#125;;</span><br><span class="line">       &#125;,</span><br><span class="line">       methods:&#123;</span><br><span class="line">           change()&#123;</span><br><span class="line">               alert(<span class="keyword">this</span>.name)</span><br><span class="line">               alert(<span class="string">'触发事件'</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 总结</span></span><br><span class="line"><span class="code">1.组件中定义事件和直接在Vue中定义事件基本一致 直接在组件内部对应的html代码上加入@事件名=函数名方式即可</span></span><br><span class="line"><span class="code">2.在组件内部使用methods属性用来定义对应的事件函数即可,事件函数中this 指向的是当前组件的实例</span></span><br></pre></td></tr></table></figure><h3 id="12-5-向子组件中传递事件并在子组件中调用改事件"><a href="#12-5-向子组件中传递事件并在子组件中调用改事件" class="headerlink" title="12.5 向子组件中传递事件并在子组件中调用改事件"></a>12.5 向子组件中传递事件并在子组件中调用改事件</h3><p><code>在子组件中调用传递过来的相关事件必须使用 this.$emit(&#39;函数名&#39;) 方式调用</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.声明组件</span></span><br><span class="line">    <span class="keyword">const</span> login = &#123;</span><br><span class="line">        template:<span class="string">"&lt;div&gt;&lt;h1&gt;百知教育 &#123;&#123; uname &#125;&#125;&lt;/h1&gt; &lt;input type='button' value='点我' @click='change'&gt;&lt;/div&gt;"</span>,</span><br><span class="line">        data()&#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                uname:<span class="keyword">this</span>.name</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        props:[<span class="string">'name'</span>],</span><br><span class="line">        methods:&#123;</span><br><span class="line">            change()&#123;</span><br><span class="line">                <span class="comment">//调用vue实例中函数</span></span><br><span class="line">                <span class="keyword">this</span>.$emit(<span class="string">'aaa'</span>);  <span class="comment">//调用组件传递过来的其他函数时需要使用 this.$emit('函数名调用')</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"> <span class="comment">//2.注册组件</span></span><br><span class="line">    <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">        el: <span class="string">"#app"</span>,</span><br><span class="line">        data: &#123;</span><br><span class="line">            username:<span class="string">"小陈"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line">            findAll()&#123;  <span class="comment">//一个事件函数  将这个函数传递给子组件</span></span><br><span class="line">                alert(<span class="string">'Vue 实例中定义函数'</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        components:&#123;</span><br><span class="line">            login,<span class="comment">//组件的注册</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.使用组件</span></span><br><span class="line">&lt;login  @find=<span class="string">"findAll"</span>&gt;&lt;<span class="regexp">/login&gt;    /</span><span class="regexp">/=====&gt; 在组件内部使用  this.$emit('find')</span></span><br></pre></td></tr></table></figure><hr><h2 id="13-Vue中路由-VueRouter"><a href="#13-Vue中路由-VueRouter" class="headerlink" title="13.Vue中路由(VueRouter)"></a>13.Vue中路由(VueRouter)</h2><h4 id="13-1-路由"><a href="#13-1-路由" class="headerlink" title="13.1 路由"></a>13.1 路由</h4><p><code>路由:根据请求的路径按照一定的路由规则进行请求的转发从而帮助我们实现统一请求的管理</code></p><h4 id="13-2-作用"><a href="#13-2-作用" class="headerlink" title="13.2 作用"></a>13.2 作用</h4><p><code>用来在vue中实现组件之间的动态切换</code></p><h4 id="13-3-使用路由"><a href="#13-3-使用路由" class="headerlink" title="13.3 使用路由"></a>13.3 使用路由</h4><ol><li><h5 id="引入路由"><a href="#引入路由" class="headerlink" title="引入路由"></a>引入路由</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script src=<span class="string">"https://cdn.jsdelivr.net/npm/vue/dist/vue.js"</span>&gt;&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;script src="https:/</span><span class="regexp">/unpkg.com/</span>vue-router/dist/vue-router.js<span class="string">"&gt;&lt;/script&gt;  //vue 路由js</span></span><br></pre></td></tr></table></figure></li><li><h5 id="创建组件对象"><a href="#创建组件对象" class="headerlink" title="创建组件对象"></a>创建组件对象</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//声明组件模板</span></span><br><span class="line"><span class="keyword">const</span> login = &#123;</span><br><span class="line">  template:<span class="string">'&lt;h1&gt;登录&lt;/h1&gt;'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> register = &#123;</span><br><span class="line">  template:<span class="string">'&lt;h1&gt;注册&lt;/h1&gt;'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><h5 id="定义路由对象的规则"><a href="#定义路由对象的规则" class="headerlink" title="定义路由对象的规则"></a>定义路由对象的规则</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> <span class="comment">//创建路由对象</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes:[</span><br><span class="line">    &#123;<span class="attr">path</span>:<span class="string">'/login'</span>,<span class="attr">component</span>:login&#125;,   <span class="comment">//path: 路由的路径  component:路径对应的组件</span></span><br><span class="line">    &#123;<span class="attr">path</span>:<span class="string">'/register'</span>,<span class="attr">component</span>:register&#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ol><ol start="4"><li><h5 id="将路由对象注册到vue实例"><a href="#将路由对象注册到vue实例" class="headerlink" title="将路由对象注册到vue实例"></a>将路由对象注册到vue实例</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">"#app"</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    username:<span class="string">"小陈"</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;&#125;,</span><br><span class="line">  router:router   <span class="comment">//设置路由对象</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ol><ol start="5"><li><h5 id="在页面中显示路由的组件"><a href="#在页面中显示路由的组件" class="headerlink" title="在页面中显示路由的组件"></a>在页面中显示路由的组件</h5><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--显示路由的组件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><h5 id="根据连接切换路由"><a href="#根据连接切换路由" class="headerlink" title="根据连接切换路由"></a>根据连接切换路由</h5><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#/login"</span>&gt;</span>点我登录<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#/register"</span>&gt;</span>点我注册<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="13-4-router-link使用"><a href="#13-4-router-link使用" class="headerlink" title="13.4 router-link使用"></a>13.4 router-link使用</h3><p><code>作用:用来替换我们在切换路由时使用a标签切换路由</code></p><p><code>好处:就是可以自动给路由路径加入#不需要手动加入</code></p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/login"</span> <span class="attr">tag</span>=<span class="string">"button"</span>&gt;</span>我要登录<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/register"</span> <span class="attr">tag</span>=<span class="string">"button"</span>&gt;</span>点我注册<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 总结:</span></span><br><span class="line"><span class="code">1.router-link 用来替换使用a标签实现路由切换 好处是不需要书写#号直接书写路由路径</span></span><br><span class="line"><span class="code">2.router-link to属性用来书写路由路径   tag属性:用来将router-link渲染成指定的标签</span></span><br></pre></td></tr></table></figure><h3 id="13-5-默认路由"><a href="#13-5-默认路由" class="headerlink" title="13.5 默认路由"></a>13.5 默认路由</h3><p><code>作用:用来在第一次进入界面是显示一个默认的组件</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes:[</span><br><span class="line">    <span class="comment">//&#123; path:'/',component:login&#125;,</span></span><br><span class="line">    &#123; <span class="attr">path</span>:<span class="string">'/'</span>,<span class="attr">redirect</span>:<span class="string">'/login'</span>&#125;,  <span class="comment">//redirect: 用来当访问的是默认路由 "/" 时 跳转到指定的路由展示  推荐使用</span></span><br><span class="line">    &#123; <span class="attr">path</span>:<span class="string">'/login'</span>, <span class="attr">component</span>:login&#125;,</span><br><span class="line">    &#123; <span class="attr">path</span>:<span class="string">'/register'</span>, <span class="attr">component</span>:register&#125;,</span><br><span class="line">  ]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="13-6-路由中参数传递"><a href="#13-6-路由中参数传递" class="headerlink" title="13.6 路由中参数传递"></a>13.6 路由中参数传递</h3><ul><li>第一种方式传递参数 传统方式</li></ul><ol><li><p>通过?号形式拼接参数</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/login?id=21&amp;name=zhangsan"</span>&gt;</span>我要登录<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>组件中获取参数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> login = &#123;</span><br><span class="line">  template:<span class="string">'&lt;h1&gt;用户登录&lt;/h1&gt;'</span>,</span><br><span class="line">  data()&#123;<span class="keyword">return</span> &#123;&#125;&#125;,</span><br><span class="line">  methods:&#123;&#125;,</span><br><span class="line">  created()&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"=============&gt;"</span>+<span class="keyword">this</span>.$route.query.id+<span class="string">"======&gt;"</span>+<span class="keyword">this</span>.$route.query.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><ul><li>第二种方式传递参数 restful</li></ul><ol><li><p>通过使用路径方式传递参数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;router-link to=<span class="string">"/register/24/张三"</span>&gt;我要注册&lt;<span class="regexp">/router-link&gt;</span></span><br><span class="line"><span class="regexp">var router = new VueRouter(&#123;</span></span><br><span class="line"><span class="regexp">  routes:[</span></span><br><span class="line"><span class="regexp">    &#123;path:'/register/:id/:name',component:register&#125;   //定义路径中获取对应参数</span></span><br><span class="line"><span class="regexp">  ]</span></span><br><span class="line"><span class="regexp">&#125;);</span></span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><p>组件中获取参数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> register = &#123;</span><br><span class="line">  template:<span class="string">'&lt;h1&gt;用户注册&#123;&#123; $route.params.name &#125;&#125;&lt;/h1&gt;'</span>,</span><br><span class="line">  created()&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"注册组件中id:   "</span>+<span class="keyword">this</span>.$route.params.id+<span class="keyword">this</span>.$route.params.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><h3 id="13-7-嵌套路由"><a href="#13-7-嵌套路由" class="headerlink" title="13.7 嵌套路由"></a>13.7 嵌套路由</h3><ol><li><h5 id="声明最外层和内层路由"><a href="#声明最外层和内层路由" class="headerlink" title="声明最外层和内层路由"></a>声明最外层和内层路由</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template id=<span class="string">"product"</span>&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line"></span><br><span class="line">        &lt;h1&gt;商品管理&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">        &lt;router-link to="/</span>product/add<span class="string">"&gt;商品添加&lt;/router-link&gt;</span></span><br><span class="line"><span class="string">        &lt;router-link to="</span>/product/edit<span class="string">"&gt;商品编辑&lt;/router-link&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        &lt;router-view&gt;&lt;/router-view&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">&lt;/template&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">//声明组件模板</span></span><br><span class="line"><span class="string">const product=&#123;</span></span><br><span class="line"><span class="string">  template:'#product'</span></span><br><span class="line"><span class="string">&#125;;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">const add = &#123;</span></span><br><span class="line"><span class="string">  template:'&lt;h4&gt;商品添加&lt;/h4&gt;'</span></span><br><span class="line"><span class="string">&#125;;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">const edit = &#123;</span></span><br><span class="line"><span class="string">  template:'&lt;h4&gt;商品编辑&lt;/h4&gt;'</span></span><br><span class="line"><span class="string">&#125;;</span></span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><h5 id="创建路由对象含有嵌套路由"><a href="#创建路由对象含有嵌套路由" class="headerlink" title="创建路由对象含有嵌套路由"></a>创建路由对象含有嵌套路由</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">        routes:[</span><br><span class="line">            &#123;</span><br><span class="line">                path:<span class="string">'/product'</span>,</span><br><span class="line">                component:product,</span><br><span class="line">                children:[</span><br><span class="line">                    &#123;<span class="attr">path</span>:<span class="string">'add'</span>,<span class="attr">component</span>: add&#125;,</span><br><span class="line">                    &#123;<span class="attr">path</span>:<span class="string">'edit'</span>,<span class="attr">component</span>: edit&#125;,</span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">        ]</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure></li></ol><ol start="3"><li><h5 id="注册路由对象"><a href="#注册路由对象" class="headerlink" title="注册路由对象"></a>注册路由对象</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">"#app"</span>,</span><br><span class="line">    data: &#123;&#125;,</span><br><span class="line">    methods: &#123;&#125;,</span><br><span class="line">    router,<span class="comment">//定义路由对象</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>测试路由</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/product"</span>&gt;</span>商品管理<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br></pre></td></tr></table></figure><hr></li></ol><h2 id="14-Vue-CLI-脚手架"><a href="#14-Vue-CLI-脚手架" class="headerlink" title="14. Vue CLI 脚手架"></a>14. Vue CLI 脚手架</h2><h3 id="14-1-什么是CLI"><a href="#14-1-什么是CLI" class="headerlink" title="14.1 什么是CLI"></a>14.1 什么是CLI</h3><p>命令行界面（英语：command-line interface，缩写：<em>CLI</em>）是在图形用户界面得到普及之前使用最为广泛的用户界面，它通常不支持鼠标，用户通过键盘输入指令，计算机接收到指令后，予以执行。也有人称之为字符用户界面（CUI）</p><h3 id="14-2-什么是Vue-CLI"><a href="#14-2-什么是Vue-CLI" class="headerlink" title="14.2 什么是Vue CLI"></a>14.2 什么是Vue CLI</h3><p>Vue CLI 是一个基于 Vue.js 进行快速开发的完整系统。使用Vue 脚手架之后我们开发的页面将是一个完整系统(项目)。</p><h3 id="14-3-Vue-CLI优势"><a href="#14-3-Vue-CLI优势" class="headerlink" title="14.3 Vue CLI优势"></a>14.3 Vue CLI优势</h3><ul><li>通过 <code>vue-cli</code> 搭建交互式的项目脚手架。bootstrap css js jquery js     通过执行命令方式下载相关依赖</li><li>通过 <code>@vue/cli</code> + <code>@vue/cli-service-global</code> 快速开始零配置原型开发    vue页面 vuejs  vuerouter        axios(一条命令)</li><li>一个运行时依赖 (<code>@vue/cli-service</code>)，该依赖：<ul><li>可升级；  一条命令</li><li>基于 webpack 构建，并带有合理的默认配置；  webpack  项目打包方式     编译好的项目源码===&gt;部署到服务器上直接使用</li><li>可以通过项目内的配置文件进行配置；               默认配置文件,通过修改默认配置文件达到自己想要的项目环境            </li><li>可以通过插件进行扩展。                                       vue v-charts  elementui </li></ul></li><li>一个丰富的官方插件集合，集成了前端生态中最好的工具。Nodejs(tomcat)  Vue VueRouter webpack yarn</li><li>一套完全图形化的创建和管理 Vue.js 项目的用户界面</li></ul><h3 id="14-4-Vue-CLI安装"><a href="#14-4-Vue-CLI安装" class="headerlink" title="14.4 Vue CLI安装"></a>14.4 Vue CLI安装</h3><h5 id="1-环境准备"><a href="#1-环境准备" class="headerlink" title="1. 环境准备"></a>1. 环境准备</h5><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section">#1.下载nodejs</span></span><br><span class="line"><span class="code">http://nodejs.cn/download/</span></span><br><span class="line"><span class="code">windows系统:   .msi  安装包(exe)指定安装位置   .zip(压缩包)直接解压缩指定目录</span></span><br><span class="line"><span class="code">  mac os 系统:   .pkg  安装包格式自动配置环境变量  .tar.gz(压缩包)解压缩安装到指定名</span></span><br><span class="line"></span><br><span class="line"><span class="section">#2.配置nodejs环境变量</span></span><br><span class="line"><span class="code">windows系统:</span></span><br><span class="line"><span class="code">1.计算上右键属性----&gt;  高级属性 ----&gt;环境变量 添加如下配置:</span></span><br><span class="line"><span class="code">NODE_HOME=  nodejs安装目录</span></span><br><span class="line"><span class="code">        PATH    = xxxx;%NODE_HOME%</span></span><br><span class="line"><span class="code">    2.macos 系统</span></span><br><span class="line"><span class="code">    推荐使用.pkg安装直接配置node环境</span></span><br><span class="line"> </span><br><span class="line"><span class="section">#3.验证nodejs环境是否成功</span></span><br><span class="line"><span class="code">node -v </span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section">#4.npm介绍</span></span><br><span class="line"><span class="code">node package mangager    nodejs包管理工具       前端主流技术  npm 进行统一管理</span></span><br><span class="line"><span class="code">maven 管理java后端依赖   远程仓库(中心仓库)      阿里云镜像</span></span><br><span class="line"><span class="code">npm   管理前端系统依赖    远程仓库(中心仓库)      配置淘宝镜像</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section">#5.配置淘宝镜像</span></span><br><span class="line"><span class="code">  npm config set registry https://registry.npm.taobao.org</span></span><br><span class="line"><span class="code">  npm config get registry</span></span><br><span class="line"></span><br><span class="line"><span class="section">#6.配置npm下载依赖位置</span></span><br><span class="line"><span class="code"> windows:</span></span><br><span class="line"><span class="code">npm config set cache "D:\nodereps\npm-cache"</span></span><br><span class="line"><span class="code">npm config set prefix "D:\nodereps\npm_global"</span></span><br><span class="line"><span class="code"> mac os:</span></span><br><span class="line"><span class="code"> npm config set cache "/Users/chenyannan/dev/nodereps"</span></span><br><span class="line"><span class="code">npm config set prefix "/Users/chenyannan/dev/nodereps"</span></span><br><span class="line"></span><br><span class="line"><span class="section">#7.验证nodejs环境配置</span></span><br><span class="line"><span class="code">npm config ls</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">    ; userconfig /Users/chenyannan/.npmrc</span></span><br><span class="line"><span class="code">    cache = "/Users/chenyannan/dev/nodereps"</span></span><br><span class="line"><span class="code">    prefix = "/Users/chenyannan/dev/nodereps"</span></span><br><span class="line"><span class="code">    registry = "https://registry.npm.taobao.org/"</span></span><br></pre></td></tr></table></figure><h5 id="2-安装脚手架"><a href="#2-安装脚手架" class="headerlink" title="2.安装脚手架"></a>2.安装脚手架</h5><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section">#0.卸载脚手架</span></span><br><span class="line"><span class="code">npm uninstall -g @vue/cli  //卸载3.x版本脚手架</span></span><br><span class="line"><span class="code">npm uninstall -g vue-cli  //卸载2.x版本脚手架</span></span><br><span class="line"></span><br><span class="line"><span class="section">#1.Vue Cli官方网站</span></span><br><span class="line"><span class="code">https://cli.vuejs.org/zh/guide/</span></span><br><span class="line"></span><br><span class="line"><span class="section">#2.安装vue Cli</span></span><br><span class="line"><span class="code">npm install -g vue-cli</span></span><br></pre></td></tr></table></figure><h5 id="3-第一个vue脚手架项目"><a href="#3-第一个vue脚手架项目" class="headerlink" title="3.第一个vue脚手架项目"></a>3.第一个vue脚手架项目</h5><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.创建vue脚手架第一个项目</span></span><br><span class="line"><span class="code">vue init webpack 项目名</span></span><br><span class="line"><span class="section"># 2.创建第一个项目</span></span><br><span class="line"><span class="code">hello     -------------&gt;项目名</span></span><br><span class="line"><span class="code">    -build  -------------&gt;用来使用webpack打包使用build依赖</span></span><br><span class="line"><span class="code">    -config -------------&gt;用来做整个项目配置目录</span></span><br><span class="line"><span class="code">    -node_modules  ------&gt;用来管理项目中使用依赖</span></span><br><span class="line"><span class="code">    -src ------&gt;用来书写vue的源代码[重点]</span></span><br><span class="line"><span class="code">    +assets      ------&gt;用来存放静态资源 [重点]</span></span><br><span class="line"><span class="code">      components   ------&gt;用来书写Vue组件 [重点]</span></span><br><span class="line"><span class="code">      router ------&gt;用来配置项目中路由[重点]</span></span><br><span class="line"><span class="code">      App.vue      ------&gt;项目中根组件[重点]</span></span><br><span class="line"><span class="code">      main.js      ------&gt;项目中主入口[重点]</span></span><br><span class="line"><span class="code">    -static        ------&gt;其它静态</span></span><br><span class="line"><span class="code">    -.babelrc      ------&gt; 将es6语法转为es5运行</span></span><br><span class="line"><span class="code">    -.editorconfig ------&gt; 项目编辑配置</span></span><br><span class="line"><span class="code">    -.gitignore    ------&gt; git版本控制忽略文件</span></span><br><span class="line"><span class="code">    -.postcssrc.js ------&gt; 源码相关js</span></span><br><span class="line"><span class="code">    -index.html    ------&gt; 项目主页</span></span><br><span class="line"><span class="code">    -package.json  ------&gt; 类似与pom.xml 依赖管理  jquery 不建议手动修改</span></span><br><span class="line"><span class="code">    -package-lock.json ----&gt; 对package.json加锁</span></span><br><span class="line"><span class="code">    -README.md         ----&gt; 项目说明文件</span></span><br><span class="line"></span><br><span class="line"><span class="section"># 3.如何运行在项目的根目录中执行</span></span><br><span class="line"><span class="code">npm start 运行前端系统</span></span><br><span class="line"></span><br><span class="line"><span class="section"># 4.如何访问项目</span></span><br><span class="line"><span class="code">http://localhost:8081    </span></span><br><span class="line"></span><br><span class="line"><span class="section"># 5.Vue Cli中项目开发方式</span></span><br><span class="line"><span class="code"> 注意: 一切皆组件   一个组件中   js代码  html代码  css样式</span></span><br><span class="line"><span class="code"> </span></span><br><span class="line"><span class="bullet"> 1. </span>VueCli开发方式是在项目中开发一个一个组件对应一个业务功能模块,日后可以将多个组件组合到一起形成一个前端系统</span><br><span class="line"><span class="bullet"> 2. </span>日后在使用vue Cli进行开发时不再书写html,编写的是一个个组件(组件后缀.vue结尾的文件),日后打包时vue cli会将组件编译成运行的html文件</span><br></pre></td></tr></table></figure><h5 id="4-如何开发Vue脚手架"><a href="#4-如何开发Vue脚手架" class="headerlink" title="4.如何开发Vue脚手架"></a>4.如何开发Vue脚手架</h5><p><code>注意:在Vue cli 中一切皆组件</code></p><hr><h2 id="15-在脚手架中使用axios"><a href="#15-在脚手架中使用axios" class="headerlink" title="15.在脚手架中使用axios"></a>15.在脚手架中使用axios</h2><h3 id="15-1-安装axios"><a href="#15-1-安装axios" class="headerlink" title="15.1 安装axios"></a>15.1 安装axios</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.安装axios</span></span><br><span class="line"><span class="code">npm install axios --save-dev</span></span><br><span class="line"></span><br><span class="line"><span class="section"># 2.配置main.js中引入axios</span></span><br><span class="line"><span class="code">import axios from 'axios';</span></span><br><span class="line"></span><br><span class="line"><span class="code">Vue.prototype.$http=axios;</span></span><br><span class="line"></span><br><span class="line"><span class="section"># 3.使用axios</span></span><br><span class="line"><span class="code">在需要发送异步请求的位置:this.$http.get("url").then((res)=&gt;&#123;&#125;) this.$http.post("url").then((res)=&gt;&#123;&#125;)</span></span><br></pre></td></tr></table></figure><hr><h2 id="16-Vue-Cli脚手架项目打包和部署"><a href="#16-Vue-Cli脚手架项目打包和部署" class="headerlink" title="16.Vue Cli脚手架项目打包和部署"></a>16.Vue Cli脚手架项目打包和部署</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.在项目根目录中执行如下命令:</span></span><br><span class="line"><span class="code">  vue run build</span></span><br><span class="line"></span><br><span class="line"><span class="code">注意:vue脚手架打包的项目必须在服务器上运行不能直接双击运行</span></span><br><span class="line"></span><br><span class="line"><span class="section"># 2.打包之后当前项目中变化</span></span><br><span class="line"><span class="code"> 在打包之后项目中出现dist目录,dist目录就是vue脚手架项目生产目录或者说是直接部署目录</span></span><br><span class="line"></span><br><span class="line"><span class="section"># 3.</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      前端体系、前后端分离
    
    </summary>
    
    
      <category term="Vue" scheme="https://SomunsTao.github.io/categories/Vue/"/>
    
    
      <category term="Vue" scheme="https://SomunsTao.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue 12： 知识总结</title>
    <link href="https://somunstao.github.io/2020/04/22/Vue%2012%EF%BC%9A%E6%80%BB%E7%BB%93/"/>
    <id>https://somunstao.github.io/2020/04/22/Vue%2012%EF%BC%9A%E6%80%BB%E7%BB%93/</id>
    <published>2020-04-21T16:00:00.000Z</published>
    <updated>2020-08-01T15:19:42.152Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Vue-知识总结"><a href="#Vue-知识总结" class="headerlink" title="Vue 知识总结"></a>Vue 知识总结</h1><h5 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h5><blockquote><p>基于vue 2+ 写一份知识总结，可以说是学习笔记</p></blockquote><h5 id="目录："><a href="#目录：" class="headerlink" title="目录："></a>目录：</h5><blockquote><p>一、vue实例的基本结构<br>二、vue事件处理、绑定属性<br>三、vue指令、自定义指令<br>四、vue过滤器<br>五、vue数据监听<br>六、vue组件<br>七、vue-router<br>八、axios</p></blockquote><h5 id="一、Vue-实例的基本结构"><a href="#一、Vue-实例的基本结构" class="headerlink" title="一、Vue 实例的基本结构"></a>一、Vue 实例的基本结构</h5><p><a href="https://cn.vuejs.org/v2/api/" target="_blank" rel="noopener">Vue官网API</a></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">  &lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;p&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Welcome</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var vm &#x3D; new Vue(&#123;</span><br><span class="line">  el: &#39;#app&#39;, &#x2F;&#x2F;等价于后面的 .$mount(&#39;#app&#39;) 用其中之一就可以了</span><br><span class="line">  render: h &#x3D;&gt; h(App), &#x2F;&#x2F;理解不够深入，参考（https:&#x2F;&#x2F;cn.vuejs.org&#x2F;v2&#x2F;api&#x2F;?#render）</span><br><span class="line">  data: &#123; </span><br><span class="line">    &#x2F;&#x2F;页面响应的数据都放在这里如上（组件只接受 function 且必须返回一个对象），zhicvm.$data 访问这里面的data</span><br><span class="line">    msg: &#39;Welcome&#39;,</span><br><span class="line">  &#125;,</span><br><span class="line">  props:&#123;</span><br><span class="line">    &#x2F;&#x2F;props 可以是数组或对象，接收任何值</span><br><span class="line">  &#125;,</span><br><span class="line">  methods:  &#123;</span><br><span class="line">    &#x2F;&#x2F;页面或组件定义的方法的集合，可通过 vm.reset() 直接调用</span><br><span class="line">    reset: function()&#123;</span><br><span class="line">      this.msg &#x3D; &#39;这是重新设置之后的数据&#39;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    &#x2F;&#x2F;计算属性(computed)与方法(methods) 类似，如果计算数据量比较大，建议放到这里</span><br><span class="line">    &#x2F;&#x2F;计算属性的结果会被缓存，除非依赖的响应式属性变化才会重新计算。</span><br><span class="line">    &#x2F;&#x2F;参考（https:&#x2F;&#x2F;cn.vuejs.org&#x2F;v2&#x2F;api&#x2F;?#computed）</span><br><span class="line">  &#125;,</span><br><span class="line">  components：&#123;</span><br><span class="line">    &#x2F;&#x2F; 局部组件注册的地方</span><br><span class="line">    &#39;component-a&#39;: ComponentA,</span><br><span class="line">    &#39;component-b&#39;: ComponentB</span><br><span class="line">  &#125;,</span><br><span class="line">  directives: &#123;</span><br><span class="line">    &#x2F;&#x2F; 局部指令注册的地方</span><br><span class="line">    focus: &#123;</span><br><span class="line">      &#x2F;&#x2F; 指令的定义</span><br><span class="line">      inserted: function (el,binding) &#123;</span><br><span class="line">        el.focus(); </span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  filters:&#123;</span><br><span class="line">    &#x2F;&#x2F; 局部过滤器注册的地方</span><br><span class="line">  &#125;,</span><br><span class="line">  &#x2F;&#x2F;生命周期钩子</span><br><span class="line">  beforeCreate: function ()&#123;&#125;, &#x2F;&#x2F;在实例初始化之后，数据观测 (data observer) 和 event&#x2F;watcher 事件配置之前被调用。</span><br><span class="line">  created: function ()&#123;&#125;,&#x2F;&#x2F;在实例创建完成后被立即调用。</span><br><span class="line">  beforeMount: function ()&#123;&#125;,&#x2F;&#x2F;在挂载开始之前被调用：相关的 render 函数首次被调用。</span><br><span class="line">  mounted: function ()&#123;&#125;,&#x2F;&#x2F;el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子。</span><br><span class="line">  beforeUpdate: function ()&#123;&#125;,&#x2F;&#x2F;数据更新时调用，发生在虚拟 DOM 打补丁之前。</span><br><span class="line">  updated: function ()&#123;&#125;,&#x2F;&#x2F;由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。</span><br><span class="line">  beforeDestroy: function ()&#123;&#125;,&#x2F;&#x2F;实例销毁之前调用。在这一步，实例仍然完全可用。</span><br><span class="line">  destroyed: function ()&#123;</span><br><span class="line">    &#x2F;&#x2F;Vue 实例销毁后调用。</span><br><span class="line">    &#x2F;&#x2F;调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;).$mount(&#39;#app&#39;)</span><br></pre></td></tr></table></figure><h5 id="二、Vue-事件处理、绑定属性"><a href="#二、Vue-事件处理、绑定属性" class="headerlink" title="二、Vue 事件处理、绑定属性"></a>二、Vue 事件处理、绑定属性</h5><p><a href="https://cn.vuejs.org/v2/api/?#v-on" target="_blank" rel="noopener">v-on：</a></p><blockquote><p>1、绑定事件监听器。用在普通元素上时，只能监听<a href="https://developer.mozilla.org/zh-CN/docs/Web/Events" target="_blank" rel="noopener"><strong>原生 DOM 事件</strong></a>（如：click、keyup/down、mouseenter/over/move/down/out 等）。也可以监听自定义事件即 methods 里面的事件。<br>2、在监听原生 DOM 事件时，方法以事件为唯一的参数。如果使用内联语句，语句可以访问一个 $event 属性：v-on:click=”handle(‘ok’, $event)”。</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">修饰符：</span><br><span class="line">.stop - 调用 event.stopPropagation()。阻止冒泡</span><br><span class="line">.prevent - 调用 event.preventDefault()。阻止默认事件</span><br><span class="line">.capture - 添加事件侦听器时使用 capture 模式。</span><br><span class="line">.self - 只当事件是从侦听器绑定的元素本身触发时才触发回调。</span><br><span class="line">.&#123;keyCode | keyAlias&#125; - 只当事件是从特定键触发时才触发回调。</span><br><span class="line">.native - 监听组件根元素的原生事件。</span><br><span class="line">.once - 只触发一次回调。</span><br><span class="line">.left - (2.2.0) 只当点击鼠标左键时触发。</span><br><span class="line">.right - (2.2.0) 只当点击鼠标右键时触发。</span><br><span class="line">.middle - (2.2.0) 只当点击鼠标中键时触发。</span><br><span class="line">.passive - (2.3.0) 以 &#123; passive: true &#125; 模式添加侦听器</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">用法：</span><br><span class="line">&lt;!-- 内联语句 --&gt;</span><br><span class="line">&lt;button v-on:click&#x3D;&quot;doThat(&#39;hello&#39;, $event)&quot;&gt;&lt;&#x2F;button&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 缩写 --&gt;</span><br><span class="line">&lt;button @click&#x3D;&quot;doThis&quot;&gt;&lt;&#x2F;button&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 停止冒泡 --&gt;</span><br><span class="line">&lt;button @click.stop&#x3D;&quot;doThis&quot;&gt;&lt;&#x2F;button&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 对象语法 (2.4.0+) --&gt;</span><br><span class="line">&lt;button v-on&#x3D;&quot;&#123; mousedown: doThis, mouseup: doThat &#125;&quot;&gt;&lt;&#x2F;button&gt;</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br></pre></td></tr></table></figure><ul><li>v-on 还提供了<a href="https://cn.vuejs.org/v2/guide/events.html#%E6%8C%89%E9%94%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6" target="_blank" rel="noopener">按键修饰符</a></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">键盘按钮的别名</span><br><span class="line">.enter</span><br><span class="line">.tab</span><br><span class="line">.delete (捕获“删除”和“退格”键)</span><br><span class="line">.esc</span><br><span class="line">.space</span><br><span class="line">.up</span><br><span class="line">.down</span><br><span class="line">.left</span><br><span class="line">.right</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 可以通过全局 &#96;config.keyCodes&#96; 对象自定义按键修饰符别名</span><br><span class="line">&#x2F;&#x2F; 使用 方式 &#96;v-on:keyup.f1&#96; ，f1 这个名字你可以任意取，你知道是什么意思就可以了</span><br><span class="line">Vue.config.keyCodes.f1 &#x3D; 112</span><br></pre></td></tr></table></figure><p><a href="https://cn.vuejs.org/v2/api/?#v-bind" target="_blank" rel="noopener">v-bind：</a></p><blockquote><p>动态地绑定一个或多个特性，或一个组件 prop 到表达式。</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 绑定一个属性 --&gt;</span><br><span class="line">&lt;img v-bind:src&#x3D;&quot;imageSrc&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 缩写 --&gt;</span><br><span class="line">&lt;img :src&#x3D;&quot;imageSrc&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 内联字符串拼接 --&gt;</span><br><span class="line">&lt;img :src&#x3D;&quot;&#39;&#x2F;path&#x2F;to&#x2F;images&#x2F;&#39; + fileName&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- class 绑定 --&gt;</span><br><span class="line">&lt;div :class&#x3D;&quot;&#123; red: isRed &#125;&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;div :class&#x3D;&quot;[classA, classB]&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;div :class&#x3D;&quot;[classA, &#123; classB: isB, classC: isC &#125;]&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- style 绑定 --&gt;</span><br><span class="line">&lt;div :style&#x3D;&quot;&#123; fontSize: size + &#39;px&#39; &#125;&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;div :style&#x3D;&quot;[styleObjectA, styleObjectB]&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 绑定一个有属性的对象 --&gt;</span><br><span class="line">&lt;div v-bind&#x3D;&quot;&#123; id: someProp, &#39;other-attr&#39;: otherProp &#125;&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- prop 绑定。“prop”必须在 my-component 中声明。--&gt;</span><br><span class="line">&lt;my-component :prop&#x3D;&quot;someThing&quot;&gt;&lt;&#x2F;my-component&gt;</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br></pre></td></tr></table></figure><h4 id="三、Vue-指令、自定义指令"><a href="#三、Vue-指令、自定义指令" class="headerlink" title="三、Vue 指令、自定义指令"></a>三、Vue 指令、自定义指令</h4><p><a href="https://cn.vuejs.org/v2/api/?#%E6%8C%87%E4%BB%A4" target="_blank" rel="noopener">Vue指令：</a></p><p>v-text：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;span v-text&#x3D;&quot;msg&quot;&gt;&lt;&#x2F;span&gt;</span><br><span class="line">&lt;!-- 和下面的一样 --&gt;</span><br><span class="line">&lt;span&gt;&#123;&#123;msg&#125;&#125;&lt;&#x2F;span&gt;</span><br></pre></td></tr></table></figure><p>v-html：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;输出真正的 HTML</span><br><span class="line">&lt;div v-html&#x3D;&quot;html&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">data&#123;</span><br><span class="line">  html:&#39;&lt;strong&gt;我是真正的html&lt;&#x2F;strong&gt;&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>v-show：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;根据表达式之真假值，切换元素的 display CSS 属性。</span><br><span class="line">&lt;h1 v-show&#x3D;&quot;ok&quot;&gt;Hello!&lt;&#x2F;h1&gt;</span><br></pre></td></tr></table></figure><p>v-if、v-if-else、v-else：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;v-if 是“真正”的条件渲染，如果条件为假，dom不会渲染在页面当中</span><br><span class="line">&#x2F;&#x2F;v-show 会一直渲染在dom当中</span><br><span class="line">&#x2F;&#x2F;当 v-if 与 v-for 一起使用时，v-for 具有比 v-if 更高的优先级。</span><br><span class="line">&lt;h1 v-if&#x3D;&quot;ok&quot;&gt;Yes&lt;&#x2F;h1&gt;</span><br><span class="line"></span><br><span class="line">&lt;h1 v-if&#x3D;&quot;ok&quot;&gt;Yes&lt;&#x2F;h1&gt;</span><br><span class="line">&lt;h1 v-else&gt;No&lt;&#x2F;h1&gt;</span><br><span class="line"></span><br><span class="line">&lt;div v-if&#x3D;&quot;type &#x3D;&#x3D;&#x3D; &#39;A&#39;&quot;&gt;A&lt;&#x2F;div&gt;</span><br><span class="line">&lt;div v-else-if&#x3D;&quot;type &#x3D;&#x3D;&#x3D; &#39;B&#39;&quot;&gt;B&lt;&#x2F;div&gt;</span><br><span class="line">&lt;div v-else-if&#x3D;&quot;type &#x3D;&#x3D;&#x3D; &#39;C&#39;&quot;&gt;C&lt;&#x2F;div&gt;</span><br><span class="line">&lt;div v-else&gt;Not A&#x2F;B&#x2F;C&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><p>v-for：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;基于源数据多次渲染元素或模板块。</span><br><span class="line">&lt;div v-for&#x3D;&quot;item in items&quot;&gt;</span><br><span class="line">  &#123;&#123; item.text &#125;&#125;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;另外也可以为数组索引指定别名 (或者用于对象的键)：val-&gt;对象的键值  key-&gt;对象的键  index-&gt;对象的下标</span><br><span class="line">&lt;div v-for&#x3D;&quot;(item, index) in items&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;div v-for&#x3D;&quot;(val, key) in object&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;div v-for&#x3D;&quot;(val, key, index) in object&quot;&gt;&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><p>v-model：作用于<input>、<select>、<textarea>，<br>当v-model作用于 <strong>多个复选框</strong>、<strong>当选择按钮</strong>、<strong>选择框</strong> 时，都是把这些标签的value值赋值给v-model的变量</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">修饰符：</span><br><span class="line">.lazy - 取代 &#96;input&#96; 监听 &#96;change&#96; 事件</span><br><span class="line">.number- 输入字符串转为数字</span><br><span class="line">.trim- 输入首尾空格过滤</span><br><span class="line"></span><br><span class="line">&lt;input v-model&#x3D;&quot;message&quot; placeholder&#x3D;&quot;edit me&quot;&gt;</span><br><span class="line">&lt;textarea v-model&#x3D;&quot;message&quot; placeholder&#x3D;&quot;add multiple lines&quot;&gt;&lt;&#x2F;textarea&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 选择框</span><br><span class="line">&lt;select v-model&#x3D;&quot;selected&quot;&gt;</span><br><span class="line">   &lt;option disabled value&#x3D;&quot;&quot;&gt;请选择&lt;&#x2F;option&gt;</span><br><span class="line">   &lt;option&gt;A&lt;&#x2F;option&gt;</span><br><span class="line">   &lt;option&gt;B&lt;&#x2F;option&gt;</span><br><span class="line">   &lt;option&gt;C&lt;&#x2F;option&gt;</span><br><span class="line">&lt;&#x2F;select&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 用 v-for 渲染的动态选项：</span><br><span class="line">&lt;select v-model&#x3D;&quot;selected&quot;&gt;</span><br><span class="line">  &lt;option v-for&#x3D;&quot;option in options&quot; v-bind:value&#x3D;&quot;option.value&quot;&gt;</span><br><span class="line">    &#123;&#123; option.text &#125;&#125;</span><br><span class="line">  &lt;&#x2F;option&gt;</span><br><span class="line">&lt;&#x2F;select&gt;</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br></pre></td></tr></table></figure><p>v-pre：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;跳过这个元素和它的子元素的编译过程。可以用来显示原始 Mustache 标签。跳过大量没有指令的节点会加快编译。</span><br><span class="line">&#x2F;&#x2F;Mustache 标签：&#123;&#123; &#125;&#125;</span><br><span class="line">&lt;span v-pre&gt;&#123;&#123; this will not be compiled &#125;&#125;&lt;&#x2F;span&gt;</span><br></pre></td></tr></table></figure><p>v-cloak：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;这个指令保持在元素上直到关联实例结束编译</span><br><span class="line">css:</span><br><span class="line">[v-cloak] &#123;</span><br><span class="line">  display: none;</span><br><span class="line">&#125;</span><br><span class="line">html:</span><br><span class="line">&lt;div v-cloak&gt;</span><br><span class="line">  &#123;&#123; message &#125;&#125;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><p>v-once：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">只渲染元素和组件一次。随后的重新渲染，元素&#x2F;组件及其所有的子节点将被视为静态内容并跳过。这可以用于优化更新性能。</span><br><span class="line"></span><br><span class="line">&lt;!-- 单个元素 --&gt;</span><br><span class="line">&lt;span v-once&gt;This will never change: &#123;&#123;msg&#125;&#125;&lt;&#x2F;span&gt;</span><br><span class="line">&lt;!-- 有子元素 --&gt;</span><br><span class="line">&lt;div v-once&gt;</span><br><span class="line">  &lt;h1&gt;comment&lt;&#x2F;h1&gt;</span><br><span class="line">  &lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;&#x2F;p&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;!-- 组件 --&gt;</span><br><span class="line">&lt;my-component v-once :comment&#x3D;&quot;msg&quot;&gt;&lt;&#x2F;my-component&gt;</span><br><span class="line">&lt;!-- &#96;v-for&#96; 指令--&gt;</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;li v-for&#x3D;&quot;i in list&quot; v-once&gt;&#123;&#123;i&#125;&#125;&lt;&#x2F;li&gt;</span><br><span class="line">&lt;&#x2F;ul&gt;</span><br></pre></td></tr></table></figure><p><a href="https://cn.vuejs.org/v2/guide/custom-directive.html" target="_blank" rel="noopener">Vue自定义指令：</a></p><p><a href="https://cn.vuejs.org/v2/guide/custom-directive.html#%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0" target="_blank" rel="noopener">指令的钩子函数：</a> 一个指令定义对象可以提供如下几个钩子函数 (均为可选)：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;bind&#96;：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。</span><br><span class="line"></span><br><span class="line">&#96;inserted&#96;：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。</span><br><span class="line"></span><br><span class="line">&#96;update&#96;：1、所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。</span><br><span class="line">          2、指令的值可能发生了改变，也可能没有。</span><br><span class="line">          3、你可以通过比较更新前后的值来忽略不必要的模板更新 (详细的钩子函数参数见下)。</span><br><span class="line"></span><br><span class="line">&#96;componentUpdated&#96;：指令所在组件的 VNode 及其子 VNode 全部更新后调用。</span><br><span class="line"></span><br><span class="line">&#96;unbind&#96;：只调用一次，指令与元素解绑时调用。</span><br></pre></td></tr></table></figure><p><a href="https://cn.vuejs.org/v2/guide/custom-directive.html#%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0" target="_blank" rel="noopener">钩子函数的参数</a> (即 el、binding、vnode 和 oldVnode)。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;el&#96;：指令所绑定的元素，可以用来直接操作 DOM 。</span><br><span class="line"></span><br><span class="line">&#96;binding&#96;：一个对象，包含以下属性：</span><br><span class="line">    &#96;name&#96;：指令名，不包括 &#96;v-&#96; 前缀。</span><br><span class="line">    &#96;value&#96;：指令的绑定值，例如：&#96;v-my-directive&#x3D;&quot;1 + 1&quot;&#96; 中，绑定值为 &#96;2&#96;。</span><br><span class="line">    &#96;oldValue&#96;：指令绑定的前一个值，仅在 &#96;update&#96; 和 &#96;componentUpdated&#96; 钩子中可用。无论值是否改变都可用。</span><br><span class="line">    &#96;expression&#96;：字符串形式的指令表达式。例如 &#96;v-my-directive&#x3D;&quot;1 + 1&quot;&#96; 中，表达式为 &#96;&quot;1 + 1&quot;&#96;。</span><br><span class="line">    &#96;arg&#96;：传给指令的参数，可选。例如 &#96;v-my-directive:foo&#96; 中，参数为 &#96;&quot;foo&quot;&#96;。</span><br><span class="line">    &#96;modifiers&#96;：一个包含修饰符的对象。例如：&#96;v-my-directive.foo.bar&#96; 中，修饰符对象为 &#96;&#123; foo: true, bar: true &#125;&#96;。</span><br><span class="line"></span><br><span class="line">&#96;vnode&#96;：Vue 编译生成的虚拟节点。移步(https:&#x2F;&#x2F;cn.vuejs.org&#x2F;v2&#x2F;api&#x2F;#VNode%E6%8E%A5%E5%8F%A3) 来了解更多详情。</span><br><span class="line"></span><br><span class="line">&#96;oldVnode&#96;：上一个虚拟节点，仅在 &#96;update&#96; 和 &#96;componentUpdated&#96; 钩子中可用。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 注册一个全局自定义指令 &#96;v-focus&#96;</span><br><span class="line">&#x2F;&#x2F; 在这里需要注意一下，给一个全局指令命名的时候不要加 &#96;v-&#96; 前缀，用在dom的时候再加上</span><br><span class="line">Vue.directive(&#39;focus&#39;, &#123;</span><br><span class="line">  &#x2F;&#x2F; 当被绑定的元素插入到 DOM 中时……</span><br><span class="line">  inserted: function (el,binding) &#123;</span><br><span class="line">    &#x2F;&#x2F; 聚焦元素</span><br><span class="line">    el.focus();</span><br><span class="line">    console.log(binding.value) &#x2F;&#x2F;&#x3D;&gt;666</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;如果想注册局部指令，组件中也接受一个 directives 的选项：</span><br><span class="line">directives: &#123;</span><br><span class="line">  focus: &#123;</span><br><span class="line">    &#x2F;&#x2F; 指令的定义</span><br><span class="line">    inserted: function (el,binding) &#123;</span><br><span class="line">      el.focus(); </span><br><span class="line">      console.log(binding.value) &#x2F;&#x2F;&#x3D;&gt;666</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;然后你可以在模板中任何元素上使用新的 v-focus 属性，如下：</span><br><span class="line">&lt;input v-focus&#x3D;&quot;6666&quot;&gt;  &#x2F;&#x2F; 6666 可用data 里面的变量替换，建议传简单数据类型</span><br></pre></td></tr></table></figure><blockquote><p>一个正常的业务不可能只有一个指令，如果把所有的指令都注册在main.js里面会不好管理，所以最好放在一个统一文件 directives.js<br>这里就产生了两个问题：<br>1、怎么把directives.js 这个文件引用到main.js<br>2、Vue.directives() 支不支持链式调用（因为老版本angular 支持，所以做一个假想）</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 第二个问题很好解决，经过测试，Vue.directives() 不支持链式调用 &#96;Vue.directives().directives()&#96;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 第一个问题：经过查阅相关资料之后可以以插件的形式引入</span><br><span class="line">&#x2F;&#x2F; 这种方式引入暂时还没有发现有其他的问题</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; main.js</span><br><span class="line">import directives from &#39;.&#x2F;directives.js&#39;</span><br><span class="line">Vue.use(directives);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; directives.js</span><br><span class="line">export default&#123;</span><br><span class="line">  &#x2F;&#x2F; install 方法会默认在main.js里面调用</span><br><span class="line">  install(Vue)&#123;</span><br><span class="line">    Vue.directive(&#39;focus&#39;,&#123;</span><br><span class="line">      inserted(el,binding)&#123;</span><br><span class="line">        el.focus();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    Vue.directive(&#39;data&#39;,&#123;</span><br><span class="line">      inserted(el)&#123;</span><br><span class="line">        console.log(el)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    &#x2F;&#x2F;有多个就继续往这里添加就好了</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="四、Vue-过滤器"><a href="#四、Vue-过滤器" class="headerlink" title="四、Vue 过滤器"></a>四、Vue 过滤器</h4><p><a href="https://cn.vuejs.org/v2/guide/filters.html" target="_blank" rel="noopener">Vue 过滤器的用法</a></p><blockquote><p>过滤器可以用在两个地方：双花括号插值和 v-bind 表达式 (后者从 2.1.0+ 开始支持)。<br>与指令的用法类似，但过滤器一定要有返回值，也不支持链式调用</p></blockquote><blockquote><p><strong>这里需要注意的地方是，vue 2.0 之后移除了自带的过滤器</strong></p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 在双花括号中</span><br><span class="line">&#123;&#123; message | capitalize &#125;&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 在 &#96;v-bind&#96; 中</span><br><span class="line">&lt;div v-bind:id&#x3D;&quot;rawId | formatId&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 局部注册过滤器</span><br><span class="line">filters: &#123;</span><br><span class="line">  &#x2F;&#x2F; 首字母大写</span><br><span class="line">  capitalize: function (value) &#123;</span><br><span class="line">    &#x2F;&#x2F; value 就是 ‘|’ 符号前面的值</span><br><span class="line">    if (!value) return &#39;&#39;;</span><br><span class="line">    value &#x3D; value.toString()</span><br><span class="line">    return value.charAt(0).toUpperCase() + value.slice(1)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 注册全局过滤器</span><br><span class="line">Vue.filter(&#39;capitalize&#39;, function (value) &#123;</span><br><span class="line">  if (!value) return &#39;&#39;;</span><br><span class="line">  value &#x3D; value.toString()</span><br><span class="line">  return value.charAt(0).toUpperCase() + value.slice(1)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 过滤器传值</span><br><span class="line">&#123;&#123; number | dual(2) &#125;&#125;</span><br><span class="line"></span><br><span class="line">Vue.filter(&#39;dual&#39;, function (value,type) &#123;</span><br><span class="line">  &#x2F;&#x2F; 回调函数里面默认有 value ,在页面上传过来的值会依次添加在后面</span><br><span class="line">  console.log(type)  &#x2F;&#x2F; &#x3D;&gt; 2</span><br><span class="line">  if (!value) return &#39;&#39;;</span><br><span class="line">  if (typeof value !&#x3D;&#x3D; &quot;number&quot;) return alert(value + &#39; 不是数字&#39;);</span><br><span class="line">  if( parseInt(type) &#x3D;&#x3D;&#x3D; 2 )&#123;</span><br><span class="line">    return value &#x3D; value &gt; 10 ? value : &#39;0&#39; + value</span><br><span class="line">  &#125;</span><br><span class="line">  return value</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 过滤器的插件用法，与 directives.js 一致</span><br><span class="line">&#x2F;&#x2F; main.js</span><br><span class="line">import directives from &#39;.&#x2F;filters.js&#39;</span><br><span class="line">Vue.use(filters);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; filters.js</span><br><span class="line">export default &#123;</span><br><span class="line">  install(Vue)&#123;</span><br><span class="line">    Vue.filter(&#39;dual&#39;, function (value,type) &#123;</span><br><span class="line">      if (!value) return &#39;&#39;;</span><br><span class="line">      if (typeof value !&#x3D;&#x3D; &quot;number&quot;) return alert(value + &#39; 不是数字&#39;);</span><br><span class="line">      if( parseInt(type) &#x3D;&#x3D;&#x3D; 2 )&#123;</span><br><span class="line">        return value &#x3D; value &gt; 10 ? value : &#39;0&#39; + value</span><br><span class="line">      &#125;</span><br><span class="line">      return value</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="五、Vue-数据监听"><a href="#五、Vue-数据监听" class="headerlink" title="五、Vue 数据监听"></a>五、Vue 数据监听</h4><p><a href="https://cn.vuejs.org/v2/api/#watch" target="_blank" rel="noopener">Vue 数据监听 watch</a></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; watch 基本用法与注意事项</span><br><span class="line">data: &#123;</span><br><span class="line">  a: 1,</span><br><span class="line">  e: &#123;</span><br><span class="line">    f: &#123;</span><br><span class="line">      g: 5</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  items: [</span><br><span class="line">    &#123; message: &#39;Foo&#39; &#125;,</span><br><span class="line">    &#123; message: &#39;Bar&#39; &#125;</span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br><span class="line">mounted: function()&#123;</span><br><span class="line">  this.a &#x3D; 2；</span><br><span class="line">  this.e.f.g &#x3D; 10;</span><br><span class="line">  this.$set(this.items, 0, &#123; message: &#39;AAA&#39; &#125;);  &#x2F;&#x2F; $set 赋值</span><br><span class="line">  this.items[0] &#x3D; &#123; message: &#39;AAA&#39; &#125;;  &#x2F;&#x2F; 直接赋值</span><br><span class="line">&#125;,</span><br><span class="line">watch: &#123;</span><br><span class="line">  &#x2F;&#x2F; 最简单最直接的监听方式，能监听简单的数据变化，这种方法默认就是执行 handler: function()&#123;&#125;</span><br><span class="line">  &#x2F;&#x2F; 注意：这种方式监听不到对象的变化</span><br><span class="line">  a: function(val, oldVal)&#123;</span><br><span class="line">    console.log(val);  &#x2F;&#x2F; &#x3D;&gt; 变化之后的数据</span><br><span class="line">    console.log(oldVal); &#x2F;&#x2F; &#x3D;&gt; 变化之前的数据</span><br><span class="line">  &#125;,</span><br><span class="line">  &#x2F;&#x2F; 深度监听，这里要注意一下，这样的方式打印出来两个值都是变化之后的值</span><br><span class="line">  &#x2F;&#x2F; deep 的值默认为false，如果不写或者deep: false 都不能监听到对象值的变化</span><br><span class="line">  e: &#123;</span><br><span class="line">    handler: function (val, oldVal) &#123;</span><br><span class="line">      console.log(val);  &#x2F;&#x2F; &#x3D;&gt; 变化之后的数据</span><br><span class="line">      console.log(oldVal);  &#x2F;&#x2F; &#x3D;&gt; 变化之后的数据</span><br><span class="line">    &#125;,</span><br><span class="line">    deep: true, </span><br><span class="line">  &#125;,</span><br><span class="line">  &#x2F;&#x2F; 如果要精准监听的对象值的变化，可以用这种方法</span><br><span class="line">  &#39;e.f.g&#39;: function (val, oldVal) &#123;</span><br><span class="line">    console.log(val);  &#x2F;&#x2F; &#x3D;&gt; 变化之后的数据</span><br><span class="line">    console.log(oldVal);  &#x2F;&#x2F; &#x3D;&gt; 变化之前的数据</span><br><span class="line">  &#125;,</span><br><span class="line">  &#x2F;&#x2F; 监听数组</span><br><span class="line">  &#x2F;&#x2F; 由于 JavaScript 的限制，Vue 不能检测 this.items[0] &#x3D; &#123; message: &#39;AAA&#39; &#125;; 这种方式赋值的变化</span><br><span class="line">  &#x2F;&#x2F; 所以你要用 $set、或者数组变异的方法赋值</span><br><span class="line">  items: function(val, oldVal)&#123;</span><br><span class="line">    console.log(val);  &#x2F;&#x2F; &#x3D;&gt; 变化之后的数据</span><br><span class="line">    console.log(oldVal);  &#x2F;&#x2F; &#x3D;&gt; 变化之后的数据</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://cn.vuejs.org/v2/guide/list.html#%E6%95%B0%E7%BB%84%E6%9B%B4%E6%96%B0%E6%A3%80%E6%B5%8B" target="_blank" rel="noopener">Vue 数组更新检测</a></p><p>官网的介绍：<strong>由于 JavaScript 的限制，Vue 不能检测以下变动的数组</strong><br>换句话来说：<strong>这样赋值不触发视图更新</strong></p><ul><li>1、当你利用索引直接设置一个项时，例如：</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">this.items[indexOfItem] &#x3D; newValue  &#x2F;&#x2F; indexOfItem 是指数组的index 下标</span><br></pre></td></tr></table></figure><ul><li>2、当你修改数组的长度时，例如：</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">this.items.length &#x3D; newLength</span><br></pre></td></tr></table></figure><p>要解决上面问题，你可以用以下方式解决：</p><h6 id="1、Vue-set-target-key-value-，set方法有下面3个参数"><a href="#1、Vue-set-target-key-value-，set方法有下面3个参数" class="headerlink" title="1、Vue.set( target, key, value) ，set方法有下面3个参数"></a>1、<a href="https://cn.vuejs.org/v2/api/#Vue-set" target="_blank" rel="noopener">Vue.set( target, key, value)</a> ，set方法有下面3个参数</h6><ul><li>{Object | Array} target  – 给谁设置值（对象，数组）都可以</li><li>{string | number} key – 给对象设值，key 就是对象的key，给数组设值，key 就是数组的下标 index</li><li>{any} value – 添加任何值都可以</li></ul><h6 id="2、数组变异的方式"><a href="#2、数组变异的方式" class="headerlink" title="2、数组变异的方式"></a>2、数组变异的方式</h6><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/push" target="_blank" rel="noopener">push()</a>：将一个或多个元素添加到数组的末尾，并返回新数组的长度。<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/pop" target="_blank" rel="noopener">pop()</a>：从数组中删除最后一个元素，并返回该元素的值。此方法更改数组的长度。<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/shift" target="_blank" rel="noopener">shift()</a>：从数组中删除第一个元素，并返回该元素的值。<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/unshift" target="_blank" rel="noopener">unshift()</a>：将一个或多个元素添加到数组的开头，并返回新数组的长度。<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/splice" target="_blank" rel="noopener">splice()</a>：通过删除现有元素和/或添加新元素来更改一个数组的内容。<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/sort" target="_blank" rel="noopener">sort()</a>：用<a href="https://en.wikipedia.org/wiki/Sorting_algorithm#Stability" target="_blank" rel="noopener">就地（ in-place ）的算法</a>对数组的元素进行排序，并返回数组。 sort 排序不一定是<a href="https://zh.wikipedia.org/wiki/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95#.E7.A9.A9.E5.AE.9A.E6.80.A7" target="_blank" rel="noopener">稳定的</a>。默认排序顺序是根据字符串Unicode码点。<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/reverse" target="_blank" rel="noopener">reverse()</a>：将数组中元素的位置颠倒。</p><h4 id="六、Vue-组件"><a href="#六、Vue-组件" class="headerlink" title="六、Vue 组件"></a>六、Vue 组件</h4><p><a href="https://cn.vuejs.org/v2/guide/components.html" target="_blank" rel="noopener">Vue 组件基础</a></p><blockquote><p>组件是可复用的 Vue 实例，所以它们与 new Vue 接收相同的选项，例如 data、computed、watch、methods 以及生命周期钩子等。<br>注意：<strong>组件没有 el 这样根实例特有的选项；而根实例没有 props 这个子组件特有的属性</strong></p></blockquote><ul><li>Vue.component( 组件名 ,{ 选项 }) 全局注册</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 全局注册组件的时候必须写在Vue实例创建之前</span><br><span class="line">&#x2F;&#x2F; 下面这几种方式是等价的</span><br><span class="line">import Vue from &#39;vue&#39;</span><br><span class="line">var MyComponent &#x3D; Vue.extend(&#123;</span><br><span class="line">  template:&quot;&lt;h1&gt;我是全局组件&lt;&#x2F;h1&gt;&quot;</span><br><span class="line">&#125;);</span><br><span class="line">Vue.component(&quot;my-component&quot;,MyComponent);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 注册组件，传入一个扩展过的构造器</span><br><span class="line">Vue.component(&#39;my-component&#39;, Vue.extend(&#123; &#x2F;* ... *&#x2F; &#125;))</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 注册组件，传入一个选项对象 (自动调用 Vue.extend)</span><br><span class="line">Vue.component(&#39;my-component&#39;, &#123; &#x2F;* ... *&#x2F; &#125;)</span><br></pre></td></tr></table></figure><ul><li>通常情况下一个组件肯定是由很多html标签组成的，如果全部写在template 里会非常难看且没有语法高亮提示，有没有其他解决办法？还真有</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 一个定义模板的方式是在一个 &lt;script&gt; 元素中，并为其带上 text&#x2F;x-template 的类型，然后通过一个 id 将模板引用过去。</span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;x-template&quot; id&#x3D;&quot;hello-world-template&quot;&gt;</span><br><span class="line">  &lt;p&gt;Hello hello hello&lt;&#x2F;p&gt;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 另一个定义模板的方式是在一个 &lt;template&gt; 元素中，通过一个 id 将模板引用过去；在单文件组件 .vue 当中，id可以省略；</span><br><span class="line">&lt;template id&#x3D;&quot;hello-world-template&quot;&gt;</span><br><span class="line">  &lt;p&gt;Hello hello hello&lt;&#x2F;p&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">Vue.component(&quot;my-component&quot;,&#123;</span><br><span class="line">    template:&quot;#hello-world-template&quot;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>引入外部单文件组件注册成全局组件</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; .vue </span><br><span class="line">&#x2F;&#x2F; 在单文件组件中 template 标签下只能有一个根元素</span><br><span class="line">&#x2F;&#x2F; 如果硬要有多个根元素，你只能在多个根元素中添加 v-if、v-else-if、v-else 来判断什么时候用哪个根元素</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;home&quot;&gt;</span><br><span class="line">    &lt;p&gt;&#123;&#123;getting&#125;&#125;&lt;&#x2F;p&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">  &lt;!-- &lt;p&gt;这样是不行的&lt;&#x2F;p&gt; --&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    name: &quot;home&quot;,  &#x2F;&#x2F; 便于在vue-devtools 调试中提供更加友好的警告信息</span><br><span class="line">    data: function () &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        getting: &#39;welcome&#39;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">&#x2F;&#x2F; 局部css样式</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; main.js</span><br><span class="line">import home from &#39;.&#x2F;components&#x2F;home&#x2F;home&#39;</span><br><span class="line">Vue.component(&#39;home&#39;,home);</span><br></pre></td></tr></table></figure><ul><li>局部注册组件</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 每个vue 实例都会有一个 components 的选项，而组件是可复用的 Vue 实例，所以每个组件都有components 选项</span><br><span class="line">&#x2F;&#x2F; 引入外部文件注册成局部组件</span><br><span class="line">import home from &#39;.&#x2F;components&#x2F;home&#x2F;home&#39;</span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el:&quot;#app&quot;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    home, &#x2F;&#x2F; 等价于home: home，ES6对象中属性的简洁表示，ES6(http:&#x2F;&#x2F;es6.ruanyifeng.com&#x2F;#docs&#x2F;object)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 直接在components 选项中写，(不推荐这种用法)</span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el:&quot;#app&quot;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    loading: &#123;</span><br><span class="line">      data: function () &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">          getting: &#39;welcome&#39;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      components:&#123;</span><br><span class="line">       &#x2F;&#x2F; 这里还可以嵌套局部组件... </span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li><h6 id="组件间的传值"><a href="#组件间的传值" class="headerlink" title="组件间的传值"></a>组件间的传值</h6></li></ul><p><a href="https://cn.vuejs.org/v2/guide/components-props.html" target="_blank" rel="noopener">通过 Prop 向子组件传递数据</a></p><ul><li>注意：这种传值方式是<a href="https://cn.vuejs.org/v2/guide/components-props.html#%E5%8D%95%E5%90%91%E6%95%B0%E6%8D%AE%E6%B5%81" target="_blank" rel="noopener">单向数据流</a>，不可逆。</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; HTML 中的特性名是大小写不敏感的，所以浏览器会把所有大写字符解释为小写字符。</span><br><span class="line">&#x2F;&#x2F; 这意味着当你使用 DOM 中的模板时，驼峰命名法的 prop 名需要使用其等价的 短横线分隔命名命名。</span><br><span class="line">&#x2F;&#x2F; 如果使用字符串模板，那么这个限制就不存在了。</span><br><span class="line">Vue.component(&#39;my-component&#39;, &#123;</span><br><span class="line">  props: [&#39;myTitle&#39;],</span><br><span class="line">  template: &#39;&lt;h3&gt;&#123;&#123; myTitle&#125;&#125;&lt;&#x2F;h3&gt;&#39;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; HTML</span><br><span class="line">&lt;my-component my-title&#x3D;&#39;hello world&#39;&gt;&lt;&#x2F;my-component&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 上述例子只是一个静态数据传输，如果你要动态传输数据，可以用 v-bind 绑定一个属性</span><br><span class="line">&#x2F;&#x2F; 也可以用v-bind 的缩写形式</span><br><span class="line">&lt;my-component v-bind:my-title&#x3D;&#39;hello world&#39;&gt;&lt;&#x2F;my-component&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 任何类型的值都可以传递给 prop，prop 允许很多个</span><br><span class="line">&#x2F;&#x2F; 如果你想要将一个对象的所有属性都作为 prop 传入，你可以使用不带参数的 v-bind，如：</span><br><span class="line">obj: &#123;</span><br><span class="line">  id: 1,</span><br><span class="line">  title: &#39;Hello World&#39;</span><br><span class="line">&#125;</span><br><span class="line">&lt;my-component v-bind&#x3D;&#39;obj&#39;&gt;&lt;&#x2F;my-component&gt;</span><br><span class="line">&#x2F;&#x2F; 等价于：</span><br><span class="line">&lt;my-component </span><br><span class="line">  v-bind:id&#x3D;&#39;obj.id&#39;</span><br><span class="line">  v-bind:title&#x3D;&#39;obj.title&#39;</span><br><span class="line">&gt;&lt;&#x2F;my-component&gt;</span><br></pre></td></tr></table></figure><p><a href="https://cn.vuejs.org/v2/guide/components-props.html#Prop-%E9%AA%8C%E8%AF%81" target="_blank" rel="noopener">Prop 还提供验证的方式指定传什么值</a></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Vue.component(&#39;my-component&#39;, &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    &#x2F;&#x2F; 基础的类型检查 (&#96;null&#96; 匹配任何类型)</span><br><span class="line">    propA: Number,</span><br><span class="line">    &#x2F;&#x2F; 多个可能的类型</span><br><span class="line">    propB: [String, Number],</span><br><span class="line">    &#x2F;&#x2F; 必填的字符串</span><br><span class="line">    propC: &#123;</span><br><span class="line">      type: String,</span><br><span class="line">      required: true</span><br><span class="line">    &#125;,</span><br><span class="line">    &#x2F;&#x2F; 带有默认值的数字</span><br><span class="line">    propD: &#123;</span><br><span class="line">      type: Number,</span><br><span class="line">      default: 100</span><br><span class="line">    &#125;,</span><br><span class="line">    &#x2F;&#x2F; 带有默认值的对象</span><br><span class="line">    propE: &#123;</span><br><span class="line">      type: Object,</span><br><span class="line">      &#x2F;&#x2F; 对象或数组且一定会从一个工厂函数返回默认值</span><br><span class="line">      default: function () &#123;</span><br><span class="line">        return &#123; message: &#39;hello&#39; &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#x2F;&#x2F; 自定义验证函数</span><br><span class="line">    propF: &#123;</span><br><span class="line">      validator: function (value) &#123;</span><br><span class="line">        &#x2F;&#x2F; 这个值必须匹配下列字符串中的一个</span><br><span class="line">        return [&#39;success&#39;, &#39;warning&#39;, &#39;danger&#39;].indexOf(value) !&#x3D;&#x3D; -1</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>既然 prop 的单向的，那如果子组件向父组件传值怎么办？</p><ul><li>子传父，使用 <a href="https://cn.vuejs.org/v2/guide/components-custom-events.html" target="_blank" rel="noopener">自定义事件</a> 的方式</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 子组件,子组件可以通过$emit() 广播一个事件给父组件</span><br><span class="line">&#x2F;&#x2F; 命名的这个事件名没有限制，子组件与父组件的名字保持一致就可以了</span><br><span class="line">&lt;button v-on:click&#x3D;&quot;$emit(&#39;broadcast&#39;)&quot;&gt;向父组件广播这个事件&lt;&#x2F;button&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; $emit() 这个方法也可以写在 子组件的 methods 里面</span><br><span class="line">&lt;button v-on:click&#x3D;&quot;broadcast&quot;&gt;向父组件广播这个事件&lt;&#x2F;button&gt;</span><br><span class="line">methods: &#123;</span><br><span class="line">  broadcast()&#123;</span><br><span class="line">    this.$emit(&#39;broadcast&#39;)</span><br><span class="line">    &#x2F;&#x2F; 如果要传值，就使用$emit(事件名, 值) 的第二个参数</span><br><span class="line">    this.$emit(&#39;broadcast&#39;, value)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 在父组件中，父组件可以用 v-on 监听子组件触发的 &#96;broadcast&#96; 事件，类似监听Dom 事件一样的用法</span><br><span class="line">&lt;my-component v-on:broadcast&#x3D;&#39;catchYou&#39;&gt;&lt;&#x2F;my-component&gt;</span><br><span class="line">methods: &#123;</span><br><span class="line">  catchYou(val)&#123;</span><br><span class="line">    &#x2F;&#x2F; 子组件传过来的值就会作为第一个参数传入这个方法 </span><br><span class="line">    console.log(val)</span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br><span class="line">&#x2F;&#x2F; 在组件的表达式里面，你可以通过$event 访问到子组件传递过来的值</span><br><span class="line">&lt;my-component v-on:broadcast&#x3D;&#39;$event&#39;&gt;&lt;&#x2F;my-component&gt;</span><br></pre></td></tr></table></figure><ul><li>组件的一些其他用法，感兴趣可以去了解 <a href="https://cn.vuejs.org/v2/guide/components-slots.html" target="_blank" rel="noopener">插槽</a>   <a href="https://cn.vuejs.org/v2/guide/components-dynamic-async.html" target="_blank" rel="noopener">动态组件 &amp; 异步组件</a></li><li><a href="https://cn.vuejs.org/v2/guide/transitions.html#%E5%8D%95%E5%85%83%E7%B4%A0-%E7%BB%84%E4%BB%B6%E7%9A%84%E8%BF%87%E6%B8%A1" target="_blank" rel="noopener">单元素/组件的过渡</a></li></ul><h4 id="七、vue-router"><a href="#七、vue-router" class="headerlink" title="七、vue-router"></a>七、vue-router</h4><ul><li>贴一段 app 构建的案例。官网API <a href="https://router.vuejs.org/zh-cn/essentials/getting-started.html" target="_blank" rel="noopener">点这里</a></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 这里我让 app.vue作为最大的渲染层，渲染tabs --&gt;</span><br><span class="line">&lt;!-- 这里我模拟的是一个商场app，下面几个tab；点击&#96;tab&#96;直接渲染在&#96;tabs&#96;的&lt;router-view&gt;&lt;&#x2F;router-view&gt;上 --&gt;</span><br><span class="line">&lt;!-- tabs 之外的页面直接渲染在app.vue 的&lt;router-view&gt;&lt;&#x2F;router-view&gt;上 --&gt;</span><br><span class="line">&lt;!--  app.vue --&gt;</span><br><span class="line">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">  &lt;router-view&gt;&lt;&#x2F;router-view&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tabs.vue --&gt;</span><br><span class="line">&lt;div class&#x3D;&quot;tabs&quot;&gt;</span><br><span class="line">  &lt;router-view&gt;&lt;&#x2F;router-view&gt;</span><br><span class="line">  &lt;nav class&#x3D;&quot;nav&quot;&gt;</span><br><span class="line">    &lt;router-link class&#x3D;&quot;nav-link&quot; to&#x3D;&quot;home&quot;&gt;</span><br><span class="line">      &lt;i&gt;&lt;&#x2F;i&gt;</span><br><span class="line">      &lt;p&gt;首页&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;&#x2F;router-link&gt;</span><br><span class="line">  &lt;nav&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 以下一些配置是简单要用到的，高级的用法请看官网</span><br><span class="line">&#x2F;&#x2F; router.js</span><br><span class="line">import tabs from &#39;.&#x2F;components&#x2F;tabs&#x2F;tabs&#39;</span><br><span class="line">import home from &#39;.&#x2F;components&#x2F;home&#x2F;home&#39;</span><br><span class="line">const router &#x3D;  new VueRouter(&#123;</span><br><span class="line">  mode: &#39;history&#39;,  &#x2F;&#x2F; 可选值: &quot;hash&quot; 、 &quot;history&quot; 、 &quot;abstract&quot; </span><br><span class="line">  linkActiveClass: &#39;active&#39;,  &#x2F;&#x2F; 默认值: &quot;router-link-active&quot; 全局配置 &lt;router-link&gt; 的默认『激活 class 类名』</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: &quot;&#x2F;tabs&quot;,    &#x2F;&#x2F; 指向的路径</span><br><span class="line">      name: &quot;tabs&quot;,   &#x2F;&#x2F; 命名路由，可以通过这个名称跳转到这个组件</span><br><span class="line">      component: tabs, &#x2F;&#x2F; 指向路径加载的组件</span><br><span class="line">      children: [  &#x2F;&#x2F; 嵌套路由也有跟父级一样的选项</span><br><span class="line">        &#123;</span><br><span class="line">          path:&quot;home&quot;,</span><br><span class="line">          name: &quot;home&quot;,</span><br><span class="line">          component: home, </span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      path: &#39;&#x2F;&#39;,</span><br><span class="line">      redirect: &#39;&#x2F;tabs&#x2F;home&#39;   &#x2F;&#x2F; 重定向，即无目标地址的时候转到这个路径</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;);</span><br><span class="line">export default router;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; main.js</span><br><span class="line">import router from &#39;.&#x2F;router.js&#39;</span><br><span class="line">new Vue(&#123;</span><br><span class="line">  router,</span><br><span class="line">  render: h &#x3D;&gt; h(App)</span><br><span class="line">&#125;).$mount(&#39;#app&#39;);</span><br></pre></td></tr></table></figure><ul><li><a href="https://router.vuejs.org/zh/api/#router-link" target="_blank" rel="noopener">router-link</a> 的几种跳转方式</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 字符串模式，可以说是静态模式，不用v-bind --&gt;</span><br><span class="line">&lt;router-link to&#x3D;&quot;home&quot;&gt;Home&lt;&#x2F;router-link&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 下面几种是动态模式 --&gt;</span><br><span class="line">&lt;!-- 使用 v-bind 的 JS 表达式 --&gt;</span><br><span class="line">&lt;router-link v-bind:to&#x3D;&quot;&#39;home&#39;&quot;&gt;Home&lt;&#x2F;router-link&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 不写 v-bind 也可以，就像绑定别的属性一样 --&gt;</span><br><span class="line">&lt;router-link :to&#x3D;&quot;&#39;home&#39;&quot;&gt;Home&lt;&#x2F;router-link&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 同上 --&gt;</span><br><span class="line">&lt;router-link :to&#x3D;&quot;&#123; path: &#39;home&#39; &#125;&quot;&gt;Home&lt;&#x2F;router-link&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 跳转到命名的路由 --&gt;</span><br><span class="line">&lt;!-- 这里有需要注意的地方是，如果路由有传值，那这里的params 就不能省略--&gt;</span><br><span class="line">&lt;router-link :to&#x3D;&quot;&#123; name: &#39;user&#39; , params: &#123; userId &#125;&#125;&quot;&gt;User&lt;&#x2F;router-link&gt;</span><br></pre></td></tr></table></figure><ul><li>router 传值的几种方式<br><strong>注意：如果提供了 path，params 会被忽略，取而代之的是提供路由的 name 或手写完整的带有参数的 path，同样的规则也适用于 router-link 组件的 to 属性</strong></li><li>另外的传参方式，有兴趣可以了解一下 <a href="https://router.vuejs.org/zh/guide/essentials/passing-props.html#%E5%B8%83%E5%B0%94%E6%A8%A1%E5%BC%8F" target="_blank" rel="noopener">props</a></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 在函数里面</span><br><span class="line">this.$router.push(&#123; name: &#39;user&#39;, params: &#123; userId &#125;&#125;)</span><br><span class="line">this.$router.push(&#123; path: &#96;&#x2F;user&#x2F;$&#123;userId&#125;&#96; &#125;)  &#x2F;&#x2F; &#96;$&#123; &#125;&#96; 是ES6 的模板字符串概念，标识符是 &#96; &#96;</span><br><span class="line">&#x2F;&#x2F; 这里的 params 不生效</span><br><span class="line">this.$router.push(&#123; path: &#39;&#x2F;user&#39;, params: &#123; userId &#125;&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; router-link 传值</span><br><span class="line">&lt;router-link :to&#x3D;&quot;&#123; name: &#39;user&#39;,params: &#123; userId &#125; &#125;&quot;&gt;User&lt;&#x2F;router-link&gt;</span><br><span class="line">&lt;router-link :to&#x3D;&quot;&#123; path: &#96;&#x2F;user&#x2F;$&#123;userId&#125;&#96; &#125;&quot;&gt;User&lt;&#x2F;router-link&gt;</span><br><span class="line">&#x2F;&#x2F; 这里的 params 不生效</span><br><span class="line">&lt;router-link :to&#x3D;&quot;&#123; path: &#39;&#x2F;user&#39;, params: &#123; userId &#125;&#125;&quot;&gt;User&lt;&#x2F;router-link&gt;</span><br></pre></td></tr></table></figure><ul><li>目标组件取值<br><strong>这里要很小心，是 this.$route，不是 this.$router，没有 r 的</strong></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 使用这种方式获取路由传过来的值</span><br><span class="line">this.$route.params.userId</span><br></pre></td></tr></table></figure><ul><li>路由的命名视图，这里贴的是官网的例子，官网API <a href="https://router.vuejs.org/zh/guide/essentials/named-views.html#%E5%B5%8C%E5%A5%97%E5%91%BD%E5%90%8D%E8%A7%86%E5%9B%BE" target="_blank" rel="noopener">点这里</a></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- html --&gt;</span><br><span class="line">&lt;router-view class&#x3D;&quot;view one&quot;&gt;&lt;&#x2F;router-view&gt;</span><br><span class="line">&lt;router-view class&#x3D;&quot;view two&quot; name&#x3D;&quot;a&quot;&gt;&lt;&#x2F;router-view&gt;</span><br><span class="line">&lt;router-view class&#x3D;&quot;view three&quot; name&#x3D;&quot;b&quot;&gt;&lt;&#x2F;router-view&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js</span><br><span class="line">const router &#x3D; new VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: &#39;&#x2F;&#39;,</span><br><span class="line">      components: &#123; &#x2F;&#x2F; 这里的 &#96;components&#96; 要跟上面的 &#96;component&#96; 区分一下，有多个视图渲染的时候有 &#96;s&#96;，别漏了</span><br><span class="line">        default: Foo,  &#x2F;&#x2F; 这是默认指定的 Foo 这个组件，也就是在没有命名的&lt;router-view&gt;上渲染</span><br><span class="line">        a: Bar,  &#x2F;&#x2F; 这里一一对应有 name 属性的&lt;router-view&gt;就可以了</span><br><span class="line">        b: Baz</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>几种导航的方法，官网 <a href="https://router.vuejs.org/zh/guide/essentials/navigation.html" target="_blank" rel="noopener">点这里</a><br>下面几种方法跟 window.history 的几种方法很像，其实就是仿照 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/History" target="_blank" rel="noopener">window.history</a></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 往路由历史新增一条记录，相关参数参考官网</span><br><span class="line">this.$router.push(location, onComplete?, onAbort?)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 替换掉当前的记录</span><br><span class="line">this.$router.replace(location, onComplete?, onAbort?)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 在浏览器记录中前进一步，等同于 this.$router.forward()</span><br><span class="line">this.$router.go(1)</span><br><span class="line">this.$router.forward()</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 后退一步记录，等同于 this.$router.back()</span><br><span class="line">this.$router.go(-1)</span><br><span class="line">this.$router.back()</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 前进 3 步记录</span><br><span class="line">this.$router.go(3)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 如果 history 记录不够用，那就默默地失败呗</span><br><span class="line">this.$router.go(-100)</span><br><span class="line">this.$router.go(100)</span><br></pre></td></tr></table></figure><ul><li>路由跳转的时候支持过度动效，感兴趣可以去玩一下，官网 <a href="https://router.vuejs.org/zh/guide/advanced/transitions.html#%E5%8D%95%E4%B8%AA%E8%B7%AF%E7%94%B1%E7%9A%84%E8%BF%87%E6%B8%A1" target="_blank" rel="noopener">点这里</a> （还有其他更加高级的用法要靠自己去<a href="https://router.vuejs.org/zh/guide/advanced/scroll-behavior.html" target="_blank" rel="noopener">查阅</a>了）</li></ul><h4 id="八、axios"><a href="#八、axios" class="headerlink" title="八、axios"></a>八、axios</h4><p><a href="https://www.npmjs.com/package/axios" target="_blank" rel="noopener">axios 英文文档</a><br><a href="https://www.kancloud.cn/yunye/axios/234845" target="_blank" rel="noopener">axios 中文文档 — 对英文文档的翻译</a><br><strong>axios 是基于 ES6 的 Promise 写的，具体可以看</strong> <a href="http://es6.ruanyifeng.com/#docs/promise" target="_blank" rel="noopener">Promise 相关说明</a></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; npm 安装</span><br><span class="line">npm i axiso  &#x2F;&#x2F; 等价于 npm install axios ，i 是 install 的简写</span><br></pre></td></tr></table></figure><p><strong>axios 的一些简单用法</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; GET 请求</span><br><span class="line">&#x2F;&#x2F; 为给定 ID 的 user 创建请求</span><br><span class="line">axios.get(&#39;&#x2F;user?ID&#x3D;12345&#39;)</span><br><span class="line">  .then(function (response) &#123;</span><br><span class="line">    console.log(response);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(function (error) &#123;</span><br><span class="line">    console.log(error);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 上面的请求可以这样做</span><br><span class="line">axios.get(&#39;&#x2F;user&#39;, &#123;</span><br><span class="line">  params: &#123;</span><br><span class="line">    ID: 12345</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">.then(function (response) &#123;</span><br><span class="line">  console.log(response);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(function (error) &#123;</span><br><span class="line">  console.log(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; POST 请求</span><br><span class="line">axios.post(&#39;&#x2F;user&#39;, &#123;</span><br><span class="line">    firstName: &#39;Fred&#39;,</span><br><span class="line">    lastName: &#39;Flintstone&#39;</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(function (response) &#123;</span><br><span class="line">    console.log(response);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(function (error) &#123;</span><br><span class="line">    console.log(error);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;  执行多个并发请求</span><br><span class="line">function getUserAccount() &#123;</span><br><span class="line">  return axios.get(&#39;&#x2F;user&#x2F;12345&#39;);</span><br><span class="line">&#125;</span><br><span class="line">function getUserPermissions() &#123;</span><br><span class="line">  return axios.get(&#39;&#x2F;user&#x2F;12345&#x2F;permissions&#39;);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 这两个方法返回的都是 Promise 对象，这两个请求方法都成功返回的时候，下面方法才返回成功。</span><br><span class="line">&#x2F;&#x2F; 这两个方法中有一个返回不成功就算返回失败 </span><br><span class="line">axios.all([getUserAccount(), getUserPermissions()])</span><br><span class="line">  .then(axios.spread(function (acct, perms) &#123;</span><br><span class="line">    &#x2F;&#x2F; 两个请求现在都执行完成</span><br><span class="line">  &#125;));</span><br></pre></td></tr></table></figure><p><strong>通过向 axios 传递相关配置来创建请求</strong></p><ul><li>axios(config)</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 发送 POST 请求</span><br><span class="line">axios(&#123;</span><br><span class="line">  method: &#39;post&#39;,</span><br><span class="line">  url: &#39;&#x2F;user&#x2F;12345&#39;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    firstName: &#39;Fred&#39;,</span><br><span class="line">    lastName: &#39;Flintstone&#39;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>axios(url[, config])</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 发送 GET 请求（默认的方法）</span><br><span class="line">axios(&#39;&#x2F;user&#x2F;12345&#39;);</span><br></pre></td></tr></table></figure><p><strong>为方便，axios 还为支持的请求方法提供了别名，如：</strong><br><em>注意：在使用别名方法时， url、method、data 这些属性都不必在配置中指定。</em></p><ul><li>axios.request(config)</li><li>axios.get(url[, config])</li><li>axios.delete(url[, config])</li><li>axios.head(url[, config])</li><li>axios.post(url[, data[, config]])</li><li>axios.put(url[, data[, config]])</li><li>axios.patch(url[, data[, config]])</li></ul><p><strong>处理并发请求的助手函数</strong></p><ul><li>axios.all(iterable)</li><li>axios.spread(callback)</li></ul><p><strong>还有其他高级用法，具体请查阅官网</strong> <a href="https://www.npmjs.com/package/axios" target="_blank" rel="noopener">axios 英文文档</a></p>]]></content>
    
    <summary type="html">
    
      前端体系、前后端分离
    
    </summary>
    
    
      <category term="Vue" scheme="https://SomunsTao.github.io/categories/Vue/"/>
    
    
      <category term="Vue" scheme="https://SomunsTao.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue 11：实战快速上手</title>
    <link href="https://somunstao.github.io/2020/04/21/Vue%2011%EF%BC%9A%E5%AE%9E%E6%88%98%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/"/>
    <id>https://somunstao.github.io/2020/04/21/Vue%2011%EF%BC%9A%E5%AE%9E%E6%88%98%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/</id>
    <published>2020-04-20T16:00:00.000Z</published>
    <updated>2020-08-01T15:19:27.256Z</updated>
    
    <content type="html"><![CDATA[<p>​    </p><h1 id="Vue：实战快速上手"><a href="#Vue：实战快速上手" class="headerlink" title="Vue：实战快速上手"></a>Vue：实战快速上手</h1><p>我们采用实战教学模式并结合 <code>ElementUI</code> 组件库，将所需知识点应用到实际中，以最快速度带领大家掌握 Vue 的使用;</p><h2 id="创建工程"><a href="#创建工程" class="headerlink" title="创建工程"></a>创建工程</h2><p>注意： 命令行都要使用管理员模式运行</p><p>1、创建一个名为 hello-vue 的工程 <code>vue init webpack hello-vue</code><br>2、安装依赖，我们需要安装 vue-router、element-ui、sass-loader 和 node-sass 四个插件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 进入工程目录</span><br><span class="line">cd hello-vue</span><br><span class="line"># 安装 vue-router</span><br><span class="line">npm install vue-router --save-dev</span><br><span class="line"># 安装 element-ui</span><br><span class="line">npm i element-ui -S</span><br><span class="line"># 安装依赖</span><br><span class="line">npm install</span><br><span class="line"># 安装 SASS 加载器</span><br><span class="line">cnpm install sass-loader node-sass --save-dev</span><br><span class="line"># 启动测试</span><br><span class="line">npm run dev</span><br></pre></td></tr></table></figure><p>3、Npm命令解释：</p><ul><li><code>npm install moduleName</code>：安装模块到项目目录下</li><li><code>npm install -g moduleName</code>：-g 的意思是将模块安装到全局，具体安装到磁盘哪个位置，要看 npm config prefix 的位置</li><li><code>npm install -save moduleName</code>：–save 的意思是将模块安装到项目目录下，并在 package 文件的 dependencies 节点写入依赖，-S 为该命令的缩写</li><li><code>npm install -save-dev moduleNam</code>e：–save-dev 的意思是将模块安装到项目目录下，并在 package 文件的 devDependencies 节点写入依赖，-D 为该命令的缩写</li></ul><h2 id="创建登录页面"><a href="#创建登录页面" class="headerlink" title="创建登录页面"></a>创建登录页面</h2><p>把没有用的初始化东西删掉！</p><p>在源码目录中创建如下结构：</p><ul><li>assets：用于存放资源文件</li><li>components：用于存放 Vue 功能组件</li><li>views：用于存放 Vue 视图组件</li><li>router：用于存放 vue-router 配置</li></ul><p><img src="https://blog.kuangstudy.com/usr/uploads/2019/10/1596391106.jpg" alt="QQ截图20191025101406.jpg"></p><p><strong>创建首页视图，在 views 目录下创建一个名为 Main.vue 的视图组件；</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      首页</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    export default &#123;</span><br><span class="line">        name: &quot;Main&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure><p><strong>创建登录页视图在 views 目录下创建一个名为 Login.vue 的视图组件，其中 el-* 的元素为 ElementUI 组件；</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;el-form ref&#x3D;&quot;loginForm&quot; :model&#x3D;&quot;form&quot; :rules&#x3D;&quot;rules&quot; label-width&#x3D;&quot;80px&quot; class&#x3D;&quot;login-box&quot;&gt;</span><br><span class="line">      &lt;h3 class&#x3D;&quot;login-title&quot;&gt;欢迎登录&lt;&#x2F;h3&gt;</span><br><span class="line">      &lt;el-form-item label&#x3D;&quot;账号&quot; prop&#x3D;&quot;username&quot;&gt;</span><br><span class="line">        &lt;el-input type&#x3D;&quot;text&quot; placeholder&#x3D;&quot;请输入账号&quot; v-model&#x3D;&quot;form.username&quot;&#x2F;&gt;</span><br><span class="line">      &lt;&#x2F;el-form-item&gt;</span><br><span class="line">      &lt;el-form-item label&#x3D;&quot;密码&quot; prop&#x3D;&quot;password&quot;&gt;</span><br><span class="line">        &lt;el-input type&#x3D;&quot;password&quot; placeholder&#x3D;&quot;请输入密码&quot; v-model&#x3D;&quot;form.password&quot;&#x2F;&gt;</span><br><span class="line">      &lt;&#x2F;el-form-item&gt;</span><br><span class="line">      &lt;el-form-item&gt;</span><br><span class="line">        &lt;el-button type&#x3D;&quot;primary&quot; v-on:click&#x3D;&quot;onSubmit(&#39;loginForm&#39;)&quot;&gt;登录&lt;&#x2F;el-button&gt;</span><br><span class="line">      &lt;&#x2F;el-form-item&gt;</span><br><span class="line">    &lt;&#x2F;el-form&gt;</span><br><span class="line"></span><br><span class="line">    &lt;el-dialog</span><br><span class="line">      title&#x3D;&quot;温馨提示&quot;</span><br><span class="line">      :visible.sync&#x3D;&quot;dialogVisible&quot;</span><br><span class="line">      width&#x3D;&quot;30%&quot;</span><br><span class="line">      :before-close&#x3D;&quot;handleClose&quot;&gt;</span><br><span class="line">      &lt;span&gt;请输入账号和密码&lt;&#x2F;span&gt;</span><br><span class="line">      &lt;span slot&#x3D;&quot;footer&quot; class&#x3D;&quot;dialog-footer&quot;&gt;</span><br><span class="line">        &lt;el-button type&#x3D;&quot;primary&quot; @click&#x3D;&quot;dialogVisible &#x3D; false&quot;&gt;确 定&lt;&#x2F;el-button&gt;</span><br><span class="line">      &lt;&#x2F;span&gt;</span><br><span class="line">    &lt;&#x2F;el-dialog&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    name: &quot;Login&quot;,</span><br><span class="line">    data() &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        form: &#123;</span><br><span class="line">          username: &#39;&#39;,</span><br><span class="line">          password: &#39;&#39;</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 表单验证，需要在 el-form-item 元素中增加 prop 属性</span><br><span class="line">        rules: &#123;</span><br><span class="line">          username: [</span><br><span class="line">            &#123;required: true, message: &#39;账号不可为空&#39;, trigger: &#39;blur&#39;&#125;</span><br><span class="line">          ],</span><br><span class="line">          password: [</span><br><span class="line">            &#123;required: true, message: &#39;密码不可为空&#39;, trigger: &#39;blur&#39;&#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 对话框显示和隐藏</span><br><span class="line">        dialogVisible: false</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      onSubmit(formName) &#123;</span><br><span class="line">        &#x2F;&#x2F; 为表单绑定验证功能</span><br><span class="line">        this.$refs[formName].validate((valid) &#x3D;&gt; &#123;</span><br><span class="line">          if (valid) &#123;</span><br><span class="line">            &#x2F;&#x2F; 使用 vue-router 路由到指定页面，该方式称之为编程式导航</span><br><span class="line">            this.$router.push(&quot;&#x2F;main&quot;);</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">            this.dialogVisible &#x3D; true;</span><br><span class="line">            return false;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style lang&#x3D;&quot;scss&quot; scoped&gt;</span><br><span class="line">  .login-box &#123;</span><br><span class="line">    border: 1px solid #DCDFE6;</span><br><span class="line">    width: 350px;</span><br><span class="line">    margin: 180px auto;</span><br><span class="line">    padding: 35px 35px 15px 35px;</span><br><span class="line">    border-radius: 5px;</span><br><span class="line">    -webkit-border-radius: 5px;</span><br><span class="line">    -moz-border-radius: 5px;</span><br><span class="line">    box-shadow: 0 0 25px #909399;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  .login-title &#123;</span><br><span class="line">    text-align: center;</span><br><span class="line">    margin: 0 auto 40px auto;</span><br><span class="line">    color: #303133;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure><p><strong>创建路由,在 router 目录下创建一个名为 index.js 的 vue-router 路由配置文件</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import Vue from &#39;vue&#39;</span><br><span class="line">import Router from &#39;vue-router&#39;</span><br><span class="line"></span><br><span class="line">import Login from &quot;..&#x2F;views&#x2F;Login&quot;</span><br><span class="line">import Main from &#39;..&#x2F;views&#x2F;Main&#39;</span><br><span class="line"></span><br><span class="line">Vue.use(Router);</span><br><span class="line"></span><br><span class="line">export default new Router(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      &#x2F;&#x2F; 登录页</span><br><span class="line">      path: &#39;&#x2F;login&#39;,</span><br><span class="line">      name: &#39;Login&#39;,</span><br><span class="line">      component: Login</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &#x2F;&#x2F; 首页</span><br><span class="line">      path: &#39;&#x2F;main&#39;,</span><br><span class="line">      name: &#39;Main&#39;,</span><br><span class="line">      component: Main</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>配置路由，修改入口代码，修改 main.js 入口代码</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import Vue from &#39;vue&#39;</span><br><span class="line">import VueRouter from &#39;vue-router&#39;</span><br><span class="line">import router from &#39;.&#x2F;router&#39;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 导入 ElementUI</span><br><span class="line">import ElementUI from &#39;element-ui&#39;</span><br><span class="line">import &#39;element-ui&#x2F;lib&#x2F;theme-chalk&#x2F;index.css&#39;</span><br><span class="line"></span><br><span class="line">import App from &#39;.&#x2F;App&#39;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 安装路由</span><br><span class="line">Vue.use(VueRouter);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 安装 ElementUI</span><br><span class="line">Vue.use(ElementUI);</span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: &#39;#app&#39;,</span><br><span class="line">  &#x2F;&#x2F; 启用路由</span><br><span class="line">  router,</span><br><span class="line">  &#x2F;&#x2F; 启用 ElementUI</span><br><span class="line">  render: h &#x3D;&gt; h(App)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>修改 App.vue 组件代码</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">    &lt;router-view&#x2F;&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    name: &#39;App&#39;,</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>测试 ： 在浏览器打开 <a href="http://localhost/" target="_blank" rel="noopener">http://localhost</a>:8080/#/login</p><p>如果出现错误: 可能是因为sass-loader的版本过高导致的编译错误，当前最高版本是8.x，需要退回到7.3.1 ；</p><p>去package.json文件里面的 “sass-loader”的版本更换成7.3.1，然后重新<code>cnpm install</code>就可以了；</p><p><img src="https://blog.kuangstudy.com/usr/uploads/2019/10/1972241333.jpg" alt="QQ截图20191025111608.jpg"></p><h2 id="路由嵌套"><a href="#路由嵌套" class="headerlink" title="路由嵌套"></a>路由嵌套</h2><p>嵌套路由又称子路由，在实际应用中，通常由多层嵌套的组件组合而成。同样地，URL 中各段动态路径也按某种结构对应嵌套的各层组件，例如：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;user&#x2F;foo&#x2F;profile                     &#x2F;user&#x2F;foo&#x2F;posts</span><br><span class="line">+------------------+                  +-----------------+</span><br><span class="line">| User             |                  | User            |</span><br><span class="line">| +--------------+ |                  | +-------------+ |</span><br><span class="line">| | Profile      | |  +------------&gt;  | | Posts       | |</span><br><span class="line">| |              | |                  | |             | |</span><br><span class="line">| +--------------+ |                  | +-------------+ |</span><br><span class="line">+------------------+                  +-----------------+</span><br></pre></td></tr></table></figure><p>1、用户信息组件，在 views/user 目录下创建一个名为 Profile.vue 的视图组件；</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      个人信息</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    export default &#123;</span><br><span class="line">        name: &quot;UserProfile&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure><p>2、用户列表组件在 views/user 目录下创建一个名为 List.vue 的视图组件；</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      用户列表</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    export default &#123;</span><br><span class="line">        name: &quot;UserList&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure><p>3、配置嵌套路由修改 router 目录下的 index.js 路由配置文件，代码如</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import Vue from &#39;vue&#39;</span><br><span class="line">import Router from &#39;vue-router&#39;</span><br><span class="line"></span><br><span class="line">import Login from &quot;..&#x2F;views&#x2F;Login&quot;</span><br><span class="line">import Main from &#39;..&#x2F;views&#x2F;Main&#39;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 用于嵌套的路由组件</span><br><span class="line">import UserProfile from &#39;..&#x2F;views&#x2F;user&#x2F;Profile&#39;</span><br><span class="line">import UserList from &#39;..&#x2F;views&#x2F;user&#x2F;List&#39;</span><br><span class="line"></span><br><span class="line">Vue.use(Router);</span><br><span class="line"></span><br><span class="line">export default new Router(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      &#x2F;&#x2F; 登录页</span><br><span class="line">      path: &#39;&#x2F;login&#39;,</span><br><span class="line">      name: &#39;Login&#39;,</span><br><span class="line">      component: Login</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &#x2F;&#x2F; 首页</span><br><span class="line">      path: &#39;&#x2F;main&#39;,</span><br><span class="line">      name: &#39;Main&#39;,</span><br><span class="line">      component: Main,</span><br><span class="line">      &#x2F;&#x2F; 配置嵌套路由</span><br><span class="line">      children: [</span><br><span class="line">        &#123;path: &#39;&#x2F;user&#x2F;profile&#39;, component: UserProfile&#125;,</span><br><span class="line">        &#123;path: &#39;&#x2F;user&#x2F;list&#39;, component: UserList&#125;,</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>说明：主要在路由配置中增加了 children 数组配置，用于在该组件下设置嵌套路由</p><p>4、修改首页视图，我们修改 Main.vue 视图组件，此处使用了 ElementUI 布局容器组件，代码如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;el-container&gt;</span><br><span class="line">        &lt;el-aside width&#x3D;&quot;200px&quot;&gt;</span><br><span class="line">          &lt;el-menu :default-openeds&#x3D;&quot;[&#39;1&#39;]&quot;&gt;</span><br><span class="line">            &lt;el-submenu index&#x3D;&quot;1&quot;&gt;</span><br><span class="line">              &lt;template slot&#x3D;&quot;title&quot;&gt;&lt;i class&#x3D;&quot;el-icon-caret-right&quot;&gt;&lt;&#x2F;i&gt;用户管理&lt;&#x2F;template&gt;</span><br><span class="line">              &lt;el-menu-item-group&gt;</span><br><span class="line">                &lt;el-menu-item index&#x3D;&quot;1-1&quot;&gt;</span><br><span class="line">                  &lt;router-link to&#x3D;&quot;&#x2F;user&#x2F;profile&quot;&gt;个人信息&lt;&#x2F;router-link&gt;</span><br><span class="line">                &lt;&#x2F;el-menu-item&gt;</span><br><span class="line">                &lt;el-menu-item index&#x3D;&quot;1-2&quot;&gt;</span><br><span class="line">                  &lt;router-link to&#x3D;&quot;&#x2F;user&#x2F;list&quot;&gt;用户列表&lt;&#x2F;router-link&gt;</span><br><span class="line">                &lt;&#x2F;el-menu-item&gt;</span><br><span class="line">              &lt;&#x2F;el-menu-item-group&gt;</span><br><span class="line">            &lt;&#x2F;el-submenu&gt;</span><br><span class="line">            &lt;el-submenu index&#x3D;&quot;2&quot;&gt;</span><br><span class="line">              &lt;template slot&#x3D;&quot;title&quot;&gt;&lt;i class&#x3D;&quot;el-icon-caret-right&quot;&gt;&lt;&#x2F;i&gt;内容管理&lt;&#x2F;template&gt;</span><br><span class="line">              &lt;el-menu-item-group&gt;</span><br><span class="line">                &lt;el-menu-item index&#x3D;&quot;2-1&quot;&gt;分类管理&lt;&#x2F;el-menu-item&gt;</span><br><span class="line">                &lt;el-menu-item index&#x3D;&quot;2-2&quot;&gt;内容列表&lt;&#x2F;el-menu-item&gt;</span><br><span class="line">              &lt;&#x2F;el-menu-item-group&gt;</span><br><span class="line">            &lt;&#x2F;el-submenu&gt;</span><br><span class="line">          &lt;&#x2F;el-menu&gt;</span><br><span class="line">        &lt;&#x2F;el-aside&gt;</span><br><span class="line"></span><br><span class="line">        &lt;el-container&gt;</span><br><span class="line">          &lt;el-header style&#x3D;&quot;text-align: right; font-size: 12px&quot;&gt;</span><br><span class="line">            &lt;el-dropdown&gt;</span><br><span class="line">              &lt;i class&#x3D;&quot;el-icon-setting&quot; style&#x3D;&quot;margin-right: 15px&quot;&gt;&lt;&#x2F;i&gt;</span><br><span class="line">              &lt;el-dropdown-menu slot&#x3D;&quot;dropdown&quot;&gt;</span><br><span class="line">                &lt;el-dropdown-item&gt;个人信息&lt;&#x2F;el-dropdown-item&gt;</span><br><span class="line">                &lt;el-dropdown-item&gt;退出登录&lt;&#x2F;el-dropdown-item&gt;</span><br><span class="line">              &lt;&#x2F;el-dropdown-menu&gt;</span><br><span class="line">            &lt;&#x2F;el-dropdown&gt;</span><br><span class="line">          &lt;&#x2F;el-header&gt;</span><br><span class="line"></span><br><span class="line">          &lt;el-main&gt;</span><br><span class="line">            &lt;router-view &#x2F;&gt;</span><br><span class="line">          &lt;&#x2F;el-main&gt;</span><br><span class="line">        &lt;&#x2F;el-container&gt;</span><br><span class="line">      &lt;&#x2F;el-container&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    export default &#123;</span><br><span class="line">        name: &quot;Main&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped lang&#x3D;&quot;scss&quot;&gt;</span><br><span class="line">  .el-header &#123;</span><br><span class="line">    background-color: #B3C0D1;</span><br><span class="line">    color: #333;</span><br><span class="line">    line-height: 60px;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  .el-aside &#123;</span><br><span class="line">    color: #333;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure><p>说明：</p><p>在 <el-main> 元素中配置了 <router-view /> 用于展示嵌套路由,主要使用 <router-link to="/user/profile">个人信息</router-link> 展示嵌套路由内容</p><h2 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h2><p>我们经常需要把某种模式匹配到的所有路由，全都映射到同个组件。例如，我们有一个 User 组件，对于所有 ID 各不相同的用户，都要使用这个组件来渲染。此时我们就需要传递参数了；</p><p>1、修改路由配置, 主要是在 path 属性中增加了 :id 这样的占位符</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;path: &#39;&#x2F;user&#x2F;profile&#x2F;:id&#39;, name:&#39;UserProfile&#39;, component: UserProfile&#125;</span><br></pre></td></tr></table></figure><p>2、传递参数</p><p>此时我们将 to 改为了 :to，是为了将这一属性当成对象使用，注意 router-link 中的 name 属性名称 一定要和 路由中的 name 属性名称 匹配，因为这样 Vue 才能找到对应的路由路径；</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;router-link :to&#x3D;&quot;&#123;name: &#39;UserProfile&#39;, params: &#123;id: 1&#125;&#125;&quot;&gt;个人信息&lt;&#x2F;router-link&gt;</span><br></pre></td></tr></table></figure><p>3、接收参数, 在目标组件中</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&#123; $route.params.id &#125;&#125;</span><br></pre></td></tr></table></figure><h3 id="使用-props-的方式"><a href="#使用-props-的方式" class="headerlink" title="使用 props 的方式"></a>使用 props 的方式</h3><p>1、修改路由配置 , 主要增加了 props: true 属性</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;path: &#39;&#x2F;user&#x2F;profile&#x2F;:id&#39;, name:&#39;UserProfile&#39;, component: UserProfile, props: true&#125;</span><br></pre></td></tr></table></figure><p>2、传递参数和之前一样<br>3、接收参数为目标组件增加 props 属性</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    个人信息</span><br><span class="line">    &#123;&#123; id &#125;&#125;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    export default &#123;</span><br><span class="line">      props: [&#39;id&#39;],</span><br><span class="line">      name: &quot;UserProfile&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure><h2 id="组件重定向"><a href="#组件重定向" class="headerlink" title="组件重定向"></a>组件重定向</h2><p>重定向的意思大家都明白，但 Vue 中的重定向是作用在路径不同但组件相同的情况下，比如：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  path: &#39;&#x2F;main&#39;,</span><br><span class="line">  name: &#39;Main&#39;,</span><br><span class="line">  component: Main</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">  path: &#39;&#x2F;goHome&#39;,</span><br><span class="line">  redirect: &#39;&#x2F;main&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：这里定义了两个路径，一个是 /main ，一个是 /goHome，其中 /goHome 重定向到了 /main 路径，由此可以看出重定向不需要定义组件；</p><p>使用的话，只需要设置对应路径即可；</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;el-menu-item index&#x3D;&quot;1-3&quot;&gt;</span><br><span class="line">    &lt;router-link to&#x3D;&quot;&#x2F;goHome&quot;&gt;回到首页&lt;&#x2F;router-link&gt;</span><br><span class="line">&lt;&#x2F;el-menu-item&gt;</span><br></pre></td></tr></table></figure><h2 id="路由模式与-404"><a href="#路由模式与-404" class="headerlink" title="路由模式与 404"></a>路由模式与 404</h2><p>路由模式有两种</p><ul><li>hash：路径带 # 符号，如 <a href="http://localhost/#/login" target="_blank" rel="noopener">http://localhost/#/login</a></li><li>history：路径不带 # 符号，如 <a href="http://localhost/login" target="_blank" rel="noopener">http://localhost/login</a></li></ul><p>修改路由配置，代码如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export default new Router(&#123;</span><br><span class="line">  mode: &#39;history&#39;,</span><br><span class="line">  routes: [</span><br><span class="line">  ]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>处理 404</strong> 创建一个名为 <code>NotFound.vue</code> 的视图组件，代码如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    页面不存在，请重试！</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    name: &quot;NotFount&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure><p>修改路由配置，代码如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import NotFound from &#39;..&#x2F;views&#x2F;NotFound&#39;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">   path: &#39;*&#39;,</span><br><span class="line">   component: NotFound</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="路由钩子与异步请求"><a href="#路由钩子与异步请求" class="headerlink" title="路由钩子与异步请求"></a>路由钩子与异步请求</h3><p><code>beforeRouteEnter</code>：在进入路由前执行<br><code>beforeRouteLeave</code>：在离开路由前执行</p><p>上代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">  props: [&#39;id&#39;],</span><br><span class="line">  name: &quot;UserProfile&quot;,</span><br><span class="line">  beforeRouteEnter: (to, from, next) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&quot;准备进入个人信息页&quot;);</span><br><span class="line">    next();</span><br><span class="line">  &#125;,</span><br><span class="line">  beforeRouteLeave: (to, from, next) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&quot;准备离开个人信息页&quot;);</span><br><span class="line">    next();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li>to：路由将要跳转的路径信息</li><li>from：路径跳转前的路径信息</li><li>next：路由的控制参数<ul><li>next() 跳入下一个页面</li><li>next(‘/path’) 改变路由的跳转方向，使其跳到另一个路由</li><li>next(false) 返回原来的页面</li><li>next((vm)=&gt;{}) 仅在 beforeRouteEnter 中可用，vm 是组件实例</li></ul></li></ul><p><strong>在钩子函数中使用异步请求</strong></p><p>1、安装 Axios <code>cnpm install axios -s</code><br>2、<code>main.js</code>引用 Axios</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import axios from &#39;axios&#39;</span><br><span class="line">Vue.prototype.axios &#x3D; axios;</span><br></pre></td></tr></table></figure><p>3、准备数据 ： 只有我们的 static 目录下的文件是可以被访问到的，所以我们就把静态文件放入该目录下。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 静态数据存放的位置</span><br><span class="line">static&#x2F;mock&#x2F;data.json</span><br></pre></td></tr></table></figure><p>4、在 beforeRouteEnter 中进行异步请求</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">   props: [&#39;id&#39;],</span><br><span class="line">   name: &quot;UserProfile&quot;,</span><br><span class="line">   beforeRouteEnter: (to, from, next) &#x3D;&gt; &#123;</span><br><span class="line">     console.log(&quot;准备进入个人信息页&quot;);</span><br><span class="line">     &#x2F;&#x2F; 注意，一定要在 next 中请求，因为该方法调用时 Vue 实例还没有创建，此时无法获取到 this 对象，在这里使用官方提供的回调函数拿到当前实例</span><br><span class="line">     next(vm &#x3D;&gt; &#123;</span><br><span class="line">       vm.getData();</span><br><span class="line">     &#125;);</span><br><span class="line">   &#125;,</span><br><span class="line">   beforeRouteLeave: (to, from, next) &#x3D;&gt; &#123;</span><br><span class="line">     console.log(&quot;准备离开个人信息页&quot;);</span><br><span class="line">     next();</span><br><span class="line">   &#125;,</span><br><span class="line">   methods: &#123;</span><br><span class="line">     getData: function () &#123;</span><br><span class="line">       this.axios(&#123;</span><br><span class="line">         method: &#39;get&#39;,</span><br><span class="line">         url: &#39;http:&#x2F;&#x2F;localhost:8080&#x2F;static&#x2F;mock&#x2F;data.json&#39;</span><br><span class="line">       &#125;).then(function (repos) &#123;</span><br><span class="line">         console.log(repos);</span><br><span class="line">       &#125;).catch(function (error) &#123;</span><br><span class="line">         console.log(error);</span><br><span class="line">       &#125;);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      前端体系、前后端分离
    
    </summary>
    
    
      <category term="Vue" scheme="https://SomunsTao.github.io/categories/Vue/"/>
    
    
      <category term="Vue" scheme="https://SomunsTao.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue 10：实战快速上手</title>
    <link href="https://somunstao.github.io/2020/04/20/Vue%2010%EF%BC%9A%E5%AE%9E%E6%88%98%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/"/>
    <id>https://somunstao.github.io/2020/04/20/Vue%2010%EF%BC%9A%E5%AE%9E%E6%88%98%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/</id>
    <published>2020-04-19T16:00:00.000Z</published>
    <updated>2020-08-01T15:19:07.123Z</updated>
    
    <content type="html"><![CDATA[<p>​    </p><h1 id="Vue：实战快速上手"><a href="#Vue：实战快速上手" class="headerlink" title="Vue：实战快速上手"></a>Vue：实战快速上手</h1><p>我们采用实战教学模式并结合 <code>ElementUI</code> 组件库，将所需知识点应用到实际中，以最快速度带领大家掌握 Vue 的使用;</p><h2 id="创建工程"><a href="#创建工程" class="headerlink" title="创建工程"></a>创建工程</h2><p>注意： 命令行都要使用管理员模式运行</p><p>1、创建一个名为 hello-vue 的工程 <code>vue init webpack hello-vue</code><br>2、安装依赖，我们需要安装 vue-router、element-ui、sass-loader 和 node-sass 四个插件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 进入工程目录</span><br><span class="line">cd hello-vue</span><br><span class="line"># 安装 vue-router</span><br><span class="line">npm install vue-router --save-dev</span><br><span class="line"># 安装 element-ui</span><br><span class="line">npm i element-ui -S</span><br><span class="line"># 安装依赖</span><br><span class="line">npm install</span><br><span class="line"># 安装 SASS 加载器</span><br><span class="line">cnpm install sass-loader node-sass --save-dev</span><br><span class="line"># 启动测试</span><br><span class="line">npm run dev</span><br></pre></td></tr></table></figure><p>3、Npm命令解释：</p><ul><li><code>npm install moduleName</code>：安装模块到项目目录下</li><li><code>npm install -g moduleName</code>：-g 的意思是将模块安装到全局，具体安装到磁盘哪个位置，要看 npm config prefix 的位置</li><li><code>npm install -save moduleName</code>：–save 的意思是将模块安装到项目目录下，并在 package 文件的 dependencies 节点写入依赖，-S 为该命令的缩写</li><li><code>npm install -save-dev moduleNam</code>e：–save-dev 的意思是将模块安装到项目目录下，并在 package 文件的 devDependencies 节点写入依赖，-D 为该命令的缩写</li></ul><h2 id="创建登录页面"><a href="#创建登录页面" class="headerlink" title="创建登录页面"></a>创建登录页面</h2><p>把没有用的初始化东西删掉！</p><p>在源码目录中创建如下结构：</p><ul><li>assets：用于存放资源文件</li><li>components：用于存放 Vue 功能组件</li><li>views：用于存放 Vue 视图组件</li><li>router：用于存放 vue-router 配置</li></ul><p><img src="https://blog.kuangstudy.com/usr/uploads/2019/10/1596391106.jpg" alt="QQ截图20191025101406.jpg"></p><p><strong>创建首页视图，在 views 目录下创建一个名为 Main.vue 的视图组件；</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      首页</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    export default &#123;</span><br><span class="line">        name: &quot;Main&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure><p><strong>创建登录页视图在 views 目录下创建一个名为 Login.vue 的视图组件，其中 el-* 的元素为 ElementUI 组件；</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;el-form ref&#x3D;&quot;loginForm&quot; :model&#x3D;&quot;form&quot; :rules&#x3D;&quot;rules&quot; label-width&#x3D;&quot;80px&quot; class&#x3D;&quot;login-box&quot;&gt;</span><br><span class="line">      &lt;h3 class&#x3D;&quot;login-title&quot;&gt;欢迎登录&lt;&#x2F;h3&gt;</span><br><span class="line">      &lt;el-form-item label&#x3D;&quot;账号&quot; prop&#x3D;&quot;username&quot;&gt;</span><br><span class="line">        &lt;el-input type&#x3D;&quot;text&quot; placeholder&#x3D;&quot;请输入账号&quot; v-model&#x3D;&quot;form.username&quot;&#x2F;&gt;</span><br><span class="line">      &lt;&#x2F;el-form-item&gt;</span><br><span class="line">      &lt;el-form-item label&#x3D;&quot;密码&quot; prop&#x3D;&quot;password&quot;&gt;</span><br><span class="line">        &lt;el-input type&#x3D;&quot;password&quot; placeholder&#x3D;&quot;请输入密码&quot; v-model&#x3D;&quot;form.password&quot;&#x2F;&gt;</span><br><span class="line">      &lt;&#x2F;el-form-item&gt;</span><br><span class="line">      &lt;el-form-item&gt;</span><br><span class="line">        &lt;el-button type&#x3D;&quot;primary&quot; v-on:click&#x3D;&quot;onSubmit(&#39;loginForm&#39;)&quot;&gt;登录&lt;&#x2F;el-button&gt;</span><br><span class="line">      &lt;&#x2F;el-form-item&gt;</span><br><span class="line">    &lt;&#x2F;el-form&gt;</span><br><span class="line"></span><br><span class="line">    &lt;el-dialog</span><br><span class="line">      title&#x3D;&quot;温馨提示&quot;</span><br><span class="line">      :visible.sync&#x3D;&quot;dialogVisible&quot;</span><br><span class="line">      width&#x3D;&quot;30%&quot;</span><br><span class="line">      :before-close&#x3D;&quot;handleClose&quot;&gt;</span><br><span class="line">      &lt;span&gt;请输入账号和密码&lt;&#x2F;span&gt;</span><br><span class="line">      &lt;span slot&#x3D;&quot;footer&quot; class&#x3D;&quot;dialog-footer&quot;&gt;</span><br><span class="line">        &lt;el-button type&#x3D;&quot;primary&quot; @click&#x3D;&quot;dialogVisible &#x3D; false&quot;&gt;确 定&lt;&#x2F;el-button&gt;</span><br><span class="line">      &lt;&#x2F;span&gt;</span><br><span class="line">    &lt;&#x2F;el-dialog&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    name: &quot;Login&quot;,</span><br><span class="line">    data() &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        form: &#123;</span><br><span class="line">          username: &#39;&#39;,</span><br><span class="line">          password: &#39;&#39;</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 表单验证，需要在 el-form-item 元素中增加 prop 属性</span><br><span class="line">        rules: &#123;</span><br><span class="line">          username: [</span><br><span class="line">            &#123;required: true, message: &#39;账号不可为空&#39;, trigger: &#39;blur&#39;&#125;</span><br><span class="line">          ],</span><br><span class="line">          password: [</span><br><span class="line">            &#123;required: true, message: &#39;密码不可为空&#39;, trigger: &#39;blur&#39;&#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 对话框显示和隐藏</span><br><span class="line">        dialogVisible: false</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      onSubmit(formName) &#123;</span><br><span class="line">        &#x2F;&#x2F; 为表单绑定验证功能</span><br><span class="line">        this.$refs[formName].validate((valid) &#x3D;&gt; &#123;</span><br><span class="line">          if (valid) &#123;</span><br><span class="line">            &#x2F;&#x2F; 使用 vue-router 路由到指定页面，该方式称之为编程式导航</span><br><span class="line">            this.$router.push(&quot;&#x2F;main&quot;);</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">            this.dialogVisible &#x3D; true;</span><br><span class="line">            return false;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style lang&#x3D;&quot;scss&quot; scoped&gt;</span><br><span class="line">  .login-box &#123;</span><br><span class="line">    border: 1px solid #DCDFE6;</span><br><span class="line">    width: 350px;</span><br><span class="line">    margin: 180px auto;</span><br><span class="line">    padding: 35px 35px 15px 35px;</span><br><span class="line">    border-radius: 5px;</span><br><span class="line">    -webkit-border-radius: 5px;</span><br><span class="line">    -moz-border-radius: 5px;</span><br><span class="line">    box-shadow: 0 0 25px #909399;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  .login-title &#123;</span><br><span class="line">    text-align: center;</span><br><span class="line">    margin: 0 auto 40px auto;</span><br><span class="line">    color: #303133;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure><p><strong>创建路由,在 router 目录下创建一个名为 index.js 的 vue-router 路由配置文件</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import Vue from &#39;vue&#39;</span><br><span class="line">import Router from &#39;vue-router&#39;</span><br><span class="line"></span><br><span class="line">import Login from &quot;..&#x2F;views&#x2F;Login&quot;</span><br><span class="line">import Main from &#39;..&#x2F;views&#x2F;Main&#39;</span><br><span class="line"></span><br><span class="line">Vue.use(Router);</span><br><span class="line"></span><br><span class="line">export default new Router(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      &#x2F;&#x2F; 登录页</span><br><span class="line">      path: &#39;&#x2F;login&#39;,</span><br><span class="line">      name: &#39;Login&#39;,</span><br><span class="line">      component: Login</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &#x2F;&#x2F; 首页</span><br><span class="line">      path: &#39;&#x2F;main&#39;,</span><br><span class="line">      name: &#39;Main&#39;,</span><br><span class="line">      component: Main</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>配置路由，修改入口代码，修改 main.js 入口代码</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import Vue from &#39;vue&#39;</span><br><span class="line">import VueRouter from &#39;vue-router&#39;</span><br><span class="line">import router from &#39;.&#x2F;router&#39;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 导入 ElementUI</span><br><span class="line">import ElementUI from &#39;element-ui&#39;</span><br><span class="line">import &#39;element-ui&#x2F;lib&#x2F;theme-chalk&#x2F;index.css&#39;</span><br><span class="line"></span><br><span class="line">import App from &#39;.&#x2F;App&#39;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 安装路由</span><br><span class="line">Vue.use(VueRouter);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 安装 ElementUI</span><br><span class="line">Vue.use(ElementUI);</span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: &#39;#app&#39;,</span><br><span class="line">  &#x2F;&#x2F; 启用路由</span><br><span class="line">  router,</span><br><span class="line">  &#x2F;&#x2F; 启用 ElementUI</span><br><span class="line">  render: h &#x3D;&gt; h(App)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>修改 App.vue 组件代码</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">    &lt;router-view&#x2F;&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    name: &#39;App&#39;,</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>测试 ： 在浏览器打开 <a href="http://localhost/" target="_blank" rel="noopener">http://localhost</a>:8080/#/login</p><p>如果出现错误: 可能是因为sass-loader的版本过高导致的编译错误，当前最高版本是8.x，需要退回到7.3.1 ；</p><p>去package.json文件里面的 “sass-loader”的版本更换成7.3.1，然后重新<code>cnpm install</code>就可以了；</p><p><img src="https://blog.kuangstudy.com/usr/uploads/2019/10/1972241333.jpg" alt="QQ截图20191025111608.jpg"></p><h2 id="路由嵌套"><a href="#路由嵌套" class="headerlink" title="路由嵌套"></a>路由嵌套</h2><p>嵌套路由又称子路由，在实际应用中，通常由多层嵌套的组件组合而成。同样地，URL 中各段动态路径也按某种结构对应嵌套的各层组件，例如：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;user&#x2F;foo&#x2F;profile                     &#x2F;user&#x2F;foo&#x2F;posts</span><br><span class="line">+------------------+                  +-----------------+</span><br><span class="line">| User             |                  | User            |</span><br><span class="line">| +--------------+ |                  | +-------------+ |</span><br><span class="line">| | Profile      | |  +------------&gt;  | | Posts       | |</span><br><span class="line">| |              | |                  | |             | |</span><br><span class="line">| +--------------+ |                  | +-------------+ |</span><br><span class="line">+------------------+                  +-----------------+</span><br></pre></td></tr></table></figure><p>1、用户信息组件，在 views/user 目录下创建一个名为 Profile.vue 的视图组件；</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      个人信息</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    export default &#123;</span><br><span class="line">        name: &quot;UserProfile&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure><p>2、用户列表组件在 views/user 目录下创建一个名为 List.vue 的视图组件；</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      用户列表</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    export default &#123;</span><br><span class="line">        name: &quot;UserList&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure><p>3、配置嵌套路由修改 router 目录下的 index.js 路由配置文件，代码如</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import Vue from &#39;vue&#39;</span><br><span class="line">import Router from &#39;vue-router&#39;</span><br><span class="line"></span><br><span class="line">import Login from &quot;..&#x2F;views&#x2F;Login&quot;</span><br><span class="line">import Main from &#39;..&#x2F;views&#x2F;Main&#39;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 用于嵌套的路由组件</span><br><span class="line">import UserProfile from &#39;..&#x2F;views&#x2F;user&#x2F;Profile&#39;</span><br><span class="line">import UserList from &#39;..&#x2F;views&#x2F;user&#x2F;List&#39;</span><br><span class="line"></span><br><span class="line">Vue.use(Router);</span><br><span class="line"></span><br><span class="line">export default new Router(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      &#x2F;&#x2F; 登录页</span><br><span class="line">      path: &#39;&#x2F;login&#39;,</span><br><span class="line">      name: &#39;Login&#39;,</span><br><span class="line">      component: Login</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &#x2F;&#x2F; 首页</span><br><span class="line">      path: &#39;&#x2F;main&#39;,</span><br><span class="line">      name: &#39;Main&#39;,</span><br><span class="line">      component: Main,</span><br><span class="line">      &#x2F;&#x2F; 配置嵌套路由</span><br><span class="line">      children: [</span><br><span class="line">        &#123;path: &#39;&#x2F;user&#x2F;profile&#39;, component: UserProfile&#125;,</span><br><span class="line">        &#123;path: &#39;&#x2F;user&#x2F;list&#39;, component: UserList&#125;,</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>说明：主要在路由配置中增加了 children 数组配置，用于在该组件下设置嵌套路由</p><p>4、修改首页视图，我们修改 Main.vue 视图组件，此处使用了 ElementUI 布局容器组件，代码如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;el-container&gt;</span><br><span class="line">        &lt;el-aside width&#x3D;&quot;200px&quot;&gt;</span><br><span class="line">          &lt;el-menu :default-openeds&#x3D;&quot;[&#39;1&#39;]&quot;&gt;</span><br><span class="line">            &lt;el-submenu index&#x3D;&quot;1&quot;&gt;</span><br><span class="line">              &lt;template slot&#x3D;&quot;title&quot;&gt;&lt;i class&#x3D;&quot;el-icon-caret-right&quot;&gt;&lt;&#x2F;i&gt;用户管理&lt;&#x2F;template&gt;</span><br><span class="line">              &lt;el-menu-item-group&gt;</span><br><span class="line">                &lt;el-menu-item index&#x3D;&quot;1-1&quot;&gt;</span><br><span class="line">                  &lt;router-link to&#x3D;&quot;&#x2F;user&#x2F;profile&quot;&gt;个人信息&lt;&#x2F;router-link&gt;</span><br><span class="line">                &lt;&#x2F;el-menu-item&gt;</span><br><span class="line">                &lt;el-menu-item index&#x3D;&quot;1-2&quot;&gt;</span><br><span class="line">                  &lt;router-link to&#x3D;&quot;&#x2F;user&#x2F;list&quot;&gt;用户列表&lt;&#x2F;router-link&gt;</span><br><span class="line">                &lt;&#x2F;el-menu-item&gt;</span><br><span class="line">              &lt;&#x2F;el-menu-item-group&gt;</span><br><span class="line">            &lt;&#x2F;el-submenu&gt;</span><br><span class="line">            &lt;el-submenu index&#x3D;&quot;2&quot;&gt;</span><br><span class="line">              &lt;template slot&#x3D;&quot;title&quot;&gt;&lt;i class&#x3D;&quot;el-icon-caret-right&quot;&gt;&lt;&#x2F;i&gt;内容管理&lt;&#x2F;template&gt;</span><br><span class="line">              &lt;el-menu-item-group&gt;</span><br><span class="line">                &lt;el-menu-item index&#x3D;&quot;2-1&quot;&gt;分类管理&lt;&#x2F;el-menu-item&gt;</span><br><span class="line">                &lt;el-menu-item index&#x3D;&quot;2-2&quot;&gt;内容列表&lt;&#x2F;el-menu-item&gt;</span><br><span class="line">              &lt;&#x2F;el-menu-item-group&gt;</span><br><span class="line">            &lt;&#x2F;el-submenu&gt;</span><br><span class="line">          &lt;&#x2F;el-menu&gt;</span><br><span class="line">        &lt;&#x2F;el-aside&gt;</span><br><span class="line"></span><br><span class="line">        &lt;el-container&gt;</span><br><span class="line">          &lt;el-header style&#x3D;&quot;text-align: right; font-size: 12px&quot;&gt;</span><br><span class="line">            &lt;el-dropdown&gt;</span><br><span class="line">              &lt;i class&#x3D;&quot;el-icon-setting&quot; style&#x3D;&quot;margin-right: 15px&quot;&gt;&lt;&#x2F;i&gt;</span><br><span class="line">              &lt;el-dropdown-menu slot&#x3D;&quot;dropdown&quot;&gt;</span><br><span class="line">                &lt;el-dropdown-item&gt;个人信息&lt;&#x2F;el-dropdown-item&gt;</span><br><span class="line">                &lt;el-dropdown-item&gt;退出登录&lt;&#x2F;el-dropdown-item&gt;</span><br><span class="line">              &lt;&#x2F;el-dropdown-menu&gt;</span><br><span class="line">            &lt;&#x2F;el-dropdown&gt;</span><br><span class="line">          &lt;&#x2F;el-header&gt;</span><br><span class="line"></span><br><span class="line">          &lt;el-main&gt;</span><br><span class="line">            &lt;router-view &#x2F;&gt;</span><br><span class="line">          &lt;&#x2F;el-main&gt;</span><br><span class="line">        &lt;&#x2F;el-container&gt;</span><br><span class="line">      &lt;&#x2F;el-container&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    export default &#123;</span><br><span class="line">        name: &quot;Main&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped lang&#x3D;&quot;scss&quot;&gt;</span><br><span class="line">  .el-header &#123;</span><br><span class="line">    background-color: #B3C0D1;</span><br><span class="line">    color: #333;</span><br><span class="line">    line-height: 60px;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  .el-aside &#123;</span><br><span class="line">    color: #333;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure><p>说明：</p><p>在 <el-main> 元素中配置了 <router-view /> 用于展示嵌套路由,主要使用 <router-link to="/user/profile">个人信息</router-link> 展示嵌套路由内容</p><h2 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h2><p>我们经常需要把某种模式匹配到的所有路由，全都映射到同个组件。例如，我们有一个 User 组件，对于所有 ID 各不相同的用户，都要使用这个组件来渲染。此时我们就需要传递参数了；</p><p>1、修改路由配置, 主要是在 path 属性中增加了 :id 这样的占位符</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;path: &#39;&#x2F;user&#x2F;profile&#x2F;:id&#39;, name:&#39;UserProfile&#39;, component: UserProfile&#125;</span><br></pre></td></tr></table></figure><p>2、传递参数</p><p>此时我们将 to 改为了 :to，是为了将这一属性当成对象使用，注意 router-link 中的 name 属性名称 一定要和 路由中的 name 属性名称 匹配，因为这样 Vue 才能找到对应的路由路径；</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;router-link :to&#x3D;&quot;&#123;name: &#39;UserProfile&#39;, params: &#123;id: 1&#125;&#125;&quot;&gt;个人信息&lt;&#x2F;router-link&gt;</span><br></pre></td></tr></table></figure><p>3、接收参数, 在目标组件中</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&#123; $route.params.id &#125;&#125;</span><br></pre></td></tr></table></figure><h3 id="使用-props-的方式"><a href="#使用-props-的方式" class="headerlink" title="使用 props 的方式"></a>使用 props 的方式</h3><p>1、修改路由配置 , 主要增加了 props: true 属性</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;path: &#39;&#x2F;user&#x2F;profile&#x2F;:id&#39;, name:&#39;UserProfile&#39;, component: UserProfile, props: true&#125;</span><br></pre></td></tr></table></figure><p>2、传递参数和之前一样<br>3、接收参数为目标组件增加 props 属性</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    个人信息</span><br><span class="line">    &#123;&#123; id &#125;&#125;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    export default &#123;</span><br><span class="line">      props: [&#39;id&#39;],</span><br><span class="line">      name: &quot;UserProfile&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure><h2 id="组件重定向"><a href="#组件重定向" class="headerlink" title="组件重定向"></a>组件重定向</h2><p>重定向的意思大家都明白，但 Vue 中的重定向是作用在路径不同但组件相同的情况下，比如：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  path: &#39;&#x2F;main&#39;,</span><br><span class="line">  name: &#39;Main&#39;,</span><br><span class="line">  component: Main</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">  path: &#39;&#x2F;goHome&#39;,</span><br><span class="line">  redirect: &#39;&#x2F;main&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：这里定义了两个路径，一个是 /main ，一个是 /goHome，其中 /goHome 重定向到了 /main 路径，由此可以看出重定向不需要定义组件；</p><p>使用的话，只需要设置对应路径即可；</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;el-menu-item index&#x3D;&quot;1-3&quot;&gt;</span><br><span class="line">    &lt;router-link to&#x3D;&quot;&#x2F;goHome&quot;&gt;回到首页&lt;&#x2F;router-link&gt;</span><br><span class="line">&lt;&#x2F;el-menu-item&gt;</span><br></pre></td></tr></table></figure><h2 id="路由模式与-404"><a href="#路由模式与-404" class="headerlink" title="路由模式与 404"></a>路由模式与 404</h2><p>路由模式有两种</p><ul><li>hash：路径带 # 符号，如 <a href="http://localhost/#/login" target="_blank" rel="noopener">http://localhost/#/login</a></li><li>history：路径不带 # 符号，如 <a href="http://localhost/login" target="_blank" rel="noopener">http://localhost/login</a></li></ul><p>修改路由配置，代码如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export default new Router(&#123;</span><br><span class="line">  mode: &#39;history&#39;,</span><br><span class="line">  routes: [</span><br><span class="line">  ]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>处理 404</strong> 创建一个名为 <code>NotFound.vue</code> 的视图组件，代码如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    页面不存在，请重试！</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    name: &quot;NotFount&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure><p>修改路由配置，代码如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import NotFound from &#39;..&#x2F;views&#x2F;NotFound&#39;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">   path: &#39;*&#39;,</span><br><span class="line">   component: NotFound</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="路由钩子与异步请求"><a href="#路由钩子与异步请求" class="headerlink" title="路由钩子与异步请求"></a>路由钩子与异步请求</h3><p><code>beforeRouteEnter</code>：在进入路由前执行<br><code>beforeRouteLeave</code>：在离开路由前执行</p><p>上代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">  props: [&#39;id&#39;],</span><br><span class="line">  name: &quot;UserProfile&quot;,</span><br><span class="line">  beforeRouteEnter: (to, from, next) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&quot;准备进入个人信息页&quot;);</span><br><span class="line">    next();</span><br><span class="line">  &#125;,</span><br><span class="line">  beforeRouteLeave: (to, from, next) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&quot;准备离开个人信息页&quot;);</span><br><span class="line">    next();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li>to：路由将要跳转的路径信息</li><li>from：路径跳转前的路径信息</li><li>next：路由的控制参数<ul><li>next() 跳入下一个页面</li><li>next(‘/path’) 改变路由的跳转方向，使其跳到另一个路由</li><li>next(false) 返回原来的页面</li><li>next((vm)=&gt;{}) 仅在 beforeRouteEnter 中可用，vm 是组件实例</li></ul></li></ul><p><strong>在钩子函数中使用异步请求</strong></p><p>1、安装 Axios <code>cnpm install axios -s</code><br>2、<code>main.js</code>引用 Axios</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import axios from &#39;axios&#39;</span><br><span class="line">Vue.prototype.axios &#x3D; axios;</span><br></pre></td></tr></table></figure><p>3、准备数据 ： 只有我们的 static 目录下的文件是可以被访问到的，所以我们就把静态文件放入该目录下。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 静态数据存放的位置</span><br><span class="line">static&#x2F;mock&#x2F;data.json</span><br></pre></td></tr></table></figure><p>4、在 beforeRouteEnter 中进行异步请求</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">   props: [&#39;id&#39;],</span><br><span class="line">   name: &quot;UserProfile&quot;,</span><br><span class="line">   beforeRouteEnter: (to, from, next) &#x3D;&gt; &#123;</span><br><span class="line">     console.log(&quot;准备进入个人信息页&quot;);</span><br><span class="line">     &#x2F;&#x2F; 注意，一定要在 next 中请求，因为该方法调用时 Vue 实例还没有创建，此时无法获取到 this 对象，在这里使用官方提供的回调函数拿到当前实例</span><br><span class="line">     next(vm &#x3D;&gt; &#123;</span><br><span class="line">       vm.getData();</span><br><span class="line">     &#125;);</span><br><span class="line">   &#125;,</span><br><span class="line">   beforeRouteLeave: (to, from, next) &#x3D;&gt; &#123;</span><br><span class="line">     console.log(&quot;准备离开个人信息页&quot;);</span><br><span class="line">     next();</span><br><span class="line">   &#125;,</span><br><span class="line">   methods: &#123;</span><br><span class="line">     getData: function () &#123;</span><br><span class="line">       this.axios(&#123;</span><br><span class="line">         method: &#39;get&#39;,</span><br><span class="line">         url: &#39;http:&#x2F;&#x2F;localhost:8080&#x2F;static&#x2F;mock&#x2F;data.json&#39;</span><br><span class="line">       &#125;).then(function (repos) &#123;</span><br><span class="line">         console.log(repos);</span><br><span class="line">       &#125;).catch(function (error) &#123;</span><br><span class="line">         console.log(error);</span><br><span class="line">       &#125;);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      前端体系、前后端分离
    
    </summary>
    
    
      <category term="Vue" scheme="https://SomunsTao.github.io/categories/Vue/"/>
    
    
      <category term="Vue" scheme="https://SomunsTao.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue 09：vue-router路由</title>
    <link href="https://somunstao.github.io/2020/04/19/Vue%2009%EF%BC%9Avue-router%E8%B7%AF%E7%94%B1/"/>
    <id>https://somunstao.github.io/2020/04/19/Vue%2009%EF%BC%9Avue-router%E8%B7%AF%E7%94%B1/</id>
    <published>2020-04-18T16:00:00.000Z</published>
    <updated>2020-08-01T15:18:48.746Z</updated>
    
    <content type="html"><![CDATA[<p>​    </p><h1 id="Vue：vue-router路由"><a href="#Vue：vue-router路由" class="headerlink" title="Vue：vue-router路由"></a>Vue：vue-router路由</h1><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>学习的时候，尽量的打开官方的文档</p><p>Vue Router 是 Vue.js 官方的路由管理器。它和 Vue.js 的核心深度集成，让构建单页面应用变得易如反掌。包含的功能有：</p><ul><li>嵌套的路由/视图表</li><li>模块化的、基于组件的路由配置</li><li>路由参数、查询、通配符</li><li>基于 Vue.js 过渡系统的视图过渡效果</li><li>细粒度的导航控制</li><li>带有自动激活的 CSS class 的链接</li><li>HTML5 历史模式或 hash 模式，在 IE9 中自动降级</li><li>自定义的滚动条行为</li></ul><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p><strong>基于第一个vue-cli进行测试学习;先查看node_modules中是否存在 vue-router</strong></p><p>vue-router 是一个插件包，所以我们还是需要用 npm/cnpm 来进行安装的。打开命令行工具，进入你的项目目录，输入下面命令。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install vue-router --save-dev</span><br></pre></td></tr></table></figure><p>如果在一个模块化工程中使用它，必须要通过 Vue.use() 明确地安装路由功能：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import Vue from &#39;vue&#39;</span><br><span class="line">import VueRouter from &#39;vue-router&#39;</span><br><span class="line"></span><br><span class="line">Vue.use(VueRouter);</span><br></pre></td></tr></table></figure><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>1、先删除没有用的东西<br>2、<code>components</code>目录下存放我们自己编写的组件<br>3、定义一个<code>Content.vue</code> 的组件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line"> &lt;h1&gt;内容页&lt;&#x2F;h1&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"> export default &#123;</span><br><span class="line">     name: &quot;Content&quot;</span><br><span class="line"> &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>4、 <strong>安装路由,在src目录下,新建一个文件夹 : router,专门存放路由</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import Vue from &#39;vue&#39;</span><br><span class="line">&#x2F;&#x2F; 导入路由插件</span><br><span class="line">import Router from &#39;vue-router&#39;</span><br><span class="line">&#x2F;&#x2F; 导入上面定义的组件</span><br><span class="line">import Content from &#39;..&#x2F;components&#x2F;Content&#39;</span><br><span class="line">import main from &#39;..&#x2F;components&#x2F;main&#39;</span><br><span class="line">&#x2F;&#x2F; 安装路由</span><br><span class="line">Vue.use(Router);</span><br><span class="line">&#x2F;&#x2F; 配置路由</span><br><span class="line">export default new Router(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      &#x2F;&#x2F; 路由路径</span><br><span class="line">      path: &#39;&#x2F;content&#39;,</span><br><span class="line">      &#x2F;&#x2F; 路由名称</span><br><span class="line">      name: &#39;Content&#39;,</span><br><span class="line">      &#x2F;&#x2F; 跳转到组件</span><br><span class="line">      component: Content</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">      &#x2F;&#x2F; 路由路径</span><br><span class="line">      path: &#39;&#x2F;main&#39;,</span><br><span class="line">      &#x2F;&#x2F; 路由名称</span><br><span class="line">      name: &#39;main&#39;,</span><br><span class="line">      &#x2F;&#x2F; 跳转到组件</span><br><span class="line">      component: main</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>5、在<code>main.js</code> 中配置路由</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import Vue from &#39;vue&#39;</span><br><span class="line">import App from &#39;.&#x2F;App&#39;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 导入上面创建的路由配置目录</span><br><span class="line">import router from &#39;.&#x2F;router&#39;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;来关闭生产模式下给出的提示</span><br><span class="line">Vue.config.productionTip &#x3D; false;</span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: &#39;#app&#39;,</span><br><span class="line">  &#x2F;&#x2F; 配置路由</span><br><span class="line">  router,</span><br><span class="line">  components: &#123; App &#125;,</span><br><span class="line">  template: &#39;&lt;App&#x2F;&gt;&#39;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>6、在<code>App.vue</code>中使用路由</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">    &lt;!--</span><br><span class="line">      router-link： 默认会被渲染成一个 &lt;a&gt; 标签，to 属性为指定链接</span><br><span class="line">      router-view： 用于渲染路由匹配到的组件</span><br><span class="line">    --&gt;</span><br><span class="line">    &lt;router-link to&#x3D;&quot;&#x2F;&quot;&gt;首页&lt;&#x2F;router-link&gt;</span><br><span class="line">    &lt;router-link to&#x3D;&quot;&#x2F;content&quot;&gt;内容&lt;&#x2F;router-link&gt;</span><br><span class="line">    &lt;router-view&gt;&lt;&#x2F;router-view&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#39;App&#39;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">  #app &#123;</span><br><span class="line">    font-family: &#39;Avenir&#39;, Helvetica, Arial, sans-serif;</span><br><span class="line">    -webkit-font-smoothing: antialiased;</span><br><span class="line">    -moz-osx-font-smoothing: grayscale;</span><br><span class="line">    text-align: center;</span><br><span class="line">    color: #2c3e50;</span><br><span class="line">    margin-top: 60px;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure><p>启动测试一下 ： <code>npm run dev</code></p><p><strong>练习： 在现有的基础上，在增加一个路由组件，优化一下！</strong></p>]]></content>
    
    <summary type="html">
    
      前端体系、前后端分离
    
    </summary>
    
    
      <category term="Vue" scheme="https://SomunsTao.github.io/categories/Vue/"/>
    
    
      <category term="Vue" scheme="https://SomunsTao.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue 08：Webpack学习</title>
    <link href="https://somunstao.github.io/2020/04/18/Vue%2008%EF%BC%9AWebpack%E5%AD%A6%E4%B9%A0/"/>
    <id>https://somunstao.github.io/2020/04/18/Vue%2008%EF%BC%9AWebpack%E5%AD%A6%E4%B9%A0/</id>
    <published>2020-04-17T16:00:00.000Z</published>
    <updated>2020-08-01T15:18:32.935Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Vue：Webpack学习"><a href="#Vue：Webpack学习" class="headerlink" title="Vue：Webpack学习"></a>Vue：Webpack学习</h1><h2 id="什么是Webpack"><a href="#什么是Webpack" class="headerlink" title="什么是Webpack"></a>什么是Webpack</h2><p>本质上，webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle.</p><p>Webpack 是当下最热门的前端资源模块化管理和打包工具，它可以将许多松散耦合的模块按照依赖和规则打包成符合生产环境部署的前端资源。还可以将按需加载的模块进行代码分离，等到实际需要时再异步加载。通过 loader 转换，任何形式的资源都可以当做模块，比如 CommonsJS、AMD、ES6、CSS、JSON、CoffeeScript、LESS 等；</p><p>伴随着移动互联网的大潮，当今越来越多的网站已经从网页模式进化到了 WebApp 模式。它们运行在现代浏览器里，使用 HTML5、CSS3、ES6 等新的技术来开发丰富的功能，网页已经不仅仅是完成浏览器的基本需求；WebApp 通常是一个 SPA （单页面应用），每一个视图通过异步的方式加载，这导致页面初始化和使用过程中会加载越来越多的 JS 代码，这给前端的开发流程和资源组织带来了巨大挑战。</p><p>前端开发和其他开发工作的主要区别，首先是前端基于多语言、多层次的编码和组织工作，其次前端产品的交付是基于浏览器的，这些资源是通过增量加载的方式运行到浏览器端，如何在开发环境组织好这些碎片化的代码和资源，并且保证他们在浏览器端快速、优雅的加载和更新，就需要一个模块化系统，这个理想中的模块化系统是前端工程师多年来一直探索的难题。</p><h3 id="模块化的演进"><a href="#模块化的演进" class="headerlink" title="模块化的演进"></a>模块化的演进</h3><h4 id="Script-标签"><a href="#Script-标签" class="headerlink" title="Script 标签"></a>Script 标签</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script src&#x3D;&quot;module1.js&quot;&gt;&lt;&#x2F;scirpt&gt;</span><br><span class="line">&lt;script src&#x3D;&quot;module2.js&quot;&gt;&lt;&#x2F;scirpt&gt;</span><br><span class="line">&lt;script src&#x3D;&quot;module3.js&quot;&gt;&lt;&#x2F;scirpt&gt;</span><br><span class="line">&lt;script src&#x3D;&quot;module4.js&quot;&gt;&lt;&#x2F;scirpt&gt;</span><br></pre></td></tr></table></figure><p>这是最原始的 JavaScript 文件加载方式，如果把每一个文件看做是一个模块，那么他们的接口通常是暴露在全局作用域下，也就是定义在 window 对象中，不同模块的调用都是一个作用域。</p><p>这种原始的加载方式暴露了一些显而易见的弊端：</p><ul><li>全局作用域下容易造成变量冲突</li><li>文件只能按照 <script> 的书写顺序进行加载</li><li>开发人员必须主观解决模块和代码库的依赖关系</li><li>在大型项目中各种资源难以管理，长期积累的问题导致代码库混乱不堪</li></ul><h4 id="CommonsJS"><a href="#CommonsJS" class="headerlink" title="CommonsJS"></a>CommonsJS</h4><p>服务器端的 NodeJS 遵循 CommonsJS 规范，该规范核心思想是允许模块通过 require 方法来同步加载所需依赖的其它模块，然后通过 exports 或 module.exports 来导出需要暴露的接口。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">require(&quot;module&quot;);</span><br><span class="line">require(&quot;..&#x2F;module.js&quot;);</span><br><span class="line">export.doStuff &#x3D; function() &#123;&#125;;</span><br><span class="line">module.exports &#x3D; someValue;</span><br></pre></td></tr></table></figure><p><strong>优点:</strong></p><ul><li>服务器端模块便于重用</li><li>NPM 中已经有超过 45 万个可以使用的模块包</li><li>简单易用</li></ul><p><strong>缺点:</strong></p><ul><li>同步的模块加载方式不适合在浏览器环境中，同步意味着阻塞加载，浏览器资源是异步加载的</li><li>不能非阻塞的并行加载多个模块</li></ul><p><strong>实现:</strong></p><ul><li>服务端的 NodeJS</li><li>Browserify，浏览器端的 CommonsJS 实现，可以使用 NPM 的模块，但是编译打包后的文件体积较大</li><li>modules-webmake，类似 Browserify，但不如 Browserify 灵活</li><li>wreq，Browserify 的前身</li></ul><h4 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h4><p>Asynchronous Module Definition 规范其实主要一个主要接口 define(id?, dependencies?, factory); 它要在声明模块的时候指定所有的依赖 dependencies，并且还要当做形参传到 factory 中，对于依赖的模块提前执行。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">define(&quot;module&quot;, [&quot;dep1&quot;, &quot;dep2&quot;], function(d1, d2) &#123;</span><br><span class="line">  return someExportedValue;</span><br><span class="line">&#125;);</span><br><span class="line">require([&quot;module&quot;, &quot;..&#x2F;file.js&quot;], function(module, file) &#123;&#125;);</span><br></pre></td></tr></table></figure><p><strong>优点</strong></p><ul><li>适合在浏览器环境中异步加载模块</li><li>可以并行加载多个模块</li></ul><p><strong>缺点</strong></p><ul><li>提高了开发成本，代码的阅读和书写比较困难，模块定义方式的语义不畅</li><li>不符合通用的模块化思维方式，是一种妥协的实现</li></ul><p><strong>实现</strong></p><ul><li>RequireJS</li><li>curl</li></ul><h4 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h4><p>Commons Module Definition 规范和 AMD 很相似，尽量保持简单，并与 CommonsJS 和 NodeJS 的 Modules 规范保持了很大的兼容性。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">define(function(require, exports, module) &#123;</span><br><span class="line">  var $ &#x3D; require(&quot;jquery&quot;);</span><br><span class="line">  var Spinning &#x3D; require(&quot;.&#x2F;spinning&quot;);</span><br><span class="line">  exports.doSomething &#x3D; ...;</span><br><span class="line">  module.exports &#x3D; ...;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>优点:</strong></p><ul><li>依赖就近，延迟执行</li><li>可以很容易在 NodeJS 中运行</li></ul><p><strong>缺点</strong></p><ul><li>依赖 SPM 打包，模块的加载逻辑偏重</li></ul><p><strong>实现</strong></p><ul><li>Sea.js</li><li>coolie</li></ul><h4 id="ES6-模块"><a href="#ES6-模块" class="headerlink" title="ES6 模块"></a>ES6 模块</h4><p>EcmaScript6 标准增加了 JavaScript 语言层面的模块体系定义。 ES6 模块的设计思想，是尽量静态化，使编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonsJS 和 AMD 模块，都只能在运行时确定这些东西。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &quot;jquery&quot;;</span><br><span class="line">export function doStuff() &#123;&#125;</span><br><span class="line">module &quot;localModule&quot; &#123;&#125;</span><br></pre></td></tr></table></figure><p><strong>优点</strong></p><ul><li>容易进行静态分析</li><li>面向未来的 EcmaScript 标准</li></ul><p><strong>缺点</strong></p><ul><li>原生浏览器端还没有实现该标准</li><li>全新的命令，新版的 NodeJS 才支持</li></ul><p><strong>实现</strong></p><ul><li>Babel</li></ul><p><strong>大家期望的模块系统</strong></p><p>可以兼容多种模块风格，尽量可以利用已有的代码，不仅仅只是 JavaScript 模块化，还有 CSS、图片、字体等资源也需要模块化。</p><h2 id="安装Webpack"><a href="#安装Webpack" class="headerlink" title="安装Webpack"></a>安装Webpack</h2><p>WebPack 是一款模块加载器兼打包工具，它能把各种资源，如 JS、JSX、ES6、SASS、LESS、图片等都作为模块来处理和使用。</p><p><strong>安装:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install webpack -g</span><br><span class="line">npm install webpack-cli -g</span><br></pre></td></tr></table></figure><p>测试安装成功:</p><ul><li><code>webpack -v</code></li><li><code>webpack-cli -v</code></li></ul><p><img src="https://blog.kuangstudy.com/usr/uploads/2019/10/2035564066.png" alt="QQ截图20191023173431.png"></p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>创建 <code>webpack.config.js</code> 配置文件</p><ul><li>entry：入口文件，指定 WebPack 用哪个文件作为项目的入口</li><li>output：输出，指定 WebPack 把处理完成的文件放置到指定路径</li><li>module：模块，用于处理各种类型的文件</li><li>plugins：插件，如：热更新、代码重用等</li><li>resolve：设置路径指向</li><li>watch：监听，用于设置文件改动后直接打包</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">    entry: &quot;&quot;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: &quot;&quot;,</span><br><span class="line">        filename: &quot;&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    module: &#123;</span><br><span class="line">        loaders: [</span><br><span class="line">            &#123;test: &#x2F;\.js$&#x2F;, loader: &quot;&quot;&#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: &#123;&#125;,</span><br><span class="line">    resolve: &#123;&#125;,</span><br><span class="line">    watch: true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接运行 <code>webpack</code> 命令打包</p><h2 id="使用webpack"><a href="#使用webpack" class="headerlink" title="使用webpack"></a>使用webpack</h2><ol><li><p>创建项目</p></li><li><p>创建一个名为 modules 的目录，用于放置 JS 模块等资源文件</p></li><li><p>在modules下创建模块文件，如 hello.js，用于编写 JS 模块相关代码</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;暴露一个方法:sayHi</span><br><span class="line">exports.sayHi &#x3D; function () &#123;</span><br><span class="line">  document.write(&quot;&lt;div&gt;Hello WebPack&lt;&#x2F;div&gt;&quot;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>在modules下创建一个名为 main.js 的入口文件，用于打包时设置 entry 属性</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;require 导入一个模块,就可以调用这个模块中的方法了</span><br><span class="line">var hello &#x3D; require(&quot;.&#x2F;hello&quot;);</span><br><span class="line">hello.sayHi();</span><br></pre></td></tr></table></figure></li><li><p>在项目目录下创建 webpack.config.js 配置文件，使用 webpack 命令打包</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">    entry: &quot;.&#x2F;modules&#x2F;main.js&quot;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: &quot;.&#x2F;js&#x2F;bundle.js&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>在项目目录下创建 HTML 页面，如 index.html，导入 WebPack 打包后的 JS 文件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!doctype html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line"> &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line"> &lt;title&gt;狂神说Java&lt;&#x2F;title&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;script src&#x3D;&quot;dist&#x2F;js&#x2F;bundle.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure></li><li><p>在IDEA控制台中直接执行webpack;如果失败的话,就使用管理员权限运行即可!</p></li><li><p>运行 HTML 看效果</p></li></ol><p><strong>说明:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 参数 --watch 用于监听变化</span><br><span class="line">webpack --watch</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      前端体系、前后端分离
    
    </summary>
    
    
      <category term="Vue" scheme="https://SomunsTao.github.io/categories/Vue/"/>
    
    
      <category term="Vue" scheme="https://SomunsTao.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue 07：第一个vue-cli项目</title>
    <link href="https://somunstao.github.io/2020/04/17/Vue%2007%EF%BC%9A%E7%AC%AC%E4%B8%80%E4%B8%AAvue-cli%E9%A1%B9%E7%9B%AE/"/>
    <id>https://somunstao.github.io/2020/04/17/Vue%2007%EF%BC%9A%E7%AC%AC%E4%B8%80%E4%B8%AAvue-cli%E9%A1%B9%E7%9B%AE/</id>
    <published>2020-04-16T16:00:00.000Z</published>
    <updated>2020-08-01T15:18:13.793Z</updated>
    
    <content type="html"><![CDATA[<p>​    </p><h1 id="Vue：第一个vue-cli项目"><a href="#Vue：第一个vue-cli项目" class="headerlink" title="Vue：第一个vue-cli项目"></a>Vue：第一个vue-cli项目</h1><h2 id="什么是vue-cli"><a href="#什么是vue-cli" class="headerlink" title="什么是vue-cli"></a>什么是vue-cli</h2><p>vue-cli 官方提供的一个脚手架,用于快速生成一个 vue 的项目模板;</p><p>预先定义好的目录结构及基础代码，就好比咱们在创建 Maven 项目时可以选择创建一个骨架项目，这个骨架项目就是脚手架,我们的开发更加的快速;</p><p><strong>主要的功能:</strong></p><ul><li>统一的目录结构</li><li>本地调试</li><li>热部署</li><li>单元测试</li><li>集成打包上线</li></ul><h2 id="需要的环境"><a href="#需要的环境" class="headerlink" title="需要的环境"></a>需要的环境</h2><ul><li>Node.js : <a href="http://nodejs.cn/download/" target="_blank" rel="noopener">http://nodejs.cn/download/</a><br>安装就无脑下一步就好,安装在自己的环境目录下</li><li>Git : <a href="https://git-scm.com/downloads" target="_blank" rel="noopener">https://git-scm.com/downloads</a><br>镜像:<a href="https://npm.taobao.org/mirrors/git-for-windows/" target="_blank" rel="noopener">https://npm.taobao.org/mirrors/git-for-windows/</a></li></ul><p><strong>确认nodejs安装成功:</strong></p><ul><li>cmd 下输入 <code>node -v</code>,查看是否能够正确打印出版本号即可!</li><li>cmd 下输入 <code>npm-v</code>,查看是否能够正确打印出版本号即可!</li></ul><p>这个npm,就是一个软件包管理工具,就和linux下的apt软件安装差不多!</p><p><strong>安装 Node.js 淘宝镜像加速器（cnpm）</strong></p><p>这样子的话,下载会快很多~</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># -g 就是全局安装</span><br><span class="line">npm install cnpm -g</span><br><span class="line"></span><br><span class="line"># 或使用如下语句解决 npm 速度慢的问题</span><br><span class="line">npm install --registry&#x3D;https:&#x2F;&#x2F;registry.npm.taobao.org</span><br></pre></td></tr></table></figure><p>安装过程可能有点慢~,耐心等待!虽然安装了cnpm,但是尽量少用!</p><p>安装的位置:<code>C:\Users\Administrator\AppData\Roaming\npm</code></p><p><img src="https://blog.kuangstudy.com/usr/uploads/2019/10/3274148234.png" alt="QQ截图20191023160802.png"></p><p><strong>安装 vue-cli</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cnpm install vue-cli -g</span><br><span class="line"></span><br><span class="line"># 测试是否安装成功</span><br><span class="line"># 查看可以基于哪些模板创建 vue 应用程序，通常我们选择 webpack</span><br><span class="line">vue list</span><br></pre></td></tr></table></figure><p><img src="https://blog.kuangstudy.com/usr/uploads/2019/10/1623428782.png" alt="QQ截图20191023161055.png"></p><h2 id="第一个-vue-cli-应用程序"><a href="#第一个-vue-cli-应用程序" class="headerlink" title="第一个 vue-cli 应用程序"></a>第一个 vue-cli 应用程序</h2><ol><li><p>创建一个Vue项目,我们随便建立一个空的文件夹在电脑上,我这里在D盘下新建一个目录<code>D:\Project\vue-study</code>;</p></li><li><p>创建一个基于 webpack 模板的 vue 应用程序</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 这里的 myvue 是项目名称，可以根据自己的需求起名</span><br><span class="line">vue init webpack myvue</span><br></pre></td></tr></table></figure><p>一路都选择no即可;</p></li></ol><p><strong>说明:</strong></p><ul><li>Project name：项目名称，默认 回车 即可</li><li>Project description：项目描述，默认 回车 即可</li><li>Author：项目作者，默认 回车 即可</li><li>Install vue-router：是否安装 vue-router，选择 n 不安装（后期需要再手动添加）</li><li>Use ESLint to lint your code：是否使用 ESLint 做代码检查，选择 n 不安装（后期需要再手动添加）</li><li>Set up unit tests：单元测试相关，选择 n 不安装（后期需要再手动添加）</li><li>Setup e2e tests with Nightwatch：单元测试相关，选择 n 不安装（后期需要再手动添加）</li><li>Should we run npm install for you after the project has been created：创建完成后直接初始化，选择 n，我们手动执行;运行结果!<br><img src="https://blog.kuangstudy.com/usr/uploads/2019/10/1192113224.png" alt="QQ截图20191023161857.png"></li></ul><h3 id="初始化并运行"><a href="#初始化并运行" class="headerlink" title="初始化并运行"></a>初始化并运行</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd myvue</span><br><span class="line">npm install</span><br><span class="line">npm run dev</span><br></pre></td></tr></table></figure><p>执行完成后,目录多了很多依赖</p><p><img src="https://blog.kuangstudy.com/usr/uploads/2019/10/1102095439.png" alt="QQ截图20191023162254.png"></p><p>安装并运行成功后在浏览器输入：<a href="http://localhost/" target="_blank" rel="noopener">http://localhost</a>:8080</p><p><img src="https://blog.kuangstudy.com/usr/uploads/2019/10/2731297978.png" alt="QQ截图20191023162439.png"></p><p><strong>效果:</strong></p><p><img src="https://blog.kuangstudy.com/usr/uploads/2019/10/3761367777.png" alt="QQ截图20191023162508.png"></p><h2 id="Vue-cli目录结构"><a href="#Vue-cli目录结构" class="headerlink" title="Vue-cli目录结构"></a>Vue-cli目录结构</h2><p>我们用IDEA,open刚才的项目!</p><p><img src="https://blog.kuangstudy.com/usr/uploads/2019/10/3943650778.png" alt="QQ截图20191023162755.png"></p><ul><li>build 和 config：WebPack 配置文件</li><li>node_modules：用于存放 npm install 安装的依赖文件</li><li>src： 项目源码目录</li><li>static：静态资源文件</li><li>.babelrc：Babel 配置文件，主要作用是将 ES6 转换为 ES5</li><li>.editorconfig：编辑器配置</li><li>eslintignore：需要忽略的语法检查配置文件</li><li>.gitignore：git 忽略的配置文件</li><li>.postcssrc.js：css 相关配置文件，其中内部的 module.exports 是 NodeJS 模块化语法</li><li>index.html：首页，仅作为模板页，实际开发时不使用</li><li>package.json：项目的配置文件<ul><li>name：项目名称</li><li>version：项目版本</li><li>description：项目描述</li><li>author：项目作者</li><li>scripts：封装常用命令</li><li>dependencies：生产环境依赖</li><li>devDependencies：开发环境依赖</li></ul></li></ul><h2 id="src-目录"><a href="#src-目录" class="headerlink" title="src 目录"></a>src 目录</h2><p><code>src</code> 目录是项目的源码目录，所有代码都会写在这里</p><p><img src="https://blog.kuangstudy.com/usr/uploads/2019/10/1887353409.png" alt="QQ截图20191023164841.png"></p><h3 id="main-js"><a href="#main-js" class="headerlink" title="main.js"></a>main.js</h3><p>项目的入口文件，我们知道所有的程序都会有一个入口</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; The Vue build version to load with the &#96;import&#96; command</span><br><span class="line">&#x2F;&#x2F; (runtime-only or standalone) has been set in webpack.base.conf with an alias.</span><br><span class="line">import Vue from &#39;vue&#39;</span><br><span class="line">import App from &#39;.&#x2F;App&#39;</span><br><span class="line"></span><br><span class="line">Vue.config.productionTip &#x3D; false;</span><br><span class="line"></span><br><span class="line">&#x2F;* eslint-disable no-new *&#x2F;</span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: &#39;#app&#39;,</span><br><span class="line">  components: &#123; App &#125;,</span><br><span class="line">  template: &#39;&lt;App&#x2F;&gt;&#39;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li><code>import Vue from &#39;vue&#39;</code>：ES6 写法，会被转换成 require(“vue”); （require 是 NodeJS 提供的模块加载器）</li><li><code>import App from &#39;./App&#39;</code>：意思同上，但是指定了查找路径，./ 为当前目录</li><li><code>Vue.config.productionTip = false</code>：关闭浏览器控制台关于环境的相关提示</li><li><code>new Vue({...})</code>：实例化 Vue<ul><li><code>el: &#39;#app&#39;</code>：查找 index.html 中 id 为 app 的元素</li><li><code>template: &#39;&lt;App/&gt;&#39;</code>：模板，会将 index.html 中 <div id="app"></div> 替换为 <App /></li><li><code>components: { App }</code>：引入组件，使用的是 import App from ‘./App’ 定义的 App 组件;</li></ul></li></ul><h3 id="App-vue"><a href="#App-vue" class="headerlink" title="App.vue"></a>App.vue</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">    &lt;img src&#x3D;&quot;.&#x2F;assets&#x2F;logo.png&quot;&gt;</span><br><span class="line">    &lt;HelloWorld&#x2F;&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import HelloWorld from &#39;.&#x2F;components&#x2F;HelloWorld&#39;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#39;App&#39;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    HelloWorld</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">#app &#123;</span><br><span class="line">  font-family: &#39;Avenir&#39;, Helvetica, Arial, sans-serif;</span><br><span class="line">  -webkit-font-smoothing: antialiased;</span><br><span class="line">  -moz-osx-font-smoothing: grayscale;</span><br><span class="line">  text-align: center;</span><br><span class="line">  color: #2c3e50;</span><br><span class="line">  margin-top: 60px;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure><ul><li>template：HTML 代码模板，会替换 <App /> 中的内容</li><li>import HelloWorld from ‘./components/HelloWorld’：引入 HelloWorld 组件，用于替换 template 中的 <HelloWorld/></li><li>export default{…}：导出 NodeJS 对象，作用是可以通过 import 关键字导入<ul><li>name: ‘App’：定义组件的名称</li><li>components: { HelloWorld }：定义子组件</li></ul></li></ul><p>在hello,Vue中,关于 <style scoped> 的说明：CSS 样式仅在当前组件有效，声明了样式的作用域,是当前的界面私有的!</p>]]></content>
    
    <summary type="html">
    
      前端体系、前后端分离
    
    </summary>
    
    
      <category term="Vue" scheme="https://SomunsTao.github.io/categories/Vue/"/>
    
    
      <category term="Vue" scheme="https://SomunsTao.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue 06：计算属性、内容分发、自定义事件</title>
    <link href="https://somunstao.github.io/2020/04/16/Vue%2006%EF%BC%9A%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E3%80%81%E5%86%85%E5%AE%B9%E5%88%86%E5%8F%91%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BA%8B%E4%BB%B6/"/>
    <id>https://somunstao.github.io/2020/04/16/Vue%2006%EF%BC%9A%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E3%80%81%E5%86%85%E5%AE%B9%E5%88%86%E5%8F%91%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BA%8B%E4%BB%B6/</id>
    <published>2020-04-15T16:00:00.000Z</published>
    <updated>2020-08-01T15:17:52.691Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Vue：计算属性、内容分发、自定义事件"><a href="#Vue：计算属性、内容分发、自定义事件" class="headerlink" title="Vue：计算属性、内容分发、自定义事件"></a>Vue：计算属性、内容分发、自定义事件</h1><h2 id="什么是计算属性"><a href="#什么是计算属性" class="headerlink" title="什么是计算属性"></a>什么是计算属性</h2><p>计算属性的重点突出在 <code>属性</code> 两个字上（属性是名词），首先它是个 <code>属性</code> 其次这个属性有 <code>计算</code> 的能力（计算是动词），这里的 <code>计算</code> 就是个函数；简单点说，它就是一个能够将计算结果缓存起来的属性（将行为转化成了静态的属性），仅此而已；可以想象为缓存！</p><p><strong>上代码：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;狂神说Java&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;vue@2.5.21&#x2F;dist&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;div id&#x3D;&quot;vue&quot;&gt;</span><br><span class="line">    &lt;!--注意，一个是方法，一个是属性--&gt;</span><br><span class="line">    &lt;p&gt;调用当前时间的方法：&#123;&#123;currentTime1()&#125;&#125;&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;p&gt;当前时间的计算属性：&#123;&#123;currentTime2&#125;&#125;&lt;&#x2F;p&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">    var vm &#x3D; new Vue(&#123;</span><br><span class="line">        el: &#39;#vue&#39;,</span><br><span class="line">        data: &#123;</span><br><span class="line">            message: &#39;Hello Vue&#39;</span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line">            currentTime1: function () &#123;</span><br><span class="line">                return Date.now();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        computed: &#123;</span><br><span class="line">            &#x2F;&#x2F;currentTime2 ，这是一个属性！不是方法</span><br><span class="line">            currentTime2: function () &#123;</span><br><span class="line">                this.message;</span><br><span class="line">                return Date.now();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p><strong>注意：methods 和 computed 里的东西不能重名</strong></p><p><strong>说明：</strong></p><ul><li>methods：定义方法，调用方法使用 currentTime1()，需要带括号</li><li>computed：定义计算属性，调用属性使用 currentTime2，不需要带括号；this.message 是为了能够让 currentTime2 观察到数据变化而变化</li><li>如何在方法中的值发生了变化，则缓存就会刷新！可以在控制台使用 <code>vm.message=&quot;qinjiang&quot;</code>,改变下数据的值，再次测试观察效果！</li></ul><p><strong>结论：</strong></p><p>调用方法时，每次都需要进行计算，既然有计算过程则必定产生系统开销，那如果这个结果是不经常变化的呢？此时就可以考虑将这个结果缓存起来，采用计算属性可以很方便的做到这一点,<strong>计算属性的主要特性就是为了将不经常变化的计算结果进行缓存，以节约我们的系统开销;</strong></p><h2 id="内容分发"><a href="#内容分发" class="headerlink" title="内容分发"></a>内容分发</h2><p>在 <code>Vue.js</code> 中我们使用 <code>&lt;slot&gt;</code> 元素作为承载分发内容的出口，作者称其为 插槽，可以应用在组合组件的场景中;</p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>比如准备制作一个待办事项组件（todo），该组件由待办标题（todo-title）和待办内容（todo-items）组成，但这三个组件又是相互独立的，该如何操作呢？</p><p><strong>第一步: 定义一个待办事项的组件</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;vue&quot;&gt;</span><br><span class="line">    &lt;todo&gt;&lt;&#x2F;todo&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">    Vue.component(&#39;todo&#39;, &#123;</span><br><span class="line">        template: &#39;&lt;div&gt;\</span><br><span class="line">                    &lt;div&gt;待办事项&lt;&#x2F;div&gt;\</span><br><span class="line">                    &lt;ul&gt;\</span><br><span class="line">                        &lt;li&gt;学习狂神说Java&lt;&#x2F;li&gt;\</span><br><span class="line">                    &lt;&#x2F;ul&gt;\</span><br><span class="line">               &lt;&#x2F;div&gt;&#39;</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p><strong>第二步: 我们需要让,待办事项的标题和值实现动态绑定,怎么做呢? 我们可以留出一个插槽!</strong></p><p>1-将上面的代码留出一个插槽,即 slot</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Vue.component(&#39;todo&#39;, &#123;</span><br><span class="line">    template: &#39;&lt;div&gt;\</span><br><span class="line">                    &lt;slot name&#x3D;&quot;todo-title&quot;&gt;&lt;&#x2F;slot&gt;\</span><br><span class="line">                    &lt;ul&gt;\</span><br><span class="line">                        &lt;slot name&#x3D;&quot;todo-items&quot;&gt;&lt;&#x2F;slot&gt;\</span><br><span class="line">                    &lt;&#x2F;ul&gt;\</span><br><span class="line">               &lt;&#x2F;div&gt;&#39;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>2-定义一个名为 todo-title 的待办标题组件 和 todo-items 的待办内容组件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Vue.component(&#39;todo-title&#39;, &#123;</span><br><span class="line">    props: [&#39;title&#39;],</span><br><span class="line">    template: &#39;&lt;div&gt;&#123;&#123;title&#125;&#125;&lt;&#x2F;div&gt;&#39;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;这里的index,就是数组的下标,使用for循环遍历的时候,可以循环出来!</span><br><span class="line">Vue.component(&#39;todo-items&#39;, &#123;</span><br><span class="line">    props: [&#39;item&#39;, &#39;index&#39;],</span><br><span class="line">    template: &#39;&lt;li&gt;&#123;&#123;index + 1&#125;&#125;. &#123;&#123;item&#125;&#125;&lt;&#x2F;li&gt;&#39;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>3-实例化 Vue 并初始化数据</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var vm &#x3D; new Vue(&#123;</span><br><span class="line">    el: &#39;#vue&#39;,</span><br><span class="line">    data: &#123;</span><br><span class="line">        todoItems: [&#39;狂神说Java&#39;, &#39;狂神说运维&#39;, &#39;狂神说前端&#39;]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>4-将这些值,通过插槽插入</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;vue&quot;&gt;</span><br><span class="line">    &lt;todo&gt;</span><br><span class="line">        &lt;todo-title slot&#x3D;&quot;todo-title&quot; title&#x3D;&quot;秦老师系列课程&quot;&gt;&lt;&#x2F;todo-title&gt;</span><br><span class="line">        &lt;todo-items slot&#x3D;&quot;todo-items&quot; v-for&#x3D;&quot;(item, index) in todoItems&quot; v-bind:item&#x3D;&quot;item&quot; v-bind:index&#x3D;&quot;index&quot; :key&#x3D;&quot;index&quot;&gt;&lt;&#x2F;todo-items&gt;</span><br><span class="line">    &lt;&#x2F;todo&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><p>说明:我们的 todo-title 和 todo-items 组件分别被分发到了 todo 组件的 todo-title 和 todo-items 插槽中</p><h2 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a>自定义事件</h2><p>通过以上代码不难发现，数据项在 Vue 的实例中，但删除操作要在组件中完成，那么组件如何才能删除 Vue 实例中的数据呢？此时就涉及到参数传递与事件分发了，Vue 为我们提供了自定义事件的功能很好的帮助我们解决了这个问题；使用 this.$emit(‘自定义事件名’, 参数)，操作过程如下:</p><p>1-在vue的实例中,增加了 methods 对象并定义了一个名为 removeTodoItems 的方法</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var vm &#x3D; new Vue(&#123;</span><br><span class="line">    el: &#39;#vue&#39;,</span><br><span class="line">    data: &#123;</span><br><span class="line">        title: &quot;秦老师系列课程1&quot;,</span><br><span class="line">        todoItems: [&#39;狂神说Java&#39;, &#39;狂神说运维&#39;, &#39;狂神说前端&#39;]</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        &#x2F;&#x2F; 该方法可以被模板中自定义事件触发</span><br><span class="line">        removeTodoItems: function (index) &#123;</span><br><span class="line">            console.log(&quot;删除 &quot; + this.todoItems[index] + &quot; 成功&quot;);</span><br><span class="line">            &#x2F;&#x2F; splice() 方法向&#x2F;从数组中添加&#x2F;删除项目，然后返回被删除的项目，其中 index 为添加&#x2F;删除项目的位置，1 表示删除的数量</span><br><span class="line">            this.todoItems.splice(index, 1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>2-修改 todo-items 待办内容组件的代码,增加一个删除按钮,并且绑定事件!</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Vue.component(&#39;todo-items&#39;, &#123;</span><br><span class="line">    props: [&#39;item&#39;, &#39;index&#39;],</span><br><span class="line">    template: &#39;&lt;li&gt;&#123;&#123;index + 1&#125;&#125;. &#123;&#123;item&#125;&#125;  &lt;button @click&#x3D;&quot;remove_component&quot;&gt;删除&lt;&#x2F;button&gt;&lt;&#x2F;li&gt;&#39;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        remove_component: function (index) &#123;</span><br><span class="line">            &#x2F;&#x2F; 这里的 remove 是自定义事件的名称，需要在 HTML 中使用 v-on:remove 的方式指派</span><br><span class="line">            this.$emit(&#39;remove&#39;, index);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>3-修改 todo-items 待办内容组件的 HTML 代码,增加一个自定义事件,比如叫 remove,可以和组件的方法绑定,然后绑定到vue的方法中!</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--增加了 v-on:remove&#x3D;&quot;removeTodoItems(index)&quot; 自定义事件，该事件会调用 Vue 实例中定义的名为 removeTodoItems 的方法--&gt;</span><br><span class="line">&lt;todo-items slot&#x3D;&quot;todo-items&quot; v-for&#x3D;&quot;(item, index) in todoItems&quot;</span><br><span class="line">            v-bind:item&#x3D;&quot;item&quot; v-bind:index&#x3D;&quot;index&quot; :key&#x3D;&quot;index&quot;</span><br><span class="line">            v-on:remove&#x3D;&quot;removeTodoItems(index)&quot;&gt;&lt;&#x2F;todo-items&gt;</span><br></pre></td></tr></table></figure><h3 id="逻辑理解"><a href="#逻辑理解" class="headerlink" title="逻辑理解"></a>逻辑理解</h3><p><img src="https://blog.kuangstudy.com/usr/uploads/2019/10/2041589231.png" alt="20191023150103.png"></p><h2 id="Vue-入门小结"><a href="#Vue-入门小结" class="headerlink" title="Vue 入门小结"></a>Vue 入门小结</h2><p>核心 : 数据驱动 , 组件化<br>优点 : 借鉴了 AngulaJS 的模块化开发 和 React 的虚拟Dom , 虚拟Dom就是把Dom操作放到内存中执行;</p><p>常用的属性:</p><ul><li>v-if</li><li>v-else-if</li><li>v-else</li><li>v-for</li><li>v-on 绑定事件 , 简写<code>@</code></li><li>v-model 数据双向绑定</li><li>v-bind 给组件绑定参数,简写 <code>:</code></li></ul><p>组件化:</p><ul><li>组合组件 slot 插槽</li><li>组件内部绑定事件需要使用到 <code>this.$emit(&quot;事件名&quot;,参数)</code>;</li><li>计算属性的特色,缓存计算数据</li></ul><p>遵循SoC 关注度分离原则,Vue是纯粹的视图框架,并不包含,比如Ajax之类的通信功能,为了解决通信问题,我们需要使用Axios 框架做异步通信;</p><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>Vue的开发都是要基于NodeJS, 实际开发采用 vue-cli脚手架开发,vue-router 路由,vuex做状态管理; Vue UI,界面我们一般使用 ElementUI(饿了么出品),或者ICE(阿里巴巴出品!)来快速搭建前端项目~</p><p>官网:</p><ul><li><a href="https://element.eleme.cn/#/zh-CN" target="_blank" rel="noopener">https://element.eleme.cn/#/zh-CN</a></li><li><a href="https://ice.work/" target="_blank" rel="noopener">https://ice.work/</a></li></ul>]]></content>
    
    <summary type="html">
    
      前端体系、前后端分离
    
    </summary>
    
    
      <category term="Vue" scheme="https://SomunsTao.github.io/categories/Vue/"/>
    
    
      <category term="Vue" scheme="https://SomunsTao.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue 05：表单双绑、组件</title>
    <link href="https://somunstao.github.io/2020/04/15/Vue%2005%EF%BC%9A%E8%A1%A8%E5%8D%95%E5%8F%8C%E7%BB%91%E3%80%81%E7%BB%84%E4%BB%B6/"/>
    <id>https://somunstao.github.io/2020/04/15/Vue%2005%EF%BC%9A%E8%A1%A8%E5%8D%95%E5%8F%8C%E7%BB%91%E3%80%81%E7%BB%84%E4%BB%B6/</id>
    <published>2020-04-14T16:00:00.000Z</published>
    <updated>2020-08-01T15:17:33.652Z</updated>
    
    <content type="html"><![CDATA[<p>​    </p><h1 id="Vue：表单双绑、组件"><a href="#Vue：表单双绑、组件" class="headerlink" title="Vue：表单双绑、组件"></a>Vue：表单双绑、组件</h1><h2 id="什么是双向数据绑定"><a href="#什么是双向数据绑定" class="headerlink" title="什么是双向数据绑定"></a>什么是双向数据绑定</h2><p>Vue.js 是一个 MVVM 框架，即数据双向绑定，即当数据发生变化的时候，视图也就发生变化，当视图发生变化的时候，数据也会跟着同步变化。这也算是 Vue.js 的精髓之处了。</p><p>值得注意的是，我们所说的数据双向绑定，一定是对于 UI 控件来说的，非 UI 控件不会涉及到数据双向绑定。单向数据绑定是使用状态管理工具的前提。如果我们使用 <code>vuex</code>，那么数据流也是单项的，这时就会和双向数据绑定有冲突。</p><h3 id="为什么要实现数据的双向绑定"><a href="#为什么要实现数据的双向绑定" class="headerlink" title="为什么要实现数据的双向绑定"></a>为什么要实现数据的双向绑定</h3><p>在 <code>Vue.js</code> 中，如果使用 <code>vuex</code>，实际上数据还是单向的，之所以说是数据双向绑定，这是用的 UI 控件来说，对于我们处理表单，Vue.js 的双向数据绑定用起来就特别舒服了。即两者并不互斥，在全局性数据流使用单项，方便跟踪；局部性数据流使用双向，简单易操作。</p><h2 id="在表单中使用双向数据绑定"><a href="#在表单中使用双向数据绑定" class="headerlink" title="在表单中使用双向数据绑定"></a>在表单中使用双向数据绑定</h2><p>你可以用 <code>v-model</code> 指令在表单 <code>&lt;input&gt;</code>、<code>&lt;textarea&gt;</code> 及 <code>&lt;select&gt;</code> 元素上创建双向数据绑定。它会根据控件类型自动选取正确的方法来更新元素。尽管有些神奇，但 v-model 本质上不过是语法糖。它负责监听用户的输入事件以更新数据，并对一些极端场景进行一些特殊处理。</p><p><strong>注意：v-model 会忽略所有表单元素的 value、checked、selected 特性的初始值而总是将 Vue 实例的数据作为数据来源。你应该通过 JavaScript 在组件的 data 选项中声明初始值!</strong></p><h3 id="单行文本"><a href="#单行文本" class="headerlink" title="单行文本"></a>单行文本</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;狂神说Java&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;vue@2.5.21&#x2F;dist&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--我们这里希望，输入框的值和&#123;&#125;取值动态绑定，实时相同，我们就使用v-model绑定message--&gt;</span><br><span class="line">&lt;div id&#x3D;&quot;vue&quot;&gt;</span><br><span class="line">    单行文本：&lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;message&quot; value&#x3D;&quot;hello&quot; &#x2F;&gt;&amp;nbsp;&amp;nbsp;单行文本是：&#123;&#123;message&#125;&#125;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">    var vm &#x3D; new Vue(&#123;</span><br><span class="line">        el: &#39;#vue&#39;,</span><br><span class="line">        data: &#123;</span><br><span class="line">            message: &quot;Hello Vue&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><h3 id="多行文本"><a href="#多行文本" class="headerlink" title="多行文本"></a>多行文本</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;vue&quot;&gt;</span><br><span class="line">    多行文本：&lt;textarea v-model&#x3D;&quot;message&quot;&gt;&lt;&#x2F;textarea&gt;&amp;nbsp;&amp;nbsp;多行文本是：&#123;&#123;message&#125;&#125;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">    var vm &#x3D; new Vue(&#123;</span><br><span class="line">        el: &#39;#vue&#39;,</span><br><span class="line">        data: &#123;</span><br><span class="line">            message: &quot;Hello Textarea&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h3 id="单复选框"><a href="#单复选框" class="headerlink" title="单复选框"></a>单复选框</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;vue&quot;&gt;</span><br><span class="line">    单复选框：</span><br><span class="line">    &lt;input type&#x3D;&quot;checkbox&quot; id&#x3D;&quot;checkbox&quot; v-model&#x3D;&quot;checked&quot;&gt;</span><br><span class="line">    &amp;nbsp;&amp;nbsp;</span><br><span class="line">    &lt;label for&#x3D;&quot;checkbox&quot;&gt;&#123;&#123; checked &#125;&#125;&lt;&#x2F;label&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">    var vm &#x3D; new Vue(&#123;</span><br><span class="line">        el: &#39;#vue&#39;,</span><br><span class="line">        data: &#123;</span><br><span class="line">            checked: false</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h3 id="多复选框"><a href="#多复选框" class="headerlink" title="多复选框"></a>多复选框</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;vue&quot;&gt;</span><br><span class="line">    多复选框：</span><br><span class="line">    &lt;input type&#x3D;&quot;checkbox&quot; id&#x3D;&quot;jack&quot; value&#x3D;&quot;Jack&quot; v-model&#x3D;&quot;checkedNames&quot;&gt;</span><br><span class="line">    &lt;label for&#x3D;&quot;jack&quot;&gt;Jack&lt;&#x2F;label&gt;</span><br><span class="line">    &lt;input type&#x3D;&quot;checkbox&quot; id&#x3D;&quot;john&quot; value&#x3D;&quot;John&quot; v-model&#x3D;&quot;checkedNames&quot;&gt;</span><br><span class="line">    &lt;label for&#x3D;&quot;john&quot;&gt;John&lt;&#x2F;label&gt;</span><br><span class="line">    &lt;input type&#x3D;&quot;checkbox&quot; id&#x3D;&quot;mike&quot; value&#x3D;&quot;Mike&quot; v-model&#x3D;&quot;checkedNames&quot;&gt;</span><br><span class="line">    &lt;label for&#x3D;&quot;mike&quot;&gt;Mike&lt;&#x2F;label&gt;</span><br><span class="line">    &lt;span&gt;选中的值: &#123;&#123; checkedNames &#125;&#125;&lt;&#x2F;span&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">    var vm &#x3D; new Vue(&#123;</span><br><span class="line">        el: &#39;#vue&#39;,</span><br><span class="line">        data: &#123;</span><br><span class="line">            checkedNames: []</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h3 id="单选按钮"><a href="#单选按钮" class="headerlink" title="单选按钮"></a>单选按钮</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;vue&quot;&gt;</span><br><span class="line">    单选按钮：</span><br><span class="line">    &lt;input type&#x3D;&quot;radio&quot; id&#x3D;&quot;one&quot; value&#x3D;&quot;One&quot; v-model&#x3D;&quot;picked&quot;&gt;</span><br><span class="line">    &lt;label for&#x3D;&quot;one&quot;&gt;One&lt;&#x2F;label&gt;</span><br><span class="line">    &lt;input type&#x3D;&quot;radio&quot; id&#x3D;&quot;two&quot; value&#x3D;&quot;Two&quot; v-model&#x3D;&quot;picked&quot;&gt;</span><br><span class="line">    &lt;label for&#x3D;&quot;two&quot;&gt;Two&lt;&#x2F;label&gt;</span><br><span class="line">    &lt;span&gt;选中的值: &#123;&#123; picked &#125;&#125;&lt;&#x2F;span&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">    var vm &#x3D; new Vue(&#123;</span><br><span class="line">        el: &#39;#vue&#39;,</span><br><span class="line">        data: &#123;</span><br><span class="line">            picked: &#39;&#39;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h3 id="下拉框"><a href="#下拉框" class="headerlink" title="下拉框"></a>下拉框</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;vue&quot;&gt;</span><br><span class="line">    下拉框：</span><br><span class="line">    &lt;select v-model&#x3D;&quot;selected&quot;&gt;</span><br><span class="line">        &lt;option disabled value&#x3D;&quot;&quot;&gt;请选择&lt;&#x2F;option&gt;</span><br><span class="line">        &lt;option&gt;A&lt;&#x2F;option&gt;</span><br><span class="line">        &lt;option&gt;B&lt;&#x2F;option&gt;</span><br><span class="line">        &lt;option&gt;C&lt;&#x2F;option&gt;</span><br><span class="line">    &lt;&#x2F;select&gt;</span><br><span class="line">    &lt;span&gt;选中的值: &#123;&#123; selected &#125;&#125;&lt;&#x2F;span&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">    var vm &#x3D; new Vue(&#123;</span><br><span class="line">        el: &#39;#vue&#39;,</span><br><span class="line">        data: &#123;</span><br><span class="line">            selected: &#39;&#39;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：如果 <code>v-model</code> 表达式的初始值未能匹配任何选项，<select> 元素将被渲染为“未选中”状态。在 iOS 中，这会使用户无法选择第一个选项。因为这样的情况下，iOS 不会触发 change 事件。因此，更推荐像上面这样提供一个值为空的禁用选项。</p><h2 id="什么是组件"><a href="#什么是组件" class="headerlink" title="什么是组件"></a>什么是组件</h2><p>组件是可复用的 <code>Vue</code> 实例，说白了就是一组可以重复使用的模板，跟 JSTL 的自定义标签、Thymeleaf 的 <code>th:fragment</code>等框架有着异曲同工之妙。通常一个应用会以一棵嵌套的组件树的形式来组织：</p><p><img src="https://blog.kuangstudy.com/usr/uploads/2019/10/1384909422.png" alt="vue-component.png"></p><p>例如，你可能会有页头、侧边栏、内容区等组件，每个组件又包含了其它的像导航链接、博文之类的组件。</p><h3 id="第一个-Vue-组件"><a href="#第一个-Vue-组件" class="headerlink" title="第一个 Vue 组件"></a>第一个 Vue 组件</h3><p>注意：在实际开发中，我们并不会用以下方式开发组件，而是采用 vue-cli 创建 .vue 模板文件的方式开发，以下方法只是为了让大家理解什么是组件。</p><p><strong>使用 Vue.component() 方法注册组件,格式如下：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">    &#x2F;&#x2F; 先注册组件</span><br><span class="line">    Vue.component(&#39;my-component-li&#39;, &#123;</span><br><span class="line">        template: &#39;&lt;li&gt;Hello li&lt;&#x2F;li&gt;&#39;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 再实例化 Vue</span><br><span class="line">    var vm &#x3D; new Vue(&#123;</span><br><span class="line">        el: &#39;#vue&#39;</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;div id&#x3D;&quot;vue&quot;&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">        &lt;my-component-li&gt;&lt;&#x2F;my-component-li&gt;</span><br><span class="line">    &lt;&#x2F;ul&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li>Vue.component()：注册组件</li><li>my-component-li：自定义组件的名字</li><li>template：组件的模板</li></ul><h3 id="使用-props-属性传递参数"><a href="#使用-props-属性传递参数" class="headerlink" title="使用 props 属性传递参数"></a>使用 <code>props</code> 属性传递参数</h3><p>像上面那样用组件没有任何意义，所以我们是需要传递参数到组件的，此时就需要使用 <code>props</code> 属性了！</p><p><strong>注意：默认规则下 props 属性里的值不能为大写；</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">    &#x2F;&#x2F; 先注册组件</span><br><span class="line">    Vue.component(&#39;my-component-li&#39;, &#123;</span><br><span class="line">        props: [&#39;item&#39;],</span><br><span class="line">        template: &#39;&lt;li&gt;Hello &#123;&#123;item&#125;&#125;&lt;&#x2F;li&gt;&#39;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 再实例化 Vue</span><br><span class="line">    var vm &#x3D; new Vue(&#123;</span><br><span class="line">        el: &#39;#vue&#39;,</span><br><span class="line">        data: &#123;</span><br><span class="line">            items: [&quot;张三&quot;, &quot;李四&quot;, &quot;王五&quot;]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;div id&#x3D;&quot;vue&quot;&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">        &lt;my-component-li v-for&#x3D;&quot;item in items&quot; v-bind:item&#x3D;&quot;item&quot;&gt;&lt;&#x2F;my-component-li&gt;</span><br><span class="line">    &lt;&#x2F;ul&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li><code>v-for=&quot;item in items&quot;</code>：遍历 <code>Vue</code> 实例中定义的名为 <code>items</code> 的数组，并创建同等数量的组件</li><li><code>v-bind:item=&quot;item&quot;</code>：将遍历的 <code>item</code> 项绑定到组件中 <code>props</code> 定义的名为 <code>item</code> 属性上；= 号左边的 item 为 props 定义的属性名，右边的为 <code>item in items</code> 中遍历的 item 项的值</li></ul>]]></content>
    
    <summary type="html">
    
      前端体系、前后端分离
    
    </summary>
    
    
      <category term="Vue" scheme="https://SomunsTao.github.io/categories/Vue/"/>
    
    
      <category term="Vue" scheme="https://SomunsTao.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue 04：Axios异步通信</title>
    <link href="https://somunstao.github.io/2020/04/14/Vue%2004%EF%BC%9AAxios%E5%BC%82%E6%AD%A5%E9%80%9A%E4%BF%A1/"/>
    <id>https://somunstao.github.io/2020/04/14/Vue%2004%EF%BC%9AAxios%E5%BC%82%E6%AD%A5%E9%80%9A%E4%BF%A1/</id>
    <published>2020-04-13T16:00:00.000Z</published>
    <updated>2020-08-01T15:17:11.703Z</updated>
    
    <content type="html"><![CDATA[<p>​    </p><h1 id="Vue：Axios异步通信"><a href="#Vue：Axios异步通信" class="headerlink" title="Vue：Axios异步通信"></a>Vue：Axios异步通信</h1><h2 id="什么是Axios"><a href="#什么是Axios" class="headerlink" title="什么是Axios"></a>什么是Axios</h2><p>Axios 是一个开源的可以用在浏览器端和 <code>NodeJS</code> 的异步通信框架，她的主要作用就是实现 AJAX 异步通信，其功能特点如下：</p><ul><li>从浏览器中创建 <code>XMLHttpRequests</code></li><li>从 node.js 创建 http 请求</li><li>支持 Promise API [JS中链式编程]</li><li>拦截请求和响应</li><li>转换请求数据和响应数据</li><li>取消请求</li><li>自动转换 JSON 数据</li><li>客户端支持防御 XSRF（跨站请求伪造）</li></ul><p>GitHub：<a href="https://github.com/axios/axios" target="_blank" rel="noopener">https://github.com/axios/axios</a></p><p>中文文档：<a href="http://www.axios-js.com/" target="_blank" rel="noopener">http://www.axios-js.com/</a></p><h3 id="为什么要使用-Axios"><a href="#为什么要使用-Axios" class="headerlink" title="为什么要使用 Axios"></a>为什么要使用 Axios</h3><p>由于 <code>Vue.js</code> 是一个 视图层框架 并且作者（尤雨溪）严格准守 SoC （关注度分离原则），所以 <code>Vue.js</code> 并不包含 AJAX 的通信功能，为了解决通信问题，作者单独开发了一个名为 <code>vue-resource</code> 的插件，不过在进入 2.0 版本以后停止了对该插件的维护并推荐了 <code>Axios</code> 框架。少用jQuery，因为它操作Dom太频繁！</p><h2 id="第一个-Axios-应用程序"><a href="#第一个-Axios-应用程序" class="headerlink" title="第一个 Axios 应用程序"></a>第一个 Axios 应用程序</h2><p>咱们开发的接口大部分都是采用 JSON 格式，可以先在项目里模拟一段 JSON 数据，数据内容如下：创建一个名为 data.json 的文件并填入上面的内容，放在项目的根目录下</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;狂神说Java&quot;,</span><br><span class="line">  &quot;url&quot;: &quot;https:&#x2F;&#x2F;blog.kuangstudy.com&quot;,</span><br><span class="line">  &quot;page&quot;: 1,</span><br><span class="line">  &quot;isNonProfit&quot;: true,</span><br><span class="line">  &quot;address&quot;: &#123;</span><br><span class="line">    &quot;street&quot;: &quot;含光门&quot;,</span><br><span class="line">    &quot;city&quot;: &quot;陕西西安&quot;,</span><br><span class="line">    &quot;country&quot;: &quot;中国&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;links&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;name&quot;: &quot;bilibili&quot;,</span><br><span class="line">      &quot;url&quot;: &quot;https:&#x2F;&#x2F;space.bilibili.com&#x2F;95256449&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;name&quot;: &quot;狂伸说java&quot;,</span><br><span class="line">      &quot;url&quot;: &quot;https:&#x2F;&#x2F;blog.kuangstudy.com&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;name&quot;: &quot;百度&quot;,</span><br><span class="line">      &quot;url&quot;: &quot;https:&#x2F;&#x2F;www.baidu.com&#x2F;&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试代码</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot; xmlns:v-bind&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;1999&#x2F;xhtml&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;狂神说Java&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;!--v-cloak 解决闪烁问题--&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        [v-cloak] &#123;</span><br><span class="line">            display: none;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;&#x2F;style&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;div id&#x3D;&quot;vue&quot; v-cloak&gt;</span><br><span class="line">    &lt;div&gt;名称：&#123;&#123;info.name&#125;&#125;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;div&gt;地址：&#123;&#123;info.address.country&#125;&#125;-&#123;&#123;info.address.city&#125;&#125;-&#123;&#123;info.address.street&#125;&#125;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;div&gt;链接：&lt;a v-bind:href&#x3D;&quot;info.url&quot; target&#x3D;&quot;_blank&quot;&gt;&#123;&#123;info.url&#125;&#125;&lt;&#x2F;a&gt; &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--引入 JS 文件--&gt;</span><br><span class="line">&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;vue@2.5.21&#x2F;dist&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;unpkg.com&#x2F;axios&#x2F;dist&#x2F;axios.min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">    var vm &#x3D; new Vue(&#123;</span><br><span class="line">        el: &#39;#vue&#39;,</span><br><span class="line">        data() &#123;</span><br><span class="line">            return &#123;</span><br><span class="line">                info: &#123;</span><br><span class="line">                    name: null,</span><br><span class="line">                    address: &#123;</span><br><span class="line">                        country: null,</span><br><span class="line">                        city: null,</span><br><span class="line">                        street: null</span><br><span class="line">                    &#125;,</span><br><span class="line">                    url: null</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        mounted() &#123; &#x2F;&#x2F;钩子函数</span><br><span class="line">            axios</span><br><span class="line">                .get(&#39;data.json&#39;)</span><br><span class="line">                .then(response &#x3D;&gt; (this.info &#x3D; response.data));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p>说明:</p><ol><li>在这里使用了 v-bind 将 a:href 的属性值与 Vue 实例中的数据进行绑定</li><li>使用 axios 框架的 get 方法请求 AJAX 并自动将数据封装进了 Vue 实例的数据对象中</li><li>我们在data中的数据结构必须要和<code>Ajax</code>响应回来的数据格式匹配！</li></ol><h2 id="Vue的生命周期"><a href="#Vue的生命周期" class="headerlink" title="Vue的生命周期"></a>Vue的生命周期</h2><p>官方文档：<a href="https://cn.vuejs.org/v2/guide/instance.html#生命周期图示" target="_blank" rel="noopener">https://cn.vuejs.org/v2/guide/instance.html#生命周期图示</a></p><p>Vue 实例有一个完整的生命周期，也就是从开始创建、初始化数据、编译模板、挂载 DOM、渲染→更新→渲染、卸载等一系列过程，我们称这是 Vue 的生命周期。通俗说就是 Vue 实例从创建到销毁的过程，就是生命周期。</p><p>在 Vue 的整个生命周期中，它提供了一系列的事件，可以让我们在事件触发时注册 JS 方法，可以让我们用自己注册的 JS 方法控制整个大局，在这些事件响应方法中的 this 直接指向的是 Vue 的实例。</p><p><img src="https://blog.kuangstudy.com/usr/uploads/2019/10/1579484219.jpg" alt="vue-life.jpg"></p>]]></content>
    
    <summary type="html">
    
      前端体系、前后端分离
    
    </summary>
    
    
      <category term="Vue" scheme="https://SomunsTao.github.io/categories/Vue/"/>
    
    
      <category term="Vue" scheme="https://SomunsTao.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue 03：基础语法</title>
    <link href="https://somunstao.github.io/2020/04/13/Vue%2003%EF%BC%9A%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    <id>https://somunstao.github.io/2020/04/13/Vue%2003%EF%BC%9A%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</id>
    <published>2020-04-12T16:00:00.000Z</published>
    <updated>2020-08-01T15:16:45.568Z</updated>
    
    <content type="html"><![CDATA[<p>​    </p><h1 id="Vue：基础语法"><a href="#Vue：基础语法" class="headerlink" title="Vue：基础语法"></a>Vue：基础语法</h1><h2 id="v-bind"><a href="#v-bind" class="headerlink" title="v-bind"></a>v-bind</h2><p>我们已经成功创建了第一个 Vue 应用！看起来这跟渲染一个字符串模板非常类似，但是 Vue 在背后做了大量工作。现在数据和 DOM 已经被建立了关联，所有东西都是响应式的。我们在控制台操作对象属性，界面可以实时更新！</p><p>我们还可以使用<code>v-bind</code>来绑定元素特性!</p><p><strong>上代码：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html xmlns:v-bind&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;1999&#x2F;xhtml&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;狂神说Java&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;vue@2.5.21&#x2F;dist&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">  &lt;span v-bind:title&#x3D;&quot;message&quot;&gt;</span><br><span class="line">    鼠标悬停几秒钟查看此处动态绑定的提示信息！</span><br><span class="line">  &lt;&#x2F;span&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">    var app &#x3D; new Vue(&#123;</span><br><span class="line">        el: &#39;#app&#39;,</span><br><span class="line">        data: &#123;</span><br><span class="line">            message: &#39;页面加载于 &#39; + new Date().toLocaleString()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p>你看到的 v-bind 等被称为指令。指令带有前缀 v-，以表示它们是 Vue 提供的特殊特性。可能你已经猜到了，它们会在渲染的 DOM 上应用特殊的响应式行为。在这里，该指令的意思是：“将这个元素节点的 title 特性和 Vue 实例的 message 属性保持一致”。</p><p>如果你再次打开浏览器的 JavaScript 控制台，输入 app.message = ‘新消息’，就会再一次看到这个绑定了 title 特性的 HTML 已经进行了更新。</p><h2 id="v-if-v-else"><a href="#v-if-v-else" class="headerlink" title="v-if,v-else"></a>v-if,v-else</h2><p>什么是条件判断语句，就不需要我说明了吧（￣▽￣）,以下两个属性！</p><ul><li><code>v-if</code></li><li><code>v-else</code></li></ul><p><strong>上代码：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;狂神说Java&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;vue@2.5.21&#x2F;dist&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;div id&#x3D;&quot;vue&quot;&gt;</span><br><span class="line">    &lt;h1 v-if&#x3D;&quot;ok&quot;&gt;YES&lt;&#x2F;h1&gt;</span><br><span class="line">    &lt;h1 v-else&gt;NO&lt;&#x2F;h1&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">    var vm &#x3D; new Vue(&#123;</span><br><span class="line">        el: &#39;#vue&#39;,</span><br><span class="line">        data: &#123;</span><br><span class="line">            ok: true</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p>测试：</p><ol><li>在浏览器上运行，打开控制台！</li><li>在控制台输入 <code>vm.ok = false</code> ，然后 回车，你会发现浏览器中显示的内容会直接变成 NO</li></ol><p>注：使用 <code>v-*</code> 属性绑定数据是不需要 <code>双花括号</code> 包裹的</p><h2 id="v-else-if"><a href="#v-else-if" class="headerlink" title="v-else-if"></a>v-else-if</h2><ul><li>v-if</li><li>v-else-if</li><li>v-else</li></ul><p>注：<code>===</code> 三个等号在 JS 中表示绝对等于（就是数据与类型都要相等）</p><p><strong>上代码：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;狂神说Java&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;vue@2.5.21&#x2F;dist&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;div id&#x3D;&quot;vue&quot;&gt;</span><br><span class="line">    &lt;h1 v-if&#x3D;&quot;type &#x3D;&#x3D;&#x3D; &#39;A&#39;&quot;&gt;A&lt;&#x2F;h1&gt;</span><br><span class="line">    &lt;h1 v-else-if&#x3D;&quot;type &#x3D;&#x3D;&#x3D; &#39;B&#39;&quot;&gt;B&lt;&#x2F;h1&gt;</span><br><span class="line">    &lt;h1 v-else-if&#x3D;&quot;type &#x3D;&#x3D;&#x3D; &#39;C&#39;&quot;&gt;C&lt;&#x2F;h1&gt;</span><br><span class="line">    &lt;h1 v-else&gt;who&lt;&#x2F;h1&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">    var vm &#x3D; new Vue(&#123;</span><br><span class="line">        el: &#39;#vue&#39;,</span><br><span class="line">        data: &#123;</span><br><span class="line">            type: &#39;A&#39;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p>测试：观察在控制台输入 vm.type = ‘B’、’C’、’D’ 的变化</p><h2 id="v-for"><a href="#v-for" class="headerlink" title="v-for"></a>v-for</h2><ul><li>v-for</li></ul><p>格式说明：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;vue&quot;&gt;</span><br><span class="line">    &lt;li v-for&#x3D;&quot;item in items&quot;&gt;</span><br><span class="line">        &#123;&#123; item.message &#125;&#125;</span><br><span class="line">    &lt;&#x2F;li&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><p>注：<code>items</code> 是数组，<code>item</code>是数组元素迭代的别名。我们之后学习的Thymeleaf模板引擎的语法和这个十分的相似！</p><p><strong>上代码：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;狂神说Java&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;vue@2.5.21&#x2F;dist&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;div id&#x3D;&quot;vue&quot;&gt;</span><br><span class="line">    &lt;li v-for&#x3D;&quot;item in items&quot;&gt;</span><br><span class="line">        &#123;&#123; item.message &#125;&#125;</span><br><span class="line">    &lt;&#x2F;li&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">    var vm &#x3D; new Vue(&#123;</span><br><span class="line">        el: &#39;#vue&#39;,</span><br><span class="line">        data: &#123;</span><br><span class="line">            &#x2F;&#x2F;items数组</span><br><span class="line">            items: [</span><br><span class="line">                &#123;message: &#39;狂神说Java&#39;&#125;,</span><br><span class="line">                &#123;message: &#39;狂神说前端&#39;&#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p>测试 ：在控制台输入 <code>vm.items.push({message: &#39;狂神说运维&#39;})</code> ，尝试追加一条数据，你会发现浏览器中显示的内容会增加一条 <code>狂神说运维</code>.</p><h2 id="v-on"><a href="#v-on" class="headerlink" title="v-on"></a>v-on</h2><p><code>v-on</code> 监听事件</p><p>事件有Vue的事件、和前端页面本身的一些事件！我们这里的<code>click</code>是vue的事件，可以绑定到Vue中的<code>methods</code>中的方法事件！</p><p><strong>上代码：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html xmlns:v-on&#x3D;&quot;&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;狂神说Java&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;vue@2.5.21&#x2F;dist&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;div id&#x3D;&quot;vue&quot;&gt;</span><br><span class="line">    &lt;!--在这里我们使用了 v-on 绑定了 click 事件，并指定了名为 sayHi 的方法--&gt;</span><br><span class="line">    &lt;button v-on:click&#x3D;&quot;sayHi&quot;&gt;点我&lt;&#x2F;button&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">    var vm &#x3D; new Vue(&#123;</span><br><span class="line">        el: &#39;#vue&#39;,</span><br><span class="line">        data: &#123;</span><br><span class="line">            message: &#39;Hello World&#39;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#x2F;&#x2F; 方法必须定义在 Vue 实例的 methods 对象中</span><br><span class="line">        methods: &#123;</span><br><span class="line">            sayHi: function (event) &#123;</span><br><span class="line">                &#x2F;&#x2F; &#96;this&#96; 在方法里指向当前 Vue 实例</span><br><span class="line">                alert(this.message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p>点击测试</p><p>Vue还有一些基本的使用方式，大家有需要的可以再跟着官方文档看看，因为这些基本的指令几乎我们都见过了，一通百通！掌握学习的方式！</p><p><a href="https://blog.kuangstudy.com/index.php/tag/Vue/" target="_blank" rel="noopener">VUE</a></p>]]></content>
    
    <summary type="html">
    
      前端体系、前后端分离
    
    </summary>
    
    
      <category term="Vue" scheme="https://SomunsTao.github.io/categories/Vue/"/>
    
    
      <category term="Vue" scheme="https://SomunsTao.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue 02：MVVM模式和第一个Vue程序</title>
    <link href="https://somunstao.github.io/2020/04/12/Vue%2002%EF%BC%9AMVVM%E6%A8%A1%E5%BC%8F%E5%92%8C%E7%AC%AC%E4%B8%80%E4%B8%AAVue%E7%A8%8B%E5%BA%8F/"/>
    <id>https://somunstao.github.io/2020/04/12/Vue%2002%EF%BC%9AMVVM%E6%A8%A1%E5%BC%8F%E5%92%8C%E7%AC%AC%E4%B8%80%E4%B8%AAVue%E7%A8%8B%E5%BA%8F/</id>
    <published>2020-04-11T16:00:00.000Z</published>
    <updated>2020-08-01T15:16:10.772Z</updated>
    
    <content type="html"><![CDATA[<p>​    </p><h1 id="Vue：MVVM模式和第一个Vue程序"><a href="#Vue：MVVM模式和第一个Vue程序" class="headerlink" title="Vue：MVVM模式和第一个Vue程序"></a>Vue：MVVM模式和第一个Vue程序</h1><h2 id="什么是-MVVM"><a href="#什么是-MVVM" class="headerlink" title="什么是 MVVM"></a>什么是 MVVM</h2><p>MVVM（Model-View-ViewModel）是一种软件架构设计模式，由微软 WPF（用于替代 WinForm，以前就是用这个技术开发桌面应用程序的）和 Silverlight（类似于 Java Applet，简单点说就是在浏览器上运行的 WPF） 的架构师 Ken Cooper 和 Ted Peters 开发，是一种简化用户界面的<strong>事件驱动编程方式</strong>。由 John Gossman（同样也是 WPF 和 Silverlight 的架构师）于 2005 年在他的博客上发表。</p><p>MVVM 源自于经典的 MVC（Model-View-Controller）模式。MVVM 的核心是 ViewModel 层，负责转换 Model 中的数据对象来让数据变得更容易管理和使用，其作用如下：</p><ul><li>该层向上与视图层进行双向数据绑定</li><li>向下与 Model 层通过接口请求进行数据交互<br><img src="https://blog.kuangstudy.com/usr/uploads/2019/10/1897504213.png" alt="20191017111649.png"></li></ul><p>MVVM 已经相当成熟了，主要运用但不仅仅在网络应用程序开发中。当下流行的 MVVM 框架有 <code>Vue.js</code>，<code>AngularJS</code> 等。</p><h2 id="为什么要使用-MVVM"><a href="#为什么要使用-MVVM" class="headerlink" title="为什么要使用 MVVM"></a>为什么要使用 MVVM</h2><p>MVVM 模式和 MVC 模式一样，主要目的是分离视图（View）和模型（Model），有几大好处</p><ul><li><strong>低耦合</strong>： 视图（View）可以独立于 Model 变化和修改，一个 ViewModel 可以绑定到不同的 View 上，当 View 变化的时候 Model 可以不变，当 Model 变化的时候 View 也可以不变。</li><li><strong>可复用</strong>： 你可以把一些视图逻辑放在一个 ViewModel 里面，让很多 View 重用这段视图逻辑。</li><li><strong>独立开发</strong>： 开发人员可以专注于业务逻辑和数据的开发（ViewModel），设计人员可以专注于页面设计。</li><li><strong>可测试</strong>： 界面素来是比较难于测试的，而现在测试可以针对 ViewModel 来写。</li></ul><h2 id="MVVM-的组成部分"><a href="#MVVM-的组成部分" class="headerlink" title="MVVM 的组成部分"></a>MVVM 的组成部分</h2><p><img src="https://blog.kuangstudy.com/usr/uploads/2019/10/1552878682.png" alt="20191017111955.png"></p><h3 id="View"><a href="#View" class="headerlink" title="View"></a>View</h3><p>View 是视图层，也就是用户界面。前端主要由 <code>HTML</code> 和 <code>CSS</code> 来构建，为了更方便地展现 <code>ViewModel</code> 或者 <code>Model</code> 层的数据，已经产生了各种各样的前后端模板语言，比如 FreeMarker、Thymeleaf 等等，各大 MVVM 框架如 Vue.js，AngularJS，EJS 等也都有自己用来构建用户界面的内置模板语言。</p><h3 id="Model"><a href="#Model" class="headerlink" title="Model"></a>Model</h3><p>Model 是指数据模型，泛指后端进行的各种业务逻辑处理和数据操控，主要围绕数据库系统展开。这里的难点主要在于需要和前端约定统一的 <code>接口规则</code></p><h3 id="ViewModel"><a href="#ViewModel" class="headerlink" title="ViewModel"></a>ViewModel</h3><p>ViewModel 是由前端开发人员组织生成和维护的视图数据层。在这一层，前端开发者对从后端获取的 Model 数据进行转换处理，做二次封装，以生成符合 View 层使用预期的视图数据模型。</p><p>需要注意的是 ViewModel 所封装出来的数据模型包括视图的状态和行为两部分，而 Model 层的数据模型是只包含状态的</p><ul><li>比如页面的这一块展示什么，那一块展示什么这些都属于视图状态（展示）</li><li>页面加载进来时发生什么，点击这一块发生什么，这一块滚动时发生什么这些都属于视图行为（交互）</li></ul><p>视图状态和行为都封装在了 ViewModel 里。这样的封装使得 ViewModel 可以完整地去描述 View 层`。由于实现了双向绑定，ViewModel 的内容会实时展现在 View 层，这是激动人心的，因为前端开发者再也不必低效又麻烦地通过操纵 DOM 去更新视图。</p><p>MVVM 框架已经把最脏最累的一块做好了，我们开发者只需要处理和维护 ViewModel，更新数据视图就会自动得到相应更新，真正实现 <code>事件驱动编程</code>。</p><p>View 层展现的不是 <code>Model</code> 层的数据，而是 <code>ViewModel</code> 的数据，由 <code>ViewModel</code> 负责与 <code>Model</code> 层交互，这就<strong>完全解耦了 View 层和 Model 层，这个解耦是至关重要的，它是前后端分离方案实施的重要一环。</strong></p><h2 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h2><p>Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式框架，发布于 2014 年 2 月。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库（如：vue-router，vue-resource，vuex）或既有项目整合。</p><h3 id="MVVM-模式的实现者"><a href="#MVVM-模式的实现者" class="headerlink" title="MVVM 模式的实现者"></a>MVVM 模式的实现者</h3><ul><li>Model：模型层，在这里表示 JavaScript 对象</li><li>View：视图层，在这里表示 DOM（HTML 操作的元素）</li><li>ViewModel：连接视图和数据的中间件，Vue.js 就是 MVVM 中的 ViewModel 层的实现者</li></ul><p>在 MVVM 架构中，是不允许 数据 和 视图 直接通信的，只能通过 ViewModel 来通信，而 ViewModel 就是定义了一个 Observer 观察者</p><ul><li>ViewModel 能够观察到数据的变化，并对视图对应的内容进行更新</li><li>ViewModel 能够监听到视图的变化，并能够通知数据发生改变</li></ul><p>至此，我们就明白了，Vue.js 就是一个 MVVM 的实现者，他的核心就是实现了 DOM 监听 与 数据绑定</p><h3 id="为什么要使用-Vue-js"><a href="#为什么要使用-Vue-js" class="headerlink" title="为什么要使用 Vue.js"></a>为什么要使用 Vue.js</h3><ul><li>轻量级，体积小是一个重要指标。Vue.js 压缩后有只有 20多kb （Angular 压缩后 56kb+，React 压缩后 44kb+）</li><li>移动优先。更适合移动端，比如移动端的 Touch 事件</li><li>易上手，学习曲线平稳，文档齐全</li><li>吸取了 Angular（模块化）和 React（虚拟 DOM）的长处，并拥有自己独特的功能，如：计算属性</li><li>开源，社区活跃度高</li><li>……</li></ul><h2 id="第一个Vue程序"><a href="#第一个Vue程序" class="headerlink" title="第一个Vue程序"></a>第一个Vue程序</h2><p>【说明】IDEA 可以安装 Vue 的插件！</p><p>注意：Vue 不支持 IE8 及以下版本，因为 Vue 使用了 IE8 无法模拟的 ECMAScript 5 特性。但它支持所有兼容 ECMAScript 5 的浏览器。</p><h3 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h3><ul><li>开发版本<ul><li>包含完整的警告和调试模式：<a href="https://vuejs.org/js/vue.js" target="_blank" rel="noopener">https://vuejs.org/js/vue.js</a></li><li>删除了警告，30.96KB min + gzip：<a href="https://vuejs.org/js/vue.min.js" target="_blank" rel="noopener">https://vuejs.org/js/vue.min.js</a></li></ul></li><li>CDN<ul><li><code>&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.js&quot;&gt;&lt;/script&gt;</code></li><li><code>&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.min.js&quot;&gt;&lt;/script&gt;</code></li></ul></li></ul><h3 id="代码编写"><a href="#代码编写" class="headerlink" title="代码编写"></a>代码编写</h3><p>Vue.js 的核心是实现了 MVVM 模式，她扮演的角色就是 ViewModel 层，那么所谓的第一个应用程序就是展示她的 数据绑定 功能，操作流程如下：</p><p><strong>1、创建一个 HTML 文件</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;狂神说&lt;&#x2F;title&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p><strong>2、引入 Vue.js</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;vue@2.5.21&#x2F;dist&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p><strong>3、创建一个 Vue 的实例</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">    var vm &#x3D; new Vue(&#123;</span><br><span class="line">        el: &#39;#vue&#39;,</span><br><span class="line">        data: &#123;</span><br><span class="line">            message: &#39;Hello Vue!&#39;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>说明:</p><ul><li><code>el:&#39;#vue&#39;</code>：绑定元素的 ID</li><li><code>data:{message:&#39;Hello Vue!&#39;}</code>：数据对象中有一个名为 message 的属性，并设置了初始值 Hello Vue!</li></ul><p><strong>4、将数据绑定到页面元素</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;vue&quot;&gt;</span><br><span class="line">    &#123;&#123;message&#125;&#125;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><p>说明：只需要在绑定的元素中使用 双花括号 将 Vue 创建的名为 message 属性包裹起来，即可实现数据绑定功能，也就实现了 ViewModel 层所需的效果，是不是和 EL 表达式非常像？</p><h3 id="完整的-HTML"><a href="#完整的-HTML" class="headerlink" title="完整的 HTML"></a>完整的 HTML</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;第一个 Vue 应用程序&lt;&#x2F;title&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--View--&gt;</span><br><span class="line">&lt;div id&#x3D;&quot;vue&quot;&gt;</span><br><span class="line">     &#123;&#123;message&#125;&#125;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;vue@2.5.21&#x2F;dist&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">    &#x2F;&#x2F; var vm &#x3D; new Vue(&#123;&#125;); &#x2F;&#x2F;ViewModel</span><br><span class="line">    var vm &#x3D; new Vue(&#123;</span><br><span class="line">        el: &#39;#vue&#39;,</span><br><span class="line">        data: &#123; &#x2F;&#x2F;Model</span><br><span class="line">            message: &#39;Hello Vue!&#39;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>为了能够更直观的体验 Vue 带来的数据绑定功能，我们需要在浏览器测试一番，操作流程如下：</p><p>1、在浏览器上运行第一个 Vue 应用程序，进入 开发者工具</p><p>2、在控制台输入 vm.message = ‘Hello World’ ，然后 回车，你会发现浏览器中显示的内容会直接变成 Hello World</p><p>此时就可以在控制台直接输入 vm.message 来修改值，中间是可以省略 data 的，在这个操作中，我并没有主动操作 DOM，就让页面的内容发生了变化，这就是借助了 Vue 的 数据绑定 功能实现的；MVVM 模式中要求 ViewModel 层就是使用 观察者模式 来实现数据的监听与绑定，以做到数据与视图的快速响应。</p>]]></content>
    
    <summary type="html">
    
      前端体系、前后端分离MVVM
    
    </summary>
    
    
      <category term="Vue" scheme="https://SomunsTao.github.io/categories/Vue/"/>
    
    
      <category term="Vue" scheme="https://SomunsTao.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue 01：前端体系、前后端分离</title>
    <link href="https://somunstao.github.io/2020/04/11/Vue%2001%EF%BC%9A%E5%89%8D%E7%AB%AF%E4%BD%93%E7%B3%BB%E3%80%81%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB/"/>
    <id>https://somunstao.github.io/2020/04/11/Vue%2001%EF%BC%9A%E5%89%8D%E7%AB%AF%E4%BD%93%E7%B3%BB%E3%80%81%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB/</id>
    <published>2020-04-10T16:00:00.000Z</published>
    <updated>2020-08-01T15:15:51.467Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Vue：前端体系、前后端分离"><a href="#Vue：前端体系、前后端分离" class="headerlink" title="Vue：前端体系、前后端分离"></a>Vue：前端体系、前后端分离</h1><h2 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h2><p>Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的<strong>渐进式框架</strong>，发布于 2014 年 2 月。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。<strong>Vue 的核心库只关注视图层</strong>，不仅易于上手，还便于与第三方库（如：<code>vue-router：跳转</code>，<code>vue-resource：通信</code>，<code>vuex：管理</code>）或既有项目整合。</p><p>官网：<a href="https://cn.vuejs.org/v2/guide/" target="_blank" rel="noopener">https://cn.vuejs.org/v2/guide/</a></p><h2 id="2、前端知识体系"><a href="#2、前端知识体系" class="headerlink" title="2、前端知识体系"></a>2、前端知识体系</h2><p>想要成为真正的“互联网 Java 全栈工程师”还有很长的一段路要走，其中“我大前端”是绕不开的一门必修课。本阶段课程的主要目的就是带领我 Java 后台程序员认识前端、了解前端、掌握前端，为实现成为“互联网 Java 全栈工程师”再向前迈进一步。</p><h3 id="2-1、前端三要素"><a href="#2-1、前端三要素" class="headerlink" title="2.1、前端三要素"></a>2.1、前端三要素</h3><ul><li>HTML（结构）：超文本标记语言（Hyper Text Markup Language），决定网页的结构和内容</li><li>CSS（表现）：层叠样式表（Cascading Style Sheets），设定网页的表现样式</li><li>JavaScript（行为）：是一种弱类型脚本语言，其源代码不需经过编译，而是由浏览器解释运行，用于控制网页的行为</li></ul><h3 id="2-2、结构层（HTML）"><a href="#2-2、结构层（HTML）" class="headerlink" title="2.2、结构层（HTML）"></a>2.2、结构层（HTML）</h3><p>太简单，略</p><h3 id="2-3、表现层（CSS）"><a href="#2-3、表现层（CSS）" class="headerlink" title="2.3、表现层（CSS）"></a>2.3、表现层（CSS）</h3><p>CSS 层叠样式表是一门标记语言，并不是编程语言，因此不可以自定义变量，不可以引用等，换句话说就是不具备任何语法支持，它主要缺陷如下：</p><ul><li>语法不够强大，比如无法嵌套书写，导致模块化开发中需要书写很多重复的选择器；</li><li>没有变量和合理的样式复用机制，使得逻辑上相关的属性值必须以字面量的形式重复输出，导致难以维护；</li></ul><p>这就导致了我们在工作中无端增加了许多工作量。为了解决这个问题，前端开发人员会使用一种称之为 <strong>【CSS 预处理器】</strong> 的工具，提供 CSS 缺失的样式层复用机制、减少冗余代码，提高样式代码的可维护性。大大提高了前端在样式上的开发效率。</p><h3 id="什么是-CSS-预处理器"><a href="#什么是-CSS-预处理器" class="headerlink" title="什么是 CSS 预处理器"></a>什么是 CSS 预处理器</h3><p>CSS 预处理器定义了一种新的语言，其基本思想是，用一种专门的编程语言，为 CSS 增加了一些编程的特性，将 CSS 作为目标生成文件，然后开发者就只要使用这种语言进行 CSS 的编码工作。转化成通俗易懂的话来说就是“<strong>用一种专门的编程语言，进行 Web 页面样式设计，再通过编译器转化为正常的 CSS 文件，以供项目使用</strong>”。</p><p><strong>常用的 CSS 预处理器有哪些</strong></p><ul><li>SASS：基于 Ruby，通过服务端处理，功能强大。解析效率高。需要学习 Ruby 语言，上手难度高于 LESS。</li><li>LESS：基于 NodeJS，通过客户端处理，使用简单。功能比 SASS 简单，解析效率也低于 SASS，但在实际开发中足够了，所以我们后台人员如果需要的话，建议使用 LESS。</li></ul><h3 id="2-4、行为层（JavaScript）"><a href="#2-4、行为层（JavaScript）" class="headerlink" title="2.4、行为层（JavaScript）"></a>2.4、行为层（JavaScript）</h3><p>JavaScript 一门弱类型脚本语言，其源代码在发往客户端运行之前不需经过编译，而是将文本格式的字符代码发送给浏览器由浏览器解释运行。</p><p><strong>Native 原生 JS 开发</strong></p><p>原生 JS 开发，也就是让我们按照 <strong>【ECMAScript】</strong> 标准的开发方式，简称是 ES，特点是所有浏览器都支持。截止到当前博客发布时间，ES 标准已发布如下版本：</p><ul><li>ES3</li><li>ES4（内部，未正式发布）</li><li>ES5（全浏览器支持）</li><li>ES6（常用，当前主流版本：webpack打包成为ES5支持！）</li><li>ES7</li><li>ES8</li><li>ES9（草案阶段）</li></ul><p>区别就是逐步增加新特性。</p><p><strong>TypeScript 微软的标准</strong></p><p>TypeScript 是一种由微软开发的自由和开源的编程语言。它是 JavaScript 的一个超集，而且本质上向这个语言添加了可选的静态类型和基于类的面向对象编程。由安德斯·海尔斯伯格（C#、Delphi、TypeScript 之父；.NET 创立者）主导。</p><p>该语言的特点就是除了具备 ES 的特性之外还纳入了许多不在标准范围内的新特性，所以会导致很多浏览器不能直接支持 TypeScript 语法，需要编译后（编译成 JS）才能被浏览器正确执行。</p><h3 id="JavaScript-框架"><a href="#JavaScript-框架" class="headerlink" title="JavaScript 框架"></a>JavaScript 框架</h3><ul><li>jQuery：大家熟知的 JavaScript 框架，优点是简化了 DOM 操作，缺点是 DOM 操作太频繁，影响前端性能；在前端眼里使用它仅仅是为了兼容 IE6、7、8；</li><li>Angular：Google 收购的前端框架，由一群 Java 程序员开发，其特点是将后台的 MVC 模式搬到了前端并增加了<strong>模块化开发</strong>的理念，与微软合作，采用 TypeScript 语法开发；对后台程序员友好，对前端程序员不太友好；最大的缺点是版本迭代不合理（如：1代 -&gt; 2代，除了名字，基本就是两个东西；截止发表博客时已推出了 Angular6）</li><li>React：Facebook 出品，一款高性能的 JS 前端框架；特点是提出了新概念 <strong>【虚拟 DOM】</strong> 用于减少真实 DOM 操作，在内存中模拟 DOM 操作，有效的提升了前端渲染效率；缺点是使用复杂，因为需要额外学习一门 <strong>【JSX】</strong> 语言；</li><li><code>Vue</code>：一款渐进式 JavaScript 框架，所谓渐进式就是逐步实现新特性的意思，如实现模块化开发、路由、状态管理等新特性。其特点是综合了 Angular（模块化） 和 React（虚拟 DOM） 的优点；</li><li><code>Axios</code>：前端通信框架；因为 <code>Vue</code> 的边界很明确，就是为了处理 DOM，所以并不具备通信能力，此时就需要额外使用一个通信框架与服务器交互；当然也可以直接选择使用 jQuery 提供的 AJAX 通信功能；</li></ul><h3 id="UI-框架"><a href="#UI-框架" class="headerlink" title="UI 框架"></a>UI 框架</h3><ul><li>Ant-Design：阿里巴巴出品，基于 React 的 UI 框架</li><li>ElementUI、iview、ice：饿了么出品，基于 Vue 的 UI 框架</li><li>Bootstrap：Twitter 推出的一个用于前端开发的开源工具包</li><li>AmazeUI：又叫“妹子 UI”，一款 HTML5 跨屏前端框架</li></ul><h3 id="JavaScript-构建工具"><a href="#JavaScript-构建工具" class="headerlink" title="JavaScript 构建工具"></a>JavaScript 构建工具</h3><ul><li>Babel：JS 编译工具，主要用于浏览器不支持的 ES 新特性，比如用于编译 TypeScript</li><li>WebPack：模块打包器，主要作用是打包、压缩、合并及按序加载</li></ul><p><strong>注：以上知识点已将 WebApp 开发所需技能全部梳理完毕</strong></p><h2 id="2-5、三端统一"><a href="#2-5、三端统一" class="headerlink" title="2.5、三端统一"></a>2.5、三端统一</h2><h3 id="混合开发（Hybrid-App）"><a href="#混合开发（Hybrid-App）" class="headerlink" title="混合开发（Hybrid App）"></a>混合开发（Hybrid App）</h3><p>主要目的是实现一套代码三端统一（PC、Android：.apk 、iOS: .ipa ）并能够调用到设备底层硬件（如：传感器、GPS、摄像头等），打包方式主要有以下两种：</p><ul><li>云打包：HBuild -&gt; HBuildX，DCloud 出品；API Cloud</li><li>本地打包： Cordova（前身是 PhoneGap）</li></ul><h3 id="微信小程序"><a href="#微信小程序" class="headerlink" title="微信小程序"></a>微信小程序</h3><p>详见微信官网，这里就是介绍一个方便微信小程序 UI 开发的框架：WeUI</p><h2 id="2-6、后端技术"><a href="#2-6、后端技术" class="headerlink" title="2.6、后端技术"></a>2.6、后端技术</h2><p>前端人员为了方便开发也需要掌握一定的后端技术，但我们 Java 后台人员知道后台知识体系极其庞大复杂，所以为了方便前端人员开发后台应用，就出现了 NodeJS 这样的技术。</p><p>NodeJS 的作者已经声称放弃 NodeJS（说是架构做的不好再加上笨重的 node_modules，可能让作者不爽了吧），开始开发全新架构的 Deno</p><p>既然是后台技术，那肯定也需要框架和项目管理工具，NodeJS 框架及项目管理工具如下：</p><ul><li>Express：NodeJS 框架</li><li>Koa：Express 简化版</li><li>NPM：项目综合管理工具，类似于 Maven</li><li>YARN：NPM 的替代方案，类似于 Maven 和 Gradle 的关系</li></ul><h3 id="2-7、主流前端框架"><a href="#2-7、主流前端框架" class="headerlink" title="2.7、主流前端框架"></a>2.7、主流前端框架</h3><p><strong>Vue.js</strong></p><h3 id="iView"><a href="#iView" class="headerlink" title="iView"></a>iView</h3><p>iview 是一个强大的基于 Vue 的 UI 库，有很多实用的基础组件比 elementui 的组件更丰富，主要服务于 PC 界面的中后台产品。使用单文件的 Vue 组件化开发模式 基于 npm + webpack + babel 开发，支持 ES2015 高质量、功能丰富 友好的 API ，自由灵活地使用空间。</p><ul><li><a href="https://www.iviewui.com/" target="_blank" rel="noopener">官网地址</a></li><li><a href="https://github.com/TalkingData/iview-weapp" target="_blank" rel="noopener">Github</a></li><li><a href="https://github.com/iview/iview-admin" target="_blank" rel="noopener">iview-admin</a></li></ul><p><strong>备注：属于前端主流框架，选型时可考虑使用，主要特点是移动端支持较多</strong></p><h3 id="ElementUI"><a href="#ElementUI" class="headerlink" title="ElementUI"></a>ElementUI</h3><p>Element 是饿了么前端开源维护的 Vue UI 组件库，组件齐全，基本涵盖后台所需的所有组件，文档讲解详细，例子也很丰富。主要用于开发 PC 端的页面，是一个质量比较高的 Vue UI 组件库。</p><ul><li><a href="http://element-cn.eleme.io/#/zh-CN" target="_blank" rel="noopener">官网地址</a></li><li><a href="https://github.com/ElementUI/element-starter" target="_blank" rel="noopener">Github</a></li><li><a href="https://github.com/PanJiaChen/vue-element-admin" target="_blank" rel="noopener">vue-element-admin</a></li></ul><p><strong>备注：属于前端主流框架，选型时可考虑使用，主要特点是桌面端支持较多</strong></p><h3 id="ICE"><a href="#ICE" class="headerlink" title="ICE"></a>ICE</h3><p>飞冰是阿里巴巴团队基于 React/Angular/Vue 的中后台应用解决方案，在阿里巴巴内部，已经有 270 多个来自几乎所有 BU 的项目在使用。飞冰包含了一条从设计端到开发端的完整链路，帮助用户快速搭建属于自己的中后台应用。</p><ul><li><a href="https://alibaba.github.io/ice" target="_blank" rel="noopener">官网地址</a></li><li><a href="https://github.com/alibaba/ice" target="_blank" rel="noopener">Github</a></li></ul><p><strong>备注：主要组件还是以 React 为主，截止 2019 年 02 月 17 日更新博客前对 Vue 的支持还不太完善，目前尚处于观望阶段</strong></p><h3 id="VantUI"><a href="#VantUI" class="headerlink" title="VantUI"></a>VantUI</h3><p>Vant UI 是有赞前端团队基于有赞统一的规范实现的 Vue 组件库，提供了一整套 UI 基础组件和业务组件。通过 Vant，可以快速搭建出风格统一的页面，提升开发效率。</p><ul><li><a href="https://youzan.github.io/vant/#/zh-CN/intro" target="_blank" rel="noopener">官网地址</a></li><li><a href="https://github.com/youzan/vant" target="_blank" rel="noopener">Github</a></li></ul><h3 id="AtUI"><a href="#AtUI" class="headerlink" title="AtUI"></a>AtUI</h3><p>at-ui 是一款基于 Vue 2.x 的前端 UI 组件库，主要用于快速开发 PC 网站产品。 它提供了一套 npm + webpack + babel 前端开发工作流程，CSS 样式独立，即使采用不同的框架实现都能保持统一的 UI 风格。</p><ul><li><a href="https://at-ui.github.io/at-ui/#/zh" target="_blank" rel="noopener">官网地址</a></li><li><a href="https://github.com/at-ui/at-ui" target="_blank" rel="noopener">Github</a></li></ul><h3 id="CubeUI"><a href="#CubeUI" class="headerlink" title="CubeUI"></a>CubeUI</h3><p>cube-ui 是滴滴团队开发的基于 Vue.js 实现的精致移动端组件库。支持按需引入和后编译，轻量灵活；扩展性强，可以方便地基于现有组件实现二次开发。</p><ul><li><a href="https://didi.github.io/cube-ui/#/zh-CN" target="_blank" rel="noopener">官网地址</a></li><li><a href="https://github.com/didi/cube-ui/" target="_blank" rel="noopener">Github</a></li></ul><h3 id="混合开发"><a href="#混合开发" class="headerlink" title="混合开发"></a>混合开发</h3><h3 id="Flutter"><a href="#Flutter" class="headerlink" title="Flutter"></a>Flutter</h3><p>Flutter 是谷歌的移动端 UI 框架，可在极短的时间内构建 Android 和 iOS 上高质量的原生级应用。Flutter 可与现有代码一起工作, 它被世界各地的开发者和组织使用, 并且 Flutter 是免费和开源的。</p><ul><li><a href="http://doc.flutter-dev.cn/" target="_blank" rel="noopener">官网地址</a></li><li><a href="https://github.com/flutter/flutter" target="_blank" rel="noopener">Github</a></li></ul><p><strong>备注：Google 出品，主要特点是快速构建原生 APP 应用程序，如做混合应用该框架为必选框架</strong></p><h3 id="Ionic"><a href="#Ionic" class="headerlink" title="Ionic"></a>Ionic</h3><p>Ionic 既是一个 CSS 框架也是一个 Javascript UI 库，Ionic 是目前最有潜力的一款 HTML5 手机应用开发框架。通过 SASS 构建应用程序，它提供了很多 UI 组件来帮助开发者开发强大的应用。它使用 JavaScript MVVM 框架和 AngularJS/Vue 来增强应用。提供数据的双向绑定，使用它成为 Web 和移动开发者的共同选择。</p><ul><li><a href="https://ionicframework.com/" target="_blank" rel="noopener">官网地址</a></li><li><a href="https://ionicframework.com/docs/" target="_blank" rel="noopener">官网文档</a></li><li><a href="https://github.com/ionic-team/ionic" target="_blank" rel="noopener">Github</a></li></ul><h3 id="微信小程序-1"><a href="#微信小程序-1" class="headerlink" title="微信小程序"></a>微信小程序</h3><h3 id="mpvue"><a href="#mpvue" class="headerlink" title="mpvue"></a>mpvue</h3><p>mpvue 是美团开发的一个使用 <code>Vue.js</code> 开发小程序的前端框架，目前支持 <strong>微信小程序</strong>、<strong>百度智能小程序</strong>，<strong>头条小程序</strong> 和 <strong>支付宝小程序</strong>。 框架基于 <code>Vue.js</code>，修改了的运行时框架 <code>runtime</code> 和代码编译器 <code>compiler</code> 实现，使其可运行在小程序环境中，从而为小程序开发引入了 <code>Vue.js</code> 开发体验。</p><ul><li><a href="http://mpvue.com/" target="_blank" rel="noopener">官网地址</a></li><li><a href="https://github.com/Meituan-Dianping/mpvue" target="_blank" rel="noopener">Github</a></li></ul><p><strong>备注：完备的 Vue 开发体验，并且支持多平台的小程序开发，推荐使用</strong></p><h3 id="WeUI"><a href="#WeUI" class="headerlink" title="WeUI"></a>WeUI</h3><p>WeUI 是一套同微信原生视觉体验一致的基础样式库，由微信官方设计团队为微信内网页和微信小程序量身设计，令用户的使用感知更加统一。包含 button、cell、dialog、toast、article、icon 等各式元素。</p><ul><li><a href="https://weui.io/" target="_blank" rel="noopener">官网地址</a></li><li><a href="https://github.com/weui/weui.git" target="_blank" rel="noopener">Github</a></li></ul><h2 id="3、了解前后分离的演变史"><a href="#3、了解前后分离的演变史" class="headerlink" title="3、了解前后分离的演变史"></a>3、了解前后分离的演变史</h2><p><strong>为什么需要前后分离</strong></p><h3 id="3-1、后端为主的-MVC-时代"><a href="#3-1、后端为主的-MVC-时代" class="headerlink" title="3.1、后端为主的 MVC 时代"></a>3.1、后端为主的 MVC 时代</h3><p>为了降低开发的复杂度，以后端为出发点，比如：Struts、SpringMVC 等框架的使用，就是后端的 MVC 时代;</p><p>以 <code>SpringMVC</code> 流程为例：</p><p><img src="https://blog.kuangstudy.com/usr/uploads/2019/10/1982474755.png" alt="Lusifer2018120811230001.png"></p><ul><li>发起请求到前端控制器(<code>DispatcherServlet</code>)</li><li>前端控制器请求 <code>HandlerMapping</code> 查找 <code>Handler</code>，可以根据 <code>xml</code> 配置、注解进行查找</li><li>处理器映射器 <code>HandlerMapping</code> 向前端控制器返回 <code>Handler</code></li><li>前端控制器调用处理器适配器去执行 <code>Handler</code></li><li>处理器适配器去执行 <code>Handler</code></li><li><code>Handler</code> 执行完成给适配器返回 <code>ModelAndView</code></li><li>处理器适配器向前端控制器返回 <code>ModelAndView</code>，<code>ModelAndView</code> 是 <code>SpringMVC</code> 框架的一个底层对象，包括 <code>Model</code> 和 <code>View</code></li><li>前端控制器请求视图解析器去进行视图解析，根据逻辑视图名解析成真正的视图(<code>JSP</code>)</li><li>视图解析器向前端控制器返回 <code>View</code></li><li>前端控制器进行视图渲染，视图渲染将模型数据(在 <code>ModelAndView</code> 对象中)填充到 <code>request</code> 域</li><li>前端控制器向用户响应结果</li></ul><p><strong>优点</strong></p><p>MVC 是一个非常好的协作模式，能够有效降低代码的耦合度，从架构上能够让开发者明白代码应该写在哪里。为了让 View 更纯粹，还可以使用 Thymeleaf、Freemarker 等模板引擎，使模板里无法写入 Java 代码，让前后端分工更加清晰。</p><p><strong>缺点</strong></p><ul><li>前端开发重度依赖开发环境，开发效率低，这种架构下，前后端协作有两种模式：<ul><li>第一种是前端写 DEMO，写好后，让后端去套模板。好处是 DEMO 可以本地开发，很高效。不足是还需要后端套模板，有可能套错，套完后还需要前端确定，来回沟通调整的成本比较大；</li><li>另一种协作模式是前端负责浏览器端的所有开发和服务器端的 View 层模板开发。好处是 UI 相关的代码都是前端去写就好，后端不用太关注，不足就是前端开发重度绑定后端环境，环境成为影响前端开发效率的重要因素。</li></ul></li><li>前后端职责纠缠不清：模板引擎功能强大，依旧可以通过拿到的上下文变量来实现各种业务逻辑。这样，只要前端弱势一点，往往就会被后端要求在模板层写出不少业务代码。还有一个很大的灰色地带是 <code>Controller</code>，页面路由等功能本应该是前端最关注的，但却是由后端来实现。 <code>Controller</code> 本身与 <code>Model</code> 往往也会纠缠不清，看了让人咬牙的业务代码经常会出现在 <code>Controller</code> 层。这些问题不能全归结于程序员的素养，否则 JSP 就够了。</li><li>对前端发挥的局限性：性能优化如果只在前端做空间非常有限，于是我们经常需要后端合作，但由于后端框架限制，我们很难使用 <a href="https://www.ibm.com/developerworks/cn/web/wa-lo-comet/index.html" target="_blank" rel="noopener"><strong>【Comet】</strong></a>、<a href="https://segmentfault.com/a/1190000002998812" target="_blank" rel="noopener"><strong>【BigPipe】</strong></a> 等技术方案来优化性能。</li></ul><p><strong>注：在这期间（2005 年以前），包括早期的 JSP、PHP 可以称之为 Web 1.0 时代。在这里想说一句，如果你是一名 Java 初学者，请你不要再把一些陈旧的技术当回事了，比如 JSP，因为时代在变、技术在变、什么都在变（引用扎克伯格的一句话：唯一不变的是变化本身）；当我们去给大学做实训时，有些同学会认为我们没有讲什么 干货 ，其实不然，只能说是你认知里的干货对于市场来说早就过时了而已。</strong></p><h3 id="3-2、基于-AJAX-带来的-SPA-时代"><a href="#3-2、基于-AJAX-带来的-SPA-时代" class="headerlink" title="3.2、基于 AJAX 带来的 SPA 时代"></a>3.2、基于 AJAX 带来的 SPA 时代</h3><p>时间回到 2005 年 <code>AJAX</code>（Asynchronous JavaScript And XML，异步 JavaScript 和 XML，老技术新用法） 被正式提出并开始使用 <code>CDN</code> 作为静态资源存储，于是出现了 JavaScript 王者归来（在这之前 JS 都是用来在网页上贴狗皮膏药广告的）的 SPA（Single Page Application）单页面应用时代。</p><p><img src="https://blog.kuangstudy.com/usr/uploads/2019/10/2422752164.png" alt="Lusifer201812090001.png"></p><p><strong>优点</strong></p><p>这种模式下，<strong>前后端的分工非常清晰，前后端的关键协作点是 AJAX 接口</strong>。看起来是如此美妙，但回过头来看看的话，这与 JSP 时代区别不大。复杂度从服务端的 JSP 里移到了浏览器的 JavaScript，浏览器端变得很复杂。类似 Spring MVC，<strong>这个时代开始出现浏览器端的分层架构</strong>：</p><p><img src="https://blog.kuangstudy.com/usr/uploads/2019/10/287702245.png" alt="Lusifer201812090002.png"></p><p><strong>缺点</strong></p><ul><li><strong>前后端接口的约定：</strong> 如果后端的接口一塌糊涂，如果后端的业务模型不够稳定，那么前端开发会很痛苦；不少团队也有类似尝试，通过接口规则、接口平台等方式来做。<strong>有了和后端一起沉淀的 接口规则，还可以用来模拟数据，使得前后端可以在约定接口后实现高效并行开发</strong>。</li><li><strong>前端开发的复杂度控制：</strong> SPA 应用大多以功能交互型为主，JavaScript 代码过十万行很正常。大量 JS 代码的组织，与 View 层的绑定等，都不是容易的事情。</li></ul><h3 id="3-3、前端为主的-MV-时代"><a href="#3-3、前端为主的-MV-时代" class="headerlink" title="3.3、前端为主的 MV* 时代"></a>3.3、前端为主的 MV* 时代</h3><p>此处的 MV* 模式如下：</p><ul><li>MVC（同步通信为主）：Model、View、Controller</li><li>MVP（异步通信为主）：Model、View、Presenter</li><li>MVVM（异步通信为主）：Model、View、ViewModel</li></ul><p>为了降低前端开发复杂度，涌现了大量的前端框架，比如：<code>AngularJS</code>、<code>React</code>、<code>Vue.js</code>、<code>EmberJS</code>等，这些框架总的原则是先按类型分层，比如 Templates、Controllers、Models，然后再在层内做切分，如下图：</p><p><img src="https://blog.kuangstudy.com/usr/uploads/2019/10/2242308737.png" alt="Lusifer201812090003.png"></p><p><strong>优点</strong></p><ul><li><strong>前后端职责很清晰：</strong> 前端工作在浏览器端，后端工作在服务端。清晰的分工，可以让开发并行，测试数据的模拟不难，前端可以本地开发。后端则可以专注于业务逻辑的处理，输出 RESTful等接口。</li><li><strong>前端开发的复杂度可控：</strong> 前端代码很重，但合理的分层，让前端代码能各司其职。这一块蛮有意思的，简单如模板特性的选择，就有很多很多讲究。并非越强大越好，限制什么，留下哪些自由，代码应该如何组织，所有这一切设计，得花一本书的厚度去说明。</li><li><strong>部署相对独立：</strong> 可以快速改进产品体验</li></ul><p><strong>缺点</strong></p><ul><li>代码不能复用。比如后端依旧需要对数据做各种校验，校验逻辑无法复用浏览器端的代码。如果可以复用，那么后端的数据校验可以相对简单化。</li><li>全异步，对 SEO 不利。往往还需要服务端做同步渲染的降级方案。</li><li>性能并非最佳，特别是移动互联网环境下。</li><li>SPA 不能满足所有需求，依旧存在大量多页面应用。URL Design 需要后端配合，前端无法完全掌控。</li></ul><h3 id="3-4、NodeJS-带来的全栈时代"><a href="#3-4、NodeJS-带来的全栈时代" class="headerlink" title="3.4、NodeJS 带来的全栈时代"></a>3.4、NodeJS 带来的全栈时代</h3><p>前端为主的 MV* 模式解决了很多很多问题，但如上所述，依旧存在不少不足之处。随着 NodeJS 的兴起，JavaScript 开始有能力运行在服务端。这意味着可以有一种新的研发模式：</p><p><img src="https://blog.kuangstudy.com/usr/uploads/2019/10/3703089123.jpg" alt="63918611gw1efj2vvjwtfj20ge0gzab9.jpg"></p><p>在这种研发模式下，前后端的职责很清晰。对前端来说，两个 UI 层各司其职：</p><ul><li>Front-end UI layer 处理浏览器层的展现逻辑。通过 CSS 渲染样式，通过 JavaScript 添加交互功能，HTML 的生成也可以放在这层，具体看应用场景。</li><li>Back-end UI layer 处理路由、模板、数据获取、Cookie 等。通过路由，前端终于可以自主把控 URL Design，这样无论是单页面应用还是多页面应用，前端都可以自由调控。后端也终于可以摆脱对展现的强关注，转而可以专心于业务逻辑层的开发。</li></ul><p>通过 Node，Web Server 层也是 JavaScript 代码，这意味着部分代码可前后复用，需要 SEO 的场景可以在服务端同步渲染，由于异步请求太多导致的性能问题也可以通过服务端来缓解。前一种模式的不足，通过这种模式几乎都能完美解决掉。</p><p>与 JSP 模式相比，全栈模式看起来是一种回归，也的确是一种向原始开发模式的回归，不过是一种螺旋上升式的回归。</p><p>基于 NodeJS 的全栈模式，依旧面临很多挑战：</p><ul><li>需要前端对服务端编程有更进一步的认识。比如 TCP/IP 等网络知识的掌握。</li><li>NodeJS 层与 Java 层的高效通信。NodeJS 模式下，都在服务器端，RESTful HTTP 通信未必高效，通过 SOAP 等方式通信更高效。一切需要在验证中前行。</li><li>对部署、运维层面的熟练了解，需要更多知识点和实操经验。</li><li>大量历史遗留问题如何过渡。这可能是最大最大的阻力。</li></ul><p><strong>注：看到这里，相信很多同学就可以理解，为什么我总在课堂上说：“前端想学后台很难，而我们后端程序员学任何东西都很简单”；就是因为我们后端程序员具备相对完善的知识体系。</strong></p><p><strong>全栈！So Easy！╮(￣▽￣)╭！</strong></p><h3 id="3-5、总结"><a href="#3-5、总结" class="headerlink" title="3.5、总结"></a>3.5、总结</h3><p>综上所述，模式也好，技术也罢，没有好坏优劣之分，只有适合不适合；前后分离的开发思想主要是基于 <code>SoC</code>（关注度分离原则），上面种种模式，都是让前后端的职责更清晰，分工更合理高效。</p>]]></content>
    
    <summary type="html">
    
      前端体系、前后端分离
    
    </summary>
    
    
      <category term="Vue" scheme="https://SomunsTao.github.io/categories/Vue/"/>
    
    
      <category term="Vue" scheme="https://SomunsTao.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>JVM和JUC复习</title>
    <link href="https://somunstao.github.io/2020/04/01/java%20%E5%A4%8D%E4%B9%A0%20-%20%E5%89%AF%E6%9C%AC/"/>
    <id>https://somunstao.github.io/2020/04/01/java%20%E5%A4%8D%E4%B9%A0%20-%20%E5%89%AF%E6%9C%AC/</id>
    <published>2020-03-31T16:00:00.000Z</published>
    <updated>2020-08-02T03:56:11.641Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JVM和JUC复习"><a href="#JVM和JUC复习" class="headerlink" title="JVM和JUC复习"></a>JVM和JUC复习</h1><!-- TOC --><ul><li><a href="#jdkjvmjuc部分图源javaguide">jdkjvmjuc(部分图源:</a><a href="https://github.com/Snailclimb/JavaGuide" target="_blank" rel="noopener">JavaGuide</a>)<ul><li><a href="#java基础知识">java基础知识</a><ul><li><a href="#java常见基础知识点">Java常见基础知识点</a><ul><li><a href="#面向对象和面向过程的区别">面向对象和面向过程的区别</a></li><li><a href="#oraclejdk与openjdk的区别">OracleJdk与OpenJdk的区别</a></li><li><a href="#java与c的异同">Java与C  的异同</a></li><li><a href="#jvmjdk和jre的区别">JVM,JDK和JRE的区别</a></li><li><a href="#java语言的特点">Java语言的特点</a></li><li><a href="#面向对象的特征">面向对象的特征</a></li><li><a href="#重载和重写的区别">重载和重写的区别</a></li><li><a href="#接口与抽象类的区别">接口与抽象类的区别</a></li><li><a href="#object类的方法有哪些">Object类的方法有哪些?</a></li><li><a href="#静态属性方法和成员属性方法区别">静态属性方法和成员属性方法区别</a></li><li><a href="#子类属性与父类属性初始化顺序">子类属性与父类属性初始化顺序</a></li><li><a href="#自动拆箱和装箱">自动拆箱和装箱</a></li><li><a href="#string为什么不可变">String为什么不可变?</a></li><li><a href="#final关键字的作用">final关键字的作用</a></li><li><a href="#stringbuilder和stringbuffer区别">StringBuilder和StringBuffer区别</a></li><li><a href="#equals知识点">equals知识点</a></li><li><a href="#深拷贝与浅拷贝">深拷贝与浅拷贝</a></li><li><a href="#io流分类">IO流分类</a></li><li><a href="#使用字节流还是字符流">使用字节流还是字符流?</a></li><li><a href="#bigdecimal">BigDecimal</a></li><li><a href="#java异常体系结构">Java异常体系结构</a></li><li><a href="#comparable和comparator">Comparable和Comparator</a></li><li><a href="#什么是泛型什么是类型擦除">什么是泛型，什么是类型擦除?</a></li><li><a href="#泛型通配符">泛型通配符</a></li><li><a href="#上界通配符--extend-e">上界通配符 ? extend E</a></li><li><a href="#下界通配符--super-e">下界通配符 ? super E</a></li><li><a href="#?和t的区别">?和T的区别</a></li><li><a href="#为什么要慎用-arraysaslist">为什么要慎用 Arrays.asList()?</a></li><li><a href="#java中引用的类型">Java中引用的类型</a></li></ul></li></ul></li><li><a href="#对象在内存中的布局64位">对象在内存中的布局(64位)</a>    * <a href="#实例数据">实例数据</a>    * <a href="#对齐填充">对齐填充</a><ul><li><a href="#对象头">对象头</a><ul><li><a href="#markword和metadata">markword和metadata</a></li><li><a href="#实例数据-1">实例数据</a></li><li><a href="#对齐填充-1">对齐填充</a></li></ul></li><li><a href="#jol工具查看对象布局">jol工具查看对象布局</a><ul><li><a href="#查看对象内存布局">查看对象内存布局</a></li><li><a href="#hashcode">hashcode</a></li><li><a href="#对象的hashcode返回的是对象的内存地址吗">对象的hashcode返回的是对象的内存地址吗?</a></li></ul></li></ul></li><li><a href="#线程并发jucaqscas">线程并发(JUC,AQS,CAS)</a><ul><li><a href="#多线程">多线程</a><ul><li><a href="#进程和线程">进程和线程</a></li><li><a href="#并发和并行">并发和并行</a></li><li><a href="#多线程的利弊">多线程的利弊</a></li><li><a href="#什么是上下文切换">什么是上下文切换?</a></li><li><a href="#线程的优先级">线程的优先级</a></li><li><a href="#线程的几种状态">线程的几种状态</a></li><li><a href="#sleep方法和wait方法">sleep方法和wait方法</a></li><li><a href="#stopsuspendresume等方法为什么会被遗弃">stop,suspend,resume等方法为什么会被遗弃</a></li><li><a href="#interruptinterruptedisinterrupted方法区别">interrupt,interrupted,isInterrupted方法区别</a></li><li><a href="#join方法">join方法</a></li><li><a href="#yield方法">yield方法</a></li></ul></li><li><a href="#并发">并发</a><ul><li><a href="#synchronized">synchronized</a></li><li><a href="#synchronized底层原理">synchronized底层原理</a></li><li><a href="#synchronized-使用方法">synchronized 使用方法</a></li><li><a href="#synchronized和reentrantlock的区别">Synchronized和ReentrantLock的区别</a></li><li><a href="#乐观锁">乐观锁</a></li><li><a href="#悲观锁">悲观锁</a></li><li><a href="#独占锁">独占锁</a></li><li><a href="#共享锁">共享锁</a></li><li><a href="#公平锁">公平锁</a></li><li><a href="#非公平锁">非公平锁</a></li><li><a href="#可重入锁递归锁">可重入锁(递归锁)</a></li><li><a href="#偏向锁">偏向锁</a></li><li><a href="#轻量级锁">轻量级锁</a></li><li><a href="#自旋锁">自旋锁</a></li><li><a href="#自适应自旋锁">自适应自旋锁</a></li><li><a href="#锁消除">锁消除</a></li><li><a href="#锁粗化">锁粗化</a></li><li><a href="#死锁">死锁</a></li><li><a href="#如何避免死锁">如何避免死锁?</a></li></ul></li><li><a href="#volatile">volatile</a><ul><li><a href="#volatile保证内存的可见性">volatile保证内存的可见性</a></li><li><a href="#volatile禁止指令重排序">volatile禁止指令重排序</a></li><li><a href="#volatile如何禁止指令重排序的">volatile如何禁止指令重排序的?</a></li><li><a href="#volatile不保证原子性">volatile不保证原子性</a></li></ul></li><li><a href="#cas">CAS</a><ul><li><a href="#cas在java中的底层实现atomic原子类实现">CAS在JAVA中的底层实现(Atomic原子类实现)</a></li><li><a href="#cas的缺点">CAS的缺点</a></li><li><a href="#解决aba问题">解决ABA问题</a></li><li><a href="#threadlocal">ThreadLocal</a></li><li><a href="#threadlocal引发的内存泄露">ThreadLocal引发的内存泄露</a></li><li><a href="#线程池的好处">线程池的好处</a></li><li><a href="#线程池构造参数">线程池构造参数</a></li><li><a href="#阿里巴巴开发者手册不建议开发者使用executors创建线程池">阿里巴巴开发者手册不建议开发者使用Executors创建线程池</a></li></ul></li><li><a href="#aqsabstractqueuedsynchronizer">AQS(AbstractQueuedSynchronizer)</a><ul><li><a href="#aqs概述">AQS概述</a></li><li><a href="#aqs的两种共享资源的访问方式">AQS的两种共享资源的访问方式</a></li><li><a href="#locktrylock和lockinterruptibly区别">lock,tryLock和lockInterruptibly区别</a></li><li><a href="#countdownlatch">CountDownLatch</a></li><li><a href="#semaphore">Semaphore</a></li><li><a href="#cyclibarrier">CycliBarrier</a></li><li><a href="#reentrantreadwritelock如何区分读写锁的">ReentrantReadWriteLock如何区分读写锁的?</a></li></ul></li></ul></li><li><a href="#java集合">Java集合</a>    * <a href="#hashmap的特点">HashMap的特点</a>    * <a href="#hashmap的长度容量为什么要设计成2的幂">HashMap的长度(容量)为什么要设计成2的幂？</a>    * <a href="#hashtable的特点">HashTable的特点</a>    * <a href="#treemap">TreeMap</a>    * <a href="#arraylist的特点">ArrayList的特点</a>    * <a href="#vector的特点">Vector的特点</a>    * <a href="#linkedlist的特点">LinkedList的特点</a>    * <a href="#set">Set</a>    * <a href="#concurrentmodificationexception异常">ConcurrentModificationException异常</a>    * <a href="#线程安全的-list">线程安全的 List</a>    * <a href="#copyonwritearraylist">CopyOnWriteArrayList</a>    * <a href="#线程安全的set">线程安全的Set</a>    * <a href="#线程安全的map">线程安全的Map</a>    * <a href="#concurrenthashmap">ConcurrentHashMap</a>    * <a href="#concurrentskiplistmap">ConcurrentSkipListMap</a></li><li><a href="#java-io">Java IO</a><ul><li><a href="#操作系统的内核">操作系统的内核</a><ul><li><a href="#操作系统的用户态与内核态">操作系统的用户态与内核态</a></li><li><a href="#为什么要有用户态与内核态">为什么要有用户态与内核态?</a></li><li><a href="#用户态切换到内核态的几种方式">用户态切换到内核态的几种方式</a></li><li><a href="#阻塞和非阻塞">阻塞和非阻塞</a></li><li><a href="#同步与异步">同步与异步</a></li></ul></li><li><a href="#linux-io模型">Linux IO模型</a><ul><li><a href="#阻塞io">阻塞IO</a></li><li><a href="#非阻塞io网络io模型">非阻塞IO(网络IO模型)</a></li><li><a href="#io多路复用网络io模型">IO多路复用(网络IO模型)</a></li><li><a href="#信号驱动io网络io模型">信号驱动IO(网络IO模型)</a></li><li><a href="#异步io">异步IO</a></li></ul></li></ul></li><li><a href="#jvm">JVM</a><ul><li><a href="#jvm运行时内存分区">JVM运行时内存分区</a><ul><li><a href="#程序计数器">程序计数器</a></li><li><a href="#程序计数器的特点">程序计数器的特点</a></li><li><a href="#java虚拟机栈">Java虚拟机栈</a></li><li><a href="#栈帧">栈帧</a></li><li><a href="#局部变量表">局部变量表</a></li><li><a href="#操作数栈">操作数栈</a></li><li><a href="#动态连接">动态连接</a></li><li><a href="#方法出口">方法出口</a></li><li><a href="#本地方法栈">本地方法栈</a></li><li><a href="#堆">堆</a></li><li><a href="#方法区">方法区</a></li></ul></li><li><a href="#javavirtualmachineerror">JavaVirtualMachineError</a><ul><li><a href="#stackoverflowerror">StackOverflowError</a></li><li><a href="#outofmemoryerror">OutOfMemoryError</a></li></ul></li><li><a href="#简单了解类文件结构">简单了解类文件结构</a></li><li><a href="#类的生命周期">类的生命周期</a><ul><li><a href="#类加载过程">类加载过程</a></li><li><a href="#加载">加载</a></li><li><a href="#连接">连接</a></li><li><a href="#初始化">初始化</a></li><li><a href="#使用">使用</a></li><li><a href="#类的卸载">类的卸载</a></li><li><a href="#java中类加载器有多少个">Java中类加载器有多少个</a></li><li><a href="#类加载器的命名空间">类加载器的命名空间</a></li><li><a href="#双亲委派机制">双亲委派机制</a></li><li><a href="#为什么需要双亲委派机制">为什么需要双亲委派机制?</a></li><li><a href="#双亲委派机制的实现原理">双亲委派机制的实现原理?</a></li></ul></li><li><a href="#jvm常量池">JVM常量池</a><ul><li><a href="#class常量池静态常量池">Class常量池(静态常量池)</a></li><li><a href="#运行时常量池">运行时常量池</a></li><li><a href="#字符串常量池全局常量池">字符串常量池(全局常量池)</a></li><li><a href="#包装类型缓存池">包装类型缓存池</a></li></ul></li></ul></li><li><a href="#gc">GC</a><ul><li><a href="#判断对象存活的方法">判断对象存活的方法</a><ul><li><a href="#引用计数法缺点">引用计数法缺点</a></li><li><a href="#什么是gc-root-">什么是GC Root ?</a></li></ul></li><li><a href="#垃圾回收算法">垃圾回收算法</a><ul><li><a href="#复制算法copying">复制算法(Copying)</a></li><li><a href="#标记-清除算法mark-sweep">标记-清除算法(Mark-Sweep)</a></li><li><a href="#标记-整理算法mark-compact">标记-整理算法(Mark-Compact)</a></li><li><a href="#分代收集算法">分代收集算法</a></li><li><a href="#内存分配与垃圾回收策略">内存分配与垃圾回收策略</a></li><li><a href="#一次gc的过程">一次GC的过程</a></li><li><a href="#动态年龄阈值">动态年龄阈值</a></li></ul></li><li><a href="#垃圾回收器">垃圾回收器</a><ul><li><a href="#serial串行收集器">Serial串行收集器</a></li><li><a href="#serial-old-串行收集器老年代版本">Serial Old 串行收集器(老年代版本)</a></li><li><a href="#parallel-scavenge-并行多线程收集器">Parallel Scavenge 并行多线程收集器</a></li><li><a href="#parallel-old-并行收集器老年代版本">Parallel Old 并行收集器(老年代版本)</a></li><li><a href="#parnew-多线程收集器">ParNew 多线程收集器</a></li><li><a href="#cms-并发标记清除收集器">CMS 并发标记清除收集器</a></li><li><a href="#cms收集器回收过程">CMS收集器回收过程</a></li><li><a href="#g1-收集器">G1 收集器</a></li><li><a href="#g1回收器的特点">G1回收器的特点</a></li><li><a href="#g1收集器回收过程">G1收集器回收过程</a></li></ul></li></ul></li><li><a href="#jvm调优相关">JVM调优相关</a><ul><li><a href="#jvm常见参数">JVM常见参数</a><ul><li><a href="#堆栈相关">堆栈相关</a></li><li><a href="#gc相关">GC相关</a></li><li><a href="#其他">其他</a></li></ul></li><li><a href="#java常用调优命令和工具">Java常用调优命令和工具</a></li></ul></li><li><a href="#jdk新特性">Jdk新特性</a><ul><li><a href="#jdk8新特性">Jdk8新特性</a></li><li><a href="#jdk9新特性">Jdk9新特性</a></li><li><a href="#jdk10新特性">Jdk10新特性</a></li><li><a href="#jdk11新特性">Jdk11新特性</a></li><li><a href="#jdk12新特性">Jdk12新特性</a></li><li><a href="#jdk13新特性">Jdk13新特性</a></li><li><a href="#jdk14新特性">Jdk14新特性</a></li></ul></li></ul></li></ul><!-- /TOC --><h1 id="jdk-amp-jvm-amp-juc-部分图源-JavaGuide"><a href="#jdk-amp-jvm-amp-juc-部分图源-JavaGuide" class="headerlink" title="jdk&amp;jvm&amp;juc(部分图源:JavaGuide)"></a>jdk&amp;jvm&amp;juc(部分图源:<a href="https://github.com/Snailclimb/JavaGuide" target="_blank" rel="noopener">JavaGuide</a>)</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">如有错误之处，敬请各位同学指教。</span><br></pre></td></tr></table></figure><p><strong>PS:以下部分内容希望各位同学下载openjdk的源码,亲自实践。</strong></p><p>openjdk8u:</p><ul><li>hotspot:<a href="http://hg.openjdk.java.net/jdk8u/hs-dev/hotspot/archive/tip.tar.gz" target="_blank" rel="noopener">hotspot</a></li><li>openjdk:<a href="https://hg.openjdk.java.net/jdk8u/hs-dev/jdk/archive/tip.tar.gz" target="_blank" rel="noopener">jdk</a></li></ul><p><strong>PS:JVM部分参考了《深入理解Java虚拟机 - 第二版》(周志明). 个人认为《深入理解Java虚拟机 - 第二版》上的部分内容已经过时 有些知识请各位同学明鉴，此外我后续会根据 《深入理解Java虚拟机 - 第三版》的内容来做更新和修改。</strong></p><h2 id="java基础知识"><a href="#java基础知识" class="headerlink" title="java基础知识"></a>java基础知识</h2><h3 id="Java常见基础知识点"><a href="#Java常见基础知识点" class="headerlink" title="Java常见基础知识点"></a>Java常见基础知识点</h3><h4 id="面向对象和面向过程的区别"><a href="#面向对象和面向过程的区别" class="headerlink" title="面向对象和面向过程的区别"></a>面向对象和面向过程的区别</h4><p>首先面向过程和面向对象的语言没有具体的性能高下之分,要依据每种语言的设计来做参考. 个人认为面向过程与面向对象的最大区别在于: <strong>面向过程的语言是结构化的,面向对象的语言是模块化的。</strong> <strong>模块化的代码比结构化的代码更易于维护,复用与扩展。</strong></p><h4 id="OracleJdk与OpenJdk的区别"><a href="#OracleJdk与OpenJdk的区别" class="headerlink" title="OracleJdk与OpenJdk的区别"></a>OracleJdk与OpenJdk的区别</h4><p>OpenJdk是基于Sum捐赠的HotSpot的源代码开发的,是开源的。 OracleJdk是Oracle对Jdk的商业化版本,由Oracle发布并维护. 因此OracleJdk比OpenJdk更可靠。</p><h4 id="Java与C-的异同"><a href="#Java与C-的异同" class="headerlink" title="Java与C++的异同"></a>Java与C++的异同</h4><ul><li>Java和C++都是基于面向对象思想的语言。</li><li>Java不提供指针来访问内存。C++允许指针访问内存。</li><li>垃圾回收机制。Java无需开发者手动释放内存,因为Java有垃圾回收机制自动回收内存; C++则需要开发者手动释放内存。因此Java在内存管理上相对C++更安全。</li><li>Java不支持多继承，而C++支持。</li></ul><h4 id="JVM-JDK和JRE的区别"><a href="#JVM-JDK和JRE的区别" class="headerlink" title="JVM,JDK和JRE的区别"></a>JVM,JDK和JRE的区别</h4><ul><li>JVM: JVM(java virtual machine)是java虚拟机</li><li>JRE: JRE(java runtime environment)是java运行时环境</li><li>JDK: JDK(java development kit)是java开发工具包,不仅包含了jre和jvm,还提供了javac编译器和javadoc等其他开发所需的工具</li></ul><h4 id="Java语言的特点"><a href="#Java语言的特点" class="headerlink" title="Java语言的特点"></a>Java语言的特点</h4><ul><li>面向对象</li><li>平台无关性,也就是跨平台(依靠JVM)</li><li>垃圾回收机制(GC)</li><li>支持多线程</li><li>支持便捷的网络编程</li><li>编译与解释(JIT)</li><li>安全(个人认为所有语言写出来的代码的安全性是开发者决定的, 而不是语言本身决定的,语言能决定的只是提供方便或不便的安全的API)</li></ul><h4 id="面向对象的特征"><a href="#面向对象的特征" class="headerlink" title="面向对象的特征"></a>面向对象的特征</h4><p>面向对象三大特征:封装,继承,多态。</p><ul><li>封装: 封装是隐藏对象属性和实现细节,只对外提供可访问或修改的接口的技术。 <strong>封装的目的是为了简化编程和增加程序的安全性,使得使用者无需了解对象的具体实现细节。</strong></li><li>继承: 继承是 在已存在的类上定义新的类的技术。 在Java中,已存在的类被称为基类(父类),新的类叫做派生类(子类).子类拥有父类的所有属性,方法。 但是子类对于父类中私有的方法或属性只是拥有,并不能访问和使用。 <strong>继承的目的主要是为了代码的复用.</strong></li><li>多态: 多态指的是相同类型的对象,调用其相同的方法,参数也相同,但是它的表现形式也就是结果不同。 <strong>多态的目的是为了程序的可扩展性和维护性。</strong> 在Java中可以使用继承与接口2大特性实现多态。</li></ul><h4 id="重载和重写的区别"><a href="#重载和重写的区别" class="headerlink" title="重载和重写的区别"></a>重载和重写的区别</h4><p>个人认为重载和重写完全没有可比性,不知道为啥老有人喜欢拿它们做比较。</p><ul><li>重载: 重载是描述一个类中有多个方法名相同的方法，但是它们的参数,类型,返回值,参数的顺序可能不同，表现形式也就不同。</li><li>重写: 重写是描述子类对父类的某个方法的逻辑进行了重新编写,但重写的只是方法的内容, 方法名,参数,类型,顺序,返回值都是不变的。</li></ul><h4 id="接口与抽象类的区别"><a href="#接口与抽象类的区别" class="headerlink" title="接口与抽象类的区别"></a>接口与抽象类的区别</h4><ul><li>接口需要被实现,而抽象类是需要被继承的。</li><li>接口里的方法都是公共抽象的，而抽象类既允许抽象也允许非抽象的方法(在jdk8中,接口被允许定义default方法,jdk9中还允许定义private私有方法)。</li><li>一个类允许实现多个接口,但只允许继承一个抽象父类。</li><li>接口是对类的规范,规范的是行为能力。而抽象类是对类的抽象,抽象的是逻辑。</li></ul><h4 id="Object类的方法有哪些"><a href="#Object类的方法有哪些" class="headerlink" title="Object类的方法有哪些?"></a>Object类的方法有哪些?</h4><ol><li>getClass</li><li>equals</li><li>hashCode</li><li>toString</li><li>wait</li><li>wait(long): 让当前对象进入TIMED_WATING状态</li><li>wait(long,int):让当前对象进入TIMED_WATING状态</li><li>notify</li><li>nofifyAll</li><li>clone</li><li>finalize</li></ol><h4 id="静态属性方法和成员属性方法区别"><a href="#静态属性方法和成员属性方法区别" class="headerlink" title="静态属性方法和成员属性方法区别"></a>静态属性方法和成员属性方法区别</h4><p><strong>静态属性和方法属于类Class,而成员属性和方法属于实例化的对象。</strong></p><p>静态方法只能使用静态方法和静态属性,不能使用成员属性和方法, 因为静态属性和方法在对象还没被实例化的时候就存在了。</p><p><strong>简单理解就是不允许一个已存在的事物使用一个不存在的事物。</strong></p><h4 id="子类属性与父类属性初始化顺序"><a href="#子类属性与父类属性初始化顺序" class="headerlink" title="子类属性与父类属性初始化顺序"></a>子类属性与父类属性初始化顺序</h4><ol><li>无论如何,静态数据首先加载,所以先初始化父类静态变量和静态初始化块(静态变量和静态初始化块按源码编写的顺序执行， 普通初始化块和普通成员变量也是如此),再初始化子类静态变量和静态初始化块。</li><li>普通初始化块和普通成员变量优先于构造方法,所以接下来加载父类的普通初始化块和普通成员变量,再调用父类构造方法。</li><li>调用子类普通代码块，普通成员变量和构造方法。</li></ol><h4 id="自动拆箱和装箱"><a href="#自动拆箱和装箱" class="headerlink" title="自动拆箱和装箱"></a>自动拆箱和装箱</h4><p>自动拆箱和装箱实际上是Java编译器的一个语法糖。</p><p>自动装箱是指: <strong>将基本数据类型转为对应的包装类对象的过程。</strong></p><p>自动拆箱是指: <strong>将包装类转为对应的基本数据类型。</strong></p><p><strong>自动装箱实际上是调用了包装类对象的valueof方法</strong>,如: Integer.valueof(1)</p><p><strong>自动拆箱实际上是调用了包装类的xxxValue方法</strong>,如: Integer.intValue()</p><p><strong>在自动装箱的时候,如果包装类允许缓存并且值在缓存的范围内,那么装箱生成的对象会被缓存到常量池中。</strong></p><p><strong>Integer,Byte,Short,Long,Character包装类型具有缓存池, 而其他三种:Float,Double,Boolean不具有缓存池。</strong></p><p>包装类的缓存池缓存的范围基本都为: -128 - 127之间， 除了Character的缓存范围为 0 - 127。</p><h4 id="String为什么不可变"><a href="#String为什么不可变" class="headerlink" title="String为什么不可变?"></a>String为什么不可变?</h4><p>先说下我的看法:String是Java中最常使用的类没有之一,如果String是可变的,那么会发生非常多数不清的问题。 如ip地址,人名,邮箱非常多的敏感数据。 如果String是可变的,就会发生安全问题, 且字符串常量池也就无从谈起了。</p><p>String是不可变的,那么它本质上也是线程安全的。 <strong>不可变类的缺点就是每个不同的值需要创建一个对象</strong></p><p><strong>String 是用final修饰的，保证了String类不能被扩展。 String内部的字段是用final修饰的(我的jdk版本是11,String由byte[]实现)， 并且没有对外提供修改字段的方法。这也是为什么String不可变的原理。</strong></p><h4 id="final关键字的作用"><a href="#final关键字的作用" class="headerlink" title="final关键字的作用"></a>final关键字的作用</h4><ul><li>被final修饰的类，不能被继承，并且这个类所有的成员方法都为final，不能被重写。</li><li>被final修饰的属性变量，不能被修改。如果该变量是基本数据类型的，那么其值在初始化后不能被修改。 如果该变量是引用类型的，那么该引用不能再指向其他对象。</li><li>被final修饰的方法不能被子类重写。</li></ul><h4 id="StringBuilder和StringBuffer区别"><a href="#StringBuilder和StringBuffer区别" class="headerlink" title="StringBuilder和StringBuffer区别"></a>StringBuilder和StringBuffer区别</h4><p><strong>StringBuilder和StringBuffer都是可变的字符串,但是StringBuilder是线程不安全的。</strong></p><p>StringBuffer是安全的,因此单线程情况下考虑使用StringBuilder,多线程情况下考虑使用StringBuffer。</p><p><strong>他们之间的关系就好比HashMap和HashTable的关系。</strong></p><h4 id="equals知识点"><a href="#equals知识点" class="headerlink" title="equals知识点"></a>equals知识点</h4><ul><li><p><strong>== 和 equals区别</strong>:</p><ul><li>==比较的是对象的内存地址,equals比较的是对象的值。 因此在Java中比较2个对象的值是否相等使用equals,判断2个对象是否是一个对象,使用==。</li></ul></li><li><p>hashCode方法返回的真是对象内存地址吗? 这个已在对象内存布局部分有讲解，此处就不重复写了。</p></li><li><p>equals方法重写要求</p><ul><li>自反性: x.equals(x) == true 永远成立</li><li>非空性: x.equals(null) == false 永远成立</li><li>对称性: 如果 x.equals(y) == true , 那 y.equals(x)== true  </li><li>传递性: 如果 x.equals(y) == true,并且 y.equals(z) == true,那么一定满足x.equals(z) == true</li><li>一致性: 如果x.equals(y) == true , 那么只要x和y的值不变,那么x.equals(y) == true 永远成立</li></ul></li><li><p>为什么重写equals方法一定要重写hashcode方法?</p><p>在普通环境下(不涉及hash表),equals方法和hashcode方法一毛钱关系没有的, 此时重写equals但不重写hashcode是没有关系的。 但<strong>当使用map,set这些散列表时, 它们会根据对象的hashcode来计算对象在散列表中的位置的。</strong> 试想下,如果2个对象的值相等,但是由于它们是2个对象,hashcode却不相等。 那么即使放入map,set(map)仍会存在重复数据。</p></li></ul><h4 id="深拷贝与浅拷贝"><a href="#深拷贝与浅拷贝" class="headerlink" title="深拷贝与浅拷贝"></a>深拷贝与浅拷贝</h4><p><strong>深拷贝: 拷贝所有的内容,除了基本数据类型的变量复制一份,连引用类型的变量也复制一份。</strong></p><p><strong>浅拷贝: 复制基本数据类型的变量,对于引用类型的变量,直接返回这个引用本身。</strong></p><h4 id="IO流分类"><a href="#IO流分类" class="headerlink" title="IO流分类"></a>IO流分类</h4><ol><li>按照流的流向,分为:输入流和输入流。</li><li>按照操作单元,分为:字节流和字符流。</li></ol><h4 id="使用字节流还是字符流"><a href="#使用字节流还是字符流" class="headerlink" title="使用字节流还是字符流?"></a>使用字节流还是字符流?</h4><p>考虑通用性,应该使用字节流。 如果只是文本文件的操作,可以使用字符流。</p><h4 id="BigDecimal"><a href="#BigDecimal" class="headerlink" title="BigDecimal"></a>BigDecimal</h4><p>BigDecimal是Java中表示大浮点数的类型。</p><p>在Java中,如果遇到浮点数的判断,可以使用BigDecimal来做计算, 因为如果使用普通数据类型很可能会发生精度丢失的情况,这个时候的结果可能会出乎意料之外.</p><h4 id="Java异常体系结构"><a href="#Java异常体系结构" class="headerlink" title="Java异常体系结构"></a>Java异常体系结构</h4><p>在Java中,异常分为 Exception和Error,这2个类都继承自Throwable。</p><ul><li>Exception: Exception异常是程序本身可以处理的。Exception 分为运行时异常(RuntimeException)和 非运行时异常(CheckedException)。<ul><li>RuntimeException: RuntimeException(运行时异常)是在程序运行时可能会发生的异常,如NullPointException, 这类异常往往是不可预料的,编译器也不会要求你手动try catch或throws。</li><li>CheckedException: CheckedException(非运行时异常)是RuntimeException以外的异常,如IOException， 这类异常要求必须显示的try catch或throws ， 如果不处理,那么编译就不会通过。</li></ul></li><li>Error: Error错误是程序无法处理的,表示程序或JVM出现了很严重的，无法解决的问题。</li></ul><h4 id="Comparable和Comparator"><a href="#Comparable和Comparator" class="headerlink" title="Comparable和Comparator"></a>Comparable和Comparator</h4><ul><li>Comparable: 自然排序接口。实现了它的类意味着就支持排序。</li><li>Comparator: 外部比较器。无需让需要排序的对象实现排序逻辑，而是根据Comparator定义的逻辑来排序。 Comparator相较于Comparable更加的灵活。</li></ul><h4 id="什么是泛型-什么是类型擦除"><a href="#什么是泛型-什么是类型擦除" class="headerlink" title="什么是泛型,什么是类型擦除?"></a>什么是泛型,什么是类型擦除?</h4><p>Java泛型(Generics) 是JDK5中引入的一个新特性，泛型提供了编译时类型安全检测机制， 该机制允许程序员在编译时检测到非法的类型。 泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。</p><p>Java中的<strong>泛型</strong>是<strong>伪泛型</strong>，在Java编译期间，所有的泛型信息都会被擦除，这就是通常所说的类型擦除。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; list &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">list.add(12);</span><br><span class="line">&#x2F;&#x2F;这里直接添加会报错</span><br><span class="line">list.add(&quot;a&quot;);</span><br><span class="line">Class&lt;? extends List&gt; clazz &#x3D; list.getClass();</span><br><span class="line">Method add &#x3D; clazz.getDeclaredMethod(&quot;add&quot;, Object.class);</span><br><span class="line">&#x2F;&#x2F;但是通过反射添加，是可以的</span><br><span class="line">add.invoke(list, &quot;kl&quot;);</span><br><span class="line"></span><br><span class="line">System.out.println(list)</span><br></pre></td></tr></table></figure><h4 id="泛型通配符"><a href="#泛型通配符" class="headerlink" title="泛型通配符"></a>泛型通配符</h4><p><strong>常用的 T，E，K，V，?</strong></p><ul><li>？ 表示不确定的 java 类型</li><li>T (type) 表示具体的一个java类型</li><li>K V (key value) 分别代表java键值中的Key Value</li><li>E (element) 代表Element</li></ul><p><strong>? 无界通配符</strong></p><p>一个抽象父类Animal和子类Dog，现在需要一个动物列表，我的第一反应是这样的：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">List&lt;Animal&gt; listAnimals</span><br></pre></td></tr></table></figure><p>但是老板的想法却是这样的：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">List&lt;? extends Animal&gt; listAnimals</span><br></pre></td></tr></table></figure><p>通配符在声明局部变量时是没有什么意义的，但是当你为一个方法设置声明一个参数时，它是非常重要的。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">      List&lt;Dog&gt; dogs &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line"> </span><br><span class="line">      countLegs(dogs);</span><br><span class="line">      &#x2F;*编译器会会报错，显示类型不匹配*&#x2F;</span><br><span class="line">      &#x2F;&#x2F;countLegs1(dogs);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  static int countLegs(List&lt;? extends Animal&gt; animals)&#123;</span><br><span class="line">      int reVal &#x3D; 0;</span><br><span class="line">      for (Animal animal : animals) &#123;</span><br><span class="line">          reVal+&#x3D; animal.getLegs();</span><br><span class="line">      &#125;</span><br><span class="line">      return reVal;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  static int countLegs1(List&lt;Animal&gt; animals)&#123;</span><br><span class="line">      int reVal &#x3D; 0;</span><br><span class="line">      for (Animal animal : animals) &#123;</span><br><span class="line">          reVal+&#x3D; animal.getLegs();</span><br><span class="line">      &#125;</span><br><span class="line">      return reVal;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>所以，对于不确定或者不关心实际要操作的类型，可以使用无限制通配符(****)，表示可以持有任意类型。像countLegs方法，规定了参数传入的上界，但是并不关心具体类型是什么，对于传入的参数，只要是<code>Animal</code>的子类，就都可以支持，而countLegs1方法不行。</p><p>为什么countLegs1方法就不行呢？<code>Dog</code>不是<code>Animal</code>的子类吗，根据多态的角度来讲，理论上应该是可以的，但是，在泛型的继承体系中，<code>Dog</code>并不算<code>Animal</code>的一个子类。</p><p>假设我们有以下代码：</p><p>animals的泛型是父类对象<code>Animal</code>，dogs的泛型是子类对象<code>Dog</code>，那么dogs转换animals能成功吗，我们知道子类对象转父类对象是可以的，但是子类泛型转父类泛型能成功吗，我们假设能成功。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">       List&lt;Animal&gt; animals &#x3D; new ArrayList&lt;Animal&gt;();</span><br><span class="line">       List&lt;Dog&gt; dogs &#x3D; new ArrayList&lt;Dog&gt;();</span><br><span class="line">       </span><br><span class="line">       animals &#x3D; dogs;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>那么animals就指向了一个泛型为<code>Dog</code>的集合容器，但是现在这个集合容器的泛型是<code>Animal</code>，看上去可以将另一个子类<code>Cat</code>加进容器中。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">       List&lt;Animal&gt; animals &#x3D; new ArrayList&lt;Animal&gt;();</span><br><span class="line">       List&lt;Dog&gt; dogs &#x3D; new ArrayList&lt;Dog&gt;();</span><br><span class="line"></span><br><span class="line">       animals &#x3D; dogs;</span><br><span class="line">       animals.add(new Cat(4));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>这段代码看上去好像没什么问题，但是仔细想想。现在animals指向的是一个泛型为Dog的容器，现在又将Cat放进容器中，就相当于在一堆狗里面放进一只猫，这就矛盾了。所以子类泛型<strong>不能</strong>转换为父类泛型，反过来也是一样。</p><h4 id="上界通配符-lt-extend-E-gt"><a href="#上界通配符-lt-extend-E-gt" class="headerlink" title="上界通配符 &lt;? extend E&gt;"></a>上界通配符 &lt;? extend E&gt;</h4><p>上界：用extend关键字指定，表示所指定的类型只能是某个类的子类或者这个类本身</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> static &lt;K extends Comparable,E extends Serializable&gt; K test(K arg1,E arg2)&#123;</span><br><span class="line">        K result &#x3D; arg1;</span><br><span class="line">        arg1.compareTo(arg2);</span><br><span class="line"></span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"> &#x2F;&#x2F; 表示既要实现Comparable接口，又要实现Serializable接口</span><br><span class="line">static &lt;K extends Comparable &amp; Serializable&gt; K test(K arg1) &#123;</span><br><span class="line">        K result &#x3D; arg1;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>有多个限定类型用”&amp;”隔开，有多个类型变量用”,”逗号隔开</p><h4 id="下界通配符-lt-super-E-gt"><a href="#下界通配符-lt-super-E-gt" class="headerlink" title="下界通配符&lt;? super E&gt;"></a>下界通配符&lt;? super E&gt;</h4><p>下界：用super关键字指定，表示所指定的类型只能是这个类本身或者某个类的父类，直至Object</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static &lt;T&gt; void  test1(List&lt;? super  T&gt; dst ,List&lt;T&gt; list)&#123;</span><br><span class="line">        for (T t : list) &#123;</span><br><span class="line">            dst.add(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="和T的区别"><a href="#和T的区别" class="headerlink" title="?和T的区别"></a>?和T的区别</h4><p>? 表示不确定的类型，常用于泛型方法的调用代码和形参，不能用于定义泛型类、泛型方法和泛型变量。</p><p>T 表示一个具体的类型，常用于泛型类和泛型方法的定义，可以定义泛型变量。</p><p><strong>利用T来保证泛型的一致性。</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 通过 T 来 确保 泛型参数的一致性,通常我们需要先声明</span><br><span class="line">public &lt;T extends Number&gt; void</span><br><span class="line">test(List&lt;T&gt; dest, List&lt;T&gt; src)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;通配符是 不确定的，所以这个方法不能保证两个 List 具有相同的元素类型，不需要提前声明</span><br><span class="line">public void</span><br><span class="line">test(List&lt;? extends Number&gt; dest, List&lt;? extends Number&gt; src)</span><br></pre></td></tr></table></figure><p><strong>类型参数可以多重限定而通配符不行。</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static &lt;T extends Comparable &amp; Serializable&gt; T test(T arg1) &#123;</span><br><span class="line">       T result &#x3D; arg1;</span><br><span class="line"></span><br><span class="line">       return result;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><strong>?可以使用下界限定，但T不行。</strong></p><p>类型参数 T 只具有 一种 类型限定方式：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">T extends A</span><br></pre></td></tr></table></figure><p>但是通配符 ? 可以进行 两种限定：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">? extends A</span><br><span class="line">? super A</span><br></pre></td></tr></table></figure><h4 id="为什么要慎用-Arrays-asList"><a href="#为什么要慎用-Arrays-asList" class="headerlink" title="为什么要慎用 Arrays.asList()?"></a>为什么要慎用 Arrays.asList()?</h4><p><strong>因为Arrays.asList这个方法返回的根本就不是我们期盼的ArrayList, 而是Arrays类内部实现的ArrayList,这个内部类只支持访问和set操作, 并不支持remove,add,clear等修改操作。</strong></p><h4 id="Java中引用的类型"><a href="#Java中引用的类型" class="headerlink" title="Java中引用的类型"></a>Java中引用的类型</h4><p>Java中引用类型总共有四种: 强引用，软引用，弱引用，虚引用。</p><ul><li>强引用(Strong Reference): Java程序中绝大部分都是强引用，一般使用new关键字创建的对象就是强引用。 只要强引用存在，强引用的对象就不会被回收，除非不可达(参考jvm部分)</li><li>软引用(Soft Reference): 软引用一般不会被回收，但是当堆内存不够的时候， 比如几乎快要发生OOM的时候，就会回收掉软引用对象。</li><li>弱引用(Weak Reference): 只要垃圾回收开始，就会回收掉弱引用的对象。</li><li>虚引用(Phantom Reference,又称幽灵引用): 和其他几种引用不同，虚引用不决定对象的生命周期， 它在任何时候都可能被回收掉。</li></ul><h2 id="对象在内存中的布局-64位"><a href="#对象在内存中的布局-64位" class="headerlink" title="对象在内存中的布局(64位)"></a>对象在内存中的布局(64位)</h2><p>鉴于此章已经涉及到jvm的内容了，所以各位同学在此章需要对JVM的一些基本术语有所了解。 这里我找到了openjdk官方对于hotspot的一些基本词汇表，各位同学在学习的时候，可以参考这个词汇表: <a href="https://openjdk.java.net/groups/hotspot/docs/HotSpotGlossary.html" target="_blank" rel="noopener">OpendJdk Hotspot Glossary</a></p><p><strong>对象在内存中的布局,在32位和64位操作系统上的实现也是不同的，以我的机器为例(64位)</strong></p><p><strong>对象在内存中由 对象头,实例数据,对齐填充三部分组成。</strong></p><p><strong>其中实例数据和对齐填充是不固定的</strong>。</p><p><img src="file://E:/%E5%B0%9A%E7%A1%85%E8%B0%B7java/JVMzhouyang/framework-learning/img/jdk-jvm-juc/%E5%AF%B9%E8%B1%A1%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E5%B8%83%E5%B1%80.png?lastModify=1596340467" alt="对象内存布局">           </p><h4 id="实例数据"><a href="#实例数据" class="headerlink" title="实例数据"></a>实例数据</h4><p>实例数据存储着对象在程序中被定义的各个字段的数据,也就是对象的字段的 数据。<strong>如果一个类没有字段，也就不存在实例数据，所以这是它不固定的原因。</strong></p><h4 id="对齐填充"><a href="#对齐填充" class="headerlink" title="对齐填充"></a>对齐填充</h4><p><strong>Java对象的大小必须是8字节的倍数</strong>,像13,15这种非8的倍数的对象的大小, 不足或多余的部分就要使用对齐填充数据补齐。 <strong>如果Java对象大小正好是8的倍数,那么就无需对齐填充数据。</strong></p><h3 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h3><p>关于对象头，在hotspot中，opendjdk是这样描述的:</p><p><img src="file://E:/%E5%B0%9A%E7%A1%85%E8%B0%B7java/JVMzhouyang/framework-learning/img/jdk-jvm-juc/%E5%AF%B9%E8%B1%A1%E5%A4%B4%E7%9A%84%E6%8F%8F%E8%BF%B0.png?lastModify=1596340467" alt="对象头描述"></p><p>大意是说: <strong>对象头是jvm在每次GC时管理的对象的通用结构，包含了对象的布局，类型(Class Type),GC状态， 同步状态和hashcode等信息，在数组中，还会跟随数组的长度。java对象和vm对象都具有通用的对象头格式。</strong></p><p>在hotspot虚拟机中的对象头由2部分组成: mark 和 metadata(包括klass* , compressed_klass)(<strong>如果是数组,对象头还会保存数组长度</strong>)(见oop.hpp文件)</p><p><img src="file://E:/%E5%B0%9A%E7%A1%85%E8%B0%B7java/JVMzhouyang/framework-learning/img/jdk-jvm-juc/%E5%AF%B9%E8%B1%A1%E5%A4%B4%E7%9A%84markword%E7%BB%84%E6%88%901.png?lastModify=1596340467" alt="对象头组成1"></p><p>mark/markword就是说面说过的，保存了对象的GC状态，同步状态和hashcode等信息。</p><p>下面是mark/markword的组成(见:markOop.hpp头文件):</p><p><img src="file://E:/%E5%B0%9A%E7%A1%85%E8%B0%B7java/JVMzhouyang/framework-learning/img/jdk-jvm-juc/%E5%AF%B9%E8%B1%A1%E5%A4%B4%E7%9A%84markword%E7%BB%84%E6%88%902.png?lastModify=1596340467" alt="对象头组成2"></p><p>对象处于不同的同步状态和GC状态，markword都不同(见:markOop.hpp头文件):</p><p><img src="file://E:/%E5%B0%9A%E7%A1%85%E8%B0%B7java/JVMzhouyang/framework-learning/img/jdk-jvm-juc/%E5%AF%B9%E8%B1%A1%E5%A4%B4%E7%9A%84markword%E7%BB%84%E6%88%903.png?lastModify=1596340467" alt="对象头组成3"></p><p><img src="file://E:/%E5%B0%9A%E7%A1%85%E8%B0%B7java/JVMzhouyang/framework-learning/img/jdk-jvm-juc/%E5%AF%B9%E8%B1%A1%E5%A4%B4%E7%9A%84markword%E7%BB%84%E6%88%904.png?lastModify=1596340467" alt="对象头组成4"></p><h4 id="markword和metadata"><a href="#markword和metadata" class="headerlink" title="markword和metadata"></a>markword和metadata</h4><p>Mark Word(mark)组成:</p><table><thead><tr><th align="center">锁状态</th><th align="center">锁标志</th><th align="center">markword组成</th></tr></thead><tbody><tr><td align="center">无锁</td><td align="center">01</td><td align="center">由hashcode,分代年龄,是否偏向锁(1位),锁标志位组成</td></tr><tr><td align="center">偏向锁</td><td align="center">01</td><td align="center">由偏向线程的ID,偏向时间戳(epoch),是否偏向锁(1位),分代年龄,锁标志位组成</td></tr><tr><td align="center">轻量级锁</td><td align="center">00</td><td align="center">由指向栈中锁的记录和锁标志位组成</td></tr><tr><td align="center">膨胀锁</td><td align="center">10</td><td align="center">由指向锁的指针和锁标志位组成</td></tr><tr><td align="center">GC</td><td align="center">11</td><td align="center">无数据</td></tr></tbody></table><p>Klass Pointer /  Compressed Klass: <strong>Klass Pointer是指向对象类型的指针，指针指向对象的类元数据。</strong> jvm通过klass pointer判断对象属于哪个类。 在64位的jvm实现中，Klass Pointer的长度为64bit(32位系统, 指针为32bit)，也就意味着,64位系统比32位的系统占用更多内存。</p><p>所以<strong>jvm提供了压缩指针(Compressed Klass)来节省空间，在64位系统下，压缩指针是默认开启的， 可以使用-XX:-UseCompressedOops来关闭指针压缩。</strong>           </p><h4 id="实例数据-1"><a href="#实例数据-1" class="headerlink" title="实例数据"></a>实例数据</h4><p>实例数据存储着对象在程序中被定义的各个字段的数据,也就是对象的字段的 数据。<strong>如果一个类没有字段，也就不存在实例数据，所以这是它不固定的原因。</strong>        </p><h4 id="对齐填充-1"><a href="#对齐填充-1" class="headerlink" title="对齐填充"></a>对齐填充</h4><p><strong>Java对象的小必须是8字节的倍数</strong>,像13,15这种非8的倍数的对象的大小, 不足或多余的部分就要使用对齐填充数据补齐。 <strong>如果Java对象大小正好是8的倍数,那么就无需对齐填充数据。</strong></p><h3 id="jol工具查看对象布局"><a href="#jol工具查看对象布局" class="headerlink" title="jol工具查看对象布局"></a>jol工具查看对象布局</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--可用此工具查看对象内存布局--&gt;</span><br><span class="line"> &lt;dependency&gt;</span><br><span class="line">     &lt;groupId&gt;org.openjdk.jol&lt;&#x2F;groupId&gt;</span><br><span class="line">     &lt;artifactId&gt;jol-core&lt;&#x2F;artifactId&gt;</span><br><span class="line">     &lt;version&gt;0.10&lt;&#x2F;version&gt;</span><br><span class="line"> &lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><p>相信各位同学可能还是对上面的概念有点模糊，那就可以使用jol工具来查看一下 对象的真实布局，在实践之前，请各位同学带着几个问题看下面的内容:</p><ul><li>hashCode方法返回的真是对象内存地址吗?</li><li>hashcode真实存在吗?</li></ul><h4 id="查看对象内存布局"><a href="#查看对象内存布局" class="headerlink" title="查看对象内存布局"></a>查看对象内存布局</h4><p>以下是我自己的一个测试demo，详解了jol的使用:</p><p><img src="file://E:/%E5%B0%9A%E7%A1%85%E8%B0%B7java/JVMzhouyang/framework-learning/img/jdk-jvm-juc/jol%E5%B7%A5%E5%85%B7%E6%9F%A5%E7%9C%8B%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%801.png?lastModify=1596340467" alt="jol工具查看对象内存布局1"></p><p>以上可以看到jol工具很直观的给我们展现了对象的内存布局， 但是在对象的markword之中，我们并没有看到hashcode的值， 难道对象不存在hashcode吗？</p><h4 id="hashcode"><a href="#hashcode" class="headerlink" title="hashcode"></a>hashcode</h4><p>上一个测试在打印对象内存布局之前，我并没有调用对象的hashcode方法， 相信各位同学也注意到了，我把那2行代码注释掉了。</p><p>打开那2行注释再运行看看:</p><p><img src="file://E:/%E5%B0%9A%E7%A1%85%E8%B0%B7java/JVMzhouyang/framework-learning/img/jdk-jvm-juc/jol%E5%B7%A5%E5%85%B7%E6%9F%A5%E7%9C%8B%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%802.png?lastModify=1596340467" alt="jol工具查看对象内存布局2"></p><p>我们发现，在调用hashcode方法后，对象的hashcode的值与打印结果完全一致， 到这里可以初步猜想(没有实际验证):</p><p><strong>hashcode的值也是不固定存在的。</strong></p><p><strong>在没有调用对象的hashcode方法之前，对象不存在hashcode。</strong></p><p><strong>当调用完对象的hashcode之后，jvm就把生成的hashcode值赋予了对象的markword之中。</strong></p><h4 id="对象的hashcode返回的是对象的内存地址吗"><a href="#对象的hashcode返回的是对象的内存地址吗" class="headerlink" title="对象的hashcode返回的是对象的内存地址吗?"></a>对象的hashcode返回的是对象的内存地址吗?</h4><p><strong>在hotspot中，hashcode返回的不完全是地址</strong> (见：hotspot的/src/share/vm/runtime/synchronizer.cpp):</p><p><img src="file://E:/%E5%B0%9A%E7%A1%85%E8%B0%B7java/JVMzhouyang/framework-learning/img/jdk-jvm-juc/hashcode%E6%96%B9%E6%B3%95%E6%BA%90%E7%A0%81.png?lastModify=1596340467" alt="hashcode方法源码"></p><p>可以看到hashcode有:随机数，自增长序列，关联地址等多种生成策略。</p><h2 id="线程并发-JUC-AQS-CAS"><a href="#线程并发-JUC-AQS-CAS" class="headerlink" title="线程并发(JUC,AQS,CAS)"></a>线程并发(JUC,AQS,CAS)</h2><h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><h4 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h4><p><strong>进程与线程最主要的区别是它们是操作系统管理资源的不同方式的体现。</strong> 准确来说进程与线程属于衍生关系。 进程是操作系统执行程序的一次过程,在这个过程中可能会产生多个线程。</p><blockquote><p>比如在使用QQ时，有窗口线程， 文字发送的线程，语音输入的线程，可能不是很恰当，但是就是这个意思。</p></blockquote><p><strong>由于系统在线程之间的切换比在进程之间的切换更高效率，所以线程也被成为轻量级进程。</strong></p><h4 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a>并发和并行</h4><ol><li>并发: 多个线程任务被一个cpu轮流执行。注意，这里并不是只允许一个cpu执行多任务，多个cpu执行也是可以的。 <strong>并发强调的是计算机应用程序有处理多个任务的能力。</strong></li><li>并行:多个线程被多个cpu同时执行。这里也并不是只允许多个cpu处理多任务，一个cpu也是可以的， 只要cpu能在同一时刻处理多任务。<strong>并行强调的是计算机应用程序拥有同时处理多任务的能力。</strong></li></ol><h4 id="多线程的利弊"><a href="#多线程的利弊" class="headerlink" title="多线程的利弊"></a>多线程的利弊</h4><ul><li>利:<ul><li>线程可以比作轻量级的进程，cpu在线程之间的切换比在进程之间的切换，耗费的资源要少的多。</li><li>现在是多核cpu时代，意味着多个线程可以被多个cpu同时运行(并行)，如果可以利用好多线程，那么可以编写出高并发的程序。</li></ul></li><li>弊:<ul><li>虽然线程带来的好处很多，但是并发编程并不容易，如果控制不好线程，那么就可能造成死锁，资源闲置，内存泄露等问题。</li></ul></li></ul><h4 id="什么是上下文切换"><a href="#什么是上下文切换" class="headerlink" title="什么是上下文切换?"></a>什么是上下文切换?</h4><p>cpu是采用时间片的轮转制度，在多个线程之间来回切换运行的。 当cpu切换到另一个线程的时候，它会先保存当前线程执行的状态， 以便在下次切换回来执行时，可以重新加载状态，继续运行。 <strong>从保存线程的状态再到重新加载回线程的状态的这个过程就叫做上下文切换。</strong></p><h4 id="线程的优先级"><a href="#线程的优先级" class="headerlink" title="线程的优先级"></a>线程的优先级</h4><p>在Java中可以通过Thread类的setPriority方法来设置线程的优先级， 虽然可以通过这样的方式来设置线程的优先级，但是线程执行的先后顺序并不依赖与线程的优先级。 换句话说就是，<strong>线程的优先级不保证线程执行的顺序。</strong></p><h4 id="线程的几种状态"><a href="#线程的几种状态" class="headerlink" title="线程的几种状态"></a>线程的几种状态</h4><p>见:jdk Thread类源码中的state枚举类</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NEW,RUNNABLE,BLOCKED,WAITING,TIMED_WAITING,TERMINATED</span><br></pre></td></tr></table></figure><h4 id="sleep方法和wait方法"><a href="#sleep方法和wait方法" class="headerlink" title="sleep方法和wait方法"></a>sleep方法和wait方法</h4><ol><li>sleep方法是Thread类的方法；而wait方法是Object类的方法。</li><li>sleep方法会<strong>使当前线程让出cpu的调度资源</strong>，从而让其他线程有获得被执行的机会， <strong>但是并不会让当前线程释放锁对象。</strong>  而wait方法是<strong>让当前线程释放锁并进入wait状态，</strong>  不参与获取锁的争夺，从而让其他等待资源的线程有机会获取锁， 只有当其他线程调用notify或notifyAll方法是，被wait的线程才能重新与其他线程一起争夺资源。 被wait的线程才能重新与其他线程一起争夺资源。</li></ol><h4 id="stop-suspend-resume等方法为什么会被遗弃"><a href="#stop-suspend-resume等方法为什么会被遗弃" class="headerlink" title="stop,suspend,resume等方法为什么会被遗弃"></a>stop,suspend,resume等方法为什么会被遗弃</h4><ul><li>stop: stop方法被弃用很好理解，因为stop方法是强行终止线程的执行， 不管线程的run方法是否执行完，资源是否释放完，它都会终止线程的运行，并释放锁。 显然，这在设计上就不合理。  </li><li>suspend和resume: suspend方法用于阻塞一个线程,但并不释放锁， 而resume方法的作用只是为了恢复被suspend的线程。 假设A，B线程都争抢同一把锁，A线程成功的获得了锁， 然后被suspend阻塞了，却并没有释放锁，它需要其他线程来唤醒， 但此时B线程需要获得这把锁才能唤醒A，所以此时就陷入了死锁。        </li></ul><h4 id="interrupt-interrupted-isInterrupted方法区别"><a href="#interrupt-interrupted-isInterrupted方法区别" class="headerlink" title="interrupt,interrupted,isInterrupted方法区别"></a>interrupt,interrupted,isInterrupted方法区别</h4><ul><li>interrupt: 这个方法并不是中断当前线程，而是给当前线程设置一个中断状态。</li><li>isInterrupted: 当线程调用interrupt方法后，线程就有了一个中断状态， 而使用isInterrupted方法就可以检测到线程的中断状态。</li><li>interrupted: 这个方法用于清除interrupt方法设置的中断状态。 如果一个线程之前调用了interrupt方法设置了中断状态， 那么interrupted方法就可以清除这个中断状态。           </li></ul><h4 id="join方法"><a href="#join方法" class="headerlink" title="join方法"></a>join方法</h4><p>join方法的作用是让指定线程加入到当前线程中执行。</p><p>假如在main方法里面创建一个线程A执行，并调用A的join方法， 那么当前线程就是main，指定的A线程就会在main之前执行， 等A执行完后，才会继续执行main。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) throws Exception</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    Thread a &#x3D; new Thread(()-&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        try</span><br><span class="line">        &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(1);</span><br><span class="line">            </span><br><span class="line">        &#125;catch (Exception e)&#123;&#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;thread join&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">    a.start();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;a会在main线程之前执行</span><br><span class="line">    a.join();</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;main&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>join方法的底层是wait方法，调用A线程(子线程)的join方法实际上是让main线程wait， 等A线程执行完后，才能继续执行后面的代码。</strong>            </p><h4 id="yield方法"><a href="#yield方法" class="headerlink" title="yield方法"></a>yield方法</h4><p>yield属于Thread的静态方法， 它的作用是让当前线程让出cpu调度资源。</p><p>yield方法其实就和线程的优先级一样，你虽然指定了， 但是最后的结果不由得你说了算， <strong>即使调用了yield方法，最后仍然可能是这个线程先执行， 只不过说别的线程可能先执行的机会稍大一些。</strong></p><h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><h4 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h4><p>synchronized是jdk提供的jvm层面的同步机制。 <strong>它解决的是多线程之间访问共享资源的同步问题,它保证了 在被它修饰的方法或代码块同一时间只有一个线程执行。</strong></p><p>java6之前的synchronized属于重量锁,性能较差, 它是基于操作系统的Mutex Lock互斥量实现的。</p><p><strong>因为java线程是映射到操作系统的线程之上的, 所以暂停或唤醒线程都需要Java程序从用户态转换为内核态,这段转换时间消耗较长。</strong></p><blockquote><p>java6之后jvm团队对synchronized做出了非常大的优化。</p></blockquote><h4 id="synchronized底层原理"><a href="#synchronized底层原理" class="headerlink" title="synchronized底层原理"></a>synchronized底层原理</h4><p>先看我编写的一段测试代码:</p><p><img src="file://E:/%E5%B0%9A%E7%A1%85%E8%B0%B7java/JVMzhouyang/framework-learning/img/jdk-jvm-juc/synchronized%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%861.png?lastModify=1596340467" alt="synchronized底层原理1"></p><p>使用 javap -c 指令反编译 class文件后的 <strong>字节码指令</strong> 如下</p><p><img src="file://E:/%E5%B0%9A%E7%A1%85%E8%B0%B7java/JVMzhouyang/framework-learning/img/jdk-jvm-juc/synchronized%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%862.png?lastModify=1596340467" alt="synchronized底层原理2"></p><blockquote><p>可以清楚的看到,在进入synchronized的时候，底层字节码编译出来的指令为 <strong>monitorenter</strong>,在执行完同步代码块后又有一个<strong>monitorexit</strong>指令.</p></blockquote><p>想了解synchronized究竟是如何实现的,可以直接进入openjdk:src/share/vm/runtime 目录,这个目录存放的是hotspot虚拟机在运行时 所需的代码.</p><blockquote><p>可以直接锁定其中的 objectMonitor.cpp源文件和objectMonitor.hpp头文件. 看到这2个文件，相信各位同学应该就知道，这个就是synchronized锁对象的monitor，它也是 一个对象,不过它是一个c++对象(见:objectMonitor.hpp头文件):</p></blockquote><p><img src="file://E:/%E5%B0%9A%E7%A1%85%E8%B0%B7java/JVMzhouyang/framework-learning/img/jdk-jvm-juc/synchronized%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%863.png?lastModify=1596340467" alt="synchronized底层原理3"> </p><p><strong>其实真正的锁应该是这个monitor cpp对象,synchronized锁的那个java对象起到的只是关联monitor的作用, 只不过我们身在java层面，无法感知到jvm层面monitor的作用，所以才称synchronized的java锁对象为锁。</strong></p><p>以下是monitorenter指令执行过程(见 InterpreterRuntime.cpp):</p><p><img src="file://E:/%E5%B0%9A%E7%A1%85%E8%B0%B7java/JVMzhouyang/framework-learning/img/jdk-jvm-juc/synchronized%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%864.png?lastModify=1596340467" alt="synchronized底层原理4"></p><p>PS:本来想真正弄清楚fast_enter(偏向锁的实现),slow_enter(轻量级锁实现)和inflate(膨胀锁实现) 的,无奈暂时看不太懂cpp源码，但是有的地方是可以根据语义来推断的。</p><p>这里做一个总结吧,这个总结可能不太准确，但大致是这样的: <strong>每次执行monitorenter指令的时候,是将当前synchronized锁对象 关联的</strong>monitor<strong>的_recursions加1, 执行monitorexit指令的时候,将当前object对象关联的</strong>monitor<strong>的*recursions减1, 当*recursions为0的时候，就说明线程不再持有锁对象。</strong></p><p><strong>如果熟悉AQS原理的同学就知道在AQS内部， 有一个被volatile修饰state变量， 这个state变量就是AQS的核心， state变量的作用类比到此处就是monitor计数器的作用。</strong></p><h4 id="synchronized-使用方法"><a href="#synchronized-使用方法" class="headerlink" title="synchronized 使用方法"></a>synchronized 使用方法</h4><ol><li>修饰静态方法: 修饰静态方法是给类加锁,会作用于所有对象,因为静态方法属于类, 而不属于对象,不管有多少个对象,static方法都是共享的。</li><li>修饰实例方法: 修饰实例方法是给对象加锁,会作用于当前类的实例对象。</li><li>修饰代码块: 修饰代码块,根据代码块给定的对象加锁,线程想要进入代码块,只能获取指定的对象的锁。</li></ol><h4 id="Synchronized和ReentrantLock的区别"><a href="#Synchronized和ReentrantLock的区别" class="headerlink" title="Synchronized和ReentrantLock的区别"></a>Synchronized和ReentrantLock的区别</h4><ul><li>Synchronized是基于JVM层面的同步机制;而ReentrantLock是基于Java API层面提供的同步机制。</li><li>Synchronized和Reentrantlock都属于可重入锁。</li><li>ReentrantLock提供了比Synchronized更高级的功能:<ul><li>公平锁</li><li>更方便的线程间的通信(Condition)</li><li>等待可中断(在线程等待获取锁的时候可以被中断) </li></ul></li></ul><h4 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h4><p>乐观锁对共享的数据很乐观，认为不会发生线程安全的问题，从而不给数据加锁。 乐观锁适用于读多写少的环境。常见的例子就是mysql的更新使用version控制。</p><p><strong>CAS属于乐观锁。</strong></p><h4 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h4><p>悲观锁对共享的数据很悲观，认为无论什么时候都有可能发生线程安全的问题， 所以在每次读写数据的时候都会加锁。</p><p><strong>Synchronized属于悲观锁。</strong></p><h4 id="独占锁"><a href="#独占锁" class="headerlink" title="独占锁"></a>独占锁</h4><p>锁一次只能被一个线程占有使用。</p><p>Synchronized和ReetrantLock都是独占锁。    </p><h4 id="共享锁"><a href="#共享锁" class="headerlink" title="共享锁"></a>共享锁</h4><p>锁可以被多个线程持有。</p><p>对于ReentrantReadWriteLock而言,它的读锁是共享锁,写锁是独占锁。</p><h4 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h4><p>公平锁指根据线程在队列中的优先级获取锁,比如线程优先加入阻塞队列,那么线程就优先获取锁。</p><h4 id="非公平锁"><a href="#非公平锁" class="headerlink" title="非公平锁"></a>非公平锁</h4><p>非公平锁指在获取锁的时候,每个线程都会去争抢,并且都有机会获取到锁,无关线程的优先级。</p><h4 id="可重入锁-递归锁"><a href="#可重入锁-递归锁" class="headerlink" title="可重入锁(递归锁)"></a>可重入锁(递归锁)</h4><p>一个线程获取到锁后,如果继续遇到被相同锁修饰的资源,那么可以继续获取该锁。</p><p>Synchronized和Reentrantlock都是可重入锁。</p><h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><p>在线程获取偏向锁的时候, jvm会判断锁对象MarkWord里偏向线程的ID是否为当前线程ID。</p><p>如果是,则说明当前锁对象处于偏向状态。</p><p>如果不是,则jvm尝试CAS把对象的MarkWord的偏向线程ID设置为当前线程ID,</p><p>如果设置成功,那么对象偏向当前线程，并将当对象的锁标志位改为01。</p><p>如果设置失败，则说明多线程竞争，将撤销偏向锁，升级为轻量级锁。</p><p><strong>偏向锁适用于单线程无锁竞争环境(单线程环境)。</strong></p><p>hotspot偏向锁实现(faster_enter): <img src="file://E:/%E5%B0%9A%E7%A1%85%E8%B0%B7java/JVMzhouyang/framework-learning/img/jdk-jvm-juc/%E5%81%8F%E5%90%91%E9%94%81%E5%AE%9E%E7%8E%B0.png?lastModify=1596340467" alt="偏向锁实现"></p><h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h4><p>在线程获取对象锁时，jvm首先会判断对象是否为无锁状态(无锁状态标志位为01)。</p><p>如果对象是无锁状态，那么将在线程的栈帧中开辟一块空间用于存储对象的MarkWord， 然后将对象的MarkWord复制到栈帧空间去，并使用CAS更新对象的MarkWord为指向 线程栈帧的指针。</p><p>如果更新成功，那么当前线程获取锁成功，并修改对象的MarkWord标志位 为 00 。</p><p>如果更新失败，那么jvm会判断对象的MarkWord是否已经指向线程的栈帧。</p><p>如果已经指向，那么线程直接执行同步代码。否则，说明多个线程竞争，将inflate为重量级锁。</p><p><strong>轻量级锁适用于多线程无锁竞争环境(多线程轮流执行,并不会发生冲突)。</strong></p><p>hotspot轻量级锁实现(slow_enter): <img src="file://E:/%E5%B0%9A%E7%A1%85%E8%B0%B7java/JVMzhouyang/framework-learning/img/jdk-jvm-juc/%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%E5%AE%9E%E7%8E%B0.png?lastModify=1596340467" alt="轻量级锁实现">   </p><h4 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h4><p>在争夺锁的过程中，线程不会停止获取锁，而是通过CAS不断的判断线程是否符合获取锁的条件。</p><p><strong>AQS获取锁的核心就是CAS。</strong></p><h4 id="自适应自旋锁"><a href="#自适应自旋锁" class="headerlink" title="自适应自旋锁"></a>自适应自旋锁</h4><p>自旋锁意味着线程会不断的消耗cpu资源，短时间还行，长时间就意味着而资源的浪费。 所以自适应自旋锁会有一个自旋的生命周期,过了这个生命周期,线程将不再自旋。</p><p>网上有文章说这个生命周期依据前一个线程的自旋时间来决定，但是我暂且没有找到相关资料，不敢妄自揣测。</p><h4 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h4><p><strong>锁消除属于Java编译器对程序的一种优化机制。</strong> 锁消除是指当JVM的JIT编译器检测出一些已经加锁的代码不可能出现共享的数据存在竞争的问题， 会消除这样的锁。<strong>锁消除的依据来源于逃逸分析算法。</strong> 如果判断到一段代码，在堆上的数据不会逃逸出去被其他线程访问到， 那么就把它们当做栈上的数据，为线程私有的，自然无需同步加锁。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;每次线程进入此方法，创建的都是不同的StringBuffer临时对象,</span><br><span class="line">&#x2F;&#x2F;也就是说 StringBuffer 临时对象不会逃出方法t,作用于外部,</span><br><span class="line">&#x2F;&#x2F;所以根本不存在线程之间的竞争，那么JIT在编译时就会消除append方法的锁</span><br><span class="line">public String t(String s1, String s2,String s3)</span><br><span class="line">&#123;</span><br><span class="line">    return new StringBuffer().append(s1).append(s2)</span><br><span class="line">                .append(s3).toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h4><p>当虚拟机检测出一系列连续的操作都对同一个连续加锁， 那么它会把加锁的返回扩大至整个操作的序列的外部，保证只加锁一次。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public String t()</span><br><span class="line">&#123; </span><br><span class="line">    StringBuffer stringBuffer &#x3D; new StringBuffer();</span><br><span class="line">    for (int i &#x3D; 0 ; i &lt; 100 ; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F;append方法执行一百次,难道加100次锁?</span><br><span class="line">       stringBuffer.append(i);</span><br><span class="line">    &#125;</span><br><span class="line">    return stringBuffer.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;t方法经过优化后可能如下:</span><br><span class="line">public String t()</span><br><span class="line">&#123; </span><br><span class="line">    StringBuffer stringBuffer &#x3D; new StringBuffer();</span><br><span class="line">    &#x2F;&#x2F;把synchronized方法提升到for循环面，这样就避免了每次</span><br><span class="line">    &#x2F;&#x2F;append方法的同步</span><br><span class="line">    synchronized (stringBuffer)</span><br><span class="line">    &#123;</span><br><span class="line">       for (int i &#x3D; 0 ; i &lt; 100 ; ++i)</span><br><span class="line">       &#123;</span><br><span class="line">           stringBuffer.append(i);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return stringBuffer.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p><strong>死锁是指多个进程在执行过程中,循环等待彼此占有的资源而导致程序的无限期的阻塞的情况。</strong></p><p>产生死锁的条件:</p><ol><li>互斥条件: 一个资源在一段时间内只能被一个进程所持有。</li><li>不可抢占条件: 进程所持有的资源只能由进程自己主动释放,其他资源的申请者不能向进程持有者抢夺资源。</li><li>占有且申请条件: 进程已经持有一个资源后,又申请其他资源,但是其他资源已被其他线程所占有。</li><li>循环等待条件: 在条件3之上,进程1有进程2需要申请的资源,进程2有进程1需要申请的资源。那么这2个线程 不停等待彼此持有的资源,又不能释放已拥有的资源,陷入循环等待。</li></ol><p>死锁:</p><p><img src="file://E:/%E5%B0%9A%E7%A1%85%E8%B0%B7java/JVMzhouyang/framework-learning/img/jdk-jvm-juc/%E6%AD%BB%E9%94%81.png?lastModify=1596340467" alt="死锁"></p><h4 id="如何避免死锁"><a href="#如何避免死锁" class="headerlink" title="如何避免死锁?"></a>如何避免死锁?</h4><p>只要打破死锁产生的4个条件之一就行,但是真正能够被打破的条件只有第3和第4个条件。 因为第1和第2个条件都是锁的必要条件。</p><p>所以有如下解决死锁的方案:</p><ul><li><p>可以打破第3个条件: <strong>实现资源的有序分配。</strong> </p></li><li><p>可以打破第4个条件: <strong>设置等待超时时间。</strong></p><p>​    </p></li></ul><h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><p>volatile是JVM提供的轻量级的线程同步机制。它可以保证内存的可见性，禁止指令重排序。 但是volatile，并不能保证数据的原子性，所以它不合适作为线程同步的工具。</p><h4 id="volatile保证内存的可见性"><a href="#volatile保证内存的可见性" class="headerlink" title="volatile保证内存的可见性"></a>volatile保证内存的可见性</h4><p>可见性是指一个线程的对于共享数据的修改对其他线程是可见的。 jvm的内存模型是: <strong>线程总是从主内存读取变量到工作内存，然后在工作内存中进行修改， 在修改完变量后，才把变量同步到主内存中。</strong> 如果多个线程同时读取了一个变量到各自的内存中，其中一个线程对变量进行了修改，并同步回了主内存， 但其它线程仍然使用的是原来的旧值，这就造成了数据的不一致。</p><p><img src="file://E:/%E5%B0%9A%E7%A1%85%E8%B0%B7java/JVMzhouyang/framework-learning/img/jdk-jvm-juc/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.png?lastModify=1596340467" alt="Java内存模型"></p><p>解决这个问题的办法就是给变量加上volatile关键字修饰。 volatile使得被它修饰的变量在被线程修改后，那么线程就需要把修改后的变量重新同步到主内存， 且其他线程每次使用这个变量，都需要从主内存读取。</p><h4 id="volatile禁止指令重排序"><a href="#volatile禁止指令重排序" class="headerlink" title="volatile禁止指令重排序"></a>volatile禁止指令重排序</h4><p>指令重排序是编译器和cpu为了程序的高效运行的一种优化手段, <strong>指令重排序只能保证程序执行的结果是正确的，但是无法保证程序指令运行的顺序是否与代码的顺序一致, volatile就禁止了这种重排序。</strong></p><p>比如: </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. int a &#x3D; 1;</span><br><span class="line">2. int b &#x3D; 3;</span><br><span class="line">3. int c &#x3D; a + b;</span><br></pre></td></tr></table></figure><p>上面的代码在编译后,指令执行的顺序可能有: 1,2,3和2,1,3 这样程序实际执行的顺序可能与代码的顺序不符,但并不会影响程序最终的结果。</p><h4 id="volatile如何禁止指令重排序的"><a href="#volatile如何禁止指令重排序的" class="headerlink" title="volatile如何禁止指令重排序的?"></a>volatile如何禁止指令重排序的?</h4><p><strong>volatile通过提供内存屏障来防止指令重排序。 java内存模型会在每个volatile写操作前后都会插入store指令，将工作内存中的变量同步回主内存。 在每个volatile读操作前后都会插入load指令，从主内存中读取变量。</strong></p><h4 id="volatile不保证原子性"><a href="#volatile不保证原子性" class="headerlink" title="volatile不保证原子性"></a>volatile不保证原子性</h4><blockquote><p>比如: i++</p></blockquote><p>如果是多线程环境下，一个线程读取到i的值到工作内存，然后对i做出自增操作， 然后写回主内存，其它内存才知道i的值被修改了，这个过程本身就不是原子的。 所以不能拿volatile来带替synchronized,如果是多线程环境，仍然需要使用synchronized保证线程同步。</p><h3 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h3><p>CAS: Compare And Swap 比较成功并交换。 CAS体现的是一种乐观锁的机制。 <strong>CAS涉及到3个元素: 指定的内存地址,期盼值和目标值。</strong> 将指定内存地址的值与期盼值相比较，如果比较成功就将内存地址的值修改为目标值。</p><h4 id="CAS在JAVA中的底层实现-Atomic原子类实现"><a href="#CAS在JAVA中的底层实现-Atomic原子类实现" class="headerlink" title="CAS在JAVA中的底层实现(Atomic原子类实现)"></a>CAS在JAVA中的底层实现(Atomic原子类实现)</h4><p>CAS在Java中的实现是 juc的atomic包下的Atomicxx原子类。</p><p>而这些Atomic原子类的核心是: <Unsafe>类 Unsafe类是个final类，它的核心方法都是native的， 因为Java无法像C/C++一样使用指针来操作内存, Unsafe类就解决了这个问题。</p><blockquote><p>拿incrementAndGet方法来说， Unsafe首先调用getAndAddInt方法, 它会根据当前Atomic的value在内存中的地址，获取到当前对象的值, 然后再重复此操作，把之前获得的值与第二次获得的值进行比较， 如果成功，就把内存地址的值更新为新值，否则就do while循环重复比较。</p></blockquote><p><strong>并且有个重要的细节就是,Atomic原子类内部的value值都是由volatile修饰的, 这就使得Atomic的value值是对其他线程可见的。</strong></p><h4 id="CAS的缺点"><a href="#CAS的缺点" class="headerlink" title="CAS的缺点"></a>CAS的缺点</h4><ul><li>循环时间开销大: 我在看源码的时候，发现Atomic的CAS操作并没有进行CAS失败的退出处理， 只是单纯的循环比较并交换，这就让我很担心它的性能问题， 如果长时间不成功，那会是很可怕的一件事请，至少cpu的负荷会很大。</li><li>只能保证一个共享变量的原子操作: Atomic原子类只能保证一个变量的原子操作， 如果是多数据的话，还是考虑用互斥锁来实现数据的同步吧</li><li>ABA问题: ABA问题是指如果一个线程进行CAS操作并成功了，却不代表这个过程就是没有问题的。</li></ul><blockquote><blockquote><p>假设2个线程读取了同一份数据，线程1修改了这个值并把它改回了原值，并同步到主内存中， 另一个线程准备进行CAS操作,当它发现原值和期盼的值是一样的，那么CAS仍然成功。</p></blockquote></blockquote><h4 id="解决ABA问题"><a href="#解决ABA问题" class="headerlink" title="解决ABA问题"></a>解决ABA问题</h4><p>在juc的atomic包中提供了 AtomicStampedReference 类, 这个类较普通的原子类新增了一个stamp字段，它的作用相当于version。 每次修改这个引用的值，也都会修改stamp的值， 当发现stamp的值与期盼的stamp不一样，也会修改失败. 这就类似于以version实现乐观锁一样。                      </p><h4 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h4><p>ThreadLocal为每个线程都提供了一份相同的变量的副本， 每个线程都可以修改这个副本，但不用担心与其他线程发生数据冲突， 实现了线程之间的数据隔离。</p><p>ThreadLocal的原理还得从Thread线程类说起， <strong>每个Thread类内部都有一个ThreadLocalMap，当使用ThreadLocal的get和remove操作的时候， 就是使用每个线程的ThreadLocalMap的get和remove。</strong></p><h4 id="ThreadLocal引发的内存泄露"><a href="#ThreadLocal引发的内存泄露" class="headerlink" title="ThreadLocal引发的内存泄露"></a>ThreadLocal引发的内存泄露</h4><p><strong>在ThreadLocalMap中，key是使用弱引用的ThreadLocal存储的。</strong> 弱引用是只要垃圾回收器开始回收，无论内存是否充足，都会回收掉弱引用对象，如此一来， 当ThreadLocal被回收掉,那么ThreadLocalMap将可能出现Null Key 的 value。但是也不必太过担心， 因为设计者已经想到了这点，所以ThreadLocal会自动处理key 为 null的 value。</p><h4 id="线程池的好处"><a href="#线程池的好处" class="headerlink" title="线程池的好处"></a>线程池的好处</h4><blockquote><p>http连接池，数据库连接池，线程池等都是利用了池化技术。 如果一个资源需要多次使用并且很昂贵，那么使用new创建的对象或资源，可能会带来较大的消耗。</p></blockquote><p>池化技术的好处在于</p><ol><li>方便资源的管理，无需显示的使用new创建。</li><li>降低了资源的消耗，在池子里的资源可以重复利用</li><li>提供了任务的响应速度，任务可以很快的被分配资源进行处理。</li></ol><h4 id="线程池构造参数"><a href="#线程池构造参数" class="headerlink" title="线程池构造参数"></a>线程池构造参数</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> new ThreadPoolExecutor</span><br><span class="line">(int corePoolSize,</span><br><span class="line"></span><br><span class="line"> int maximumPoolSize, </span><br><span class="line"></span><br><span class="line"> long keepAliveTime,</span><br><span class="line"></span><br><span class="line"> TimeUnit unit,</span><br><span class="line"></span><br><span class="line"> BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="line"></span><br><span class="line"> ThreadFactory threadFactory,</span><br><span class="line"></span><br><span class="line"> RejectedExecutionHandler handler)</span><br></pre></td></tr></table></figure><ol><li>corePoolSize: 线程池的核心线程数(常驻线程数),也就是线程池的最小线程数,这部分线程不会被回收.</li><li>maximumPoolSize: 线程池最大线程数,线程池中允许同时执行的最大线程数量</li><li>keepAliveTime: 当线程池中的线程数量超过corePoolSize，但此时没有任务执行， 那么空闲的线程会保持keepAliveTime才会被回收，corePoolSize的线程不会被回收。</li><li>unit: KeepAliveTime的时间单位</li><li>workQueue: 当线程池中的线程达到了corePoolSize的线程数量， 并仍然有新任务，那么新任务就会被放入workQueue。          </li><li>threadFactory: 创建工作线程的工厂,也就是如何创建线程的,一般采用默认的</li><li>handler: 拒绝策略，当线程池中的工作线程达到了最大数量， 并且阻塞队列也已经满了，那么拒绝策略会决定如何处理新的任务。ThreadPoolExecutor 提供了四种策略:<ul><li>AbortPolicy(是线程池的默认拒绝策略): 如果使用此拒绝策略，那么将对新的任务抛出RejectedExecutionException异常，来拒绝任务。</li><li>DiscardPolicy: 如果使用此策略，那么会拒绝执行新的任务，但不会抛出异常。</li><li>DiscardOldestPolicy: 如果使用此策略，那么不会拒绝新的任务，但会抛弃阻塞队列中等待最久的那个线程。     </li><li>CallerRunsPolicy: 如果使用此策略，不会拒绝新的任务，但会让调用者执行线程。 也就是说哪个线程发出的任务，哪个线程执行。</li></ul></li></ol><h4 id="阿里巴巴开发者手册不建议开发者使用Executors创建线程池"><a href="#阿里巴巴开发者手册不建议开发者使用Executors创建线程池" class="headerlink" title="阿里巴巴开发者手册不建议开发者使用Executors创建线程池"></a>阿里巴巴开发者手册不建议开发者使用Executors创建线程池</h4><p><strong>newFixedThreadPool和newSingleThreadPoolExecutor都是创建固定线程的线程池, 尽管它们的线程数是固定的，但是它们的阻塞队列的长度却是Integer.MAX_VALUE的,所以， 队列的任务很可能过多，导致OOM。</strong></p><p><strong>newCacheThreadPool和newScheduledThreadPool创建出来的线程池的线程数量却是Integer.MAX_VALUE的， 如果任务数量过多,也很可能发生OOM。</strong></p><h3 id="AQS-AbstractQueuedSynchronizer"><a href="#AQS-AbstractQueuedSynchronizer" class="headerlink" title="AQS(AbstractQueuedSynchronizer)"></a>AQS(AbstractQueuedSynchronizer)</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AQS是Doug Lea大师为JDK编写的一套基于API层面的抽象队列同步器.</span><br><span class="line">AbstractQueuedSynchronizer,抽象队列同步器.</span><br><span class="line">Lock,CountDownLatch等等这些并发工具都是基于AQS来实现的。</span><br><span class="line">由此可以看出Doug Lea大师的功力已经臻至化境</span><br></pre></td></tr></table></figure><h4 id="AQS概述"><a href="#AQS概述" class="headerlink" title="AQS概述"></a>AQS概述</h4><p><strong>AQS的核心思想是如果被请求的资源空闲，那么就将当前请求资源的线程设置为有效的工作线程; 如果请求的资源被其他线程所占有， 那么就使用CLH线程阻塞队列来提供阻塞线程并唤线程分配资源的机制。 在CLH队列中，每个请求资源的线程都会被封装成队列中的一个节点。</strong></p><p><strong>在AQS内部有一个int类型的state表示线程同步状态， 当线程lock获取到锁后，该state计数就加1,unlock就减1， 这就是为什么解锁次数要对应加锁次数的原因。</strong></p><p><strong>AQS主要实现技术为:CLH队列(Craig,Landin and Hagersten)， 自旋CAS，park(阻塞线程)以及unparkSuccessor(唤醒阻塞队列中的后继线程)。</strong>     </p><h4 id="AQS的两种共享资源的访问方式"><a href="#AQS的两种共享资源的访问方式" class="headerlink" title="AQS的两种共享资源的访问方式"></a>AQS的两种共享资源的访问方式</h4><blockquote><p>AQS定义了两种共享资源方式.</p></blockquote><ol><li>独占式(Exclusive): <strong>同一时间只有一个线程可以访问共享资源,也就是独占锁。</strong> 如:Synchronized,ReentrantLock。 <strong>对于独占式锁的实现,在AQS中对应tryAcquire获取锁和tryRelease释放锁。</strong>       </li></ol><ul><li>共享式(Share): <strong>同一时间允许多个线程同时访问共享资源,也就是共享锁。</strong> CountDownLatch,Semaphore,ReentrantReadWriteLock的ReadLock都是共享锁。 <strong>对于共享式锁的实现,在AQS中对应tryAcquireShare获取锁和tryReleaseShare释放锁。</strong></li></ul><h4 id="lock-tryLock和lockInterruptibly区别"><a href="#lock-tryLock和lockInterruptibly区别" class="headerlink" title="lock,tryLock和lockInterruptibly区别"></a>lock,tryLock和lockInterruptibly区别</h4><p><strong>PS: AQS中的锁计数指的是 state 变量。</strong></p><ul><li>lock: 如果线程获取到了锁或线程已经拥有了锁就更改锁计数， 否则线程就加入阻塞队列并一直CAS自旋获取。</li><li>tryLock: 线程尝试获取锁，如果线程获取到了锁或线程已经拥有了锁就更改锁计数，否则返回false。</li><li>lockInterruptibly: 如果线程在获取锁之前被设置了中断状态，那么当线程获取锁时就会响应中断状态， 抛出InterruptedException异常。如果获取不到就加入阻塞队列并自旋获取，并且阻塞自旋期间还会响应中断， 也就是说在阻塞自旋期间可能抛出InterruptedException异常。 <strong>所以lockInterruptibly优先响应中断，而不是优先获取锁。</strong>  如果线程获取到了锁或线程已经拥有了锁才更改锁计数。</li></ul><h4 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h4><blockquote><p>CountDownLatch允许count个线程阻塞在一个地方，直至所有线程的任务都执行完毕。</p></blockquote><p>CountDownLatch是共享锁的一种实现,<strong>它默认构造AQS的state为count。 当线程使用countDown方法时,其实使用了tryReleaseShared方法以CAS的操作来减少state, 直至state为0就代表所有的线程都调用了countDown方法。</strong> 假如某线程A调用await方法时，如果state不为0，就代表还有线程未执行countDown方法， 那么就把线程A放入阻塞队列Park，并自旋CAS判断state == 0。 直至最后一个线程调用了countDown，使得state == 0， 于是阻塞的线程判断成功，并被唤醒，就继续往下执行。</p><h4 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h4><blockquote><p>Semaphore允许一次性最多(不是同时)permits个线程执行任务。</p></blockquote><p>Semaphore与CountDownLatch一样，也是共享锁的一种实现。 <strong>它默认构造AQS的state为permits。 当执行任务的线程数量超出permits,那么多余的线程将会被放入阻塞队列Park,并自旋判断state是否大于0。 只有当state大于0的时候，阻塞的线程才有机会继续执行,此时先前执行任务的线程继续执行release方法， release方法使得state的变量会加1，那么自旋的线程便会判断成功。</strong></p><p>如此，<strong>每次只有不超过permits个的线程能自旋成功，便限制了执行任务线程的数量。</strong> 所以这也是我为什么说它可能不是permits个线程同时执行， 因为只要state&gt;0,线程就有机会执行.</p><h4 id="CycliBarrier"><a href="#CycliBarrier" class="headerlink" title="CycliBarrier"></a>CycliBarrier</h4><p>CycliBarrier的功能与CountDownLatch相似，但是<strong>CountDownLatch的实现是基于AQS的， 而CycliBarrier是基于ReentrantLock(ReentrantLock也属于AQS同步器)和Condition的。</strong></p><p>CountDownLatch虽然可以令多个线程阻塞在同一代码处，但只能await一次就不能使用了。 而CycliBarrier有Generation代的概念，一个代，就代表CycliBarrier的一个循环， 这也是CycliBarrier支持重复await的原因。 </p><h4 id="ReentrantReadWriteLock如何区分读写锁的"><a href="#ReentrantReadWriteLock如何区分读写锁的" class="headerlink" title="ReentrantReadWriteLock如何区分读写锁的?"></a>ReentrantReadWriteLock如何区分读写锁的?</h4><p><strong>Sync既有写锁，又有读锁，因此一个state不够用， 所以使用state的高16位表示读锁，低16位表示写锁.</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> ReentrantReadWriteLock部分源码:</span><br><span class="line"></span><br><span class="line"> static final int SHARED_SHIFT   &#x3D; 16;</span><br><span class="line"> static final int SHARED_UNIT    &#x3D; (1 &lt;&lt; SHARED_SHIFT);</span><br><span class="line"> static final int MAX_COUNT      &#x3D; (1 &lt;&lt; SHARED_SHIFT) - 1;</span><br><span class="line"> static final int EXCLUSIVE_MASK &#x3D; (1 &lt;&lt; SHARED_SHIFT) - 1;</span><br><span class="line"></span><br><span class="line"> &#x2F;** Returns the number of shared holds represented in count. *&#x2F;</span><br><span class="line"> static int sharedCount(int c)    &#123; return c &gt;&gt;&gt; SHARED_SHIFT; &#125;</span><br><span class="line"> &#x2F;** Returns the number of exclusive holds represented in count. *&#x2F;</span><br><span class="line"> static int exclusiveCount(int c) &#123; return c &amp; EXCLUSIVE_MASK; &#125;</span><br><span class="line">剩下的就读源码吧。</span><br></pre></td></tr></table></figure><p>其实吧，在我读了几遍源码后,才发现jdk的源码不算特别难阅读。</p><p>但是像我在读SpringBoot的源码时，我就只能分析个大概。</p><p>主要是Jdk的源码之间并没有什么耦合性，你看一个jdk的类，不像Spring的源码那样绕来绕去， 各种设计模式搞得你头晕。 所以我建议阅读源码可以从jdk的源码开始，前提是你需要一定的基础才能看得懂。 比如我这个版本(11)就发现AQS的部分源码与之前版本的源码不同。 这个版本的AQS使用了: VarHandle 这个类来设置Node类内部的属性， 而之前都是直接使用构造方法来构造Node的。 并且AQS使用的是LockSupport来阻塞线程的，LockSupport仍然使用的是Unsafe类来进行操作的, 这些都属于java与c/c++交互的类,所以你如果没有基础，会诧异,jdk还有这种东西呀 ^-^…            </p><h2 id="Java集合"><a href="#Java集合" class="headerlink" title="Java集合"></a>Java集合</h2><h4 id="HashMap的特点"><a href="#HashMap的特点" class="headerlink" title="HashMap的特点"></a>HashMap的特点</h4><ul><li>HashMap在Jdk8之前使用拉链法实现,jdk8之后使用拉链法+红黑树实现。</li><li>HashMap是线程不安全的,并允许null key 和 null value。**</li><li>HashMap在我当前的jdk版本(11)的默认容量为0,在第一次添加元素的时候才初始化容量为 16, 之后才扩容为原来的2倍。</li><li>HashMap的扩容是根据 threshold决定的 : threshold = loadFactor * capacity。  当 size 大于 threshold 时,扩容。</li><li><strong>当每个桶的元素数量达到默认的阈值TREEIFY_THRESHOLD(8)时，HashMap会判断当前数组的 长度是否大于MIN_TREEIFY_CAPACITY(64),如果大于，那么这个桶的链表将会转为红黑树，否则HashMap将会扩容。 当红黑树节点的数量小于等于默认的阈值UNTREEIFY_THRESHOLD(6)时，那么在扩容的时候，这个桶的红黑树将转为链表。</strong></li></ul><h4 id="HashMap的长度-容量-为什么要设计成2的幂？"><a href="#HashMap的长度-容量-为什么要设计成2的幂？" class="headerlink" title="HashMap的长度(容量)为什么要设计成2的幂？"></a>HashMap的长度(容量)为什么要设计成2的幂？</h4><blockquote><p>这就不得不佩服大师们的设计。</p></blockquote><p>想想看，一个对象的hashcode是很大的，当HashMap的容量仅为16,32时， 如何根据hashcode来确定key在数组中的下标。 一个好的办法就是取余: hashcode % length。 这样就能确保，key的下标是永远不会超过数组的长度的。 但是想想，除了取余有没有更好的办法，</p><p>当然有:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hash % length &#x3D;&#x3D; hash &amp; (length - 1)</span><br></pre></td></tr></table></figure><p>为什么上面这个性能超高的等式成立，当然是有条件的，</p><p><strong>只有当length为2的幂的时候这样的等式才成立,</strong> 这就明白了为什么使用2的幂来定义HashMap的长度。</p><h4 id="HashTable的特点"><a href="#HashTable的特点" class="headerlink" title="HashTable的特点"></a>HashTable的特点</h4><ul><li>HashTable底层使用拉链法实现。</li><li>HashTable就像Vector一样,也是jdk1就存在的很古老的一个类，它是线程安全的， 实现线程安全的手段是使用synchronized。</li><li>HashTable的默认容量为16，每次扩容为原来的2倍+1。</li><li>HashTable不允许null key 和 null value。</li></ul><h4 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h4><p><strong>TreeMap使用红黑树实现,不允许null key,允许自然排序Comparable和比较器Comparator排序。</strong></p><h4 id="ArrayList的特点"><a href="#ArrayList的特点" class="headerlink" title="ArrayList的特点"></a>ArrayList的特点</h4><ul><li>ArrayList底层使用Object数组实现。</li><li>ArrayList的容量默认为0,只有在第一次执行add操作时才会初始化容量为10，正常的扩容是为原来的1/2倍。</li><li>由于ArrayList采用数组实现,它的容量是固定的,所以当添加新元素的时候,如果超出了数组的容量, 那么此时add操作的时间复杂度将会是O(n-1)。</li><li>ArrayList实现了RandomAccess接口，该接口没有具体的规范，只是一个标记， 这代表ArrayList支持快速的随机访问。</li><li>ArrayList在内存空间利用率上肯定是不如LinkedList的， 因为数组是一片固定的连续的内存空间，一旦分配就无法改变， 所以难免会有空间不足或空间使用率很低的情况。</li></ul><h4 id="Vector的特点"><a href="#Vector的特点" class="headerlink" title="Vector的特点"></a>Vector的特点</h4><ol><li>ArrayList是线程不安全的，Vector是线程安全的， 但Vector实现线程安全的手段是synchronized。这就好比HashMap与HashTable的区别。</li><li>Vector默认容量为10。</li><li>Vector是当它的扩容增量大于0时，会扩容为原来的容量+扩容增量，否则扩容为原来的2倍。</li></ol><h4 id="LinkedList的特点"><a href="#LinkedList的特点" class="headerlink" title="LinkedList的特点"></a>LinkedList的特点</h4><ul><li>LinkedList底层使用<strong>双端链表</strong>实现。</li><li>LinkedList的add操作只需要改变尾节点的引用就行了。 但是如果需要在指定位置进行add操作的话，那么时间复杂度也是比较高的,为O(n)， 因为需要从头节点或尾节点遍历到需要操作的节点。</li><li>LinkedList的空间利用率虽然很高，但是它的每个Node可以说也是占用了较大空间的， 因为每个Node需要保存它的前继和后继节点。</li><li>LinkedList不仅是List，还是Queue，Deque，还可作为Stack使用。</li></ul><p><strong>PS: 双端链表与双向链表的区别: 双端链表:每个Node都保存了前后2个节点的引用，双向链表的first节点的前一个节点为null, last节点的后一个节点为null。</strong></p><p><strong>双向链表: 每个Node都保存了前后2个节点的引用， 双向链表的first节点的前一个节点指向last节点， last节点的最后一个节点指向first节点。</strong></p><h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><p>为啥不单独说HashSet，我目前看到的JDK所有的Set,都是使用Map实现的, 除了CopyOnWriteArraySet(底层是CopyOnWriteArrayList)。</p><p>TreeSet –&gt; TreeMap</p><p>LinkedHashSet –&gt; LinkedHashMap</p><p>HashSet –&gt; HashMap</p><p>ConcurrentSkipListSet –&gt; ConcurrentSkipListMap</p><p>Set是如何保证元素不会重复,这个得看各自Map的实现了。</p><p>拿HashMap来讲，它先判断key的hash是否相等，然后才使用equals判断2个对象是否相等。</p><h4 id="ConcurrentModificationException异常"><a href="#ConcurrentModificationException异常" class="headerlink" title="ConcurrentModificationException异常"></a>ConcurrentModificationException异常</h4><p>ConcurrentModificationException可以从名字看出是并发修改的异常。</p><p>但我要说的是<strong>这个异并不是在修改的时候会抛出的，而是在调用迭代器遍历集合的时候才会抛出。</strong></p><p>而集合类的大部分toString方法，都是使用迭代器遍历的。<strong>所以如果多线程修改集合后， 接着就遍历集合，那么很有可能会抛出ConcurrentModificationException。</strong></p><p><strong>在ArrayList，HashMap等非线程安全的集合内部都有一个modCount变量， 这个变量是在集合被修改时(删除，新增)，都会被修改。</strong></p><p>如果是多线程对同一个集合做出修改操作，就可能会造成modCount与实际的操作次数不符， 那么最终在调用集合的迭代方法时，modCount与预期expectedModeCount比较， expectedModCount是在迭代器初始化时使用modCount赋值的， <strong>如果发现modCount与expectedModeCount不一致，就说明在使用迭代器遍历集合期间， 有其他线程对集合进行了修改,所以就会抛出ConcurrentModificationException异常。</strong></p><h4 id="线程安全的-List"><a href="#线程安全的-List" class="headerlink" title="线程安全的 List"></a>线程安全的 List</h4><ol><li>使用集合工具类Collections的 synchronizedList把普通的List转为线程安全的List.(不推荐)</li><li>使用Vector.(不推荐)</li><li>使用CopyOnWriteArrayList,推荐使用此种方法，因为以上2种全部都是单纯的Synchronized加锁.</li></ol><h4 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h4><p>CopyOnWriteArrayList是线程安全的ArrayList，可以被称为写时复制的ArrayList。 CopyOnWriteArrayList底层仍然使用数组实现， 但是它的修改操作(增删改)采用synchronized关键字保证并发的安全性， 然后<strong>在进行修改的时候复制原来的数组到一个新副本，对新副本进行修改，修改完后再设置原数组。</strong> 这样就不会让写操作影响读操作了。 </p><p><strong>但是CopyOnWriteArrayList不容忽视的缺点就是修改操作比较消耗内存空间，所以它适用于读多写少的环境。</strong></p><h4 id="线程安全的Set"><a href="#线程安全的Set" class="headerlink" title="线程安全的Set"></a>线程安全的Set</h4><ol><li>使用集合工具类的Collections的synchronizedSet把普通的set转为线程安全的set(不推荐)</li><li>使用CopyOnWriteArraySet,此set适用于读多写少的情况，它的底层采用CopyOnWriteArrayList实现.</li><li>使用ConcurrentSkipListSet，底层采用ConcurrentSkipListMap实现</li></ol><h4 id="线程安全的Map"><a href="#线程安全的Map" class="headerlink" title="线程安全的Map"></a>线程安全的Map</h4><ol><li>使用集合工具类Collections的synchronizedMap把普通map转为线程安全的map(不推荐)</li><li>HashTable(不推荐)</li><li>使用ConcurrentHashMap(常用)</li><li>ConcurrentSkipListMap(跳表map,推荐)</li></ol><h4 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h4><p>ConcurrentHashMap使用数组+链表/红黑树实现,其扩容机制与HashMap一样。</p><p><strong>但是ConcurrentHashMap控制并发的方法改为了CAS+synchronized, synchronized锁的只是链表的首节点或红黑树的首节点。</strong></p><p><strong>PS:我只看了常用的put,get,remove等核心方法的源码. 整个ConcurrentHashMap的实现用”复杂”来形容一点也不为过, 你只要想到它内部有52个内部类就知道有多复杂了,但如果不考虑并发CAS这部分， ConcurrentHashMap和普通的HashMap的差别是不大的。</strong></p><h4 id="ConcurrentSkipListMap"><a href="#ConcurrentSkipListMap" class="headerlink" title="ConcurrentSkipListMap"></a>ConcurrentSkipListMap</h4><p>ConcurrentSkipListMap是基于跳表这种数据结构实现的。 跳表比较特殊，它由多个层次的链表组成，每层链表又有多个索引节点连接， 每层链表的元素也都是有序的。处于上层索引的链表都是下层链表的子集。 跳表与普通链表相比查找元素的效率更高。</p><p><img src="file://E:/%E5%B0%9A%E7%A1%85%E8%B0%B7java/JVMzhouyang/framework-learning/img/jdk-jvm-juc/%E8%B7%B3%E8%A1%A8.png?lastModify=1596340467" alt="跳表"></p><h2 id="Java-IO"><a href="#Java-IO" class="headerlink" title="Java IO"></a>Java IO</h2><h3 id="操作系统的内核"><a href="#操作系统的内核" class="headerlink" title="操作系统的内核"></a>操作系统的内核</h3><p>操作系统的内核是操作系统的核心部分。 它负责系统的内存管理，硬件设备的管理，文件系统的管理以及应用程序的管理。</p><p><strong>IO图源: <a href="https://www.jianshu.com/p/85e931636f27" target="_blank" rel="noopener">简书</a> (如有侵权,请联系俺,俺会立刻删除)</strong></p><h4 id="操作系统的用户态与内核态"><a href="#操作系统的用户态与内核态" class="headerlink" title="操作系统的用户态与内核态"></a>操作系统的用户态与内核态</h4><p>unix与linux的体系架构：分为用户态与内核态。 用户态与内核态与内核态是操作系统对执行权限进行分级后的不同的运行模式。</p><p><img src="file://E:/%E5%B0%9A%E7%A1%85%E8%B0%B7java/JVMzhouyang/framework-learning/img/jdk-jvm-juc/%E7%94%A8%E6%88%B7%E6%80%81%E4%B8%8E%E5%86%85%E6%A0%B8%E6%80%81.png?lastModify=1596340467" alt="用户态与内核态"></p><h4 id="为什么要有用户态与内核态"><a href="#为什么要有用户态与内核态" class="headerlink" title="为什么要有用户态与内核态?"></a>为什么要有用户态与内核态?</h4><p>在cpu的所有指令中，有些指令是非常危险的，如果使用不当，将会造成系统崩溃等后果。 为了避免这种情况发生，cpu将指令划分为<strong>特权级(内核态)指令</strong>和<strong>非特权级(用户态)指令。</strong></p><p><strong>对于那些危险的指令只允许内核及其相关模块调用，对于那些不会造成危险的指令，就允许用户应用程序调用。</strong></p><ul><li>内核态(核心态,特权态): <strong>内核态是操作系统内核运行的模式。</strong> 内核态控制计算机的硬件资源，如硬件设备，文件系统等等，并为上层应用程序提供执行环境。</li><li>用户态: <strong>用户态是用户应用程序运行的状态。</strong> 应用程序必须依托于内核态运行,因此用户态的态的操作权限比内核态是要低的， 如磁盘，文件等，访问操作都是受限的。</li><li>系统调用: 系统调用是操作系统为应用程序提供能够访问到内核态的资源的接口。</li></ul><h4 id="用户态切换到内核态的几种方式"><a href="#用户态切换到内核态的几种方式" class="headerlink" title="用户态切换到内核态的几种方式"></a>用户态切换到内核态的几种方式</h4><ul><li>系统调用: 系统调用是用户态主动要求切换到内核态的一种方式， 用户应用程序通过操作系统调用内核为上层应用程序开放的接口来执行程序。</li><li>异常: 当cpu在执行用户态的应用程序时，发生了某些不可知的异常。 于是当前用户态的应用进程切换到处理此异常的内核的程序中去。</li><li>硬件设备的中断: 当硬件设备完成用户请求后，会向cpu发出相应的中断信号， 这时cpu会暂停执行下一条即将要执行的指令，转而去执行与中断信号对应的应用程序， 如果先前执行的指令是用户态下程序的指令，那么这个转换过程也是用户态到内核台的转换。</li></ul><h4 id="阻塞和非阻塞"><a href="#阻塞和非阻塞" class="headerlink" title="阻塞和非阻塞"></a>阻塞和非阻塞</h4><ol><li>阻塞: 一个线程调用一个方法计算 1 - 100 的和，如果该方法没有返回， 那么调用的线程就一直等待该方法返回，不继续往下执行。</li><li>非阻塞: 一个线程调用一个方法计算 1 - 100的和，如果该方法没有返回， 调用者线程也无需一直等待该方法返回，可以执行其他任务，但是线程仍然需要不断检查方法是否返回。</li></ol><p><strong>结论: 阻塞与非阻塞针对调用者的立场而言。</strong></p><h4 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h4><ol><li>同步: 一个线程调用一个方法计算 1 - 100 的和，如果方法没有计算完，就不返回。</li><li>异步: 一个线程调用一个方法计算 1 - 100 的和，该方法立刻返回，但是由于方法没有返回结果， 所以就需要被调用的这个方法来通知调用线程 1 - 100的结果， 或者线程在调用方法的时候指定一个回调函数来告诉被调用的方法执行完后就执行回调函数。</li></ol><p><strong>结论:同步和异步是针对被调用者的立场而言的。</strong></p><h3 id="Linux-IO模型"><a href="#Linux-IO模型" class="headerlink" title="Linux IO模型"></a>Linux IO模型</h3><p>Linux下共有5种IO模型:</p><ol><li>阻塞IO</li><li>非阻塞IO</li><li>IO多路复用</li><li>信号驱动IO</li><li>异步IO</li></ol><h4 id="阻塞IO"><a href="#阻塞IO" class="headerlink" title="阻塞IO"></a>阻塞IO</h4><p>阻塞IO是很常见的一种IO模型。 在这种模型中，<strong>用户态的应用程序会执行一个操作系统的调用， 检查内核的数据是否准备好。如果内核的数据已经准备好， 就把数据复制到用户应用进程。如果内核没有准备好数据， 那么用户应用进程(线程)就阻塞，直到内核准备好数据并把数据从 内核复制到用户应用进程，</strong> 最后应用程序再处理数据。</p><p><img src="file://E:/%E5%B0%9A%E7%A1%85%E8%B0%B7java/JVMzhouyang/framework-learning/img/jdk-jvm-juc/BIO%E5%8E%9F%E7%90%86.png?lastModify=1596340467" alt="BIO原理"></p><p><strong>阻塞IO是同步阻塞的。</strong></p><ol><li>阻塞IO的同步体现在: <strong>内核只有准备好数据并把数据复制到用户应用进程才会返回。</strong></li><li>阻塞IO的阻塞体现在:<strong>用户应用进程等待内核准备数据和把数据从用户态拷贝到内核态的这2段时间。</strong> 当然,如果是本地磁盘IO,内核准备数据的时间可能会很短。 但网络IO就不一样了，因为服务端不知道客户端何时发送数据， 内核就仍需要等待socket数据，时间就可能会很长。</li></ol><blockquote><p><strong>阻塞IO的优点是对于数据是能够保证无延时的，因为应用程序进程会一直阻塞直到IO完成。</strong> 但应用程序的阻塞就意味着应用程序进程无法执行其他任务， 这会大大降低程序性能。一个不太可行的办法是为每个客户端socket都分配一个线程， 这样就会提升server处理请求的能力。不过操作系统的线程资源是有限的， 如果请求过多，可能造成线程资源耗尽，系统卡死等后果。</p></blockquote><h4 id="非阻塞IO-网络IO模型"><a href="#非阻塞IO-网络IO模型" class="headerlink" title="非阻塞IO(网络IO模型)"></a>非阻塞IO(网络IO模型)</h4><p>在非阻塞IO模型中，用户态的应用程序也会执行一个操作系统的调用， 检查内核的数据是否准备完成。<strong>如果内核没有准备好数据, 内核会立刻返回结果,用户应用进程不用一直阻塞等待内核准备数据， 而是可以执行其他任务,但仍需要不断的向内核发起系统调用，检测数据是否准备好， 这个过程就叫轮询。</strong> 轮询直到内核准备好数据，然后内核把数据拷贝到用户应用进程， 再进行数据处理。</p><p><img src="file://E:/%E5%B0%9A%E7%A1%85%E8%B0%B7java/JVMzhouyang/framework-learning/img/jdk-jvm-juc/NIO%E5%8E%9F%E7%90%86.png?lastModify=1596340467" alt="NIO原理"></p><p>非阻塞IO的非阻塞体现在: <strong>用户应用进程不用阻塞在对内核的系统调用上</strong></p><blockquote><p>非阻塞IO的优点在于用户应用进程在轮询阶段可以执行其它任务。 但这也是它的缺点，轮询就代表着用户应用进程不是时刻都会发起系统调用。 <strong>可能数据准备好了，而用户应用进程可能等待其它任务执行完毕才会发起系统调用， 这就意味着数据可能会被延时获取。</strong></p></blockquote><h4 id="IO多路复用-网络IO模型"><a href="#IO多路复用-网络IO模型" class="headerlink" title="IO多路复用(网络IO模型)"></a>IO多路复用(网络IO模型)</h4><p>在IO多路复用模型中,<strong>用户应用进程会调用操作系统的select/poll/epoll函数, 它会使内核同步的轮询指定的socket， (在NIO,socket就是注册到Selector上的SocketChannel,可以允许多个) 直至监听的socket有数据可读或可写，select/poll/epoll函数才会返回, 用户应用进程也会阻塞的等待select/poll/epoll函数返回。</strong> 当select/poll/epoll函数返回后，即某个socket有事件发生了，用户应用进程就会 发起系统调用，处理事件，将socket数据复制到用户进程内，然后进行数据处理。</p><p><img src="file://E:/%E5%B0%9A%E7%A1%85%E8%B0%B7java/JVMzhouyang/framework-learning/img/jdk-jvm-juc/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E5%8E%9F%E7%90%86.png?lastModify=1596340467" alt="IO多路复用原理"></p><p><strong>IO多路复用模型是同步阻塞的</strong></p><ol><li>IO多路复用模型的同步体现在: <strong>select函数只有监听到某个socket有事件才会返回。</strong></li><li>IO多路复用模型的阻塞体现在: <strong>用户应用进程会阻塞在对select函数上的调用上。</strong></li></ol><blockquote><p><strong>IO多路复用的优点在于内核可以处理多个socket， 相当于一个用户进程(线程)就可以处理多个socket连接。</strong> 这样不仅降低了系统的开销，并且对于需要高并发的应用是非常有利的。 而非阻塞IO和阻塞IO的一个用户应用进程只能处理一个socket， 要想处理多socket，只能新开进程或线程，但这样很消耗系统资源。</p></blockquote><p><strong>PS:  在IO多路复用模型中, socket一般应该为非阻塞的， 这就是Java中NIO被称为非阻塞IO的原因。 但实际上NIO属于IO多路复用，它是同步阻塞的IO。 具体原因见 <a href="https://www.zhihu.com/question/37271342" target="_blank" rel="noopener">知乎讨论</a></strong></p><p><strong>PS: select/poll/epoll函数是IO多路复用模型的基础，所以如果想 深入了解IO多路复用模型，就需要了解这3个函数以及它们的优缺点。</strong></p><h4 id="信号驱动IO-网络IO模型"><a href="#信号驱动IO-网络IO模型" class="headerlink" title="信号驱动IO(网络IO模型)"></a>信号驱动IO(网络IO模型)</h4><p>在信号驱动IO模型中，<strong>用户应用进程发起sigaction系统调用,内核收到并立即返回。 用户应用进程可以继续执行其他任务，不会阻塞。当内核准备好数据后向用户应用进程 发送SIGIO信号，应用进程收到信号后，发起系统调用， 将数据从内核拷贝到用户进程，</strong> 然后进行数据处理。</p><p><img src="file://E:/%E5%B0%9A%E7%A1%85%E8%B0%B7java/JVMzhouyang/framework-learning/img/jdk-jvm-juc/%E4%BF%A1%E5%8F%B7%E9%A9%B1%E5%8A%A8IO%E5%8E%9F%E7%90%86.png?lastModify=1596340467" alt="信号驱动IO原理"></p><p>个人感觉在内核收到系统调用就立刻返回这一点很像异步IO的方式了，不过 与异步IO仍有很大差别。</p><h4 id="异步IO"><a href="#异步IO" class="headerlink" title="异步IO"></a>异步IO</h4><p>在异步IO模型中，<strong>用户进程发起aio_read系统调用，无论内核的数据是否准备好， 都会立即返回。用户应用进程不会阻塞,可以继续执行其他任务。当内核准备好数据, 会直接把数据复制到用户应用进程。最后内核会通知用户应用进程IO完成。</strong></p><p><img src="file://E:/%E5%B0%9A%E7%A1%85%E8%B0%B7java/JVMzhouyang/framework-learning/img/jdk-jvm-juc/%E5%BC%82%E6%AD%A5IO%E5%8E%9F%E7%90%86.png?lastModify=1596340467" alt="异步IO原理"></p><p><strong>异步IO的异步体现在:内核不用等待数据准备好就立刻返回， 所以内核肯定需要在IO完成后通知用户应用进程。</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">弄清楚了阻塞与非阻塞，同步与异步和上面5种IO模型，相信再看</span><br><span class="line">Java中的IO模型，也只是换汤不换药。</span><br></pre></td></tr></table></figure><ul><li>BIO : 阻塞IO</li><li>NIO : IO多路复用</li><li>AIO : 异步IO</li></ul><p>本来打算写Java中的IO模型的，发现上面几乎讲完了(剩API使用吧)，没啥要写的了， 所以暂时就这样吧。如果各位同学有好的建议，欢迎pr或issue。</p><p><strong>PS: 我此处写的IO模型大部分是借鉴于网上的资料，如有错误，请各位同学指出。</strong></p><h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><h3 id="JVM运行时内存分区"><a href="#JVM运行时内存分区" class="headerlink" title="JVM运行时内存分区"></a>JVM运行时内存分区</h3><blockquote><p>以HotSpot为例:</p></blockquote><ul><li>JDK8之前: <ul><li>线程私有的部分有:程序计数器(PC寄存器),JAVA虚拟机栈,本地方法栈(native)。</li><li>线程共享部分有: GC堆,永久代(是方法区的一种实现)。</li></ul></li></ul><p><img src="file://E:/%E5%B0%9A%E7%A1%85%E8%B0%B7java/JVMzhouyang/framework-learning/img/jdk-jvm-juc/jdk8%E4%B9%8B%E5%89%8D%E7%9A%84JVM%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA.png?lastModify=1596340467" alt="jdk8之前的jvm内存分区"></p><ul><li>JDK8之后:<ul><li>线程私有的部分不变, 线程共享部分的永久代改为了元空间(MetaSpace) (永久代和元空间都是方法区的实现),字符串常量池也移动到了heap空间</li></ul></li></ul><p><img src="file://E:/%E5%B0%9A%E7%A1%85%E8%B0%B7java/JVMzhouyang/framework-learning/img/jdk-jvm-juc/jdk8%E4%B9%8B%E5%90%8E%E7%9A%84jvm%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA.png?lastModify=1596340467" alt="jdk8之后的jvm内存分区">         </p><h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><p>程序计数器是一块较小的内存空间，<strong>它的作用是作为当前线程执行的字节码的行号计数器。 当字节码解释器工作时，通过改变行号计数器的值来选取下一条要执行的字节码指令。</strong> 分支，循环，跳转，异常处理，线程恢复等功能都需要依赖程序计数器完成。</p><p><strong>程序计数器是属于线程私有的部分。 当cpu在多个线程之间切换执行时，需要记录下当前线程执行的字节码的位置， 以便下次切换回当前线程时，能够继续执行字节码指令， 所以每个线程都需要有自己的程序计数器。</strong></p><h4 id="程序计数器的特点"><a href="#程序计数器的特点" class="headerlink" title="程序计数器的特点"></a>程序计数器的特点</h4><ol><li>如果当前线程执行的是java方法，那么程序计数器记录的是字节码指令的地址。</li><li>如果当前线程执行的native方法，那么程序计数器记录的值为空(undefined)。</li><li>程序计数器这部分内存区域是JVM中唯一不会出现OOM错误的区域</li><li>程序计数器的生命周期与线程相同,即程序计数器随着线程创建而创建， 随着线程的销毁而销毁。</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">使用 javap -c 反编译class文件后的代码如下,</span><br><span class="line">红框里的就是字节码的偏移地址:</span><br></pre></td></tr></table></figure><p><img src="file://E:/%E5%B0%9A%E7%A1%85%E8%B0%B7java/JVMzhouyang/framework-learning/img/jdk-jvm-juc/JVM%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8.png?lastModify=1596340467" alt="JVM程序计数器">      </p><h4 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h4><p>Java虚拟机栈与程序计数器一样，都是线程私有的部分，生命周期也跟线程一样。</p><p><strong>Java虚拟机栈描述的是Java方法运行时的内存模型，它由一个一个的栈帧组成。</strong></p><h4 id="栈帧"><a href="#栈帧" class="headerlink" title="栈帧"></a>栈帧</h4><p><strong>栈帧是用于支持Java方法运行时的数据结构。 栈帧包含了局部变量表，操作数栈，动态连接，方法出口等信息。 每个方法执行时，都会在java虚拟机栈中创建一个栈帧。 对方法的调用和返回，就对应着栈帧的入栈和出栈的过程。</strong></p><p>Java虚拟机栈: <img src="file://E:/%E5%B0%9A%E7%A1%85%E8%B0%B7java/JVMzhouyang/framework-learning/img/jdk-jvm-juc/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88.png?lastModify=1596340467" alt="Java虚拟机栈">               </p><h4 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h4><p><strong>局部变量表用于存储方法参数和方法内定义的局部变量。 局部变量表存放了各种已知的数据类型的变量。</strong> 一个局部变量的类型可以是基本数据类型 (int,short,float,double,boolean,long,byte,char)或引用类型(reference)。 在Java代码被编译成class字节码后，方法Code属性的locals就确定了方法的局部变量表的大小。 局部变量表以slot为最小单位，一个slot代表4个字节，也就是32位长度的大小。</p><h4 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h4><p>操作数栈是一个后进先出(LIFO)的数据结构。 <strong>它存储的是方法在进行数据运算时的元素。</strong> 和局部变量表一样，操作数栈的每个元素的类型也可以是基本数据类型和引用类型。 操作数栈的深度不会超过 Code属性的stack值。</p><p>使用javap -c 反编译class文件后可以得到的字节码指令如下:</p><p><img src="file://E:/%E5%B0%9A%E7%A1%85%E8%B0%B7java/JVMzhouyang/framework-learning/img/jdk-jvm-juc/%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8.png?lastModify=1596340467" alt="局部变量表"></p><h4 id="动态连接"><a href="#动态连接" class="headerlink" title="动态连接"></a>动态连接</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">了解动态连接首先需要了解符号引用和直接引用</span><br></pre></td></tr></table></figure><ul><li>符号引用: 符号引用存于Class文件常量池。分为类的全限定名，方法名和描述符，字段名和描述符。</li><li>直接引用: 指向目标的指针，可以简单理解为目标的内存地址(如指向类的字段的内存地址)。</li></ul><p>Class文件常量池如下(javap -c 反编译class文件后的字节码):</p><p><img src="file://E:/%E5%B0%9A%E7%A1%85%E8%B0%B7java/JVMzhouyang/framework-learning/img/jdk-jvm-juc/Class%E6%96%87%E4%BB%B6%E5%B8%B8%E9%87%8F%E6%B1%A0.png?lastModify=1596340467" alt="Class文件常量池"></p><p><strong>在虚拟机栈中，每个栈帧都包含了一个该栈帧所属方法的符号引用， 持有这个符号引用的目的是为了支持方法调用过程中的动态连接。 这些符号引用有的一部分会在JVM类解析阶段就会转为直接引用，这部分转换成为静态解析。 还有一部分会在运行时转为直接引用，这部分称为动态连接。</strong></p><h4 id="方法出口"><a href="#方法出口" class="headerlink" title="方法出口"></a>方法出口</h4><p>当方法执行时，有2种方式可以退出该方法。</p><ol><li>正常退出: 当方法执行时，执行到return指令，该方法就会正常退出。 一般来说，方法正常退出时，调用线程的程序计数器的值可以作为方法返回的地址， 栈帧中可能会保存这个计数器的值。</li><li>异常退出: 在方法执行过程中遇到了异常，并且方法内部没有处理这个异常，就会导致方法退出。 方法异常退出时，返回地址需要通过异常处理器表来确定的，栈帧中不会保存这部分值。</li></ol><p><strong>无论何种退出方式，在方法退出后，都需要回到方法被调用的位置，程序才能继续执行。</strong></p><h4 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h4><p>本地方法栈与虚拟机栈的作用是相似的， 不过<strong>虚拟机栈是为执行Java方法提供服务的， 本地方法栈视为执行native方法提供服务的。</strong> 在本地方法执行的时候，也会在本地方法栈中创建栈帧， 用于存放该本地方法的局部变量表，操作数栈，动态连接和方法返回地址等信息。</p><h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4><p><strong>堆是JVM中内存占用最大的一块区域，它是所有线程共享的一块区域。 堆的作用是为对象分配内存并存储和回收它们。 堆是垃圾回收的主要区域，所以堆区也被成为GC堆。</strong></p><p>堆区可以划分为 <strong>新生代(Young Generation),老年代(Old Generation)</strong> 和 永久代(Permanent Generation),但永久代已被元空间代替, <strong>元空间存储的是类的元信息，几乎不可能发生GC。</strong></p><p>新生代再细分可以分为: <strong>Eden空间，From Survivor空间和To Survivor空间。</strong></p><p>缺省状态下新生代占堆区的 1/3,老年代占堆区的2/3， eden空间占新生代的80%,2个Survivor空间栈新生代的20%, FromSurvivor和ToSurvivor的空间占比为1:1。</p><p>(通过-XX:NewRatio参数可以调整新生代和老年代的空间占比) (通过-XX:SurvivorRatio参数可以调整eden和survivor的空间占比)</p><p><strong>发生在新生代的GC叫做Young GC或Minor GC, 发生在老年代的GC叫做Old GC或Major GC</strong></p><p>堆: <img src="file://E:/%E5%B0%9A%E7%A1%85%E8%B0%B7java/JVMzhouyang/framework-learning/img/jdk-jvm-juc/%E5%A0%86%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA.png?lastModify=1596340467" alt="堆内存分区"></p><p><strong>PS: FromSurvivor和ToSurvivor这两块内存空间并不是固定的， 在进行GC的时候，这两块内存会轮流替换使用。这部分内容参考GC部分。</strong></p><p><strong>PS: 有的文章说 Full GC与Major GC一样是属于对老年代的GC， 也有的文章说 Full GC 是对整个堆区的GC，所以这点需要各位同学自行分辨Full GC语义。 见: <a href="https://www.zhihu.com/question/41922036" target="_blank" rel="noopener">知乎讨论</a></strong></p><h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h4><p>方法区在JVM规范里也是各个<strong>线程共享的一部分区域， 它用于存储已被jvm加载的类的元信息，运行时常量池等数据。</strong></p><p>HotSpot虚拟机对于方法区的实现在jdk8之前为永久代，在jdk8之后， HotSpot移除了永久代，新增了元空间。</p><p>元空间使用的是本地内存，所以元空间仅受本地物理内存的限制。 元空间存储着已被加载的类的方法描述，字段描述，运行时常量池等信息。</p><p><strong>字符串常量池在jdk7已经从永久代转移到了堆内存之中。</strong></p><p><strong>无论是永久代还是元空间，都有可能发生OOM。</strong></p><h3 id="JavaVirtualMachineError"><a href="#JavaVirtualMachineError" class="headerlink" title="JavaVirtualMachineError"></a>JavaVirtualMachineError</h3><h4 id="StackOverflowError"><a href="#StackOverflowError" class="headerlink" title="StackOverflowError"></a>StackOverflowError</h4><p>当前线程执行或请求的栈的大小超过了Java 虚拟机栈的最大空间(比如递归嵌套调用太深),就可能出现StackOverflowError错误           </p><h4 id="OutOfMemoryError"><a href="#OutOfMemoryError" class="headerlink" title="OutOfMemoryError"></a>OutOfMemoryError</h4><p>发生OOM的情况:              </p><ul><li>java heap space </li></ul><blockquote><p>当需要为对象分配内存时，堆空间占用已经达到最大值， 无法继续为对象分配内存，可能会出现OOM: java heap space错误。 </p></blockquote><ul><li>Requested array size exceeds VM limit</li></ul><blockquote><p>当为数组分配内存时，数组需要的容量超过了虚拟机的限制范围， 就会抛出OOM: Requested array size exceeds VM limit。 根据我的测试，Integer.MAX_VALUE - 2 是虚拟机能为数组分配的最大容量    </p></blockquote><ul><li>GC overhead limit exceed</li></ul><blockquote><p>垃圾回收器花费了很长时间GC,但是GC回收的内存非常少, 就可能抛出OOM:GC overhead limit exceed 错误。</p><p>但是这点在我的机器上测试不出来,可能与jdk版本或gc收集器或Xmx分配内存的大小有关, 一直抛出的是java heap space</p></blockquote><ul><li>Direct buffer memory</li></ul><blockquote><p>当程序分配了超额的本地物理内存(native memory/ direct buffer)， minor gc(young gc)并不会回收这部分内存， 只有 full gc才会回收直接内存，如果不发生full  gc， 但直接内存却被使用完了，那么可能会发生 OOM: Direct buffer memory。</p></blockquote><ul><li>unable to create new native thread </li></ul><blockquote><p>操作系统的线程资源是有限的， 如果程序创建的线程资源太多(无需超过平台限制的线程资源上限)， 就可能发生 OOM: unable to create new native thread 错误。 </p></blockquote><ul><li>Metaspace</li></ul><blockquote><p>当加载到元空间中的类的信息太多，就有可能导致 OOM : Metaspace。 <strong>使用cglib的库，可以动态生成class，所以可以使用cglib测试此错误。</strong></p></blockquote><h3 id="简单了解类文件结构"><a href="#简单了解类文件结构" class="headerlink" title="简单了解类文件结构"></a>简单了解类文件结构</h3><p>Class文件结构如下:</p><p><img src="file://E:/%E5%B0%9A%E7%A1%85%E8%B0%B7java/JVMzhouyang/framework-learning/img/jdk-jvm-juc/Class%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%841.png?lastModify=1596340467" alt="Class文件结构1"></p><p>使用vim -b filename 以二进制模式编辑class文件， 然后输入 <strong>:%!xxd</strong> 即可查看十六进制的Class文件,如下:</p><p><img src="file://E:/%E5%B0%9A%E7%A1%85%E8%B0%B7java/JVMzhouyang/framework-learning/img/jdk-jvm-juc/Class%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%842.png?lastModify=1596340467" alt="Class文件结构2"></p><p>当然，最直观的方法是对 class 文件使用 javap -c命令进行详细查看。</p><h3 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h3><p>当java源代码文件被javac编译成class文件后，并不能直接运行， 而是需要经过加载，连接和初始化这几个阶段后才能使用。 在使用完类或JVM被销毁后，JVM会将类卸载掉。</p><p><img src="file://E:/%E5%B0%9A%E7%A1%85%E8%B0%B7java/JVMzhouyang/framework-learning/img/jdk-jvm-juc/%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png?lastModify=1596340467" alt="类的生命周期"></p><h4 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h4><p>类加载过程需要经过3个阶段:</p><ol><li>加载</li><li>连接</li><li>初始化</li></ol><p>其中连接又可分为3个阶段: 验证 ， 准备 ， 解析。</p><h4 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h4><p><strong>在加载阶段，类加载器将类的class文件的二进制数据读取到内存， 并保存到方法区，并在堆区生成该类的Class对象。</strong></p><p>通常有多种方式可以获取类的二进制数据:</p><ul><li>通过javac编译器编译java源文件，读取在本地磁盘上生成的class文件。</li><li>从Jar，ZIP等归档文件中读取class文件。</li><li>通过网络读取类的字节流。</li><li>通过动态生成字节码的技术(如使用动态代理，cglib)来生成class。</li></ul><p><strong>PS:数组由数组元素的类型的类加载器在java程序运行时加载，这是ClassLoader类的部分注释:</strong></p><p><img src="file://E:/%E5%B0%9A%E7%A1%85%E8%B0%B7java/JVMzhouyang/framework-learning/img/jdk-jvm-juc/ClassLoader%E9%83%A8%E5%88%86%E6%B3%A8%E9%87%8A.png?lastModify=1596340467" alt="ClassLoader部分注释"></p><p><strong>见: <a href="https://github.com/guang19/framework-learning/blob/master/jdk-jvm-juc/src/main/java/com/github/guang19/jvm/classloader/ArrayClassLoaderTest.java" target="_blank" rel="noopener">测试</a></strong></p><h4 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h4><p>1.验证 <strong>验证阶段是为了确保类的字节流符合虚拟机规范，并且不会对虚拟机造成恶意损害。</strong> JVM会对字节流进行如下验证:</p><ul><li>文件格式验证:会验证class文件是否符合虚拟机规范，如是否以0×CAFEBABE开头， 主次版本号是否在虚拟机规定范围类，常量池中的类型是否有JVM不支持的类型。</li><li>元数据验证: 会对类的元信息进行语义分析，确保符合Java语法规范。</li><li>字节码验证: 通过分析数据流和控制流，确保类的方法体的程序语义是合法的， 符合逻辑的。</li><li>符号引用验证: 确保常量池中的符号引用能在解析阶段正常解析。</li></ul><p>2.准备: 准备阶段会为类的静态变量初始化零值，如(0,0L,null,false).</p><p>3.解析: 解析阶段会将常量池中的符号引用转为直接引用。 符号引用包括类的全限定名，方法名和描述符，字段名和描述符。   直接引用是指向目标的指针，可以简单理解为目标的内存地址。</p><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><blockquote><p>初始化阶段是类加载过程的最后一个阶段。</p></blockquote><p>在这个阶段,<strong>只有主动使用类才会初始化类，总共有8种情况会涉及到主动使用类。</strong></p><ol><li>当jvm执行new指令时会初始化类，即当程序创建一个类的实例对象。</li><li>当jvm执行getstatic指令时会初始化类，即程序访问类的静态变量(不是静态常量，常量归属于运行时常量池)。</li><li>当jvm执行putstatic指令时会初始化类，即程序给类的静态变量赋值。</li><li>当jvm执行invokestatic指令时会初始化类，即程序调用类的静态方法。</li><li>当使用反射主动访问这个类时,也会初始化类,如Class.forname(“…”),newInstance()等等。</li><li>当初始化一个子类的时候，会先初始化这个子类的所有父类，然后才会初始化这个子类。</li><li>当一个类是启动类时，即这个类拥有main方法，那么jvm会首先初始化这个类。</li><li>MethodHandle和VarHandle可以看作是轻量级的反射调用机制，而要想使用这2个调用， 就必须先使用findStatic/findStaticVarHandle来初始化要调用的类。</li></ol><p><strong>PS:见:<a href="https://github.com/guang19/framework-learning/blob/master/jdk-jvm-juc/src/main/java/com/github/guang19/jvm/classloader/LoadClass.java" target="_blank" rel="noopener">测试</a></strong></p><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>在类被初始化完成后，就可以使用类了。</p><h4 id="类的卸载"><a href="#类的卸载" class="headerlink" title="类的卸载"></a>类的卸载</h4><p>类被卸载(Class对象被GC掉)需要满足3个条件:</p><ol><li>该类的实例对象都已被GC，也就是说堆中不存在该类的实例对象。</li><li>该类没有在其它任何地方被使用。</li><li>加载该类的类加载器实例已被GC。</li></ol><p><strong>在JVM的生命周期中，被JVM自带的类加载器所加载的类是不会被卸载的。 而被我们自定义的类加载器所加载的类是可能会被卸载的。</strong></p><p>其实只要想通一点就好了，<strong>jdk自带的BootstrapClassLoader， PlatformClassLoader和AppClassLoader负责加载jdk提供的类， 它们(类加载器)的实例肯定不会被回收，其中BootstrapClassLoader在java中更是不能被获取到。 而我们自定义的类加载器的实例是可以被GC掉的， 所以被我们自定义类加载器加载的类是可以被GC掉的。</strong></p><p><img src="file://E:/%E5%B0%9A%E7%A1%85%E8%B0%B7java/JVMzhouyang/framework-learning/img/jdk-jvm-juc/%E7%B1%BB%E5%8D%B8%E8%BD%BD.png?lastModify=1596340467" alt="类卸载"></p><p><strong>PS:使用-XX:+TraceClassUnloading 或 -Xlog:class+unload=info可以打印类卸载的信息。</strong></p><h4 id="Java中类加载器有多少个"><a href="#Java中类加载器有多少个" class="headerlink" title="Java中类加载器有多少个"></a>Java中类加载器有多少个</h4><ol><li>BootstrapClassLoader(用于加载Java基础核心类库。由c/c++编写，Java获取不到)。</li><li>PlatformClassLoader (jdk9之后才有此类加载器，jdk8之前是扩展加载器ExtensionClassLoader 。PlatformClassLoader加载平台相关的模块，ExtensionClassLoader加载jdk扩展的模块)。</li><li>AppClassLoader。(应用程序类加载器，负责加载我们程序的classpath下的jar和类)。</li><li>自定义类加载器。</li></ol><h4 id="类加载器的命名空间"><a href="#类加载器的命名空间" class="headerlink" title="类加载器的命名空间"></a>类加载器的命名空间</h4><p><strong>每个类加载器实例都有自己的命名空间，命名空间由该加载器及其所有父加载器加载的所有的类组成。</strong></p><ul><li>在同一个命名空间中(<strong>一个类加载器实例</strong>)，不会出现全限定名(包括包名)相同的2个类(<strong>不会加载2个相同名称的类</strong>)。</li><li>在不同的命名空间中(<strong>多个类加载器实例</strong>)，可能会出现全限定名(包括包名)相同的2个类(<strong>可能加载2个相同名称的类</strong>)。</li></ul><p><strong>PS:见:<a href="https://github.com/guang19/framework-learning/blob/master/jdk-jvm-juc/src/main/java/com/github/guang19/jvm/classloader/MyClassLoader.java" target="_blank" rel="noopener">测试</a></strong></p><h4 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h4><h4 id="为什么需要双亲委派机制"><a href="#为什么需要双亲委派机制" class="headerlink" title="为什么需要双亲委派机制?"></a>为什么需要双亲委派机制?</h4><p><strong>双亲委派机制是为了防止类被重复加载，避免核心API遭到恶意破坏。</strong> 如Object类，它由BootstrapClassLoader在JVM启动时加载。 如果没有双亲委派机制，那么Object类就可以被重写，其带来的后果将无法想象。</p><h4 id="双亲委派机制的实现原理"><a href="#双亲委派机制的实现原理" class="headerlink" title="双亲委派机制的实现原理?"></a>双亲委派机制的实现原理?</h4><p>每个类都有其对应的类加载器。</p><p>双亲委派机制是指在加载一个类的时候，JVM会判断这个类是否已经被其类加载器加载过了。 如果已经加载过了，那么直接返回这个类。 <strong>如果没有加载，就使用这个类对应的加载器的父类加载器判断， 一层一层的往上判断，最终会由BootstrapClassLoader判断。</strong> 如果BootstrapClassLoader判断都没有加载这个类, <strong>那么就由BootstrapClassLoader尝试加载。 如果BootstrapClassLoader加载失败了， 就由BootstrapClassLoader的子类加载器们加载。</strong></p><p><strong>在jdk9之后，由于模块化的到来，双亲委派机制也变化了一点: 如果类没有被加载，那么会根据类名找到这个类的模块。 如果找到了这个类的模块， 就由这个类的模块加载，否则仍然使用父类加载器加载。</strong></p><p><img src="file://E:/%E5%B0%9A%E7%A1%85%E8%B0%B7java/JVMzhouyang/framework-learning/img/jdk-jvm-juc/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6.png?lastModify=1596340467" alt="双亲委派机制"></p><p>可以看出:在加载一个类时，是由下自上判断类是否被加载的。如果类没有被加载， 就由上自下尝试加载类。</p><h3 id="JVM常量池"><a href="#JVM常量池" class="headerlink" title="JVM常量池"></a>JVM常量池</h3><p>Jvm常量池分为:</p><ol><li>Class常量池(静态常量池)</li><li>运行时常量池</li><li>字符串常量池(全局常量池)</li><li>包装类型缓存池</li></ol><h4 id="Class常量池-静态常量池"><a href="#Class常量池-静态常量池" class="headerlink" title="Class常量池(静态常量池)"></a>Class常量池(静态常量池)</h4><p>当Java源文件被编译后，就会生成Class字节码文件。</p><p><strong>Class常量池就存在于Class文件中(Class文件的Constant Pool中)。</strong></p><p><strong>Class文件常量池主要存放两大常量:字面量和符号引用。</strong></p><ol><li>字面量: 字面量分为文本字符串(如: “abc”,1等)和用final修饰的成员变量(实例变量和静态变量)</li><li>符号引用: 符号引用包括三种：类的全限定名，方法名和描述符，字段名和描述符。</li></ol><p><img src="file://E:/%E5%B0%9A%E7%A1%85%E8%B0%B7java/JVMzhouyang/framework-learning/img/jdk-jvm-juc/Class%E6%96%87%E4%BB%B6%E5%B8%B8%E9%87%8F%E6%B1%A0.png?lastModify=1596340467" alt="Class文件常量池"></p><h4 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><p><strong>运行是常量池是在类加载阶段，将class二进制数据加载到内存， 并将数据保存到方法区,其中class文件中的常量池将保存到 运行时常量池(数据都在方法区，常量池肯定也在方法区)。 也就是说一个Class文件常量池对应一个运行时常量池。</strong></p><h4 id="字符串常量池-全局常量池"><a href="#字符串常量池-全局常量池" class="headerlink" title="字符串常量池(全局常量池)"></a>字符串常量池(全局常量池)</h4><p>字符串常量池在jdk7之前都是存于永久代(永久代)之中,jdk7以后存于 堆区之中。</p><h4 id="包装类型缓存池"><a href="#包装类型缓存池" class="headerlink" title="包装类型缓存池"></a>包装类型缓存池</h4><p>包装类缓存池并不是所有的包装类都有，并且缓存池缓存的是一定范围内的数据。 拥有包装类型缓存池的类有:Integer,Byte,Character,Long,Short， 而Float，Double，Boolean都不具有缓存池。</p><p><strong>包装类的缓存池缓存的范围基本都为: -128 - 127之间， Character的缓存范围为 0 - 127。</strong></p><h2 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h2><h3 id="判断对象存活的方法"><a href="#判断对象存活的方法" class="headerlink" title="判断对象存活的方法"></a>判断对象存活的方法</h3><p>在垃圾回收器对堆内存回收前，需要判断对象是否存活。</p><ul><li>引用计数算法: 给每个对象添加一个引用计数器,每当对象被引用, 对象的引用计数器就加1,当引用失效时,引用计数器就减1。 直到引用计数器为0,就代表对象不再被引用。</li><li>可达性算法: 通过GC ROOT的对象节点往下搜索,节点走过的路径被称为引用链。 如果一个对象不处于任何引用链,那么就可以判断此对象是不可达的。</li></ul><h4 id="引用计数法缺点"><a href="#引用计数法缺点" class="headerlink" title="引用计数法缺点"></a>引用计数法缺点</h4><p>引用计数的主要缺陷是很难解决循环引用的问题: 也就是当2个对象互相引用的时候,除了彼此, 没有其它对象再引用这2个对象,那么他们的引用计数都为1,就无法被回收。                </p><h4 id="什么是GC-Root"><a href="#什么是GC-Root" class="headerlink" title="什么是GC Root ?"></a>什么是GC Root ?</h4><p>上面说通过GC Root对象搜索引用链,那么GC Root对象是什么对象, 或者说什么样的对象是GC Root对象。 可以作为GC Root对象的有: </p><ol><li>虚拟机栈和本地方法栈区中的引用对象(stack)</li><li>方法区中类的静态属性引用的对象(static)</li><li>方法区中的常量引用的对象(final)   </li></ol><p><img src="file://E:/%E5%B0%9A%E7%A1%85%E8%B0%B7java/JVMzhouyang/framework-learning/img/jdk-jvm-juc/%E5%8F%AF%E8%BE%BE%E6%80%A7%E7%AE%97%E6%B3%95.png?lastModify=1596340467" alt="可达性算法">              </p><h3 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h3><p>常见的垃圾回收算法主要有以下4种:</p><ol><li>复制算法</li><li>标记-清除算法</li><li>标记-整理算法</li><li>分代收集算法</li></ol><h4 id="复制算法-Copying"><a href="#复制算法-Copying" class="headerlink" title="复制算法(Copying)"></a>复制算法(Copying)</h4><p>将堆内存分为2块大小相等的内存空间， 每次只使用其中的一块内存，另一块则空闲。 当其中一块内存使用完后， 就将仍然存活的对象复制到另一块空闲内存空间，再清理已使用的内存。</p><p><strong>复制算法的优点是不会产生连续的内存碎片，速度也很高效。 但是缺点更明显:每次只使用内存的一半，就代表可使用的内存减少了1/2，代价很高昂。</strong></p><p><strong>复制算法一般用于新生代。 因为新生代的GC非常频繁，每次GC的对象较多，存活的对象较少。 所以采用复制算法效率更高，复制时只需要复制少量存活的对象。</strong>          <img src="file://E:/%E5%B0%9A%E7%A1%85%E8%B0%B7java/JVMzhouyang/framework-learning/img/jdk-jvm-juc/%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95.png?lastModify=1596340467" alt="复制算法">                  </p><h4 id="标记-清除算法-Mark-Sweep"><a href="#标记-清除算法-Mark-Sweep" class="headerlink" title="标记-清除算法(Mark-Sweep)"></a>标记-清除算法(Mark-Sweep)</h4><p>标记-清除算法分为2个步骤：标记和清除。</p><p>首先标记出所有可达(存活)的对象，在标记完成后， 统一回收所有未被标记(不可达)的对象。</p><p>标记-清除算法的缺点主要有2个:</p><ol><li><strong>标记和清除2个阶段的耗时都比较长，可以总结为效率较低。</strong></li><li><strong>对象在内存中的分布可能是不连续的，分散的，标记-清除后可能造成不连续的内存碎片。</strong> 当内存碎片过多后，后续想要分配较大的对象时，无法找到足够大的内存碎片， 可能又需要触发GC。</li></ol><p><strong>标记-清除算法一般用于老年代。</strong> 因为老年代中的对象存活率较高，几乎很少被回收， 所以标记-清除和标记-整理算法GC的时间不会太长， GC的对象相比新生代更少。</p><p><img src="file://E:/%E5%B0%9A%E7%A1%85%E8%B0%B7java/JVMzhouyang/framework-learning/img/jdk-jvm-juc/%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95.png?lastModify=1596340467" alt="标记-清除算法">      </p><h4 id="标记-整理算法-Mark-Compact"><a href="#标记-整理算法-Mark-Compact" class="headerlink" title="标记-整理算法(Mark-Compact)"></a>标记-整理算法(Mark-Compact)</h4><p>标记-整理算法是对标记-清除算法的一种改进。</p><p>标记-整理算法与标记-清除算法的在标记阶段是相同的， 都是首先标记出所有可达(存活)的对象。 但<strong>标记之后并不直接清理未被标记(不可达)的对象， 而是使被标记(存活)的对象向内存一端移动，然后清理掉这一端外的内存。</strong>          <strong>标记-整理算法的优点是: 几乎不会如标记-清除算法那样产生不连续的内存碎片。 但，所谓慢工出细活,标记-整理的效率是比标记-清除要低的。</strong>         </p><p><strong>标记-整理算法和标记-清除算法一样，一般用于老年代。</strong></p><p><img src="file://E:/%E5%B0%9A%E7%A1%85%E8%B0%B7java/JVMzhouyang/framework-learning/img/jdk-jvm-juc/%E6%A0%87%E8%AE%B0-%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95.png?lastModify=1596340467" alt="标记-整理算法">                  </p><h4 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h4><p><strong>分代收集算法并不是指某一种具体的垃圾收集算法， 而是将复制，标记-清除，标记-整理等算法合理运用到堆区的不同空间。</strong> 比如新生代使用复制算法，老年代使用标记清除或标记整理算法。</p><p>现代的几乎所有的JVM都使用分代收集，毕竟每种算法都有优缺点， 结合它们的特点，对不同的环境采用不同的算法是非常明智的选择。</p><h4 id="内存分配与垃圾回收策略"><a href="#内存分配与垃圾回收策略" class="headerlink" title="内存分配与垃圾回收策略"></a>内存分配与垃圾回收策略</h4><ol><li>对象优先在eden区域被分配</li><li>大对象将直接进入老年代 (大对象是指需要大量连续的内存空间的对象，如长字符串，大数组等。)</li><li>长期存活的对象将进入老年代</li></ol><h4 id="一次GC的过程"><a href="#一次GC的过程" class="headerlink" title="一次GC的过程"></a>一次GC的过程</h4><p>对象优先在eden区被分配，当eden区内存不足时， JVM发起Minor GC。Minor GC的范围包括eden和From Survivor:</p><p>首先JVM会根据可达性算法标记出所有存活的对象。</p><p>如果存活的对象中，有的对象的年龄已经达到晋升阈值 (阈值是动态计算的，可以通过-XX:MaxTenuringThreshold设置最大年龄阈值)， 那么将已经达到阈值的对象复制到老年代中。</p><p>如果To Survivor空间不足以存放剩余存活对象， 则直接将存活的对象提前复制到老年代。 如果老年代也没有足够的空间存放存活的对象， 那么将触发Full GC(GC整个堆，包括新生代和老年代)。</p><p>如果To Survivor可以存放存活的对象， 那么将对象复制到To Survivor空间，并清理eden和From Survivor。</p><p>此时From Survivor为空， 那么From Survivor就成为了下一次的To Survivor， 此时To Survivor存放着存活的对象，就成为了下一次的From Survivor。 这样From Survivor与To Survivor就是不断交替复制的使用。</p><p><strong>老年代的空间比新生代的空间要大， 所以老年代的Major GC要比Minor GC耗时更长。 根据垃圾回收器的不同，老年代的GC算法也不同。</strong></p><h4 id="动态年龄阈值"><a href="#动态年龄阈值" class="headerlink" title="动态年龄阈值"></a>动态年龄阈值</h4><p>JVM并不要求对象年龄一定要达到 MaxTenuringThreshold 才会 晋升到老年代，晋升的年龄阈值是动态计算的。￼￼￼￼￼ 如果在Survivor中，某个相同年龄阶段的所有对象大小的总和 大于Survivor区域的一半，则大于等于这个年龄的所有对象 可以直接进入老年代，无需等到MaxTenuringThreshold。</p><h3 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h3><p><strong>如果说垃圾回收算法是JVM对GC算法的方法论，那么垃圾回收器就是对GC算法的实现。</strong></p><p>垃圾回收器主要分为以下几种收集器:</p><ul><li>Serial收集器</li><li>Parallel Scanvel收集器</li><li>ParNew收集器</li><li>CMS收集器</li><li>G1收集器</li></ul><h4 id="Serial串行收集器"><a href="#Serial串行收集器" class="headerlink" title="Serial串行收集器"></a>Serial串行收集器</h4><p>Serial收集器为单线程环境设计,并只使用一个线程进行垃圾回收。 在回收时，会暂停用户线程,并不适用于并发环境。</p><p>Serial收集器在单线程环境中是很高效的,它没有多线程切换的消耗。     </p><p><strong>Serial收集器采用复制算法</strong>       </p><h4 id="Serial-Old-串行收集器-老年代版本"><a href="#Serial-Old-串行收集器-老年代版本" class="headerlink" title="Serial Old 串行收集器(老年代版本)"></a>Serial Old 串行收集器(老年代版本)</h4><p>它是 Serial收集器的老年代使用的GC收集器，同样是一个单线程的垃圾收集器。 </p><p><strong>Serial Old收集器采用的是标记-整理算法。</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;** 开启串行收集器使用 -XX:+UseSerialGC , </span><br><span class="line">  * 这样默认新生代使用 Serial 收集器,</span><br><span class="line">  * 老年代使用 Serial Old 收集器. </span><br><span class="line">  *</span><br><span class="line">  * 设置VM参数:</span><br><span class="line">  *</span><br><span class="line">  * -XX:+Xlogs:gc* 打印gc信息</span><br><span class="line">  * -XX:+PrintCommandLineFlags  打印java版本信息</span><br><span class="line">  * -XX:+UseSerialGC 使用串行GC</span><br><span class="line">  *&#x2F;                      </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;如果程序正常运行,日志会显示 :</span><br><span class="line">&#x2F;&#x2F; 新生代的信息为:  def new generation.....</span><br><span class="line">&#x2F;&#x2F; 老年代的信息为:  tenured generation.....</span><br></pre></td></tr></table></figure><h4 id="Parallel-Scavenge-并行多线程收集器"><a href="#Parallel-Scavenge-并行多线程收集器" class="headerlink" title="Parallel Scavenge 并行多线程收集器"></a>Parallel Scavenge 并行多线程收集器</h4><p>Parallel Scavenge是并行收集器，它使用多个垃圾回收线程一起工作, 但是仍然会暂停用户线程。</p><p>Parallel Scavenge与其它垃圾回收器不同的是它<strong>更关注于达到可控制的吞吐量。</strong></p><p>吞吐量是CPU运行用户应用程序代码的时间与CPU总消耗的时间的比值:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">吞吐量 &#x3D; 应用程序代码运行时间 &#x2F; (应用程序代码运行时间 + GC时间)</span><br></pre></td></tr></table></figure><p><strong>Parallel Scavenge收集器采用复制算法</strong></p><h4 id="Parallel-Old-并行收集器-老年代版本"><a href="#Parallel-Old-并行收集器-老年代版本" class="headerlink" title="Parallel Old 并行收集器(老年代版本)"></a>Parallel Old 并行收集器(老年代版本)</h4><p>它是 Parallel Scavenge 的老年代版本,同样是一个并行多线程的收集器。</p><p><strong>Parallel Old收集器采用标记-整理算法。</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * </span><br><span class="line"> * 设置 Parallel Scavenge 收集器的参数:</span><br><span class="line"> *</span><br><span class="line"> * -XX:+UseParallelGC</span><br><span class="line"> * </span><br><span class="line"> * ParallelGC老年代默认使用的 Parallel Old GC 回收器</span><br><span class="line"> * </span><br><span class="line"> * 并行收集器打印的新生代的信息为:</span><br><span class="line"> *  PSYoungGen ....</span><br><span class="line"> *  </span><br><span class="line"> *  老年代的信息为:</span><br><span class="line"> *  ParOldGen ....</span><br><span class="line"> * </span><br><span class="line"> *&#x2F;</span><br></pre></td></tr></table></figure><h4 id="ParNew-多线程收集器"><a href="#ParNew-多线程收集器" class="headerlink" title="ParNew 多线程收集器"></a>ParNew 多线程收集器</h4><p>它可以看做是多线程版的Serial收集器。 除了多线程外，ParNew收集器与Serial收集器几乎没啥区别。</p><p><strong>PS:目前只有Serial和ParNew能作为CMS收集器的新生代收集器。</strong>          <strong>ParNew收集器采用复制算法</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">  * </span><br><span class="line">  * 设置ParNewGC回收器的参数为:</span><br><span class="line">  * -XX:+UseConcMarkSweepGC</span><br><span class="line">  * </span><br><span class="line">  *&#x2F;</span><br></pre></td></tr></table></figure><h4 id="CMS-并发标记清除收集器"><a href="#CMS-并发标记清除收集器" class="headerlink" title="CMS 并发标记清除收集器"></a>CMS 并发标记清除收集器</h4><p>Concurrent Mark Sweep,并发标记-清除垃圾回收器。 它是一款老年代的收集器，是<strong>以达到最短回收停顿时间目标的收集器。</strong></p><p><strong>见名知意,CMS收集器使用的是标记-清除算法。 CMS在垃圾回收过程中，用户线程可以同时工作，无需暂停。</strong></p><p><strong>因为CMS收集器采用的是标记-清除算法，所以回收时可能会产生不连续的内存碎片。</strong></p><p><strong>PS: CMS收集器在jdk14中被删除了。</strong></p><h4 id="CMS收集器回收过程"><a href="#CMS收集器回收过程" class="headerlink" title="CMS收集器回收过程"></a>CMS收集器回收过程</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在jdk14中，CMS被删除了。但是仍然有必要学习它。</span><br></pre></td></tr></table></figure><ul><li>初始标记(Stop The World，此阶段会暂停用户线程): 只标记与GC ROOT直接关联的对象。</li><li>并发标记: 对第一个阶段已经标记的对象进行Tracing，标记所有可达的对象。</li><li>重新标记(Stop The World,此阶段会暂停用户线程): 在第二个阶段，由于用户程序的运行， 可能有些对象之间的引用关系受到了影响，所以需要对这部分对象进行重新标记调整。</li><li>并发清除: 清除所有未被标记的对象。    </li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> *</span><br><span class="line"> * 设置 CMS 收集器参数:</span><br><span class="line"> * -XX:+UseConcMarkSweepGC</span><br><span class="line"> *</span><br><span class="line"> * 使用ConcMarkSweepGC收集器后,它的新生代使用的是:</span><br><span class="line"> * ParNew收集器.</span><br><span class="line"> *</span><br><span class="line"> * 当ConcMarkSweepGC收集器出现异常时,会将CMS替换成Serial Old收集器</span><br><span class="line"> *</span><br><span class="line"> * CMS回收分为4个阶段:</span><br><span class="line"> *</span><br><span class="line"> * 初始标记:    (Stop the world 暂停用户线程)</span><br><span class="line"> * 标记与GC Root直接可达的对象.      </span><br><span class="line"> *</span><br><span class="line"> * 并发标记:  </span><br><span class="line"> * 从第一步标记的可达的对象开始,并发的标记所有可达的对象 </span><br><span class="line"> *</span><br><span class="line"> * 重新标记:    (Stop the world 暂停用户线程)</span><br><span class="line"> * 在第二部的并发标记阶段,由于程序运行导致对象间引用的关系发生变化,</span><br><span class="line"> * 就需要重新标记</span><br><span class="line"> *</span><br><span class="line"> * 并发清除:     </span><br><span class="line"> * 这个阶段不暂停用户线程,并且并发的去清除未被标记的对象</span><br><span class="line"> * </span><br><span class="line"> *&#x2F;</span><br></pre></td></tr></table></figure><h4 id="G1-收集器"><a href="#G1-收集器" class="headerlink" title="G1 收集器"></a>G1 收集器</h4><p>G1收集器可以说是目前最前沿的一款收集器，它是一款面向服务端的收集器。 G1收集器<strong>无需配合其他收集器就可以管理整个堆内存。</strong> jdk9开始，G1成为jdk默认使用的垃圾回收器。</p><h4 id="G1回收器的特点"><a href="#G1回收器的特点" class="headerlink" title="G1回收器的特点"></a>G1回收器的特点</h4><ul><li>并行和并发: G1能够充分利用多核cpu的优势，使垃圾回收与用户线程同时运行。</li><li>可预测的停顿: 降低GC停顿时间是CMS与G1收集器的共同目标。但是除了降低GC停顿时间， G1收集器还可以建立可预测的停顿时间模型。(…太np了 =_=)</li><li>空间整合: 个人认为这是G1收集器不同于其他收集器的最大亮点了。 在其他收集器中，堆区基本都分为新生代和老年代。 而在G1收集器中虽然仍然保留了新生代和老年代的概念，但已经不再是物理上的分隔了。 <strong>在G1收集器的堆内存模型中，内存被分割成了一块一块大小相等的Region， 在这些Region中，Region的类型也不同，有eden，survivor，old，humongous之分。 当有大对象时，对象会被分配到Humongous Region之中。</strong></li></ul><p><img src="file://E:/%E5%B0%9A%E7%A1%85%E8%B0%B7java/JVMzhouyang/framework-learning/img/jdk-jvm-juc/G1%E6%94%B6%E9%9B%86%E5%99%A8Region.png?lastModify=1596340467" alt="G1收集器Region"></p><h4 id="G1收集器回收过程"><a href="#G1收集器回收过程" class="headerlink" title="G1收集器回收过程"></a>G1收集器回收过程</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">G1收集器与CMS收集器的回收过程相似</span><br></pre></td></tr></table></figure><ul><li>初始标记(Stop The World,此阶段会暂停用户线程): 只标记与GC ROOT直接关联的对象。</li><li>并发标记: 对第一个阶段标记的对象Tracing，标记所有可达的对象。</li><li>最终标记(Stop The World,此阶段会暂停用户线程): 在并发标记阶段，由于用户线程执行， 可能导致被标记对象之间的引用关系发生影响，需要对这些对象进行重新标记调整。</li><li>筛选回收: 不同于CMS的并发清除，G1收集器首先会对所有Region的回收价值和回收成本进行排序, 然后再进行回收。这样可以在有限的时间内获得最大的回收率。</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> *</span><br><span class="line"> * 因为我的机器的jdk版本是11,所以无需指定垃圾回收器</span><br><span class="line"> * 指定G1回收器的参数是: -XX:+UseG1GC</span><br><span class="line"> *</span><br><span class="line"> * 1:初始标记:(Stop the world 暂停用户线程)</span><br><span class="line"> *   标记所有与GC Root直接可达的对象</span><br><span class="line"> *</span><br><span class="line"> * 2:并发标记</span><br><span class="line"> *  从第一个阶段标记的对象开始,trace标记</span><br><span class="line"> *</span><br><span class="line"> * 4:最终标记:(Stop the world 暂停用户线程)</span><br><span class="line"> *  在第二步并发标记的阶段,由于程序执行,</span><br><span class="line"> *  导致被标记对象之间的引用关系发生变化,所以需要重新调整标记</span><br><span class="line"> *</span><br><span class="line"> * 5:筛选回收:</span><br><span class="line"> *  和CMS的并发回收不一样,</span><br><span class="line"> *  G1收集器首先会对所有Region的回收价值和回收成本进行排序,</span><br><span class="line"> *  然后再进行回收。</span><br><span class="line"> *  这样可以保证在有限的时间内获得最大的回收率.</span><br><span class="line"> *</span><br><span class="line"> *&#x2F;</span><br></pre></td></tr></table></figure><h2 id="JVM调优相关"><a href="#JVM调优相关" class="headerlink" title="JVM调优相关"></a>JVM调优相关</h2><h3 id="JVM常见参数"><a href="#JVM常见参数" class="headerlink" title="JVM常见参数"></a>JVM常见参数</h3><h4 id="堆栈相关"><a href="#堆栈相关" class="headerlink" title="堆栈相关"></a>堆栈相关</h4><ul><li>-Xss</li></ul><blockquote><p>调整线程栈大小。</p></blockquote><ul><li>-Xms</li></ul><blockquote><p>设置堆内存初始化大小。</p></blockquote><ul><li>-Xmx / -XX:MaxHeapSize=?</li></ul><blockquote><p>设置堆内存最大值。</p></blockquote><ul><li>-Xmn / -XX:NewSize=?</li></ul><blockquote><p>设置新生代大小。</p></blockquote><ul><li>-XX:NewRatio=?</li></ul><blockquote><p>设置老年代与新生代的空间占比。 如: -XX:NewRatio=2,那么老年代:新生代=2:1。</p></blockquote><ul><li>-XX:SurvivorRatio=?</li></ul><blockquote><p>设置eden与survivor的空间占比。 如: -XX:SurvivorRatio=2,那么eden:from survivor:to survivor=2:1:1</p></blockquote><ul><li>-XX:MetaspaceSize=? / -XX:PerGenSize=?</li></ul><blockquote><p>-XX:MetaspaceSize=9m 设置元空间的初始化大小为9m,此参数只在jdk8以后的版本有效。</p><p>-XX:PerGenSize=9m 设置永久代的初始化大小为9m，此参数只在jdk8以前的版本有效。</p></blockquote><ul><li>-XX:MaxMetaspaceSize=? / -XX:MaxPerGenSize=?</li></ul><blockquote><p>-XX:MaxMetaspaceSize=50m 设置元空间最大值为50m,此参数只在jdk8以后的版本有效。</p><p>-XX:MaxPerGenSize=50m 设置永久代的最大值为50m,此参数只在jdk8以前的版本有效。</p></blockquote><ul><li>-XX:+HeapDumpOnOutOfMemoryError</li></ul><blockquote><p>此参数使程序发生OOM时，dump错误堆栈信息。</p></blockquote><ul><li>-XX:HeapDumpPath=?</li></ul><blockquote><p>-XX:HeapDumpPath=/home/log 此参数指定发生OOM时，dump错误堆栈信息存放的日志文件或目录。 此参数只在 -XX:+HeapDumpOnOutOfMemoryError 开启时生效。</p></blockquote><h4 id="GC相关"><a href="#GC相关" class="headerlink" title="GC相关"></a>GC相关</h4><ul><li>-XX:+PrintGCDetails / -Xlog:gc*</li></ul><blockquote><p>打印GC的日志信息。 -Xlog:gc* 在我使用的版本(jdk11)是更受推荐的。</p></blockquote><ul><li>-XX:+TraceClassUnloading / -Xlog:class+unload=info</li></ul><blockquote><p>打印类卸载的日志信息。 -Xlog:class+unload=info 在我使用的版本(jdk11)是更受推荐的。</p></blockquote><ul><li>-XX:+UseSerialGC</li></ul><blockquote><p>使用Serial串行回收器。</p></blockquote><ul><li>-XX:+UseParallelGC</li></ul><blockquote><p>使用Parallel并行回收器。</p></blockquote><ul><li>-XX:ParallelGCThreads=?</li></ul><blockquote><p>设置并行收集的线程数,如-XX:ParallelGCThreads=5。</p></blockquote><ul><li>-XX:+UseConcMarkSweepGC</li></ul><blockquote><p>使用CMS收集器，它默认的新生代搜集器为ParNew。 可以与参数: -XX:+UseSerialGC 一起使用，就替换掉了ParNew， 使用Serial作为CMS的新生代收集器。</p></blockquote><ul><li>-XX:+UseG1GC</li></ul><blockquote><p>使用G1收集器。</p></blockquote><ul><li>-XX:MaxTenuringThreshold=?</li></ul><blockquote><p>设置新生代对象晋升到老年代的最大年龄阈值。</p></blockquote><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ul><li>-server / -client</li></ul><blockquote><p>-server:以服务端模式运行应用程序，server模式适用于服务端应用程序。 JVM在此模式下，会对服务端运行效率做很大优化。</p><p>-client:以客户端模式运行应用程序，client模式适用于客户端桌面程序(GUI)。 JVM在此模式下，会对客户端运行做很大优化。</p></blockquote><h3 id="Java常用调优命令和工具"><a href="#Java常用调优命令和工具" class="headerlink" title="Java常用调优命令和工具"></a>Java常用调优命令和工具</h3><ul><li>jps(个人认为非常重要)</li></ul><blockquote><p>jps 命令类似于 linux的 ps 命令，不过ps命令是用于查看系统进程的， 而jps用于查看当前系统运行的java进程。</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jps -q 只输出java进程id</span><br><span class="line">jps -l 输出java进程main函数的详细路径</span><br><span class="line">jps -v 输出java进程时指定的jvm参数</span><br><span class="line">jps -m 输出java进程执行时main函数的参数</span><br></pre></td></tr></table></figure><ul><li>jstat</li></ul><blockquote><p>jstat用于查看java进程的运行状态.</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jstat -class pid    用于查看java进程类的情况</span><br><span class="line">jstat -compiler pid 用于查看java进程编译的情况</span><br><span class="line">jstat -gc pid       用于查看java进程gc的情况</span><br></pre></td></tr></table></figure><ul><li>jinfo</li></ul><blockquote><p>jinfo 查看正在运行的java进程的jvm参数</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jinfo -flag MetaspaceSize pid  查看java进程的jvm的元空间大小</span><br><span class="line">jinfo -flag MaxHeapSize pid    查看java进程的jvm的最大堆的大小</span><br><span class="line">...</span><br></pre></td></tr></table></figure><ul><li>jmap</li></ul><blockquote><p>jmap 既可以dump java程序的快照，也可以查看对象的统计信息。</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jmap -heap pid               查看java进程堆的信息</span><br><span class="line">jmap -histo pid              查看java进程对象的信息</span><br><span class="line">jmap -dump:file&#x3D;filename pid 生成java进程jvm的堆快照到指定文件</span><br></pre></td></tr></table></figure><ul><li>jstack</li></ul><blockquote><p>jstack用于分析java线程栈信息</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jstack pid</span><br></pre></td></tr></table></figure><ul><li>jconsole</li></ul><blockquote><p>jconsole 是jdk提供的对java程序进行分析的GUI界面工具。</p></blockquote><h2 id="Jdk新特性"><a href="#Jdk新特性" class="headerlink" title="Jdk新特性"></a>Jdk新特性</h2><p>总结的不全，还请各位同学补充。</p><h3 id="Jdk8新特性"><a href="#Jdk8新特性" class="headerlink" title="Jdk8新特性"></a>Jdk8新特性</h3><ul><li>Lambda / 方法引用</li><li>接口新增default方法</li><li>Stream API</li><li>Optional API</li><li>新的时间API(java.time强烈推荐使用)</li><li>内置Base64工具</li></ul><h3 id="Jdk9新特性"><a href="#Jdk9新特性" class="headerlink" title="Jdk9新特性"></a>Jdk9新特性</h3><p>PS: jdk9应该是继jdk8之后，又一个重要的版本，后续jdk的迭代，都是基于jdk9来完成的。</p><ul><li>模块化: 模块化是jdk9或者说jdk8之后最大的改进，在jdk8及以前，jvm启动时，需要加载非常多的不需要的外部扩展类库，导致程序消耗的内存非常大， 并且在打包后，应用的归档包也是比较庞大。但是在模块化系统中，jvm只需要加载每个模块需要的类库，这就大大减少了jvm的开销。模块化的好处 当然不止我所说的这些，其中奥妙，还请各位同学实践出真知。</li><li>集合的工厂方法</li><li>try语句升级</li><li>接口新增private方法</li><li>响应式流(Doug Lea大师编写的，个人认为很重要，也是Webflux的基础)</li><li>JShell 交互式编程环境</li><li>String改为byte数组实现(记住这个特性)</li></ul><p>PS: String类在jdk9后的每个版本，好像都会新增一些API，这个不再重复。</p><h3 id="Jdk10新特性"><a href="#Jdk10新特性" class="headerlink" title="Jdk10新特性"></a>Jdk10新特性</h3><ul><li>var类型推断: 这一功能在其他语言中早有实现，比如我接触过的c++的auto,js中的var(当然，js并不是强类型语言)。 其实我个人认为此特性意义不是特别重大，因为java本身就是强类型语言，var只能使用于局部变量推断。如果大量使用var, 反而可能造成代码可读性下降。</li><li>集合工厂方法，使用集合工厂创建的集合是不可变的集合</li><li>移除javah(在编写本地jni库时，需要javah生成c/c++头文件，javah被移除了，说明另有他法来解决这个问题)。</li></ul><p>jdk10的特性还是有很多的，但是并没有像模块化这样大的改动。</p><h3 id="Jdk11新特性"><a href="#Jdk11新特性" class="headerlink" title="Jdk11新特性"></a>Jdk11新特性</h3><ul><li>java命令直接可以编译并运行java源文件</li><li>HttpClient: 长期以来，java类库之中只有一个HttpUrlConnection可以使用，且HttpUrlConnection使用起来较为麻烦。</li><li>Javascript引擎更换: Javascript引擎由Nashorn改为GraalVM。</li><li>String类新增了许多好用的API，如: strip,isBlank等。</li></ul><h3 id="Jdk12新特性"><a href="#Jdk12新特性" class="headerlink" title="Jdk12新特性"></a>Jdk12新特性</h3><ul><li>switch语法糖</li><li>Unicode11支持</li></ul><p>…</p><h3 id="Jdk13新特性"><a href="#Jdk13新特性" class="headerlink" title="Jdk13新特性"></a>Jdk13新特性</h3><ul><li>文本块</li><li>Socket API被重新实现</li></ul><h3 id="Jdk14新特性"><a href="#Jdk14新特性" class="headerlink" title="Jdk14新特性"></a>Jdk14新特性</h3><ul><li>instanceof 模式匹配</li><li>Record结构(实用)</li><li><strong>CMS收集器被删除了。</strong></li><li>Parallel Scavenge 和 Serial Old这对组合被弃用了。(我觉着也是，本来Parallel Scavenge和Parallel Old， Serial和Serial Old这两对收集器各自搭配的挺好，Parallel Scavenge非要脚踏两只船)</li></ul><p>展望: ZGC是11中引入的一款新的垃圾回收器。G1收集器本身已经很高效了，但是停顿时间这一块缺陷是所有收集器的缺点， 而ZGC不仅对停顿时间这个缺点做了大量优化，也提供了非常多当高级功能。 似乎ZGC的到来，是要主宰Java GC的未来了。。。</p><p>关于ZGC可以参考这篇文章: <a href="https://juejin.im/entry/5b86a276f265da435c4402d4" target="_blank" rel="noopener"><a href="https://juejin.im/entry/5b86a276f265da435c4402d4" target="_blank" rel="noopener">ZGC - 掘金</a></a></p>]]></content>
    
    <summary type="html">
    
      JVM和JUC复习
    
    </summary>
    
    
      <category term="java" scheme="https://SomunsTao.github.io/categories/java/"/>
    
    
      <category term="java" scheme="https://SomunsTao.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Spring：源码解析</title>
    <link href="https://somunstao.github.io/2020/03/30/Spring%2012%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%20%E5%89%AF%E6%9C%AC/"/>
    <id>https://somunstao.github.io/2020/03/30/Spring%2012%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%20%E5%89%AF%E6%9C%AC/</id>
    <published>2020-03-29T16:00:00.000Z</published>
    <updated>2020-06-09T14:55:41.144Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring：源码解析"><a href="#Spring：源码解析" class="headerlink" title="Spring：源码解析"></a><strong>Spring：源码解析</strong></h1><p>优秀的源码中有着多年沉积下来的精华，这些精华是非常值得我们学习的。放弃阅读源码，你将失去一个和大师学习的机会。</p><p>用Spring框架做了几年的开发，只停留在会用的阶段上，然而Spring的设计思想和原理确实一个巨大的宝库。大部分人仅仅知道怎么去配，或着加上什么属性就能达到什么效果，这些东西都可以通过查文档，查google来解决。关键是在怎么理解它，把它的思想变为自己的东西。这几天没有学习(装逼)，感觉心里甚是空虚，索性研究了下一直很好奇的Spring大佬,毕竟写代码天天都在用。</p><p>前方高能，非战斗人员迅速投入战斗:</p><ol><li>Spring IOC容器</li><li>ApplicationContext与BeanFactory探究.</li><li>bean的加载</li><li>FactoryBean</li><li>Spring AOP实现原理及实战</li></ol><p>文章篇幅有限，只对Spring几个重要的知识点进行简单阐述，有兴趣的可以看看《Spring源码深度解析》，该书下载地址：<a href="https://pan.baidu.com/s/1jGxdGTg，本文也是基于该书总结出来的。" target="_blank" rel="noopener">https://pan.baidu.com/s/1jGxdGTg，本文也是基于该书总结出来的。</a></p><p>1.Spring IOC容器</p><p>很多人一提IOC，便张口就来：控制反转。究竟哪些方面被反转了呢？答案是依赖对象的获得被反转了。很多时候，我们通过多个对象之间的协作来完成一个功能，如果获取所依赖对象靠自身来实现，这将导致代码的耦合度高和难以测试。当然,控制反转还有一个好听的名字:依赖注入。</p><p>Spring IOC通过引入xml配置，由IOC容器来管理对象的生命周期,依赖关系等。</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20180508/c79a9018721948f3a6e6eeb358ac8ee3.png" alt="img"></p><p>从图中可以看出，我们以前获取两个有依赖关系的对象，要用set方法，而用容器之后，它们之间的关系就由容器来管理。那么，Spring容器的加载过程是什么样的呢?</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20180508/dfa81c829b234c5584ffd09899dd1250.png" alt="img"></p><p>BeanDefinition是一个接口，用于属性承载，比如<bean>元素标签拥有class、scope、lazy-init等配置。bean的定义方式有千千万万种，无论是何种标签，无论是何种资源定义，无论是何种容器，只要按照Spring的规范编写xml配置文件，最终的bean定义内部表示都将转换为内部的唯一结构：BeanDefinition。当BeanDefinition注册完毕以后，Spring的BeanFactory就可以随时根据需要进行实例化了。</p><p>2.ApplicationContext与BeanFactory探究</p><p>实例化的工作会在容器启动后过AbstractApplicationContext中reflash方法自动进行。我们常用的ApplicationContext实现类ClassPathXmlApplicationContext继承了AbstractApplicationContext类，继承关系如下图.</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20180508/345d95a6fce6447d8823bac6ae14f7c0.png" alt="img"></p><p>AbstractApplicationContext里的reflash方法是Spring初始IOC容器一个非常重要的方法，不管你是ApplicationContext哪个实现类，最终都会进入这个方法。</p><p>@Override</p><p>publicvoidrefresh()throwsBeansException, IllegalStateException{</p><p>synchronized( this.startupShutdownMonitor) {</p><p>// 设置和校验系统变量和环境变量的值</p><p>prepareRefresh();</p><p>//主要是创建beanFactory，同时加载配置文件.xml中的beanDefinition</p><p>//通过String[] configLocations = getConfigLocations()获取资源路径，然后加载beanDefinition</p><p>ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</p><p>//给beanFactory注册一些标准组建，如ClassLoader，StandardEnvironment，BeanProcess</p><p>prepareBeanFactory(beanFactory);</p><p>try{</p><p>//提供给子类实现一些postProcess的注册，如AbstractRefreshableWebApplicationContext注册一些Servlet相关的</p><p>//postProcess，真对web进行生命周期管理的Scope，通过registerResolvableDependency()方法注册指定ServletRequest，HttpSession，WebRequest对象的工厂方法</p><p>postProcessBeanFactory(beanFactory);</p><p>//调用所有BeanFactoryProcessor的postProcessBeanFactory()方法</p><p>invokeBeanFactoryPostProcessors(beanFactory);</p><p>//注册BeanPostProcessor，BeanPostProcessor作用是用于拦截Bean的创建</p><p>registerBeanPostProcessors(beanFactory);</p><p>//初始化消息Bean</p><p>initMessageSource();</p><p>//初始化上下文的事件多播组建，ApplicationEvent触发时由multicaster通知给ApplicationListener</p><p>initApplicationEventMulticaster();</p><p>//ApplicationContext初始化一些特殊的bean</p><p>onRefresh();</p><p>//注册事件监听器，事件监听Bean统一注册到multicaster里头，ApplicationEvent事件触发后会由multicaster广播</p><p>registerListeners();</p><p>//非延迟加载的单例Bean实例化</p><p>finishBeanFactoryInitialization(beanFactory);</p><p>finishRefresh();</p><p>}</p><p>catch(BeansException ex) {</p><p>logger.warn( “Exception encountered during context initialization - cancelling refresh attempt”, ex);</p><p>destroyBeans();</p><p>cancelRefresh(ex);</p><p>throwex;</p><p>}</p><p>}</p><p>}</p><p>代码逻辑清晰的值得mark一下。这个方法的作用是创建加载Spring容器配置（包括.xml配置，property文件和数据库模式等）。</p><p>BeanFactory体系结构是典型的工厂方法模式，即什么样的工厂生产什么样的产品。要知道工厂是如何产生对象的，我们需要看具体的IOC容器实现，具体的实现有：如 DefaultListableBeanFactory 、 XmlBeanFactory 、 ApplicationContext 等。那么，究竟BeanFactory里到底是什么样的呢？</p><p>packageorg.springframework.beans.factory;</p><p>publicinterfaceBeanFactory{</p><p>/**</p><p>* 用来引用一个实例，或把它和工厂产生的Bean区分开，就是说，如果一个FactoryBean的名字为a，那么，&amp;a会得到那个Factory</p><p>*/</p><p>String FACTORY_BEAN_PREFIX = “&amp;”;</p><p>/*</p><p>* 四个不同形式的getBean方法，获取实例</p><p>*/</p><p>ObjectgetBean(String name)throwsBeansException;</p><p><T> TgetBean(String name, Class<T> requiredType)throwsBeansException;</p><p><T> TgetBean(Class<T> requiredType)throwsBeansException;</p><p>ObjectgetBean(String name, Object… args)throwsBeansException;</p><p>booleancontainsBean(String name); // 是否存在</p><p>booleanisSingleton(String name)throwsNoSuchBeanDefinitionException; // 是否为单实例</p><p>booleanisPrototype(String name)throwsNoSuchBeanDefinitionException; // 是否为原型（多实例）</p><p>booleanisTypeMatch(String name, Class&lt;?&gt; targetType)</p><p>throwsNoSuchBeanDefinitionException; // 名称、类型是否匹配</p><p>Class&lt;?&gt; getType(String name) throwsNoSuchBeanDefinitionException; // 获取类型</p><p>String[] getAliases(String name); // 根据实例的名字获取实例的别名</p><p>}</p><p>我们可以看出BeanFactory里只对IOC容器的基本行为作了定义，根本不关心你的bean是如何定义怎样加载的，它规定了所有的容器至少需要实现的标准。说到实现，BeanFactory有几个比较重要的实现类需要知道，ref：【Spring4揭秘 BeanFactory】基本容器-BeanFactory：<a href="https://blog.csdn.net/u011179993/article/details/51636742。那么BeanFactory的基本实现类XmlBeanFactory与我们常用的ApplicationContext有什么区别呢?答案是bean的加载。" target="_blank" rel="noopener">https://blog.csdn.net/u011179993/article/details/51636742。那么BeanFactory的基本实现类XmlBeanFactory与我们常用的ApplicationContext有什么区别呢?答案是bean的加载。</a></p><p>3.bean的加载</p><p>我们先看一道面试经常会问到的问题:<strong>Spring的bean在什么时候实例化?</strong>——第一：如果你使用BeanFactory，如XmlBeanFactory作为Spring Bean的工厂类，则所有的bean都是在第一次使用该bean的时候实例化 。第二：如果你使用ApplicationContext作为Spring Bean的工厂类，则又分为以下几种情况：</p><ol><li>如果bean的scope是singleton的，并且lazy-init为false（默认是false，所以可以不用设置），则ApplicationContext启动的时候就实例化该bean，并且将实例化的bean放在一个线程安全的 ConcurrentHashMap 结构的缓存中，下次再使用该Bean的时候，直接从这个缓存中取 。</li><li>如果bean的scope是singleton的，并且lazy-init为true，则该bean的实例化是在第一次使用该bean的时候进行实例化 。</li><li>如果bean的scope是prototype的，则该bean的实例化是在第一次使用该Bean的时候进行实例化 。</li></ol><p>ClassPathXmlApplicationContext有几个重载的构造函数最终都会调用父类AbstractApplicationContext的reflash方法，reflash方法在前文有介绍，作用是创建加载Spring容器配置。AbstractApplicationContext也有getBean方法：</p><p>AbstractApplicationContext下的代码：</p><p>publicObjectgetBean( Stringname) throws BeansException {</p><p>//Bean的获取外部容器交给了内部容器</p><p>returngetBeanFactory().getBean(name);</p><p>}</p><p>内部容器由DefaultListableBeanFactory承当，但真实的getBean方法实现是由其父类AbstractBeanFactory实现的，AbstractBeanFactory类同样实现了BeanFactory接口的方法，它有四个重载的getBean方法，不管哪一个都会去调用doGetBean方法：</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20180508/fb9021a0e35f4c639606d43903c4a182.jpeg" alt="img"></p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20180508/cb5912600cee482ba9767ebdd66e721d.png" alt="img"></p><p>那么doGetBean里干了什么事情呢？</p><p>protected<T> T doGetBean(</p><p>final Stringname, final Class<T> requiredType, final Object[] args, booleantypeCheckOnly)</p><p>throws BeansException {</p><p>//bean name处理，去除FactoryBean前缀等</p><p>final StringbeanName = transformedBeanName(name);</p><p>Objectbean = null;</p><p>//先从singleton缓存中查看是否已经实例化过该Bean，根据是否有缓存分为两个分支分别处理</p><p>ObjectsharedInstance = getSingleton(beanName);</p><p>if(sharedInstance != null&amp;&amp; args == null) {</p><p>// 分支一，若缓存中获取到了并且该BeanDefinition信息表明该bean是singleton的，直接将获取到的缓存Bean</p><p>//(有可能是半成品)交给getObjectForBeanInstance处理</p><p>/<em>………省略logger部分代码…………</em>/</p><p>//调用getObjectForBeanInstance处理</p><p>bean = getObjectForBeanInstance(sharedInstance, name, beanName, null);</p><p>} else{</p><p>// 分之二：没有缓存，则需要从头实例化该bean</p><p>// We’re assumably within a circular reference.</p><p>if(isPrototypeCurrentlyInCreation(beanName)) {</p><p>thrownewBeanCurrentlyInCreationException(beanName);}</p><p>// 检查BeanDefinition是否在当前工厂或父工厂</p><p>BeanFactory parentBeanFactory = getParentBeanFactory();</p><p>if(parentBeanFactory != null&amp;&amp; !containsBeanDefinition(beanName)) {</p><p>// Not found -&gt; check parent.</p><p>StringnameToLookup = originalBeanName(name);</p><p>if(args != null) {</p><p>// 父工厂getBean</p><p>returnparentBeanFactory.getBean(nameToLookup, args);</p><p>}</p><p>else{</p><p>// No args -&gt; delegate to standard getBean method.</p><p>returnparentBeanFactory.getBean(nameToLookup, requiredType);</p><p>}</p><p>}</p><p>//将bean加入“正在创建”的集合，完成后会remove,对应afterSingletonCreation/afterPrototypeCreation方法</p><p>if(!typeCheckOnly) {</p><p>markBeanAsCreated(beanName);</p><p>}</p><p>final RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);</p><p>checkMergedBeanDefinition(mbd, beanName, args);</p><p>// 解决依赖关系，将依赖的bean提前实例化</p><p>String[] dependsOn = mbd.getDependsOn();</p><p>if(dependsOn != null) {</p><p>for(int i = 0; i &lt; dependsOn.length; i++) {</p><p>StringdependsOnBean = dependsOn[i];</p><p>getBean(dependsOnBean);</p><p>registerDependentBean(dependsOnBean, beanName);</p><p>}</p><p>}</p><p>// 这里又需要根据bean的类型分为三种情况：singleton、prototype、request/session</p><p>if(mbd.isSingleton()) {</p><p>//通过自定义ObjectFactory实例化Bean，此结果可能是半成品(是FactoryBean等)</p><p>sharedInstance = getSingleton(beanName, newObjectFactory() {</p><p>publicObjectgetObject() throws BeansException {</p><p>try{</p><p>//真正实例化装配的逻辑在createBean方法中</p><p>returncreateBean(beanName, mbd, args);</p><p>}</p><p>catch(BeansException ex) {</p><p>destroySingleton(beanName);</p><p>throwex;</p><p>}</p><p>}</p><p>});</p><p>//上一步半成品的Bean交给getObjectForBeanInstance方法处理</p><p>bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</p><p>}</p><p>elseif(mbd.isPrototype()) {</p><p>ObjectprototypeInstance = null;</p><p>try{</p><p>beforePrototypeCreation(beanName);</p><p>//真正实例化装配的逻辑在createBean方法中</p><p>prototypeInstance = createBean(beanName, mbd, args);</p><p>}</p><p>finally{</p><p>afterPrototypeCreation(beanName);</p><p>}</p><p>//上一步半成品的Bean交给getObjectForBeanInstance方法处理</p><p>bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);</p><p>}</p><p>else{</p><p>//request、session 的bean</p><p>StringscopeName = mbd.getScope();</p><p>final Scope scope = (Scope) this.scopes.get(scopeName);</p><p>if(scope == null) {</p><p>thrownewIllegalStateException( “No Scope registered for scope ‘“+ scopeName + “‘“);</p><p>}</p><p>try{</p><p>ObjectscopedInstance = scope.get(beanName, newObjectFactory() {</p><p>publicObjectgetObject() throws BeansException {</p><p>beforePrototypeCreation(beanName);</p><p>try{</p><p>//真正实例化装配的逻辑在createBean方法中</p><p>returncreateBean(beanName, mbd, args);</p><p>}</p><p>finally{</p><p>afterPrototypeCreation(beanName);</p><p>}</p><p>}</p><p>});</p><p>//上一步半成品的Bean交给getObjectForBeanInstance方法处理</p><p>bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);</p><p>}</p><p>catch(IllegalStateException ex) {</p><p>thrownewBeanCreationException(beanName,</p><p>“Scope ‘“+ scopeName + “‘ is not active for the current thread; “+</p><p>“consider defining a scoped proxy for this bean if you intend to refer to it from a singleton”,</p><p>ex);</p><p>}</p><p>}</p><p>}</p><p>if(requiredType != null&amp;&amp; bean != null&amp;&amp;</p><p>!requiredType.isAssignableFrom(bean.getClass())) {</p><p>thrownewBeanNotOfRequiredTypeException(name, requiredType, bean.getClass());</p><p>}</p><p>returnbean;</p><p>}</p><p>bean的加载经历了一个复杂的过程，上面代码主要做了以下几件事(此段摘抄自《Spring源码深度解析》)：</p><p>1.转换对应的beanName。如果name=“&amp;aa”的，会去除&amp;符号。或者<bean>标签带有alias（别名的意思），则取alias所表示最终的beanName。</p><p>2.尝试从缓存中加载单例bean。如果加载不成功，会再次尝试从singletonFactories中加载。</p><p>3.bean的实例化。假如我们需要对工厂bean进行处理，那么这里得到的其实是工厂bean 的初始状态。真正干活的则是getObjectForBeanInstance定义factory-method方法返回的bean。</p><p>4.原型模式的依赖检查。如果A类有B的属性，B中有A的属性，则会产生循环依赖。参考：spring如何解决循环依赖问题<a href="http://www.cnblogs.com/bhlsheji/p/5208076.html" target="_blank" rel="noopener">http://www.cnblogs.com/bhlsheji/p/5208076.html</a></p><p>5.将存储的Xml配置文件的GernericBeanDefinition转换为RootBeanDefinition。前文提到的用于承载属性的BeanDefinition有三个实现，GernericBeanDefinition，RootBeanDefinition和ChildBeanDefinition，如果父类bean不为空的话，这里会把所有的属性一并合并父类属性，因为后续所有的Bean都是针对RootBeanDefinition的。</p><p>6.寻找依赖。在初始化一个bean的时候，会首先初始化这个bean所对应的依赖。</p><p>7.根据不同的scope创建bean。scope属性默认是singleton，还有prototype、request等。</p><p>8.类型转换。如果bean是个String，而requiredType传入了Integer，然后返回bean，加载结束。</p><p>其中,最重要的步骤是(7),spring的常用特性都在那里实现.</p><p>4.FactoryBean</p><p>首先要分辨BeanFactory 与 FactoryBean的区别， 两个名字很像，所以容易搞混。这里做一个简单的比喻你就明白了：</p><p>1.FactoryBean：工厂类接口，用户可以通过实现该接口定制实例化 bean的逻辑。我们把bean比作是人，那么FactoryBean则是女娲，首先它本身有人的特征，但它能够生产人。</p><p>2.BeanFactory ：BeanFactory定义了 IOC 容器的最基本形式。如果bean还比作是人，那么它可以理解成三界，三界里有各种功能的人，它是一个容器，可以管理很多的人。</p><p>FactoryBean里干了什么事情？</p><p>publicinterfaceFactoryBean<T>{</p><p>//返回由FactoryBean创建的Bean实例,如果isSingleton返回true,则该实例会放到spring容器中单例缓存池中.</p><p>TgetObject()throwsException;</p><p>//返回FactoryBean创建的bean类型.</p><p>Class&lt;?&gt; getObjectType();</p><p>//返回由FactoryBean创建的bean实例的作用域是singleton还是prototype</p><p>booleanisSingleton();</p><p>}</p><p>它的作用不在这里做阐述，ref：Spring的FactoryBean使用<a href="http://www.cnblogs.com/quanyongan/p/4133724.html" target="_blank" rel="noopener">http://www.cnblogs.com/quanyongan/p/4133724.html</a></p><p>写到这里，总结一下阅读Spring源码的心得:</p><p>1.学习Spring思想和编码规范。Spring的很多函数代码量大，逻辑复杂,而Spring的编码风格就是将复杂的逻辑分解，分成N个小函数的嵌套，每一层都是对下一层的总结和概要。在工作中最佩服的一个大神说过：学习Spring源码思想为我所用，哪怕是一天学习一个变量名，他在工作中设计很多小组件的时候都是基于Spring思想和规范。他说，不要迷茫学什么技术，其实每天只要进步一点点就好，突破的是自己，而不是某个领域。用10年其实才敢说入门一门技术。</p><p>2.跟了Spring代码的函数，你会或多或少发现一些规律：一个真正干活的函数其实是以do开头的，如doGetBean，而给我们错觉的函数，如getBean和createBean等等方法，其实只是从全局角度做一些统筹工作。</p><p>3.放弃阅读源码是一个不明智的选择，因为你失去了跟大师学习的机会。当你硬着头皮读完一个框架的源码，则其他框架都是相通的。</p><p>4.下一篇文章：Spring AOP是什么?你都拿它做什么?因为篇幅有限，AOP又是一个重要且内容比较多的部分，所以打算单独拿出来搞事情。</p>]]></content>
    
    <summary type="html">
    
      Spring
    
    </summary>
    
    
      <category term="Spring" scheme="https://SomunsTao.github.io/categories/Spring/"/>
    
    
      <category term="Spring" scheme="https://SomunsTao.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot：小总结</title>
    <link href="https://somunstao.github.io/2020/03/30/SpringBoot20%EF%BC%9A%E5%B0%8F%E6%80%BB%E7%BB%93/"/>
    <id>https://somunstao.github.io/2020/03/30/SpringBoot20%EF%BC%9A%E5%B0%8F%E6%80%BB%E7%BB%93/</id>
    <published>2020-03-29T16:00:00.000Z</published>
    <updated>2020-05-01T02:13:32.338Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://p99.pstatp.com/large/pgc-image/15367619528862cca2a0df9" alt="img"></p><h1 id="spring-boot-总结"><a href="#spring-boot-总结" class="headerlink" title="spring boot 总结"></a><a href="https://www.cnblogs.com/huangjianping/p/8203811.html" target="_blank" rel="noopener">spring boot 总结</a></h1><p><strong>一、什么是SpringBoot</strong><br>　　描述：Spring Boot是Spring社区发布的一个开源项目，旨在帮助开发者快速并且更简单的构建项目。大多数SpringBoot项目只需要很少的配置文件。<br><strong>二、SpringBoot核心功能</strong><br>1、独立运行Spring项目<br>　　　　Spring boot 可以以jar包形式独立运行，运行一个Spring Boot项目只需要通过java -jar xx.jar来运行。<br>2、内嵌servlet容器<br>Spring Boot可以选择内嵌Tomcat、jetty或者Undertow,这样我们无须以war包形式部署项目。<br>3、提供starter简化Maven配置<br>spring提供了一系列的start pom来简化Maven的依赖加载，例如，当你使用了spring-boot-starter-web，会自动加入如图5-1所示的依赖包。<br>4、自动装配Spring<br>SpringBoot会根据在类路径中的jar包，类、为jar包里面的类自动配置Bean，这样会极大地减少我们要使用的配置。当然，SpringBoot只考虑大多数的开发场景，并不是所有的场景，若在实际开发中我们需要配置Bean，而SpringBoot灭有提供支持，则可以自定义自动配置。<br>5、准生产的应用监控<br>SpringBoot提供基于http ssh telnet对运行时的项目进行监控。<br>6、无代码生产和xml配置　　<br>SpringBoot不是借助与代码生成来实现的，而是通过条件注解来实现的，这是Spring4.x提供的新特性。<br><strong>三、SpringBoot优缺点</strong><br>优点：<br>1、快速构建项目。<br>2、对主流开发框架的无配置集成。<br>3、项目可独立运行，无须外部依赖Servlet容器。<br>4、提供运行时的应用监控。<br>5、极大的提高了开发、部署效率。<br>6、与云计算的天然集成。<br>缺点：<br>1、如果你不认同spring框架，也许这就是缺点。<br><strong>四、SpringBoot特性</strong><br>1、创建独立的Spring项目<br>2、内置Tomcat和Jetty容器<br>3、提供一个starter POMs来简化Maven配置<br>4、提供了一系列大型项目中常见的非功能性特性，如安全、指标，健康检测、外部配置等<br>5、完全没有代码生成和xml配置文件<br><strong>五、SpringBoot快速搭建</strong><br>网址：<a href="http://start.spring.io" target="_blank" rel="noopener">http://start.spring.io</a>;<br><strong>六、SpringBoot CLI</strong><br>SpringBoot CLI 是SpringBoot提供的控制台命令工具。<br><strong>七、SpringBoot maven 构建项目</strong><br>spring-boot-starter-parent：是一个特殊Start，它用来提供相关的Maven依赖项，使用它之后，常用的包依赖可以省去version标签。<br><strong>八、SpringBoot几个常用的注解</strong><br>（1）@RestController和@Controller指定一个类，作为控制器的注解<br>（2）@RequestMapping方法级别的映射注解，这一个用过Spring MVC的小伙伴相信都很熟悉<br>（3）@EnableAutoConfiguration和@SpringBootApplication是类级别的注解，根据maven依赖的jar来自动猜测完成正确的spring的对应配置，只要引入了spring-boot-starter-web的依赖，默认会自动配置Spring MVC和tomcat容器<br>（4）@Configuration类级别的注解，一般这个注解，我们用来标识main方法所在的类,完成元数据bean的初始化。<br>（5）@ComponentScan类级别的注解，自动扫描加载所有的Spring组件包括Bean注入，一般用在main方法所在的类上<br>（6）@ImportResource类级别注解，当我们必须使用一个xml的配置时，使用@ImportResource和@Configuration来标识这个文件资源的类。<br>（7）@Autowired注解，一般结合@ComponentScan注解，来自动注入一个Service或Dao级别的Bean<br>（8）@Component类级别注解，用来标识一个组件，比如我自定了一个filter，则需要此注解标识之后，Spring Boot才会正确识别。</p>]]></content>
    
    <summary type="html">
    
      you can &quot;just run&quot;
    
    </summary>
    
    
      <category term="SpringBoot" scheme="https://SomunsTao.github.io/categories/SpringBoot/"/>
    
    
      <category term="SpringBoot" scheme="https://SomunsTao.github.io/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot：雷神笔记(高级)</title>
    <link href="https://somunstao.github.io/2020/03/30/SpringBoot22%EF%BC%9A%E9%9B%B7%E7%A5%9E%E7%AC%94%E8%AE%B0%E9%AB%98%E7%BA%A7/"/>
    <id>https://somunstao.github.io/2020/03/30/SpringBoot22%EF%BC%9A%E9%9B%B7%E7%A5%9E%E7%AC%94%E8%AE%B0%E9%AB%98%E7%BA%A7/</id>
    <published>2020-03-29T16:00:00.000Z</published>
    <updated>2020-05-03T08:28:21.154Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://niceseason.github.io/images/OG-Spring.png" alt="springboot高级"></p><h1 id="springboot高级"><a href="#springboot高级" class="headerlink" title="springboot高级"></a>springboot高级</h1><hr><p>本文分别从缓存、消息、检索、任务、安全、分布式、热部署和监控管理方面，对spring boot高级部分做了简单总结，内容不深但覆盖全。</p><h1 id="一-Spring-Boot与缓存"><a href="#一-Spring-Boot与缓存" class="headerlink" title="(一) Spring Boot与缓存"></a>(一) Spring Boot与缓存</h1><h2 id="一、-JSR107"><a href="#一、-JSR107" class="headerlink" title="一、 JSR107"></a>一、 JSR107</h2><p>Java Caching定义了5个核心接口</p><ul><li><p>CachingProvider</p><p>定义了创建、配置、获取、管理和控制多个CacheManager。一个应用可<br>以在运行期访问多个CachingProvider。</p></li><li><p>CacheManager</p><p>定义了创建、配置、获取、管理和控制多个唯一命名的Cache，这些Cache<br>存在于CacheManager的上下文中。一个CacheManager仅被一个CachingProvider所拥有。</p></li><li><p>Cache</p><p>一个类似<strong>Map</strong>的数据结构并<strong>临时存储以Key为索引</strong>的值。一个Cache仅被一个<br>CacheManager所拥有。</p></li><li><p>Entry</p><p>一个存储在Cache中的key-value对。</p></li><li><p>Expiry</p><p>每一个存储在Cache中的条目有一个定义的有效期。一旦超过这个时间，条目为过期的状态。一旦过期，条目将不可访问、更新和删除。缓存有效期可以通过ExpiryPolicy设置。</p><p><a href="https://niceseason.github.io/images/图片1.png" target="_blank" rel="noopener"><img src="https://niceseason.github.io/images/%E5%9B%BE%E7%89%871.png" alt="jsr107示意图"></a></p><p><a href="https://niceseason.github.io/images/图片1.png" target="_blank" rel="noopener">jsr107示意图</a></p></li></ul><h2 id="二、-Spring缓存抽象"><a href="#二、-Spring缓存抽象" class="headerlink" title="二、 Spring缓存抽象"></a>二、 Spring缓存抽象</h2><p>  Spring从3.1开始定义了org.springframework.cache.Cache<br>  和org.springframework.cache.CacheManager接口来<strong>统一</strong>不同的缓存技术；<br>  <strong>并支持使用JCache（JSR-107）</strong>注解简化我们开发；</p><p>  Cache接口有以下功能：</p><ul><li>为缓存的组件规范定义，包含缓存的各种操作集合；</li></ul><ul><li><p>Spring提供了各种xxxCache的实现；如RedisCache，EhCacheCache ,<br>ConcurrentMapCache等；</p><p><a href="https://niceseason.github.io/images/图片2.png" target="_blank" rel="noopener"><img src="https://niceseason.github.io/images/%E5%9B%BE%E7%89%872.png" alt="Spring缓存抽象"></a></p><p><a href="https://niceseason.github.io/images/图片2.png" target="_blank" rel="noopener">Spring缓存抽象</a></p></li></ul><h2 id="三、-重要缓存注解及概念"><a href="#三、-重要缓存注解及概念" class="headerlink" title="三、 重要缓存注解及概念"></a>三、 重要缓存注解及概念</h2><table><thead><tr><th><strong>Cache</strong></th><th align="left"><strong>缓存接口，定义缓存操作。实现有：RedisCache、EhCacheCache、ConcurrentMapCache等</strong></th></tr></thead><tbody><tr><td><strong>CacheManager</strong></td><td align="left"><strong>缓存管理器，管理各种缓存（Cache）组件</strong></td></tr><tr><td><strong>@Cacheable</strong></td><td align="left"><strong>根据方法的请求参数对其结果进行缓存</strong></td></tr><tr><td><strong>@CacheEvict</strong></td><td align="left"><strong>清空缓存</strong></td></tr><tr><td><strong>@CachePut</strong></td><td align="left"><strong>更新缓存</strong></td></tr><tr><td><strong>@EnableCaching</strong></td><td align="left"><strong>开启基于注解的缓存</strong></td></tr><tr><td><strong>keyGenerator</strong></td><td align="left"><strong>缓存数据时key生成策略</strong></td></tr><tr><td><strong>serialize</strong></td><td align="left"><strong>缓存数据时value序列化策略</strong></td></tr></tbody></table><h3 id="1-Cacheable-CachePut-CacheEvict-主要的参数"><a href="#1-Cacheable-CachePut-CacheEvict-主要的参数" class="headerlink" title="1 . @Cacheable/@CachePut/@CacheEvict 主要的参数"></a>1 . @Cacheable/@CachePut/@CacheEvict 主要的参数</h3><ul><li><p><strong>value</strong></p><p>缓存名称，字符串/字符数组形式；</p><p>如@Cacheable(value=”mycache”) 或者@Cacheable(value={”cache1”,”cache2”}</p></li><li><p><strong>key</strong></p><p>缓存的key,需要按照SpEL表达式编写，如果不指定则按照方法所有参数进行组合；</p><p>如@Cacheable(value=”testcache”,key=”#userName”)</p></li><li><p><strong>keyGenerator</strong></p><p>key的生成器；可以自己指定key的生成器的组件id</p><p>注意：key/keyGenerator：二选一使用;</p></li><li><p><strong>condition</strong></p><p>缓存条件，使用SpEL编写，在调用方法之前之后都能判断；</p><p>如@Cacheable(value=”testcache”,condition=”#userName.length()&gt;2”)</p></li><li><p><strong>unless</strong>（@CachePut、@Cacheable）</p><p>用于否决缓存的条件，只在方法执行之后判断；</p><p>如@Cacheable(value=”testcache”,unless=”#result ==null”)</p></li><li><p><strong>beforeInvocation</strong>（@CacheEvict）</p><p>是否在执行前清空缓存，默认为false，false情况下方法执行异常则不会清空；</p><p>如@CachEvict(value=”testcache”，beforeInvocation=true)</p></li><li><p><strong>allEntries</strong>（@CacheEvict）</p><p>是否清空所有缓存内容，默认为false；</p><p>如@CachEvict(value=”testcache”,allEntries=true)</p></li></ul><h3 id="2-缓存可用的SpEL表达式"><a href="#2-缓存可用的SpEL表达式" class="headerlink" title="2 . 缓存可用的SpEL表达式"></a>2 . 缓存可用的SpEL表达式</h3><p><strong>root</strong></p><p>表示根对象，不可省略</p><ul><li><p>被调用方法名 <strong>methodName</strong></p><p>如 #root.methodName</p></li><li><p>被调用方法 <strong>method</strong></p><p>如 #root.method.name</p></li><li><p>目标对象 <strong>target</strong></p><p>如 #root.target</p></li><li><p>被调用的目标对象类 <strong>targetClass</strong></p><p>如 #root.targetClass</p></li><li><p>被调用的方法的参数列表 <strong>args</strong></p><p>如 #root.args[0]</p></li><li><p>方法调用使用的缓存列表 <strong>caches</strong></p><p>如 #root.caches[0].name</p></li></ul><p><strong>参数名</strong></p><p>方法参数的名字. 可以直接 #参数名 ，也可以使用 #p0或#a0 的形式，0代表参数的索引；</p><p>如 #iban 、 #a0 、 #p0</p><p><strong>返回值</strong></p><p>方法执行后的返回值（仅当方法执行之后的判断有效，如‘unless’ ， @CachePut、@CacheEvict’的表达式beforeInvocation=false ）</p><p>如 #result</p><h2 id="四、-缓存使用"><a href="#四、-缓存使用" class="headerlink" title="四、 缓存使用"></a>四、 缓存使用</h2><h3 id="1-基本使用步骤"><a href="#1-基本使用步骤" class="headerlink" title="1. 基本使用步骤"></a>1. 基本使用步骤</h3><ol><li>引入spring-boot-starter-cache模块</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-cache&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><ol><li><p>@EnableCaching开启缓存</p><p>在主配置类上标注</p></li><li><p>使用缓存注解</p><p>如@Cacheable、@CachePut</p></li><li><p>切换为其他缓存</p></li></ol><h3 id="2-搭建实验环境"><a href="#2-搭建实验环境" class="headerlink" title="2. 搭建实验环境"></a>2. 搭建实验环境</h3><ol><li><p>导入数据库文件 创建出department和employee表</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- ----------------------------</span><br><span class="line">-- Table structure for department</span><br><span class="line">-- ----------------------------</span><br><span class="line">DROP TABLE IF EXISTS &#96;department&#96;;</span><br><span class="line">CREATE TABLE &#96;department&#96; (</span><br><span class="line">  &#96;id&#96; int(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  &#96;departmentName&#96; varchar(255) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (&#96;id&#96;)</span><br><span class="line">) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8;</span><br><span class="line"></span><br><span class="line">-- ----------------------------</span><br><span class="line">-- Table structure for employee</span><br><span class="line">-- ----------------------------</span><br><span class="line">DROP TABLE IF EXISTS &#96;employee&#96;;</span><br><span class="line">CREATE TABLE &#96;employee&#96; (</span><br><span class="line">  &#96;id&#96; int(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  &#96;lastName&#96; varchar(255) DEFAULT NULL,</span><br><span class="line">  &#96;email&#96; varchar(255) DEFAULT NULL,</span><br><span class="line">  &#96;gender&#96; int(2) DEFAULT NULL,</span><br><span class="line">  &#96;d_id&#96; int(11) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (&#96;id&#96;)</span><br><span class="line">) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8;</span><br></pre></td></tr></table></figure></li><li><p>创建javaBean封装数据</p></li><li><p>整合MyBatis操作数据库</p><p>配置数据源信息</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring.datasource.username&#x3D;root</span><br><span class="line">spring.datasource.password&#x3D;123</span><br><span class="line">spring.datasource.url&#x3D;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;springboot?serverTimezone&#x3D;GMT</span><br><span class="line">spring.datasource.driver-class-name&#x3D;com.mysql.cj.jdbc.Driver</span><br><span class="line"></span><br><span class="line"># 开启驼峰命名法(否则部分字段封装不了)</span><br><span class="line">mybatis.configuration.map-underscore-to-camel-case&#x3D;true</span><br><span class="line">#打印sql</span><br><span class="line">logging.level.cn.edu.ustc.springboot.mapper&#x3D;debug</span><br><span class="line"></span><br><span class="line">debug&#x3D;true</span><br></pre></td></tr></table></figure><p>使用注解版的MyBatis；</p><p> @MapperScan指定需要扫描的mapper接口所在的包</p></li><li><p>主配置类开启@EnableCaching</p></li></ol><h3 id="3-快速体验缓存"><a href="#3-快速体验缓存" class="headerlink" title="3. 快速体验缓存"></a>3. 快速体验缓存</h3><p><strong>@Cacheable、@CachePut、@CacheEvict的使用</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class EmployeeService &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private EmployeeMapper employeeMapper;</span><br><span class="line"></span><br><span class="line">    @Cacheable(value&#x3D;&#123;&quot;emp&quot;&#125;,</span><br><span class="line">            key &#x3D; &quot;#id+#root.methodName+#root.caches[0].name&quot;,</span><br><span class="line">            condition &#x3D; &quot;#a0&gt;1&quot;,</span><br><span class="line">            unless &#x3D; &quot;#p0&#x3D;&#x3D;2&quot;</span><br><span class="line">    )</span><br><span class="line">    public Employee getEmpById(Integer id) &#123;</span><br><span class="line">        System.out.println(&quot;查询员工：&quot;+id);</span><br><span class="line">        return employeeMapper.getEmpById(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @CachePut(value &#x3D; &#123;&quot;emp&quot;&#125;,key &#x3D; &quot;#employee.id&quot; )</span><br><span class="line">    public Employee updateEmp(Employee employee) &#123;</span><br><span class="line">        System.out.println(&quot;更新员工&quot;+employee);</span><br><span class="line">        employeeMapper.updateEmp(employee);</span><br><span class="line">        return employee;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @CacheEvict(value &#x3D; &#123;&quot;emp&quot;&#125;,allEntries &#x3D; true,beforeInvocation &#x3D; true)</span><br><span class="line">    public Integer delEmp(Integer id)&#123;</span><br><span class="line">        int i&#x3D;1&#x2F;0;</span><br><span class="line">        System.out.println(&quot;删除员工：&quot;+id);</span><br><span class="line">        employeeMapper.delEmp(id);</span><br><span class="line">        return id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>自定义KeyGenerator</strong></p><p>使用时在注解属性内指定KeyGenerator=“myKeyGenerator”</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class MyCacheConfig &#123;</span><br><span class="line">    @Bean(&quot;myKeyGenerator&quot;)</span><br><span class="line">    public KeyGenerator myKeyGenerator() &#123;</span><br><span class="line">        return new KeyGenerator()&#123;</span><br><span class="line">            @Override</span><br><span class="line">            public Object generate(Object target, Method method, Object... params) &#123;</span><br><span class="line">                return method.getName()+&quot;[&quot;+ Arrays.asList(params).toString()+target+&quot;]&quot;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>@CacheConfig</strong></p><p>标注在类上，用于抽取@Cacheable的公共属性</p><p>由于一个类中可能会使用多次@Cacheable等注解，所以各项属性可以抽取到@CacheConfig</p><p><strong>@Caching</strong></p><p>组合使用@Cacheable、@CachePut、@CacheEvict</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Caching(</span><br><span class="line">       cacheable &#x3D; &#123;</span><br><span class="line">           @Cacheable(&#x2F;*value&#x3D;&quot;emp&quot;,*&#x2F;key &#x3D; &quot;#lastName&quot;)</span><br><span class="line">       &#125;,</span><br><span class="line">       put &#x3D; &#123;</span><br><span class="line">           @CachePut(&#x2F;*value&#x3D;&quot;emp&quot;,*&#x2F;key &#x3D; &quot;#result.id&quot;),</span><br><span class="line">           @CachePut(&#x2F;*value&#x3D;&quot;emp&quot;,*&#x2F;key &#x3D; &quot;#result.email&quot;)</span><br><span class="line">       &#125;</span><br><span class="line">  )</span><br><span class="line">  public Employee getEmpByLastName(String lastName)&#123;</span><br><span class="line">      return employeeMapper.getEmpByLastName(lastName);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="4-工作原理"><a href="#4-工作原理" class="headerlink" title="4. 工作原理"></a>4. 工作原理</h3><p>缓存的自动配置类CacheAutoConfiguration向容器中导入了CacheConfigurationImportSelector，此类的selectImports()方法添加了许多配置类，其中SimpleCacheConfiguration默认生效</p><p> GenericCacheConfiguration<br>​ JCacheCacheConfiguration<br>​ EhCacheCacheConfiguration<br>​ HazelcastCacheConfiguration<br>​ InfinispanCacheConfiguration<br>​ CouchbaseCacheConfiguration<br>​ RedisCacheConfiguration<br>​ CaffeineCacheConfiguration<br>​ GuavaCacheConfiguration<br>​ SimpleCacheConfiguration【默认】<br>​ NoOpCacheConfiguration</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Import(&#123; CacheConfigurationImportSelector.class, CacheManagerEntityManagerFactoryDependsOnPostProcessor.class &#125;)</span><br><span class="line">public class CacheAutoConfiguration &#123;</span><br><span class="line">    static class CacheConfigurationImportSelector implements ImportSelector &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public String[] selectImports(AnnotationMetadata importingClassMetadata) &#123;</span><br><span class="line">CacheType[] types &#x3D; CacheType.values();</span><br><span class="line">String[] imports &#x3D; new String[types.length];</span><br><span class="line">for (int i &#x3D; 0; i &lt; types.length; i++) &#123;</span><br><span class="line">                &#x2F;&#x2F;将即将导入的各配置类存入字符数组内</span><br><span class="line">imports[i] &#x3D; CacheConfigurations.getConfigurationClass(types[i]);</span><br><span class="line">&#125;</span><br><span class="line">return imports;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SimpleCacheConfiguration向容器中导入了ConcurrentMapCacheManager</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Configuration(proxyBeanMethods &#x3D; false)</span><br><span class="line">@ConditionalOnMissingBean(CacheManager.class)</span><br><span class="line">@Conditional(CacheCondition.class)</span><br><span class="line">class SimpleCacheConfiguration &#123;</span><br><span class="line">    &#x2F;&#x2F;向容器中导入ConcurrentMapCacheManager</span><br><span class="line">@Bean</span><br><span class="line">ConcurrentMapCacheManager cacheManager(CacheProperties cacheProperties,</span><br><span class="line">CacheManagerCustomizers cacheManagerCustomizers) &#123;</span><br><span class="line">ConcurrentMapCacheManager cacheManager &#x3D; new ConcurrentMapCacheManager();</span><br><span class="line">List&lt;String&gt; cacheNames &#x3D; cacheProperties.getCacheNames();</span><br><span class="line">if (!cacheNames.isEmpty()) &#123;</span><br><span class="line">cacheManager.setCacheNames(cacheNames);</span><br><span class="line">&#125;</span><br><span class="line">return cacheManagerCustomizers.customize(cacheManager);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ConcurrentMapCacheManager使用ConcurrentMap以k-v的方式存储缓存缓存，下面以@Cacheable的运行流程为例说明ConcurrentMapCacheManager的作用。</p><p><strong>==@Cacheable的运行流程==</strong></p><ol><li><p>方法运行之前，先去查询Cache（缓存组件），<strong>按照cacheNames指定的名字获取</strong>；<br>（CacheManager先获取相应的缓存），第一次获取缓存如果没有Cache组件会自动创建,并以cacheNames-cache对放入ConcurrentMap。</p></li><li><p>去Cache中查找缓存的内容，使用一个key，默认就是方法的参数；<br><strong>key是按照某种策略生成的</strong>；默认是使用keyGenerator生成的，默认使用SimpleKeyGenerator生成key；</p><p> SimpleKeyGenerator生成key的默认策略；</p><p> 如果没有参数；key=new SimpleKey()；<br>​ 如果有一个参数：key=参数的值<br>​ 如果有多个参数：key=new SimpleKey(params)；</p></li><li><p>没有查到缓存就调用目标方法；</p></li><li><p>将目标方法返回的结果，放进缓存中</p></li></ol><p>@Cacheable标注的方法执行之前先来检查缓存中有没有这个数据，默认按照参数的值作为key去查询缓存，<br>如果没有就运行方法并将结果放入缓存；以后再来调用就可以直接使用缓存中的数据；</p><p>核心：<br>1）、使用CacheManager【ConcurrentMapCacheManager】按照名字得到Cache【ConcurrentMapCache】组件<br>2）、key使用keyGenerator生成的，默认是SimpleKeyGenerator</p><p><strong>源码分析</strong></p><p>默认使用ConcurrentMapCacheManager管理缓存，该类使用ConcurrentMap保存缓存，获取缓存如果没有Cache组件会自动创建,并以cacheNames-cache对放入ConcurrentMap。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ConcurrentMapCacheManager implements CacheManager, BeanClassLoaderAware &#123;</span><br><span class="line"></span><br><span class="line">private final ConcurrentMap&lt;String, Cache&gt; cacheMap &#x3D; new ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">private boolean dynamic &#x3D; true;</span><br><span class="line">    </span><br><span class="line">   &#x2F;&#x2F;获取缓存</span><br><span class="line">public Cache getCache(String name) &#123;</span><br><span class="line">Cache cache &#x3D; this.cacheMap.get(name);</span><br><span class="line">        &#x2F;&#x2F;如果没有缓存会自动创建</span><br><span class="line">if (cache &#x3D;&#x3D; null &amp;&amp; this.dynamic) &#123;</span><br><span class="line">synchronized (this.cacheMap) &#123;</span><br><span class="line">cache &#x3D; this.cacheMap.get(name);</span><br><span class="line">if (cache &#x3D;&#x3D; null) &#123;</span><br><span class="line">cache &#x3D; createConcurrentMapCache(name);</span><br><span class="line">this.cacheMap.put(name, cache);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return cache;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在@Cacheable标注方法执行前执行CacheAspectSupport的execute()方法，在该方法中会以一定的规则生成key，并尝试在缓存中通过该key获取值，若通过key获取到值则直接返回，不用执行@Cacheable标注方法，否则执行该方法获得返回值。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public abstract class CacheAspectSupport extends AbstractCacheInvoker</span><br><span class="line">implements BeanFactoryAware, InitializingBean, SmartInitializingSingleton &#123;</span><br><span class="line">    &#x2F;&#x2F;在执行@Cacheable标注的方法前执行此方法</span><br><span class="line">    @Nullable</span><br><span class="line">private Object execute(final CacheOperationInvoker invoker, Method method, CacheOperationContexts contexts) &#123;</span><br><span class="line">if (contexts.isSynchronized()) &#123;</span><br><span class="line">CacheOperationContext context &#x3D; contexts.get(CacheableOperation.class).iterator().next();</span><br><span class="line">if (isConditionPassing(context, CacheOperationExpressionEvaluator.NO_RESULT)) &#123;</span><br><span class="line">Object key &#x3D; generateKey(context, CacheOperationExpressionEvaluator.NO_RESULT);</span><br><span class="line">Cache cache &#x3D; context.getCaches().iterator().next();</span><br><span class="line">try &#123;</span><br><span class="line">return wrapCacheValue(method, cache.get(key, () -&gt; unwrapReturnValue(invokeOperation(invoker))));</span><br><span class="line">&#125;</span><br><span class="line">catch (Cache.ValueRetrievalException ex) &#123;</span><br><span class="line">throw (CacheOperationInvoker.ThrowableWrapper) ex.getCause();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">return invokeOperation(invoker);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line">processCacheEvicts(contexts.get(CacheEvictOperation.class), true,</span><br><span class="line">CacheOperationExpressionEvaluator.NO_RESULT);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 见findCachedItem方法</span><br><span class="line">        &#x2F;&#x2F;此方法通过一定规则生成的key找cache，若没找到则返回null</span><br><span class="line">Cache.ValueWrapper cacheHit &#x3D; findCachedItem(contexts.get(CacheableOperation.class));</span><br><span class="line"></span><br><span class="line">List&lt;CachePutRequest&gt; cachePutRequests &#x3D; new LinkedList&lt;&gt;();</span><br><span class="line">if (cacheHit &#x3D;&#x3D; null) &#123;</span><br><span class="line">collectPutRequests(contexts.get(CacheableOperation.class),</span><br><span class="line">CacheOperationExpressionEvaluator.NO_RESULT, cachePutRequests);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Object cacheValue;</span><br><span class="line">Object returnValue;</span><br><span class="line"></span><br><span class="line">if (cacheHit !&#x3D; null &amp;&amp; !hasCachePut(contexts)) &#123;</span><br><span class="line">&#x2F;&#x2F; 如果通过该key找到缓存，且无@cacheput,则直接返回cacheValue</span><br><span class="line">cacheValue &#x3D; cacheHit.get();</span><br><span class="line">returnValue &#x3D; wrapCacheValue(method, cacheValue);</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">&#x2F;&#x2F; 若通过该key未找到缓存，则执行@cacheable标注方法</span><br><span class="line">returnValue &#x3D; invokeOperation(invoker);</span><br><span class="line">cacheValue &#x3D; unwrapReturnValue(returnValue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Collect any explicit @CachePuts</span><br><span class="line">collectPutRequests(contexts.get(CachePutOperation.class), cacheValue, cachePutRequests);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Process any collected put requests, either from @CachePut or a @Cacheable miss</span><br><span class="line">for (CachePutRequest cachePutRequest : cachePutRequests) &#123;</span><br><span class="line">cachePutRequest.apply(cacheValue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Process any late evictions</span><br><span class="line">processCacheEvicts(contexts.get(CacheEvictOperation.class), false, cacheValue);</span><br><span class="line"></span><br><span class="line">return returnValue;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    @Nullable</span><br><span class="line">private Cache.ValueWrapper findCachedItem(Collection&lt;CacheOperationContext&gt; contexts) &#123;</span><br><span class="line">Object result &#x3D; CacheOperationExpressionEvaluator.NO_RESULT;</span><br><span class="line">for (CacheOperationContext context : contexts) &#123;</span><br><span class="line">if (isConditionPassing(context, result)) &#123;</span><br><span class="line">                &#x2F;&#x2F;通过一定规则生成key值(生成规则见generateKey方法)</span><br><span class="line">Object key &#x3D; generateKey(context, result);</span><br><span class="line">                &#x2F;&#x2F;通过生成的key寻找缓存</span><br><span class="line">Cache.ValueWrapper cached &#x3D; findInCaches(context, key);</span><br><span class="line">if (cached !&#x3D; null) &#123;</span><br><span class="line">return cached;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">if (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(&quot;No cache entry for key &#39;&quot; + key + &quot;&#39; in cache(s) &quot; + context.getCacheNames());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;key的生成策略</span><br><span class="line">    @Nullable</span><br><span class="line">    protected Object generateKey(@Nullable Object result) &#123;</span><br><span class="line">        &#x2F;&#x2F;如果@Cacheable设置了属性key，则根据设置值生成key</span><br><span class="line">        if (StringUtils.hasText(this.metadata.operation.getKey())) &#123;</span><br><span class="line">            EvaluationContext evaluationContext &#x3D; createEvaluationContext(result);</span><br><span class="line">            return evaluator.key(this.metadata.operation.getKey(), this.metadata.methodKey, evaluationContext);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;否则使用keyGenerator生成key，默认keyGenerator为SimpleKeyGenerator</span><br><span class="line">        return this.metadata.keyGenerator.generate(this.target, this.metadata.method, this.args);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>默认情况下使用SimpleKeyGenerator生成key</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class SimpleKeyGenerator implements KeyGenerator &#123;</span><br><span class="line">    &#x2F;&#x2F;SimpleKeyGenerator的生成规则</span><br><span class="line">    public static Object generateKey(Object... params) &#123;</span><br><span class="line">        &#x2F;&#x2F;若无参，则返回空key</span><br><span class="line">if (params.length &#x3D;&#x3D; 0) &#123;</span><br><span class="line">return SimpleKey.EMPTY;</span><br><span class="line">&#125;</span><br><span class="line">if (params.length &#x3D;&#x3D; 1) &#123;</span><br><span class="line">Object param &#x3D; params[0];</span><br><span class="line">if (param !&#x3D; null &amp;&amp; !param.getClass().isArray()) &#123;</span><br><span class="line">                &#x2F;&#x2F;1个参数，则直接返回该参数</span><br><span class="line">return param;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">          &#x2F;&#x2F;多个参数返回数组</span><br><span class="line">return new SimpleKey(params);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认的缓存类ConcurrentMapCache，使用ConcurrentMap存储k-v</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ConcurrentMapCache extends AbstractValueAdaptingCache &#123;</span><br><span class="line"></span><br><span class="line">private final String name;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;存储key-cacheValue</span><br><span class="line">private final ConcurrentMap&lt;Object, Object&gt; store;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;通过key查找cacheValue</span><br><span class="line">protected Object lookup(Object key) &#123;</span><br><span class="line">return this.store.get(key);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;方法调用完后将结果存入缓存中</span><br><span class="line">    public void put(Object key, @Nullable Object value) &#123;</span><br><span class="line">this.store.put(key, toStoreValue(value));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="五、Redis与缓存"><a href="#五、Redis与缓存" class="headerlink" title="五、Redis与缓存"></a>五、Redis与缓存</h2><h3 id="1-环境搭建"><a href="#1-环境搭建" class="headerlink" title="1. 环境搭建"></a>1. 环境搭建</h3><p>导入依赖</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">     &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">     &lt;artifactId&gt;spring-boot-starter-data-redis&lt;&#x2F;artifactId&gt;</span><br><span class="line"> &lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><p>在spring.properties指定Redis服务器地址</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#redis服务器主机地址</span><br><span class="line">spring.redis.host&#x3D;192.168.31.162</span><br></pre></td></tr></table></figure><h3 id="2-RedisTemplate"><a href="#2-RedisTemplate" class="headerlink" title="2. RedisTemplate"></a>2. RedisTemplate</h3><p>RedisAutoConfiguration向容器中导入了两个类RedisTemplate&lt;Object, Object&gt; redisTemplate和StringRedisTemplate，作为Redis客户端分别操作k-v都为对象和k-v都为字符串的值</p><p><strong>Redis常见的五大数据类型</strong></p><p>String（字符串）、List（列表）、Set（集合）、Hash（散列）、ZSet（有序集合）</p><p> stringRedisTemplate.opsForValue()[String（字符串）]</p><p> stringRedisTemplate.opsForList()[List（列表）]</p><p> stringRedisTemplate.opsForSet()[Set（集合）]</p><p> stringRedisTemplate.opsForHash()[Hash（散列）]</p><p> stringRedisTemplate.opsForZSet()[ZSet（有序集合）]</p><h3 id="3-Redis缓存使用"><a href="#3-Redis缓存使用" class="headerlink" title="3. Redis缓存使用"></a>3. Redis缓存使用</h3><p>在导入redis依赖后RedisCacheConfiguration类就会自动生效，创建RedisCacheManager，并使用RedisCache进行缓存数据，要缓存的对象的类要实现Serializable接口，默认情况下是以<strong>jdk序列化数据</strong>存在redis中，如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">k:&quot;emp::1&quot;</span><br><span class="line">v:</span><br><span class="line">\xAC\xED\x00\x05sr\x00$cn.edu.ustc.springboot.bean.Employeeuqf\x03p\x9A\xCF\xE0\x02\x00\x05L\x00\x03dIdt\x00\x13Ljava&#x2F;lang&#x2F;Integer;L\x00\x05emailt\x00\x12Ljava&#x2F;lang&#x2F;String;L\x00\x06genderq\x00~\x00\x01L\x00\x02idq\x00~\x00\x01L\x00\x08lastNameq\x00~\x00\x02xpsr\x00\x11java.lang.Integer\x12\xE2\xA0\xA4\xF7\x81\x878\x02\x00\x01I\x00\x05valuexr\x00\x10java.lang.Number\x86\xAC\x95\x1D\x0B\x94\xE0\x8B\x02\x00\x00xp\x00\x00\x00\x03t\x00\x07cch@aaasq\x00~\x00\x04\x00\x00\x00\x01q\x00~\x00\x08t\x00\x03cch</span><br></pre></td></tr></table></figure><p>要想让对象以<strong>json形式</strong>存储在redis中，需要自定义RedisCacheManager，使用GenericJackson2JsonRedisSerializer类对value进行序列化</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class MyRedisConfig &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    RedisCacheManager cacheManager(RedisConnectionFactory factory)&#123;</span><br><span class="line">        &#x2F;&#x2F;创建默认RedisCacheWriter</span><br><span class="line">        RedisCacheWriter cacheWriter &#x3D; RedisCacheWriter.nonLockingRedisCacheWriter(factory);</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;创建默认RedisCacheConfiguration并使用GenericJackson2JsonRedisSerializer构造的SerializationPair对value进行转换</span><br><span class="line">        &#x2F;&#x2F;创建GenericJackson2JsonRedisSerializer的json序列化器</span><br><span class="line">        GenericJackson2JsonRedisSerializer jsonRedisSerializer &#x3D; new GenericJackson2JsonRedisSerializer();</span><br><span class="line">        &#x2F;&#x2F;使用json序列化器构造出对转换Object类型的SerializationPair序列化对</span><br><span class="line">        RedisSerializationContext.SerializationPair&lt;Object&gt; serializationPair &#x3D; RedisSerializationContext.SerializationPair.fromSerializer(jsonRedisSerializer);</span><br><span class="line">        &#x2F;&#x2F;将可以把Object转换为json的SerializationPair传入RedisCacheConfiguration</span><br><span class="line">        &#x2F;&#x2F;使得RedisCacheConfiguration在转换value时使用定制序列化器</span><br><span class="line">        RedisCacheConfiguration cacheConfiguration&#x3D;RedisCacheConfiguration.defaultCacheConfig().serializeValuesWith(serializationPair);</span><br><span class="line">        </span><br><span class="line">        RedisCacheManager cacheManager &#x3D; new RedisCacheManager(cacheWriter,cacheConfiguration);</span><br><span class="line">        return cacheManager;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>序列化数据如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">k:&quot;emp::3&quot;</span><br><span class="line"></span><br><span class="line">v:</span><br><span class="line">&#123;</span><br><span class="line">  &quot;@class&quot;: &quot;cn.edu.ustc.springboot.bean.Employee&quot;,</span><br><span class="line">  &quot;id&quot;: 3,</span><br><span class="line">  &quot;lastName&quot;: &quot;aaa&quot;,</span><br><span class="line">  &quot;email&quot;: &quot;aaaa&quot;,</span><br><span class="line">  &quot;gender&quot;: 1,</span><br><span class="line">  &quot;dId&quot;: 5</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>，这里必须用<strong>GenericJackson2JsonRedisSerializer</strong>进行value的序列化解析，如果使用Jackson2JsonRedisSerializer，序列化的json没有<code>&quot;@class&quot;: &quot;cn.edu.ustc.springboot.bean.Employee&quot;</code>,在读取缓存时会报类型转换异常。</p><h3 id="4-Redis缓存原理"><a href="#4-Redis缓存原理" class="headerlink" title="4. Redis缓存原理"></a>4. Redis缓存原理</h3><p>配置类RedisCacheConfiguration向容器中导入了其定制的RedisCacheManager，在默认的RedisCacheManager的配置中，是使用jdk序列化value值</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Configuration(proxyBeanMethods &#x3D; false)</span><br><span class="line">@ConditionalOnClass(RedisConnectionFactory.class)</span><br><span class="line">@AutoConfigureAfter(RedisAutoConfiguration.class)</span><br><span class="line">@ConditionalOnBean(RedisConnectionFactory.class)</span><br><span class="line">@ConditionalOnMissingBean(CacheManager.class)</span><br><span class="line">@Conditional(CacheCondition.class)</span><br><span class="line">class RedisCacheConfiguration &#123;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;向容器中导入RedisCacheManager</span><br><span class="line">@Bean</span><br><span class="line">RedisCacheManager cacheManager(CacheProperties cacheProperties, CacheManagerCustomizers cacheManagerCustomizers,</span><br><span class="line">ObjectProvider&lt;org.springframework.data.redis.cache.RedisCacheConfiguration&gt; redisCacheConfiguration,</span><br><span class="line">ObjectProvider&lt;RedisCacheManagerBuilderCustomizer&gt; redisCacheManagerBuilderCustomizers,</span><br><span class="line">RedisConnectionFactory redisConnectionFactory, ResourceLoader resourceLoader) &#123;</span><br><span class="line">&#x2F;&#x2F;使用determineConfiguration()的返回值生成RedisCacheManagerBuilder</span><br><span class="line">        &#x2F;&#x2F;调用了RedisCacheManagerBuilder的cacheDefaults()方法(见下一代码块)</span><br><span class="line">        RedisCacheManagerBuilder builder &#x3D; RedisCacheManager.builder(redisConnectionFactory).cacheDefaults(</span><br><span class="line">determineConfiguration(cacheProperties, redisCacheConfiguration, resourceLoader.getClassLoader()));</span><br><span class="line">List&lt;String&gt; cacheNames &#x3D; cacheProperties.getCacheNames();</span><br><span class="line">if (!cacheNames.isEmpty()) &#123;</span><br><span class="line">builder.initialCacheNames(new LinkedHashSet&lt;&gt;(cacheNames));</span><br><span class="line">&#125;</span><br><span class="line">redisCacheManagerBuilderCustomizers.orderedStream().forEach((customizer) -&gt; customizer.customize(builder));</span><br><span class="line">        &#x2F;&#x2F;使用RedisCacheManagerBuilder的build()方法创建RedisCacheManager并进行定制操作</span><br><span class="line">return cacheManagerCustomizers.customize(builder.build());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">private org.springframework.data.redis.cache.RedisCacheConfiguration determineConfiguration(</span><br><span class="line">CacheProperties cacheProperties,</span><br><span class="line">ObjectProvider&lt;org.springframework.data.redis.cache.RedisCacheConfiguration&gt; redisCacheConfiguration,</span><br><span class="line">ClassLoader classLoader) &#123;</span><br><span class="line">        &#x2F;&#x2F;determineConfiguration()调用了createConfiguration()</span><br><span class="line">return redisCacheConfiguration.getIfAvailable(() -&gt; createConfiguration(cacheProperties, classLoader));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;createConfiguration()定义了其序列化value的规则</span><br><span class="line">private org.springframework.data.redis.cache.RedisCacheConfiguration createConfiguration(</span><br><span class="line">CacheProperties cacheProperties, ClassLoader classLoader) &#123;</span><br><span class="line">Redis redisProperties &#x3D; cacheProperties.getRedis();</span><br><span class="line">org.springframework.data.redis.cache.RedisCacheConfiguration config &#x3D; org.springframework.data.redis.cache.RedisCacheConfiguration</span><br><span class="line">.defaultCacheConfig();</span><br><span class="line">        &#x2F;&#x2F;使用jdk序列化器对value进行序列化</span><br><span class="line">config &#x3D; config.serializeValuesWith(</span><br><span class="line">SerializationPair.fromSerializer(new JdkSerializationRedisSerializer(classLoader)));</span><br><span class="line">        &#x2F;&#x2F;设置properties文件中设置的各项属性</span><br><span class="line">if (redisProperties.getTimeToLive() !&#x3D; null) &#123;</span><br><span class="line">config &#x3D; config.entryTtl(redisProperties.getTimeToLive());</span><br><span class="line">&#125;</span><br><span class="line">if (redisProperties.getKeyPrefix() !&#x3D; null) &#123;</span><br><span class="line">config &#x3D; config.prefixKeysWith(redisProperties.getKeyPrefix());</span><br><span class="line">&#125;</span><br><span class="line">if (!redisProperties.isCacheNullValues()) &#123;</span><br><span class="line">config &#x3D; config.disableCachingNullValues();</span><br><span class="line">&#125;</span><br><span class="line">if (!redisProperties.isUseKeyPrefix()) &#123;</span><br><span class="line">config &#x3D; config.disableKeyPrefix();</span><br><span class="line">&#125;</span><br><span class="line">return config;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RedisCacheManager的直接构造类，该类保存了配置类RedisCacheConfiguration，该配置在会传递给RedisCacheManager</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static class RedisCacheManagerBuilder &#123;</span><br><span class="line"></span><br><span class="line">private final RedisCacheWriter cacheWriter;</span><br><span class="line">    &#x2F;&#x2F;默认缓存配置使用RedisCacheConfiguration的默认配置</span><br><span class="line">    &#x2F;&#x2F;该默认配置缓存时默认将k按字符串存储，v按jdk序列化数据存储(见下一代码块)</span><br><span class="line">private RedisCacheConfiguration defaultCacheConfiguration &#x3D; RedisCacheConfiguration.defaultCacheConfig();</span><br><span class="line">private final Map&lt;String, RedisCacheConfiguration&gt; initialCaches &#x3D; new LinkedHashMap&lt;&gt;();</span><br><span class="line">private boolean enableTransactions;</span><br><span class="line">boolean allowInFlightCacheCreation &#x3D; true;</span><br><span class="line"></span><br><span class="line">private RedisCacheManagerBuilder(RedisCacheWriter cacheWriter) &#123;</span><br><span class="line">this.cacheWriter &#x3D; cacheWriter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;传入RedisCacheManagerBuilder使用的缓存配置规则RedisCacheConfiguration类</span><br><span class="line">public RedisCacheManagerBuilder cacheDefaults(RedisCacheConfiguration defaultCacheConfiguration) &#123;</span><br><span class="line"></span><br><span class="line">Assert.notNull(defaultCacheConfiguration, &quot;DefaultCacheConfiguration must not be null!&quot;);</span><br><span class="line"></span><br><span class="line">this.defaultCacheConfiguration &#x3D; defaultCacheConfiguration;</span><br><span class="line"></span><br><span class="line">return this;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;使用默认defaultCacheConfiguration创建RedisCacheManager</span><br><span class="line">    public RedisCacheManager build() &#123;</span><br><span class="line"></span><br><span class="line">RedisCacheManager cm &#x3D; new RedisCacheManager(cacheWriter, defaultCacheConfiguration, initialCaches,</span><br><span class="line">allowInFlightCacheCreation);</span><br><span class="line"></span><br><span class="line">cm.setTransactionAware(enableTransactions);</span><br><span class="line"></span><br><span class="line">return cm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RedisCacheConfiguration保存了许多缓存规则，这些规则都保存在RedisCacheManagerBuilder的RedisCacheConfiguration defaultCacheConfiguration属性中，并且当RedisCacheManagerBuilder创建RedisCacheManager传递过去</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class RedisCacheConfiguration &#123;</span><br><span class="line"></span><br><span class="line">private final Duration ttl;</span><br><span class="line">private final boolean cacheNullValues;</span><br><span class="line">private final CacheKeyPrefix keyPrefix;</span><br><span class="line">private final boolean usePrefix;</span><br><span class="line"></span><br><span class="line">private final SerializationPair&lt;String&gt; keySerializationPair;</span><br><span class="line">private final SerializationPair&lt;Object&gt; valueSerializationPair;</span><br><span class="line"></span><br><span class="line">private final ConversionService conversionService;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;默认缓存配置</span><br><span class="line">    public static RedisCacheConfiguration defaultCacheConfig(@Nullable ClassLoader classLoader) &#123;</span><br><span class="line"></span><br><span class="line">            DefaultFormattingConversionService conversionService &#x3D; new DefaultFormattingConversionService();</span><br><span class="line"></span><br><span class="line">            registerDefaultConverters(conversionService);</span><br><span class="line"></span><br><span class="line">            return new RedisCacheConfiguration(Duration.ZERO, true, true, CacheKeyPrefix.simple(),</span><br><span class="line">                                     SerializationPair.fromSerializer(RedisSerializer.string()),&#x2F;&#x2F;key使用字符串</span><br><span class="line">                                               SerializationPair.fromSerializer(RedisSerializer.java(classLoader)), conversionService);</span><br><span class="line">        &#x2F;&#x2F;value按jdk序列化存储</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>RedisCacheManager在创建RedisCache时将RedisCacheConfiguration传递过去，并在创建RedisCache时通过createRedisCache()起作用</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class RedisCacheManager extends AbstractTransactionSupportingCacheManager &#123;</span><br><span class="line"></span><br><span class="line">private final RedisCacheWriter cacheWriter;</span><br><span class="line">private final RedisCacheConfiguration defaultCacheConfig;</span><br><span class="line">private final Map&lt;String, RedisCacheConfiguration&gt; initialCacheConfiguration;</span><br><span class="line">private final boolean allowInFlightCacheCreation;</span><br><span class="line">    </span><br><span class="line">    protected RedisCache createRedisCache(String name, @Nullable RedisCacheConfiguration cacheConfig) &#123;</span><br><span class="line">        &#x2F;&#x2F;如果调用该方法时RedisCacheConfiguration有值则使用定制的，否则则使用默认的RedisCacheConfiguration defaultCacheConfig，即RedisCacheManagerBuilder传递过来的配置</span><br><span class="line">return new RedisCache(name, cacheWriter, cacheConfig !&#x3D; null ? cacheConfig : defaultCacheConfig);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RedisCache，Redis缓存，具体负责将缓存数据序列化的地方，将RedisCacheConfiguration的序列化对SerializationPair提取出来并使用其定义的序列化方式分别对k和v进行序列化操作</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class RedisCache extends AbstractValueAdaptingCache &#123;</span><br><span class="line">    </span><br><span class="line">    private static final byte[] BINARY_NULL_VALUE &#x3D; RedisSerializer.java().serialize(NullValue.INSTANCE);</span><br><span class="line"></span><br><span class="line">private final String name;</span><br><span class="line">private final RedisCacheWriter cacheWriter;</span><br><span class="line">private final RedisCacheConfiguration cacheConfig;</span><br><span class="line">private final ConversionService conversionService;</span><br><span class="line">    </span><br><span class="line">    public void put(Object key, @Nullable Object value) &#123;</span><br><span class="line"></span><br><span class="line">Object cacheValue &#x3D; preProcessCacheValue(value);</span><br><span class="line"></span><br><span class="line">if (!isAllowNullValues() &amp;&amp; cacheValue &#x3D;&#x3D; null) &#123;</span><br><span class="line"></span><br><span class="line">throw new IllegalArgumentException(String.format(</span><br><span class="line">&quot;Cache &#39;%s&#39; does not allow &#39;null&#39; values. Avoid storing null via &#39;@Cacheable(unless&#x3D;\&quot;#result &#x3D;&#x3D; null\&quot;)&#39; or configure RedisCache to allow &#39;null&#39; via RedisCacheConfiguration.&quot;,</span><br><span class="line">name));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;在put k-v时使用cacheConfig中的k-v序列化器分别对k-v进行序列化</span><br><span class="line">cacheWriter.put(name, createAndConvertCacheKey(key), serializeCacheValue(cacheValue), cacheConfig.getTtl());</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;从cacheConfig(即RedisCacheConfiguration)中获取KeySerializationPair并写入key值</span><br><span class="line">    protected byte[] serializeCacheKey(String cacheKey) &#123;</span><br><span class="line">return ByteUtils.getBytes(cacheConfig.getKeySerializationPair().write(cacheKey));</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;从cacheConfig(即RedisCacheConfiguration)中获取ValueSerializationPair并写入key值</span><br><span class="line">    protected byte[] serializeCacheValue(Object value) &#123;</span><br><span class="line"></span><br><span class="line">        if (isAllowNullValues() &amp;&amp; value instanceof NullValue) &#123;</span><br><span class="line">            return BINARY_NULL_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return ByteUtils.getBytes(cacheConfig.getValueSerializationPair().write(value));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>分析到这也就不难理解，要使用json保存序列化数据时，需要自定义RedisCacheManager，在RedisCacheConfiguration中定义序列化转化规则，并向RedisCacheManager传入我们自己定制的RedisCacheConfiguration了，我定制的序列化规则会跟随RedisCacheConfiguration一直传递到RedisCache，并在序列化时发挥作用。</p><h1 id="二-Spring-Boot与消息"><a href="#二-Spring-Boot与消息" class="headerlink" title="(二) Spring Boot与消息"></a>(二) Spring Boot与消息</h1><h2 id="一、消息简介"><a href="#一、消息简介" class="headerlink" title="一、消息简介"></a>一、消息简介</h2><p><strong>消息代理规范</strong></p><ul><li>JMS（Java Message Service）JAVA消息服务<ul><li>基于JVM消息代理的规范。ActiveMQ、HornetMQ是JMS实现</li></ul></li><li>AMQP（Advanced Message Queuing Protocol）<ul><li>高级消息队列协议，也是一个消息代理的规范，兼容JMS</li><li>RabbitMQ是AMQP的实现</li></ul></li></ul><p><strong>作用</strong></p><p>通过消息服务中间件来提升系统异步通信、扩展解耦能力</p><p>当消息发送者发送消息以后，将由消息代理接管，消息代理保证消息传递到指定目的地</p><p><strong>应用场景</strong></p><ol><li><p>异步处理</p><p>用户注册操作和消息处理并行，提高响应速度</p></li></ol><p><a href="https://niceseason.github.io/images/图片3.png" target="_blank" rel="noopener"><img src="https://niceseason.github.io/images/%E5%9B%BE%E7%89%873.png" alt="img"></a></p><ol><li><p>应用解耦</p><p>在下单时库存系统不能正常使用。也不影响正常下单，因为下单后，订单系统写入消息队列就不再关心其他的后续操作了。实现订单系统与库存系统的应用解耦</p><p><img src="https://niceseason.github.io/images/%E5%9B%BE%E7%89%874.png" alt="img"></p></li><li><p>流量削峰</p><p>用户的请求，服务器接收后，首先写入消息队列。假如消息队列长度超过最大数量，则直接抛弃用户请求或跳转到错误页面</p><p>秒杀业务根据消息队列中的请求信息，再做后续处理</p><p><a href="https://niceseason.github.io/images/图片5.png" target="_blank" rel="noopener"><img src="https://niceseason.github.io/images/%E5%9B%BE%E7%89%875.png" alt="img"></a></p></li></ol><h2 id="二、RabbitMQ"><a href="#二、RabbitMQ" class="headerlink" title="二、RabbitMQ"></a>二、RabbitMQ</h2><p>RabbitMQ是一个由erlang开发的AMQP(Advanved Message Queue Protocol)的开源实现。</p><h3 id="1-核心概念"><a href="#1-核心概念" class="headerlink" title="1. 核心概念"></a>1. 核心概念</h3><ul><li><strong>Message</strong><ul><li>消息，消息是不具名的，它由消息头和消息体组成</li><li>消息头，包括routing-key（路由键）、priority（相对于其他消息的优先权）、delivery-mode（指出该消息可能需要持久性存储）等</li></ul></li><li>Publisher<ul><li>消息的生产者，也是一个向交换器发布消息的客户端应用程序</li></ul></li><li><strong>Exchange</strong><ul><li>交换器，将生产者消息路由给服务器中的队列</li><li>类型有direct(默认)，fanout, topic, 和headers，具有不同转发策略</li></ul></li><li><strong>Queue</strong><ul><li>消息队列，保存消息直到发送给消费者</li></ul></li><li><strong>Binding</strong><ul><li>绑定，用于消息队列和交换器之间的关联</li></ul></li><li>Connection<ul><li>网络连接，比如一个TCP连接</li></ul></li><li>Consumer<ul><li>消息的消费者，表示一个从消息队列中取得消息的客户端应用程序</li></ul></li><li>Virtual Host<ul><li>虚拟主机，表示一批交换器、消息队列和相关对象。</li><li>vhost 是 AMQP 概念的基础，必须在连接时指定</li><li>RabbitMQ 默认的 vhost 是 /</li></ul></li><li>Broker<ul><li>消息队列服务器实体</li></ul></li></ul><h3 id="2-运行机制"><a href="#2-运行机制" class="headerlink" title="2. 运行机制"></a>2. 运行机制</h3><p><strong>消息路由</strong></p><p>AMQP 中增加了Exchange 和 Binding 的角色， Binding 决定交换器的消息应该发送到那个队列</p><p><strong>Exchange 类型</strong></p><ol><li><p>direct</p><p>点对点模式，消息中的路由键（routing key）如果和 Binding 中的 binding<br>key 一致， 交换器就将消息发到对应的队列中。</p></li><li><p>fanout</p><p>广播模式，每个发到 fanout 类型交换器的消息都会分到所有绑定的队列上去</p></li><li><p>topic</p><p>将路由键和某个模式进行匹配，此时队列需要绑定到一个模式上。它将路由键和绑定键的字符串切分成单词，这些单词之间用点隔开。<br>识别通配符： # 匹配 0 个或多个单词， *匹配一个单词</p><p><a href="https://niceseason.github.io/images/Snipaste_2020-04-09_14-11-13.png" target="_blank" rel="noopener"><img src="https://niceseason.github.io/images/Snipaste_2020-04-09_14-11-13.png" alt="img"></a></p></li></ol><h2 id="三、-Springboot中的RabbitMQ"><a href="#三、-Springboot中的RabbitMQ" class="headerlink" title="三、 Springboot中的RabbitMQ"></a>三、 Springboot中的RabbitMQ</h2><h3 id="1-环境准备"><a href="#1-环境准备" class="headerlink" title="1. 环境准备"></a>1. 环境准备</h3><p>在docker中安装rabbitmq并运行</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 5672为服务端口，15672为web控制台端口</span><br><span class="line">docker run -d -p 5672:5672 -p 15672:15672 38e57f281891</span><br></pre></td></tr></table></figure><p>导入依赖</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">   &lt;dependency&gt;</span><br><span class="line">       &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">       &lt;artifactId&gt;spring-boot-starter-amqp&lt;&#x2F;artifactId&gt;</span><br><span class="line">   &lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;!--自定义消息转化器Jackson2JsonMessageConverter所需依赖--&gt;</span><br><span class="line">   &lt;dependency&gt;</span><br><span class="line">       &lt;groupId&gt;com.fasterxml.jackson.core&lt;&#x2F;groupId&gt;</span><br><span class="line">       &lt;artifactId&gt;jackson-databind&lt;&#x2F;artifactId&gt;</span><br><span class="line">   &lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><p>配置文件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 指定rebbitmq服务器主机</span><br><span class="line">spring.rabbitmq.host&#x3D;192.168.31.162</span><br><span class="line">#spring.rabbitmq.username&#x3D;guest  默认值为guest</span><br><span class="line">#spring.rabbitmq.password&#x3D;guest 默认值为guest</span><br></pre></td></tr></table></figure><h3 id="2-RabbitMQ的使用"><a href="#2-RabbitMQ的使用" class="headerlink" title="2. RabbitMQ的使用"></a>2. RabbitMQ的使用</h3><p>RabbitAutoConfiguration中有内部类RabbitTemplateConfiguration,在该类中向容器中分别导入了<strong>RabbitTemplate</strong>和<strong>AmqpAdmin</strong></p><p>在测试类中分别注入</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">   private RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">   @Autowired</span><br><span class="line">   private AmqpAdmin amqpAdmin;</span><br></pre></td></tr></table></figure><ul><li><p><strong>RabbitTemplate消息发送处理组件</strong></p><p> 可用来发送和接收消息</p></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;发送消息</span><br><span class="line">rabbitTemplate.convertAndSend(&quot;amq.direct&quot;,&quot;ustc&quot;,&quot;aaaa&quot;);</span><br><span class="line">      Book book &#x3D; new Book();</span><br><span class="line">      book.setName(&quot;西游记&quot;);</span><br><span class="line">      book.setPrice(23.2f);</span><br><span class="line">&#x2F;&#x2F;Book要实现Serializable接口</span><br><span class="line">      rabbitTemplate.convertAndSend(&quot;amq.direct&quot;,&quot;ustc&quot;,book);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;接收消息</span><br><span class="line">Object o &#x3D; rabbitTemplate.receiveAndConvert(&quot;ustc&quot;);</span><br><span class="line">      System.out.println(o.getClass());  &#x2F;&#x2F;class cn.edu.ustc.springboot.bean.Book</span><br><span class="line">      System.out.println(o);&#x2F;&#x2F;Book&#123;name&#x3D;&#39;西游记&#39;, price&#x3D;23.2&#125;</span><br></pre></td></tr></table></figure><p>默认的消息转化器是SimpleMessageConverter，对于对象以jdk序列化方式存储，若要以Json方式存储对象，就要自定义消息转换器</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class AmqpConfig &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    public MessageConverter messageConverter() &#123;</span><br><span class="line">        &#x2F;&#x2F;在容器中导入Json的消息转换器</span><br><span class="line">        return new Jackson2JsonMessageConverter();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>AmqpAdmin管理组件</strong></p><p> 可用于创建和删除exchange、binding和queue</p></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;创建Direct类型的Exchange</span><br><span class="line">amqpAdmin.declareExchange(new DirectExchange(&quot;admin.direct&quot;));</span><br><span class="line">&#x2F;&#x2F;创建Queue</span><br><span class="line">amqpAdmin.declareQueue(new Queue(&quot;admin.test&quot;));</span><br><span class="line">&#x2F;&#x2F;将创建的队列与Exchange绑定</span><br><span class="line">amqpAdmin.declareBinding(new Binding(&quot;admin.test&quot;, Binding.DestinationType.QUEUE,&quot;admin.direct&quot;,&quot;admin.test&quot;,null));</span><br></pre></td></tr></table></figure><p><strong>消息的监听</strong></p><p>在回调方法上标注@RabbitListener注解，并设置其属性queues，注册监听队列，当该队列收到消息时，标注方法遍会调用</p><p>可分别使用Message和保存消息所属对象进行消息接收，若使用Object对象进行消息接收，实际上接收到的也是Message</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class BookService &#123;</span><br><span class="line">    @RabbitListener(queues &#x3D; &#123;&quot;admin.test&quot;&#125;)</span><br><span class="line">    public void receive1(Book book)&#123;</span><br><span class="line">        System.out.println(&quot;收到消息：&quot;+book);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @RabbitListener(queues &#x3D; &#123;&quot;admin.test&quot;&#125;)</span><br><span class="line">    public void receive1(Object object)&#123;</span><br><span class="line">        System.out.println(&quot;收到消息：&quot;+object.getClass());</span><br><span class="line">        &#x2F;&#x2F;收到消息：class org.springframework.amqp.core.Message</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @RabbitListener(queues &#x3D; &#123;&quot;admin.test&quot;&#125;)</span><br><span class="line">    public void receive2(Message message)&#123;</span><br><span class="line">        System.out.println(&quot;收到消息&quot;+message.getHeaders()+&quot;---&quot;+message.getPayload());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="三-Spring-boot与检索"><a href="#三-Spring-boot与检索" class="headerlink" title="(三) Spring boot与检索"></a>(三) Spring boot与检索</h1><h2 id="一、-ElasticSearch入门"><a href="#一、-ElasticSearch入门" class="headerlink" title="一、 ElasticSearch入门"></a>一、 ElasticSearch入门</h2><h3 id="1-ES的简介"><a href="#1-ES的简介" class="headerlink" title="1. ES的简介"></a>1. ES的简介</h3><p><strong>简介</strong></p><p>我们的应用经常需要添加检索功能，开源的 ElasticSearch 是目前全文搜索引擎的首选。他可以快速的存储、搜索和分析海量数据。Spring Boot通过整合Spring Data ElasticSearch为我们提供了非常便捷的检索功能支持；<br>Elasticsearch是一个分布式搜索服务，提供Restful API，底层基于Lucene，采用多shard（分片）的方式保证数据安全，并且提供自动resharding的功能，github等大型的站点也是采用了ElasticSearch作为其搜索服务。</p><p><strong>概念</strong></p><p>员工文档 的形式存储为例：一个<strong>文档</strong>代表一个<strong>员工数据</strong>。存储数据到ElasticSearch 的行为叫做 <strong>索引</strong> ，但在索引一个文档之前，需要确定将文档存储在哪里。</p><p>一个 ElasticSearch 集群可以包含多个 <strong>索引</strong> ，相应的每个索引可以包含多个 <strong>类型</strong> 。 这些不同的类型存储着多个 文<strong>档</strong> ，每个文档又有 多个 <strong>属性</strong> 。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">索引（名词）：</span><br><span class="line"></span><br><span class="line">如前所述，一个 *索引* 类似于传统关系数据库中的一个 *数据库* ，是一个存储关系型文档的地方。 *索引* (*index*) 的复数词为 *indices* 或 *indexes* 。</span><br><span class="line"></span><br><span class="line">索引（动词）：</span><br><span class="line"></span><br><span class="line">*索引一个文档* 就是存储一个文档到一个 *索引* （名词）中以便被检索和查询。这非常类似于 SQL 语句中的 &#96;INSERT&#96; 关键词，除了文档已存在时，新文档会替换旧文档情况之外。</span><br></pre></td></tr></table></figure><p>类似关系：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-索引---数据库</span><br><span class="line">-类型---表</span><br><span class="line">-文档---表中的记录</span><br><span class="line">-属性---列</span><br></pre></td></tr></table></figure><p><a href="https://niceseason.github.io/images/Snipaste_2020-04-11_23-25-26.png" target="_blank" rel="noopener"><img src="https://niceseason.github.io/images/Snipaste_2020-04-11_23-25-26.png" alt="img"></a></p><h3 id="2-ES的安装与运行"><a href="#2-ES的安装与运行" class="headerlink" title="2. ES的安装与运行"></a>2. ES的安装与运行</h3><p>与ES交互</p><ul><li><p>9200端口</p><p> RESTful API通过HTTP通信</p></li><li><p>9300端口</p><p> Java客户端与ES的原生传输协议和集群交互</p></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 拉取ES镜像</span><br><span class="line">docker pull elasticsearch:7.6.1</span><br><span class="line">#运行ES</span><br><span class="line">docker run -e &quot;discovery.type&#x3D;single-node&quot; -e ES_JAVA_OPTS&#x3D;&quot;-Xms256m -Xmx256m&quot; -d -p 9200:9200 -p 9300:9300 --name ES03 41072cdeebc5</span><br></pre></td></tr></table></figure><p><code>ES_JAVA_OPTS</code>指定java虚拟机相关参数</p><p> <code>-Xms256m</code> 初始堆内存大小为256m</p><p> <code>-Xmx256m</code> 最大堆内存大小为256m</p><p><code>discovery.type=single-node</code> 设置为单点启动</p><h3 id="3-ES的基础入门"><a href="#3-ES的基础入门" class="headerlink" title="3. ES的基础入门"></a>3. ES的基础入门</h3><p><strong>案例：创建一个员工目录，并支持各类型检索</strong></p><p><strong>索引员工文档</strong></p><p>对于员工目录，我们将做如下操作：</p><ul><li>每个员工索引一个文档，文档包含该员工的所有信息。</li><li>每个文档都将是 <code>employee</code> <em>类型</em> 。</li><li>该类型位于 <em>索引</em> <code>megacorp</code> 内。</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PUT &#x2F;megacorp&#x2F;employee&#x2F;1</span><br><span class="line">&#123;</span><br><span class="line">    &quot;first_name&quot; : &quot;John&quot;,</span><br><span class="line">    &quot;last_name&quot; :  &quot;Smith&quot;,</span><br><span class="line">    &quot;age&quot; :        25,</span><br><span class="line">    &quot;about&quot; :      &quot;I love to go rock climbing&quot;,</span><br><span class="line">    &quot;interests&quot;: [ &quot;sports&quot;, &quot;music&quot; ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，路径 <code>/megacorp/employee/1</code> 包含了三部分的信息：</p><ul><li><p><strong><code>megacorp</code></strong></p><p>索引名称</p></li><li><p><strong><code>employee</code></strong></p><p>类型名称</p></li><li><p><strong><code>1</code></strong></p><p>特定雇员的ID</p></li></ul><p>请求体 —— JSON 文档 —— 包含了这位员工的所有详细信息</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;_index&quot;: &quot;megacorp&quot;,</span><br><span class="line">    &quot;_type&quot;: &quot;employee&quot;,</span><br><span class="line">    &quot;_id&quot;: &quot;1&quot;,</span><br><span class="line">    &quot;_version&quot;: 1,</span><br><span class="line">    &quot;result&quot;: &quot;created&quot;,</span><br><span class="line">    &quot;_shards&quot;: &#123;</span><br><span class="line">        &quot;total&quot;: 2,</span><br><span class="line">        &quot;successful&quot;: 1,</span><br><span class="line">        &quot;failed&quot;: 0</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;_seq_no&quot;: 0,</span><br><span class="line">    &quot;_primary_term&quot;: 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同理，添加更多员工</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PUT &#x2F;megacorp&#x2F;employee&#x2F;2</span><br><span class="line">&#123;</span><br><span class="line">    &quot;first_name&quot; :  &quot;Jane&quot;,</span><br><span class="line">    &quot;last_name&quot; :   &quot;Smith&quot;,</span><br><span class="line">    &quot;age&quot; :         32,</span><br><span class="line">    &quot;about&quot; :       &quot;I like to collect rock albums&quot;,</span><br><span class="line">    &quot;interests&quot;:  [ &quot;music&quot; ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT &#x2F;megacorp&#x2F;employee&#x2F;3</span><br><span class="line">&#123;</span><br><span class="line">    &quot;first_name&quot; :  &quot;Douglas&quot;,</span><br><span class="line">    &quot;last_name&quot; :   &quot;Fir&quot;,</span><br><span class="line">    &quot;age&quot; :         35,</span><br><span class="line">    &quot;about&quot;:        &quot;I like to build cabinets&quot;,</span><br><span class="line">    &quot;interests&quot;:  [ &quot;forestry&quot; ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>检索文档</strong></p><p>HTTP <code>GET</code> 请求并指定文档的地址——索引库、类型和ID。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET &#x2F;megacorp&#x2F;employee&#x2F;1</span><br></pre></td></tr></table></figure><p>返回数据</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;_index&quot;: &quot;megacorp&quot;,</span><br><span class="line">    &quot;_type&quot;: &quot;employee&quot;,</span><br><span class="line">    &quot;_id&quot;: &quot;1&quot;,</span><br><span class="line">    &quot;_version&quot;: 1,</span><br><span class="line">    &quot;_seq_no&quot;: 0,</span><br><span class="line">    &quot;_primary_term&quot;: 1,</span><br><span class="line">    &quot;found&quot;: true,</span><br><span class="line">    &quot;_source&quot;: &#123;</span><br><span class="line">        &quot;first_name&quot;: &quot;John&quot;,</span><br><span class="line">        &quot;last_name&quot;: &quot;Smith&quot;,</span><br><span class="line">        &quot;age&quot;: 25,</span><br><span class="line">        &quot;about&quot;: &quot;I love to go rock climbing&quot;,</span><br><span class="line">        &quot;interests&quot;: [</span><br><span class="line">            &quot;sports&quot;,</span><br><span class="line">            &quot;music&quot;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将 HTTP 命令由 <code>PUT</code> 改为 <code>GET</code> 可以用来检索文档，同样的，可以使用 <code>DELETE</code> 命令来删除文档，以及使用 <code>HEAD</code> 指令来检查文档是否存在。如果想更新已存在的文档，只需再次 <code>PUT</code> 。</p><p><strong>轻量搜索</strong></p><p>搜索所有雇员：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET &#x2F;megacorp&#x2F;employee&#x2F;_search</span><br></pre></td></tr></table></figure><p>返回数据</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;took&quot;: 46,</span><br><span class="line">    &quot;timed_out&quot;: false,</span><br><span class="line">    &quot;_shards&quot;: &#123;</span><br><span class="line">        &quot;total&quot;: 1,</span><br><span class="line">        &quot;successful&quot;: 1,</span><br><span class="line">        &quot;skipped&quot;: 0,</span><br><span class="line">        &quot;failed&quot;: 0</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;hits&quot;: &#123;</span><br><span class="line">        &quot;total&quot;: &#123;</span><br><span class="line">            &quot;value&quot;: 3,</span><br><span class="line">            &quot;relation&quot;: &quot;eq&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;max_score&quot;: 1,</span><br><span class="line">        &quot;hits&quot;: [</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;_index&quot;: &quot;megacorp&quot;,</span><br><span class="line">                &quot;_type&quot;: &quot;employee&quot;,</span><br><span class="line">                &quot;_id&quot;: &quot;1&quot;,</span><br><span class="line">                &quot;_score&quot;: 1,</span><br><span class="line">                &quot;_source&quot;: &#123;</span><br><span class="line">                    &quot;first_name&quot;: &quot;John&quot;,</span><br><span class="line">                    &quot;last_name&quot;: &quot;Smith&quot;,</span><br><span class="line">                    &quot;age&quot;: 25,</span><br><span class="line">                    &quot;about&quot;: &quot;I love to go rock climbing&quot;,</span><br><span class="line">                    &quot;interests&quot;: [</span><br><span class="line">                        &quot;sports&quot;,</span><br><span class="line">                        &quot;music&quot;</span><br><span class="line">                    ]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;_index&quot;: &quot;megacorp&quot;,</span><br><span class="line">                &quot;_type&quot;: &quot;employee&quot;,</span><br><span class="line">                &quot;_id&quot;: &quot;2&quot;,</span><br><span class="line">                &quot;_score&quot;: 1,</span><br><span class="line">                &quot;_source&quot;: &#123;</span><br><span class="line">                    &quot;first_name&quot;: &quot;Jane&quot;,</span><br><span class="line">                    &quot;last_name&quot;: &quot;Smith&quot;,</span><br><span class="line">                    &quot;age&quot;: 32,</span><br><span class="line">                    &quot;about&quot;: &quot;I like to collect rock albums&quot;,</span><br><span class="line">                    &quot;interests&quot;: [</span><br><span class="line">                        &quot;music&quot;</span><br><span class="line">                    ]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;_index&quot;: &quot;megacorp&quot;,</span><br><span class="line">                &quot;_type&quot;: &quot;employee&quot;,</span><br><span class="line">                &quot;_id&quot;: &quot;3&quot;,</span><br><span class="line">                &quot;_score&quot;: 1,</span><br><span class="line">                &quot;_source&quot;: &#123;</span><br><span class="line">                    &quot;first_name&quot;: &quot;Douglas&quot;,</span><br><span class="line">                    &quot;last_name&quot;: &quot;Fir&quot;,</span><br><span class="line">                    &quot;age&quot;: 35,</span><br><span class="line">                    &quot;about&quot;: &quot;I like to build cabinets&quot;,</span><br><span class="line">                    &quot;interests&quot;: [</span><br><span class="line">                        &quot;forestry&quot;</span><br><span class="line">                    ]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回结果包括三个文档，放在数据<code>hits</code>中。</p><p>搜索姓氏为 <code>Smith</code> 的雇员</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET &#x2F;megacorp&#x2F;employee&#x2F;_search?q&#x3D;last_name:Smith</span><br></pre></td></tr></table></figure><p>在请求路径中使用 <code>_search</code> 端点，并将查询本身赋值给参数 <code>q=</code> 。返回结果给出了所有的 Smith：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;took&quot;: 23,</span><br><span class="line">    &quot;timed_out&quot;: false,</span><br><span class="line">    &quot;_shards&quot;: &#123;</span><br><span class="line">        &quot;total&quot;: 1,</span><br><span class="line">        &quot;successful&quot;: 1,</span><br><span class="line">        &quot;skipped&quot;: 0,</span><br><span class="line">        &quot;failed&quot;: 0</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;hits&quot;: &#123;</span><br><span class="line">        &quot;total&quot;: &#123;</span><br><span class="line">            &quot;value&quot;: 2,</span><br><span class="line">            &quot;relation&quot;: &quot;eq&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;max_score&quot;: 0.4700036,</span><br><span class="line">        &quot;hits&quot;: [</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;_index&quot;: &quot;megacorp&quot;,</span><br><span class="line">                &quot;_type&quot;: &quot;employee&quot;,</span><br><span class="line">                &quot;_id&quot;: &quot;1&quot;,</span><br><span class="line">                &quot;_score&quot;: 0.4700036,</span><br><span class="line">                &quot;_source&quot;: &#123;</span><br><span class="line">                    &quot;first_name&quot;: &quot;John&quot;,</span><br><span class="line">                    &quot;last_name&quot;: &quot;Smith&quot;,</span><br><span class="line">                    &quot;age&quot;: 25,</span><br><span class="line">                    &quot;about&quot;: &quot;I love to go rock climbing&quot;,</span><br><span class="line">                    &quot;interests&quot;: [</span><br><span class="line">                        &quot;sports&quot;,</span><br><span class="line">                        &quot;music&quot;</span><br><span class="line">                    ]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;_index&quot;: &quot;megacorp&quot;,</span><br><span class="line">                &quot;_type&quot;: &quot;employee&quot;,</span><br><span class="line">                &quot;_id&quot;: &quot;2&quot;,</span><br><span class="line">                &quot;_score&quot;: 0.4700036,</span><br><span class="line">                &quot;_source&quot;: &#123;</span><br><span class="line">                    &quot;first_name&quot;: &quot;Jane&quot;,</span><br><span class="line">                    &quot;last_name&quot;: &quot;Smith&quot;,</span><br><span class="line">                    &quot;age&quot;: 32,</span><br><span class="line">                    &quot;about&quot;: &quot;I like to collect rock albums&quot;,</span><br><span class="line">                    &quot;interests&quot;: [</span><br><span class="line">                        &quot;music&quot;</span><br><span class="line">                    ]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用查询表达式搜索</strong></p><p>Query-string 搜索通过命令非常方便地进行临时性的即席搜索 ，但它有自身的局限性。Elasticsearch 提供一个丰富灵活的查询语言叫做 <em>查询表达式</em> ， 它支持构建更加复杂和健壮的查询。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET &#x2F;megacorp&#x2F;employee&#x2F;_search</span><br><span class="line">&#123;</span><br><span class="line">    &quot;query&quot; : &#123;</span><br><span class="line">        &quot;match&quot; : &#123;</span><br><span class="line">            &quot;last_name&quot; : &quot;Smith&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回效果与之前一样</p><p><strong>更复杂的搜索</strong></p><p>同样搜索姓氏为 Smith 的员工，但这次我们只需要年龄大于 30 的</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET &#x2F;megacorp&#x2F;employee&#x2F;_search</span><br><span class="line">&#123;</span><br><span class="line">    &quot;query&quot; : &#123;</span><br><span class="line">        &quot;bool&quot;: &#123;</span><br><span class="line">            &quot;must&quot;: &#123;</span><br><span class="line">                &quot;match&quot; : &#123;</span><br><span class="line">                    &quot;last_name&quot; : &quot;smith&quot; </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;filter&quot;: &#123;</span><br><span class="line">                &quot;range&quot; : &#123;</span><br><span class="line">                    &quot;age&quot; : &#123; &quot;gt&quot; : 30 &#125; </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>全文搜索</strong></p><p>搜索下所有喜欢攀岩（rock climbing）的员工：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET &#x2F;megacorp&#x2F;employee&#x2F;_search</span><br><span class="line">&#123;</span><br><span class="line">    &quot;query&quot; : &#123;</span><br><span class="line">        &quot;match&quot; : &#123;</span><br><span class="line">            &quot;about&quot; : &quot;rock climbing&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回结果</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;took&quot;: 13,</span><br><span class="line">    &quot;timed_out&quot;: false,</span><br><span class="line">    &quot;_shards&quot;: &#123;</span><br><span class="line">        &quot;total&quot;: 1,</span><br><span class="line">        &quot;successful&quot;: 1,</span><br><span class="line">        &quot;skipped&quot;: 0,</span><br><span class="line">        &quot;failed&quot;: 0</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;hits&quot;: &#123;</span><br><span class="line">        &quot;total&quot;: &#123;</span><br><span class="line">            &quot;value&quot;: 2,</span><br><span class="line">            &quot;relation&quot;: &quot;eq&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;max_score&quot;: 1.4167401,</span><br><span class="line">        &quot;hits&quot;: [</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;_index&quot;: &quot;megacorp&quot;,</span><br><span class="line">                &quot;_type&quot;: &quot;employee&quot;,</span><br><span class="line">                &quot;_id&quot;: &quot;1&quot;,</span><br><span class="line">                &quot;_score&quot;: 1.4167401,</span><br><span class="line">                &quot;_source&quot;: &#123;</span><br><span class="line">                    &quot;first_name&quot;: &quot;John&quot;,</span><br><span class="line">                    &quot;last_name&quot;: &quot;Smith&quot;,</span><br><span class="line">                    &quot;age&quot;: 25,</span><br><span class="line">                    &quot;about&quot;: &quot;I love to go rock climbing&quot;,</span><br><span class="line">                    &quot;interests&quot;: [</span><br><span class="line">                        &quot;sports&quot;,</span><br><span class="line">                        &quot;music&quot;</span><br><span class="line">                    ]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;_index&quot;: &quot;megacorp&quot;,</span><br><span class="line">                &quot;_type&quot;: &quot;employee&quot;,</span><br><span class="line">                &quot;_id&quot;: &quot;2&quot;,</span><br><span class="line">                &quot;_score&quot;: 0.4589591,</span><br><span class="line">                &quot;_source&quot;: &#123;</span><br><span class="line">                    &quot;first_name&quot;: &quot;Jane&quot;,</span><br><span class="line">                    &quot;last_name&quot;: &quot;Smith&quot;,</span><br><span class="line">                    &quot;age&quot;: 32,</span><br><span class="line">                    &quot;about&quot;: &quot;I like to collect rock albums&quot;,</span><br><span class="line">                    &quot;interests&quot;: [</span><br><span class="line">                        &quot;music&quot;</span><br><span class="line">                    ]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到返回结果还带有相关性得分<code>_score</code></p><p><strong>短语搜索</strong></p><p><strong>精确匹配</strong>一系列单词或者<em>短语</em> 。 比如， 执行这样一个查询，短语 “rock climbing” 的形式紧挨着的雇员记录。</p><p>为此对 <code>match</code> 查询稍作调整，使用一个叫做 <code>match_phrase</code> 的查询</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET &#x2F;megacorp&#x2F;employee&#x2F;_search</span><br><span class="line">&#123;</span><br><span class="line">    &quot;query&quot; : &#123;</span><br><span class="line">        &quot;match_phrase&quot; : &#123;</span><br><span class="line">            &quot;about&quot; : &quot;rock climbing&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>高亮搜索</strong></p><p>每个搜索结果中 <em>高亮</em> 部分文本片段</p><p>再次执行前面的查询，并增加一个新的 <code>highlight</code> 参数：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET &#x2F;megacorp&#x2F;employee&#x2F;_search</span><br><span class="line">&#123;</span><br><span class="line">    &quot;query&quot; : &#123;</span><br><span class="line">        &quot;match_phrase&quot; : &#123;</span><br><span class="line">            &quot;about&quot; : &quot;rock climbing&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;highlight&quot;: &#123;</span><br><span class="line">        &quot;fields&quot; : &#123;</span><br><span class="line">            &quot;about&quot; : &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回结果</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">    </span><br><span class="line">        &quot;hits&quot;: [</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;_index&quot;: &quot;megacorp&quot;,</span><br><span class="line">                &quot;_type&quot;: &quot;employee&quot;,</span><br><span class="line">                &quot;_id&quot;: &quot;1&quot;,</span><br><span class="line">                &quot;_score&quot;: 1.4167401,</span><br><span class="line">                &quot;_source&quot;: &#123;</span><br><span class="line">                    &quot;first_name&quot;: &quot;John&quot;,</span><br><span class="line">                    &quot;last_name&quot;: &quot;Smith&quot;,</span><br><span class="line">                    &quot;age&quot;: 25,</span><br><span class="line">                    &quot;about&quot;: &quot;I love to go rock climbing&quot;,</span><br><span class="line">                    &quot;interests&quot;: [</span><br><span class="line">                        &quot;sports&quot;,</span><br><span class="line">                        &quot;music&quot;</span><br><span class="line">                    ]</span><br><span class="line">                &#125;,</span><br><span class="line">                &quot;highlight&quot;: &#123;</span><br><span class="line">                    &quot;about&quot;: [</span><br><span class="line">                        &quot;I love to go &lt;em&gt;rock&lt;&#x2F;em&gt; &lt;em&gt;climbing&lt;&#x2F;em&gt;&quot;</span><br><span class="line">                    ]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果中还多了一个叫做 <code>highlight</code> 的部分。这个部分包含了 <code>about</code> 属性匹配的文本片段，并以 HTML 标签 `` 封装</p><h2 id="二、-Springboot整合ElasticSearch"><a href="#二、-Springboot整合ElasticSearch" class="headerlink" title="二、 Springboot整合ElasticSearch"></a>二、 Springboot整合ElasticSearch</h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h3><p>SpringBoot默认支持两种技术来和ES交互；</p><ul><li><p>Jest（默认不生效）</p><ul><li>需要导入jest的工具包（io.searchbox.client.JestClient）</li><li>从springboot 2.2.0以后被弃用</li></ul></li><li><p>SpringData ElasticSearch</p><p>版本适配说明</p></li></ul><table><thead><tr><th>Spring Data Elasticsearch</th><th>Elasticsearch</th></tr></thead><tbody><tr><td>3.2.x</td><td>6.8.1</td></tr><tr><td>3.1.x</td><td>6.2.2</td></tr><tr><td>3.0.x</td><td>5.5.0</td></tr><tr><td>2.1.x</td><td>2.4.0</td></tr><tr><td>2.0.x</td><td>2.2.0</td></tr><tr><td>1.3.x</td><td>1.5.2</td></tr></tbody></table><p>Springboot 2.2.6对应于 Spring Data Elasticsearch 3.2.6，即适配Elasticsearch 6.8.1</p><h3 id="2-环境搭建"><a href="#2-环境搭建" class="headerlink" title="2. 环境搭建"></a>2. 环境搭建</h3><p>编写文件对应Javabean，指定索引名和类型</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Document(indexName &#x3D; &quot;ustc&quot;,type &#x3D; &quot;book&quot;)</span><br><span class="line">public class Book &#123;</span><br><span class="line">    private Integer id;</span><br><span class="line">    private String bookName;</span><br><span class="line">    private String author;</span><br><span class="line"></span><br><span class="line">    public Integer getId() &#123;</span><br><span class="line">        return id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setId(Integer id) &#123;</span><br><span class="line">        this.id &#x3D; id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getBookName() &#123;</span><br><span class="line">        return bookName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setBookName(String bookName) &#123;</span><br><span class="line">        this.bookName &#x3D; bookName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getAuthor() &#123;</span><br><span class="line">        return author;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAuthor(String author) &#123;</span><br><span class="line">        this.author &#x3D; author;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Book&#123;&quot; +</span><br><span class="line">                &quot;id&#x3D;&quot; + id +</span><br><span class="line">                &quot;, bookName&#x3D;&#39;&quot; + bookName + &#39;\&#39;&#39; +</span><br><span class="line">                &quot;, author&#x3D;&#39;&quot; + author + &#39;\&#39;&#39; +</span><br><span class="line">                &#39;&#125;&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-ElasticSearch客户端"><a href="#3-ElasticSearch客户端" class="headerlink" title="3. ElasticSearch客户端"></a>3. ElasticSearch客户端</h3><ul><li><p><strong>Transport Client</strong></p><p>在ES7中已经被弃用，将在ES8被移除</p></li><li><p><strong>High Level REST Client</strong></p><p>ES的默认客户端</p></li><li><p><strong>Reactive Client</strong></p><p>非官方驱动，基于WebClient</p></li></ul><p>下面以REST客户端为例说明ES的使用</p><p><strong>配置主机地址</strong></p><p>方式一 配置类配置</p><p>注意：这种方式底层依赖于Http相关类，因此要导入web相关jar包</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">static class Config &#123;</span><br><span class="line">  @Bean</span><br><span class="line">  RestHighLevelClient client() &#123;</span><br><span class="line"></span><br><span class="line">    ClientConfiguration clientConfiguration &#x3D; ClientConfiguration.builder() </span><br><span class="line">      .connectedTo(&quot;localhost:9200&quot;)</span><br><span class="line">      .build();</span><br><span class="line"></span><br><span class="line">    return RestClients.create(clientConfiguration).rest();                  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方式二 spring配置文件指定</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring.elasticsearch.rest.uris&#x3D;http:&#x2F;&#x2F;192.168.31.162:9200</span><br></pre></td></tr></table></figure><p><strong>在测试类中注入客户端</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">RestHighLevelClient highLevelClient;</span><br></pre></td></tr></table></figure><p><strong>创建索引</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">IndexRequest request &#x3D; new IndexRequest(&quot;ustc&quot;, &quot;book&quot;,</span><br><span class="line">        UUID.randomUUID().toString())</span><br><span class="line">        .source(Collections.singletonMap(&quot;feature&quot;, &quot;high-level-rest-client&quot;))</span><br><span class="line">        .setRefreshPolicy(WriteRequest.RefreshPolicy.IMMEDIATE);</span><br><span class="line">IndexResponse index &#x3D; highLevelClient.index(request, RequestOptions.DEFAULT);</span><br><span class="line">System.out.println(index.toString());</span><br></pre></td></tr></table></figure><p>下面为创建索引</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;_index&quot;: &quot;ustc&quot;,</span><br><span class="line">    &quot;_type&quot;: &quot;book&quot;,</span><br><span class="line">    &quot;_id&quot;: &quot;0dc9f47a-7913-481d-a36d-e8f034a6a3ac&quot;,</span><br><span class="line">    &quot;_score&quot;: 1,</span><br><span class="line">    &quot;_source&quot;: &#123;</span><br><span class="line">        &quot;feature&quot;: &quot;high-level-rest-client&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到索引</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;分别指定要获取的索引、类型、id</span><br><span class="line">GetRequest getRequest &#x3D; new GetRequest(&quot;ustc&quot;,&quot;book&quot;,&quot;0dc9f47a-7913-481d-a36d-e8f034a6a3ac&quot;);</span><br><span class="line">GetResponse documentFields &#x3D; highLevelClient.get(getRequest, RequestOptions.DEFAULT);</span><br><span class="line">System.out.println(documentFields);</span><br></pre></td></tr></table></figure><h3 id="4-ElasticsearchRestTemplate"><a href="#4-ElasticsearchRestTemplate" class="headerlink" title="4. ElasticsearchRestTemplate"></a>4. ElasticsearchRestTemplate</h3><p>ES有两个模板，分别为<code>ElasticsearchRestTemplate</code>和<code>ElasticsearchTemplate</code></p><p>分别对应于<strong>High Level REST Client</strong>和<strong>Transport Client</strong>(弃用)，两个模板都实现了<code>ElasticsearchOperations</code>接口，因此使用时我们一般使用<code>ElasticsearchOperations</code>，具体实现方式由底层决定。</p><p>由于在<code>AbstractElasticsearchConfiguration</code>中已经向容器中导入了<code>ElasticsearchRestTemplate</code>，因此我们使用时可以直接注入</p><p><strong>注入模板</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">ElasticsearchOperations elasticsearchOperations;</span><br></pre></td></tr></table></figure><p><strong>保存索引</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Book book &#x3D; new Book();</span><br><span class="line">book.setAuthor(&quot;路遥&quot;);</span><br><span class="line">book.setBookName(&quot;平凡的世界&quot;);</span><br><span class="line">book.setId(1);</span><br><span class="line">IndexQuery indexQuery &#x3D; new IndexQueryBuilder()</span><br><span class="line">    .withId(book.getId().toString())</span><br><span class="line">    .withObject(book)</span><br><span class="line">    .build();</span><br><span class="line">String index &#x3D; elasticsearchOperations.index(indexQuery);</span><br></pre></td></tr></table></figure><p><strong>查询索引</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Book book &#x3D; elasticsearchOperations.queryForObject(GetQuery.getById(&quot;1&quot;), Book.class);</span><br></pre></td></tr></table></figure><h3 id="5-Elasticsearch-Repositories"><a href="#5-Elasticsearch-Repositories" class="headerlink" title="5. Elasticsearch Repositories"></a>5. Elasticsearch Repositories</h3><p>编写相关Repository并继承Repository或ElasticsearchRepository，泛型分别为&lt;查询类，主键&gt;</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface BookRepository extends Repository&lt;Book,Integer&gt; &#123;</span><br><span class="line">    List&lt;Book&gt; findByBookNameAndAuthor(String bookName, String author);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查询的方法仅需按照<strong>一定规则</strong>命名即可实现功能，<strong>无需编写实现</strong>，如上findByBookNameAndAuthor()方法相当于ES的json查询</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;query&quot;: &#123;</span><br><span class="line">        &quot;bool&quot; : &#123;</span><br><span class="line">            &quot;must&quot; : [</span><br><span class="line">                &#123; &quot;query_string&quot; : &#123; &quot;query&quot; : &quot;?&quot;, &quot;fields&quot; : [ &quot;bookName&quot; ] &#125; &#125;,</span><br><span class="line">                &#123; &quot;query_string&quot; : &#123; &quot;query&quot; : &quot;?&quot;, &quot;fields&quot; : [ &quot;author&quot; ] &#125; &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://docs.spring.io/spring-data/elasticsearch/docs/3.2.6.RELEASE/reference/html/#elasticsearch.repositories" target="_blank" rel="noopener">更多命名规则见本文档</a></p><p><strong>@Query</strong></p><p>此外，还可以使用<code>@Query</code>自定义请求json</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interface BookRepository extends ElasticsearchRepository&lt;Book, String&gt; &#123;</span><br><span class="line">    @Query(&quot;&#123;\&quot;match\&quot;: &#123;\&quot;name\&quot;: &#123;\&quot;query\&quot;: \&quot;?0\&quot;&#125;&#125;&#125;&quot;)</span><br><span class="line">    Page&lt;Book&gt; findByName(String name,Pageable pageable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若参数为John，相当于请求体为</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match&quot;: &#123;</span><br><span class="line">      &quot;name&quot;: &#123;</span><br><span class="line">        &quot;query&quot;: &quot;John&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>更多ES与springboot整合内容见<a href="https://docs.spring.io/spring-data/elasticsearch/docs/3.2.6.RELEASE/reference/html/#new-features" target="_blank" rel="noopener">官方文档</a></strong></p><h1 id="四-Spring-boot与任务"><a href="#四-Spring-boot与任务" class="headerlink" title="(四) Spring boot与任务"></a>(四) Spring boot与任务</h1><h2 id="一、异步任务"><a href="#一、异步任务" class="headerlink" title="一、异步任务"></a>一、异步任务</h2><p>在Java应用中，绝大多数情况下都是通过同步的方式来实现交互处理的；但是在处理与第三方系统交互的时候，容易造成响应迟缓的情况，之前大部分都是使用多线程来完成此类任务，springboot中可以用异步任务解决。</p><p><strong>两个注解：</strong></p><p><code>@Async</code> 在需要异步执行的方法上标注注解</p><p><code>@EnableAsync</code> 在主类上标注开启异步任务支持</p><p>开启异步任务后，当controller层调用该方法会直接返回结果，该任务异步执行</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class AsyncService &#123;</span><br><span class="line">    @Async</span><br><span class="line">    public void sayHello() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(3000);</span><br><span class="line">            System.out.println(&quot;hello async task!&quot;);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二、-定时任务"><a href="#二、-定时任务" class="headerlink" title="二、 定时任务"></a>二、 定时任务</h2><p>项目开发中经常需要执行一些定时任务，比如需要在每天凌晨时候，分析一次前一天的日志信息。Spring为我们提供了异步执行任务调度的方式，提供TaskExecutor 、TaskScheduler 接口。</p><p><strong>两个注解：</strong></p><p><code>@EnableScheduling</code> 标注在主类，开启对定时任务支持</p><p><code>@Scheduled</code> 标注在执行的方法上，并制定cron属性</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class ScheduleService &#123;</span><br><span class="line">    @Scheduled(cron &#x3D; &quot;0,1,2,3,4,5,30,50 * * * * 0-7&quot;)</span><br><span class="line">    public void schedule() &#123;</span><br><span class="line">        System.out.println(&quot;I am executing..&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>cron</strong>表达式：</p><p>second(秒), minute（分）, hour（时）, day of month（日）, month（月）, day of week（周几）.</p><p><code>0 0/5 14,18 * * ?</code> 每天14点整，和18点整，每隔5分钟执行一次</p><p><code>0 15 10 ? * 1-6</code> 每个月的周一至周六10:15分执行一次</p><p><code>0 0 2 ? * 6L</code> 每个月的最后一个周六凌晨2点执行一次</p><p><code>0 0 2 LW * ?</code> 每个月的最后一个工作日凌晨2点执行一次</p><p><code>0 0 2-4 ? * 1#1</code> 每个月的第一个周一凌晨2点到4点期间，每个整点都执行一次；</p><table><thead><tr><th align="left"><strong>字段</strong></th><th align="left"><strong>允许值</strong></th><th align="left"><strong>允许的特殊字符</strong></th></tr></thead><tbody><tr><td align="left">秒</td><td align="left">0-59</td><td align="left">, - * /</td></tr><tr><td align="left">分</td><td align="left">0-59</td><td align="left">, - * /</td></tr><tr><td align="left">小时</td><td align="left">0-23</td><td align="left">, - * /</td></tr><tr><td align="left">日期</td><td align="left">1-31</td><td align="left">, - * ? / L W C</td></tr><tr><td align="left">月份</td><td align="left">1-12</td><td align="left">, - * /</td></tr><tr><td align="left">星期</td><td align="left">0-7或SUN-SAT 0,7是SUN</td><td align="left">, - * ? / L C #</td></tr></tbody></table><table><thead><tr><th align="left"><strong>特殊字符</strong></th><th align="left"><strong>代表含义</strong></th></tr></thead><tbody><tr><td align="left">,</td><td align="left">枚举</td></tr><tr><td align="left">-</td><td align="left">区间</td></tr><tr><td align="left">*</td><td align="left">任意</td></tr><tr><td align="left">/</td><td align="left">步长</td></tr><tr><td align="left">?</td><td align="left">日/星期冲突匹配</td></tr><tr><td align="left">L</td><td align="left">最后</td></tr><tr><td align="left">W</td><td align="left">工作日</td></tr><tr><td align="left">C</td><td align="left">和calendar联系后计算过的值</td></tr><tr><td align="left">#</td><td align="left">星期，4#2，第2个星期四</td></tr></tbody></table><h2 id="三、-邮件任务"><a href="#三、-邮件任务" class="headerlink" title="三、 邮件任务"></a>三、 邮件任务</h2><p>springboot自动配置包中<code>MailSenderAutoConfiguration</code>通过<code>@Import</code>注解向容器中导入了<code>MailSenderJndiConfiguration</code>,而<code>MailSenderJndiConfiguration</code>向容器中导入了<code>JavaMailSenderImpl</code>类，我们可以使用该类发送邮件</p><p><strong>配置文件</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring.mail.username&#x3D;邮箱用户名</span><br><span class="line">spring.mail.password&#x3D;邮箱密码或授权码</span><br><span class="line">spring.mail.host&#x3D;smtp.example.com</span><br></pre></td></tr></table></figure><p><strong>自动注入</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">private JavaMailSenderImpl javaMailSender;</span><br></pre></td></tr></table></figure><p><strong>简单邮件发送</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SimpleMailMessage message &#x3D; new SimpleMailMessage();</span><br><span class="line">&#x2F;&#x2F;设置主题和内容</span><br><span class="line">message.setSubject(&quot;今天开会&quot;);</span><br><span class="line">message.setText(&quot;物质楼555开会，不要迟到&quot;);</span><br><span class="line">&#x2F;&#x2F;设置发送方和接收方</span><br><span class="line">message.setFrom(&quot;xxx@163.com&quot;);</span><br><span class="line">message.setTo(&quot;xxx@qq.com&quot;);</span><br><span class="line"></span><br><span class="line">javaMailSender.send(message);</span><br></pre></td></tr></table></figure><p><strong>复杂邮件发送</strong></p><p>带有附件或html页面的邮件</p><p><strong>两个设置</strong></p><p><code>new MimeMessageHelper(message,true)</code> 设置multipart=true，开启对内联元素和附件的支持</p><p><code>helper.setText(&quot;xxxx&quot;,true)</code> html=ture，设置content type=text/html，默认为text/plain</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MimeMessage message &#x3D; javaMailSender.createMimeMessage();</span><br><span class="line">&#x2F;&#x2F;multipart&#x3D;true</span><br><span class="line">&#x2F;&#x2F;开启对内联元素和附件的支持</span><br><span class="line">MimeMessageHelper helper &#x3D; new MimeMessageHelper(message,true);</span><br><span class="line"></span><br><span class="line">helper.setSubject(&quot;今天开会&quot;);</span><br><span class="line">&#x2F;&#x2F;html&#x3D;ture</span><br><span class="line">&#x2F;&#x2F;设置content type&#x3D;text&#x2F;html，默认为text&#x2F;plain</span><br><span class="line">helper.setText(&quot;&lt;b style&#x3D;&#39;color:red&#39;&gt;物质楼555开会，不要迟到&lt;&#x2F;b&gt;&quot;,true);</span><br><span class="line"></span><br><span class="line">helper.setFrom(&quot;hongshengmo@163.com&quot;);</span><br><span class="line">helper.setTo(&quot;1043245239@qq.com&quot;);</span><br><span class="line">&#x2F;&#x2F;设置附件</span><br><span class="line">helper.addAttachment(&quot;2.png&quot;,new File(&quot;D:\\Works\\Note\\images\\图片2.png&quot;));</span><br><span class="line">helper.addAttachment(&quot;3.png&quot;,new File(&quot;D:\\Works\\Note\\images\\图片3.png&quot;));</span><br><span class="line">javaMailSender.send(message);</span><br></pre></td></tr></table></figure><h1 id="五-Spring-boot与安全"><a href="#五-Spring-boot与安全" class="headerlink" title="(五) Spring boot与安全"></a>(五) Spring boot与安全</h1><h2 id="一、安全"><a href="#一、安全" class="headerlink" title="一、安全"></a>一、安全</h2><p>应用程序的两个主要区域是“认证”和“授权”（或者访问控制），这两个主要区域是安全的两个目标。 身份验证意味着<strong>确认您自己的身份</strong>，而授权意味着<strong>授予对系统的访问权限</strong></p><p><strong>认证</strong></p><p>身份验证是关于验证您的凭据，如用户名/用户ID和密码，以验证您的身份。系统确定您是否就是您所说的使用凭据。在公共和专用网络中，系统通过登录密码验证用户身份。身份验证通常通过用户名和密码完成，</p><p><strong>授权</strong></p><p>另一方面，授权发生在系统成功验证您的身份后，最终会授予您访问资源（如信息，文件，数据库，资金，位置，几乎任何内容）的完全权限。简单来说，授权决定了您访问系统的能力以及达到的程度。验证成功后，系统验证您的身份后，即可授权您访问系统资源。</p><h2 id="二、Spring-Security"><a href="#二、Spring-Security" class="headerlink" title="二、Spring Security"></a>二、Spring Security</h2><p>Spring Security是针对Spring项目的安全框架，也是Spring Boot底层安全模块默认的技术选型。他可以实现强大的web安全控制。对于安全控制，我们仅需引入<code>spring-boot-starter-security</code>模块，进行少量的配置，即可实现强大的安全管理。</p><p><strong>WebSecurityConfigurerAdapter：自定义Security策略</strong></p><p>通过在配置类中继承该类重写<code>configure(HttpSecurity http)</code>方法来实现自定义策略</p><p><strong>@EnableWebSecurity：开启WebSecurity模式</strong></p><p>在配置类上标注<code>@EnableWebSecurity</code>开启WebSecurity模式</p><h2 id="三、-Springboot整合security"><a href="#三、-Springboot整合security" class="headerlink" title="三、 Springboot整合security"></a>三、 Springboot整合security</h2><h3 id="1-导入依赖"><a href="#1-导入依赖" class="headerlink" title="1. 导入依赖"></a>1. 导入依赖</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-security&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><p>导入spring security的包之后，默认情况所有应用访问认证授权，默认用户名user，密码为随机生成的uuid，启动时打印在控制台</p><h3 id="2-登录-注销"><a href="#2-登录-注销" class="headerlink" title="2. 登录/注销"></a>2. 登录/注销</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@EnableWebSecurity</span><br><span class="line">public class MySecurityConfig extends WebSecurityConfigurerAdapter &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void configure(HttpSecurity http) throws Exception &#123;</span><br><span class="line">        &#x2F;&#x2F;根目录允许所有人访问，其他目录都需要对应角色</span><br><span class="line">        http.authorizeRequests().antMatchers(&quot;&#x2F;&quot;).permitAll()</span><br><span class="line">                .antMatchers(&quot;&#x2F;level1&#x2F;**&quot;).hasRole(&quot;VIP1&quot;)</span><br><span class="line">                .antMatchers(&quot;&#x2F;level2&#x2F;**&quot;).hasRole(&quot;VIP2&quot;)</span><br><span class="line">                .antMatchers(&quot;&#x2F;level3&#x2F;**&quot;).hasRole(&quot;VIP3&quot;);</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;开启自动配置的登陆功能，效果，如果没有登陆，没有权限就会来到登陆页面</span><br><span class="line">        &#x2F;&#x2F;&#x2F;login来到登陆页</span><br><span class="line">        &#x2F;&#x2F;重定向到&#x2F;login?error表示登陆失败</span><br><span class="line">        http.formLogin();</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;开启自动配置的注销功能</span><br><span class="line">        &#x2F;&#x2F;向&#x2F;logout发送post请求表示注销</span><br><span class="line">        http.logout();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时除了主页，点击其他的页面都会自动跳转到security自动生成的登录页面，<code>/login</code>来到登陆页,重定向到<code>/login?error</code>表示登陆失败；</p><p><code>http.logout()</code>开启自动配置的注销功能,向<code>/logout</code>发送post请求表示注销,需要在欢迎页加上注销表单，默认注销后自动跳转到登录页面，若想改变转发路径，可以通过<code>logoutSuccessUrl(url)</code>设置路径</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;form th:action&#x3D;&quot;@&#123;&#x2F;logout&#125;&quot; method&#x3D;&quot;post&quot;&gt;</span><br><span class="line">   &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;注销&quot;&gt;</span><br><span class="line">&lt;&#x2F;form&gt;</span><br></pre></td></tr></table></figure><h3 id="3-定义认证规则"><a href="#3-定义认证规则" class="headerlink" title="3. 定义认证规则"></a>3. 定义认证规则</h3><p>为了保证密码能安全存储，springboot内置<code>PasswordEncoder</code>对密码进行转码，默认密码编码器为<code>DelegatingPasswordEncoder</code>。在定义认证规则时，我们需要使用<code>PasswordEncoder</code>将密码转码，由于<code>withDefaultPasswordEncoder()</code>并非安全已被弃用，因此仅在测试中使用。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public UserDetailsService users() &#123;</span><br><span class="line">    &#x2F;&#x2F;使用默认的PasswordEncoder</span><br><span class="line">    User.UserBuilder builder &#x3D; User.withDefaultPasswordEncoder();</span><br><span class="line">    &#x2F;&#x2F;定义账户用户名、密码、权限</span><br><span class="line">    UserDetails user1 &#x3D; builder.username(&quot;zhangsan&quot;)</span><br><span class="line">            .password(&quot;123456&quot;)</span><br><span class="line">            .roles(&quot;VIP1&quot;, &quot;VIP2&quot;)</span><br><span class="line">            .build();</span><br><span class="line">    UserDetails user2 &#x3D; builder.username(&quot;lisi&quot;)</span><br><span class="line">            .password(&quot;123456&quot;)</span><br><span class="line">            .roles(&quot;VIP3&quot;, &quot;VIP2&quot;)</span><br><span class="line">            .build();</span><br><span class="line">    UserDetails user3 &#x3D; builder.username(&quot;wangwu&quot;)</span><br><span class="line">            .password(&quot;123456&quot;)</span><br><span class="line">            .roles(&quot;VIP1&quot;, &quot;VIP3&quot;)</span><br><span class="line">            .build();</span><br><span class="line">    &#x2F;&#x2F;使用内存保存用户信息</span><br><span class="line">    return new InMemoryUserDetailsManager(user1,user2,user3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-自定义欢迎页"><a href="#4-自定义欢迎页" class="headerlink" title="4.自定义欢迎页"></a>4.自定义欢迎页</h3><p><strong>导入依赖</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.thymeleaf.extras&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;thymeleaf-extras-springsecurity5&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><p><strong>引入命名空间</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html xmlns:th&#x3D;&quot;http:&#x2F;&#x2F;www.thymeleaf.org&quot;</span><br><span class="line">     xmlns:sec&#x3D;&quot;http:&#x2F;&#x2F;www.thymeleaf.org&#x2F;extras&#x2F;spring-security&quot;&gt;</span><br></pre></td></tr></table></figure><p><strong>根据是否登录显示游客或用户信息</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 未登录显示此div --&gt;</span><br><span class="line">&lt;div sec:authorize&#x3D;&quot;!isAuthenticated()&quot;&gt;</span><br><span class="line">   &lt;h2 align&#x3D;&quot;center&quot;&gt;游客您好，如果想查看武林秘籍 &lt;a th:href&#x3D;&quot;@&#123;&#x2F;userlogin&#125;&quot;&gt;请登录&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;!-- 登录显示此div --&gt;</span><br><span class="line">&lt;div sec:authorize&#x3D;&quot;isAuthenticated()&quot;&gt;</span><br><span class="line">    &lt;!-- 显示用户名 --&gt;</span><br><span class="line">   &lt;h2&gt;尊敬的&lt;span th:text&#x3D;&quot;$&#123;#authentication.name&#125;&quot;&gt;&lt;&#x2F;span&gt;,您好！您的角色有：</span><br><span class="line">       &lt;!-- 显示用户角色 --&gt;</span><br><span class="line">      &lt;span th:text&#x3D;&quot;$&#123;#authentication.authorities&#125;&quot;&gt;&lt;&#x2F;span&gt;&lt;&#x2F;h2&gt;</span><br><span class="line">   &lt;form th:action&#x3D;&quot;@&#123;&#x2F;logout&#125;&quot; method&#x3D;&quot;post&quot;&gt;</span><br><span class="line">      &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;注销&quot;&gt;</span><br><span class="line">   &lt;&#x2F;form&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><p><strong>根据角色类型显示信息</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 具有VIP1的角色显示以下div --&gt;</span><br><span class="line">&lt;div sec:authorize&#x3D;&quot;hasRole(&#39;VIP1&#39;)&quot;&gt;</span><br><span class="line">   &lt;h3&gt;普通武功秘籍&lt;&#x2F;h3&gt;</span><br><span class="line">   &lt;ul&gt;</span><br><span class="line">      &lt;li&gt;&lt;a th:href&#x3D;&quot;@&#123;&#x2F;level1&#x2F;1&#125;&quot;&gt;罗汉拳&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;</span><br><span class="line">      &lt;li&gt;&lt;a th:href&#x3D;&quot;@&#123;&#x2F;level1&#x2F;2&#125;&quot;&gt;武当长拳&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;</span><br><span class="line">      &lt;li&gt;&lt;a th:href&#x3D;&quot;@&#123;&#x2F;level1&#x2F;3&#125;&quot;&gt;全真剑法&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;</span><br><span class="line">   &lt;&#x2F;ul&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/thymeleaf/thymeleaf-extras-springsecurity" target="_blank" rel="noopener">更多spring-security与thymeleaf整合教程</a></p><h3 id="5-自定义登录页-记住我"><a href="#5-自定义登录页-记住我" class="headerlink" title="5. 自定义登录页/记住我"></a>5. 自定义登录页/记住我</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void configure(HttpSecurity http) throws Exception &#123;</span><br><span class="line">    ...</span><br><span class="line">    &#x2F;&#x2F;定制登录页</span><br><span class="line">    http.formLogin()</span><br><span class="line">            .usernameParameter(&quot;user&quot;)  &#x2F;&#x2F;表单用户名name</span><br><span class="line">            .passwordParameter(&quot;pwd&quot;)   &#x2F;&#x2F;表单密码name</span><br><span class="line">            .loginPage(&quot;&#x2F;userlogin&quot;);   &#x2F;&#x2F;定制登陆页路径</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;开启记住我</span><br><span class="line">    http.rememberMe().</span><br><span class="line">        rememberMeParameter(&quot;rem&quot;);&#x2F;&#x2F;设置表单记住我name值</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<code>loginPage(url)</code>设置登录页路径后，在定制的登录页发送<code>post url</code>即为登录请求，并设置表单的<code>name</code>属性都为对应值；</p><p>通过勾选<code>记住我</code>，session退出后依然能通过<code>cookie</code>保存用户信息，下次免登陆</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;form th:action&#x3D;&quot;@&#123;&#x2F;userlogin&#125;&quot; method&#x3D;&quot;post&quot;&gt;</span><br><span class="line">   用户名:&lt;input name&#x3D;&quot;user&quot;&#x2F;&gt;&lt;br&gt;</span><br><span class="line">   密码:&lt;input name&#x3D;&quot;pwd&quot;&gt;&lt;br&#x2F;&gt;</span><br><span class="line">   &lt;input type&#x3D;&quot;checkbox&quot; name&#x3D;&quot;rem&quot;&gt;记住我&lt;br&gt;</span><br><span class="line">   &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;登陆&quot;&gt;</span><br><span class="line">&lt;&#x2F;form&gt;</span><br></pre></td></tr></table></figure><p><a href="https://docs.spring.io/spring-security/site/docs/5.3.2.BUILD-SNAPSHOT/reference/html5/" target="_blank" rel="noopener">更多spring-security参阅官方文档</a></p><h1 id="六-Spring-boot与分布式"><a href="#六-Spring-boot与分布式" class="headerlink" title="(六) Spring boot与分布式"></a>(六) Spring boot与分布式</h1><h2 id="一、分布式应用"><a href="#一、分布式应用" class="headerlink" title="一、分布式应用"></a>一、分布式应用</h2><p> 分布式应用（distributed application）指的是应用程序分布在不同计算机上，通过网络来共同完成一项任务的工作方式。</p><p><strong>为什么需要分布式？</strong></p><ul><li><p><strong>单一应用架构</strong><br>当网站流量很小时，只需一个应用，将所有功能都部署在一起，以减少部署节点和成本。此时，用于简化增删改查工作量的数据访问框架(ORM)是关键。</p></li><li><p><strong>垂直应用架构</strong><br>当访问量逐渐增大，单一应用增加机器带来的加速度越来越小，将应用拆成互不相干的几个应用，以提升效率。此时，用于加速前端页面开发的Web框架(MVC)是关键。</p></li><li><p>分布式服务架构</p><p>当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。此时，用于提高业务复用及整合的分布式服务框架(RPC)是关键。</p><ul><li><strong>流动计算架构</strong><br>当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。此时，用于提高机器利用率的资源调度和治理中心(SOA)是关键。</li></ul></li></ul><p>在分布式系统中，国内常用zookeeper+dubbo组合，而Spring Boot推荐使用全栈的Spring，Spring Boot+Spring Cloud。</p><h2 id="二、Zookeeper和Dubbo"><a href="#二、Zookeeper和Dubbo" class="headerlink" title="二、Zookeeper和Dubbo"></a>二、Zookeeper和Dubbo</h2><h3 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="1. 概述"></a>1. 概述</h3><p><strong>ZooKeeper</strong><br>ZooKeeper 是一个分布式的，开放源码的分布式应用程序协调服务。它是一个为分布式应用提供一致性服务的软件，提供的功能包括：配置维护、域名服务、分布式同步、组服务等。</p><p><strong>Dubbo</strong><br>Dubbo是Alibaba开源的分布式服务框架，它最大的特点是按照分层的方式来架构，使用这种方式可以使各个层之间解耦合（或者最大限度地松耦合）。从服务模型的角度来看，Dubbo采用的是一种非常简单的模型，要么是提供方提供服务，要么是消费方消费服务，所以基于这一点可以抽象出服务提供方（Provider）和服务消费方（Consumer）两个角色。</p><h3 id="2-整合springboot"><a href="#2-整合springboot" class="headerlink" title="2. 整合springboot"></a>2. 整合springboot</h3><p><strong>环境搭建</strong></p><p>分别创建provider和consumer模块并分别导入依赖</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">       &lt;!-- 导入dubbo与springboot整合启动器 --&gt;</span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;org.apache.dubbo&lt;&#x2F;groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;dubbo-spring-boot-starter&lt;&#x2F;artifactId&gt;</span><br><span class="line">           &lt;version&gt;2.7.6&lt;&#x2F;version&gt;</span><br><span class="line">       &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">       &lt;!-- 导入zookeeper客户端 --&gt;</span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;com.github.sgroschupf&lt;&#x2F;groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;zkclient&lt;&#x2F;artifactId&gt;</span><br><span class="line">           &lt;version&gt;0.1&lt;&#x2F;version&gt;</span><br><span class="line">           &lt;exclusions&gt;</span><br><span class="line">               &lt;exclusion&gt;</span><br><span class="line">                   &lt;groupId&gt;org.apache.zookeeper&lt;&#x2F;groupId&gt;</span><br><span class="line">                   &lt;artifactId&gt;zookeeper&lt;&#x2F;artifactId&gt;</span><br><span class="line">               &lt;&#x2F;exclusion&gt;</span><br><span class="line">           &lt;&#x2F;exclusions&gt;</span><br><span class="line">       &lt;&#x2F;dependency&gt;</span><br><span class="line">       &lt;!-- 导入zookeeper客户端所需依赖：curator框架 --&gt;</span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;org.apache.curator&lt;&#x2F;groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;curator-framework&lt;&#x2F;artifactId&gt;</span><br><span class="line">           &lt;version&gt;4.3.0&lt;&#x2F;version&gt;</span><br><span class="line">       &lt;&#x2F;dependency&gt;</span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;org.apache.curator&lt;&#x2F;groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;curator-recipes&lt;&#x2F;artifactId&gt;</span><br><span class="line">           &lt;version&gt;4.3.0&lt;&#x2F;version&gt;</span><br><span class="line">       &lt;&#x2F;dependency&gt;</span><br><span class="line">   &lt;&#x2F;dependencies&gt;</span><br></pre></td></tr></table></figure><p>provider配置文件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 应用项目名</span><br><span class="line">dubbo.application.name&#x3D;provider-ticket</span><br><span class="line"># zookeeper地址</span><br><span class="line">dubbo.registry.address&#x3D;zookeeper:&#x2F;&#x2F;192.168.31.162:2181</span><br><span class="line"># dubbo扫描包路径        </span><br><span class="line">dubbo.scan.base-packages&#x3D;cn.edu.ustc.service</span><br></pre></td></tr></table></figure><p>consumer配置文件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dubbo.application.name&#x3D;consumer-user</span><br><span class="line">dubbo.registry.address&#x3D;zookeeper:&#x2F;&#x2F;192.168.31.162:2181</span><br></pre></td></tr></table></figure><p><strong>生产者服务</strong></p><p><code>@EnableDubbo</code> ：</p><p>可以在指定的包名下（通过 <code>scanBasePackages</code>），或者指定的类中（通过 <code>scanBasePackageClasses</code>）扫描 Dubbo 的服务提供者（以 <code>@Service</code> 标注）以及 Dubbo 的服务消费者（以 <code>Reference</code> 标注）。</p><p><code>@Service</code>：</p><p>表示服务的具体实现，被注解的类会被dubbo扫描</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import org.apache.dubbo.config.annotation.Service;</span><br><span class="line">import org.apache.dubbo.config.spring.context.annotation.EnableDubbo;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@EnableDubbo &#x2F;&#x2F;开启对dubbo支持</span><br><span class="line">@Component</span><br><span class="line">@Service &#x2F;&#x2F;标记此类，表示服务的具体实现</span><br><span class="line">public class TicketServiceImpl implements TicketService&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public String getTicket() &#123;</span><br><span class="line">        return &quot;Gxx:合肥-北京&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>消费者服务</strong></p><p>编写与分布式服务类相同的接口(不必实现)，并保证包结构相同</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface TicketService &#123;</span><br><span class="line">    String getTicket();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@Reference 可以定义在类中的一个字段、方法上，表示一个服务的引用。通常 @Reference 定义在一个字段上</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class UserService &#123;</span><br><span class="line"></span><br><span class="line">    @Reference</span><br><span class="line">    TicketService ticketService;</span><br><span class="line"></span><br><span class="line">    public void hello() &#123;</span><br><span class="line">        String ticket &#x3D; ticketService.getTicket();</span><br><span class="line">        System.out.println(&quot;买到票了:&quot;+ticket);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时若调用<code>hello()</code>,控制台将打印</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">买到票了:Gxx:合肥-北京</span><br></pre></td></tr></table></figure><p><strong>有关dubbo更多</strong></p><p><a href="http://dubbo.apache.org/zh-cn/blog/dubbo-annotation.html" target="_blank" rel="noopener">dubbo注解详细解释</a></p><p><a href="http://dubbo.apache.org/zh-cn/blog/dubbo-zk.html" target="_blank" rel="noopener">dubbo与zookeeper官方整合案例</a></p><h2 id="三、Spring-Cloud"><a href="#三、Spring-Cloud" class="headerlink" title="三、Spring Cloud"></a>三、Spring Cloud</h2><h3 id="1-概述-2"><a href="#1-概述-2" class="headerlink" title="1. 概述"></a>1. 概述</h3><p>Spring Cloud是一个分布式的整体解决方案。Spring Cloud 为开发者提供了在分布式系统（配置管理，服务发现，熔断，路由，微代理，控制总线，一次性token，全局琐，leader选举，分布式session，集群状态）中快速构建的工具，使用Spring Cloud的开发者可以快速的启动服务或构建应用、同时能够快速和云平台资源进行对接。</p><p>SpringCloud分布式开发五大常用组件</p><ul><li>服务发现——Netflix Eureka</li><li>客服端负载均衡——Netflix Ribbon</li><li>断路器——Netflix Hystrix</li><li>服务网关——Netflix Zuul</li><li>分布式配置——Spring Cloud Config</li></ul><h3 id="2-入门"><a href="#2-入门" class="headerlink" title="2. 入门"></a>2. 入门</h3><p><strong>Eureka注册中心</strong></p><p>创建工程导入<code>eureka-server</code>模块</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;&#x2F;artifactId&gt;</span><br><span class="line">       &lt;&#x2F;dependency&gt;</span><br><span class="line">       ...</span><br><span class="line">   &lt;&#x2F;dependencies&gt;</span><br><span class="line"></span><br><span class="line">   &lt;dependencyManagement&gt;</span><br><span class="line">       &lt;dependencies&gt;</span><br><span class="line">           &lt;dependency&gt;</span><br><span class="line">               &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">               &lt;artifactId&gt;spring-cloud-dependencies&lt;&#x2F;artifactId&gt;</span><br><span class="line">               &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;&#x2F;version&gt;</span><br><span class="line">               &lt;type&gt;pom&lt;&#x2F;type&gt;</span><br><span class="line">               &lt;scope&gt;import&lt;&#x2F;scope&gt;</span><br><span class="line">           &lt;&#x2F;dependency&gt;</span><br><span class="line">       &lt;&#x2F;dependencies&gt;</span><br><span class="line">   &lt;&#x2F;dependencyManagement&gt;</span><br></pre></td></tr></table></figure><p>配置文件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8761</span><br><span class="line">eureka:</span><br><span class="line">  instance:</span><br><span class="line">    hostname: eureka-server  # eureka实例的主机名</span><br><span class="line">  client:</span><br><span class="line">    register-with-eureka: false #不把自己注册到eureka上</span><br><span class="line">    fetch-registry: false #不从eureka上来获取服务的注册信息</span><br><span class="line">    service-url:</span><br><span class="line">      defaultZone: http:&#x2F;&#x2F;localhost:8761&#x2F;eureka&#x2F;</span><br></pre></td></tr></table></figure><p><strong>生产者模块</strong></p><p>创建工程导入<code>eureka-client</code>和<code>web</code>模块</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">    ...</span><br><span class="line">&lt;&#x2F;dependencies&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependencyManagement&gt;</span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-dependencies&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;&#x2F;version&gt;</span><br><span class="line">            &lt;type&gt;pom&lt;&#x2F;type&gt;</span><br><span class="line">            &lt;scope&gt;import&lt;&#x2F;scope&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;&#x2F;dependencies&gt;</span><br><span class="line">&lt;&#x2F;dependencyManagement&gt;</span><br></pre></td></tr></table></figure><p>配置文件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8002</span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: provider-ticket</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">eureka:</span><br><span class="line">  instance:</span><br><span class="line">    prefer-ip-address: true # 注册服务的时候使用服务的ip地址</span><br><span class="line">  client:</span><br><span class="line">    service-url:</span><br><span class="line">      defaultZone: http:&#x2F;&#x2F;localhost:8761&#x2F;eureka&#x2F;</span><br></pre></td></tr></table></figure><p>编写controller层和service层demo</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class TicketService &#123;</span><br><span class="line">    public String getTicket()&#123;</span><br><span class="line">        System.out.println(&quot;8002&quot;);</span><br><span class="line">        return &quot;《厉害了，我的国》&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@RestController</span><br><span class="line">public class TicketController &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    TicketService ticketService;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;&#x2F;ticket&quot;)</span><br><span class="line">    public String getTicket()&#123;</span><br><span class="line">        return ticketService.getTicket();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>消费者模块</strong></p><p>创建工程导入<code>eureka-client</code>和<code>web</code>模块</p><p>配置文件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: consumer-user</span><br><span class="line">server:</span><br><span class="line">  port: 8200</span><br><span class="line"></span><br><span class="line">eureka:</span><br><span class="line">  instance:</span><br><span class="line">    prefer-ip-address: true # 注册服务的时候使用服务的ip地址</span><br><span class="line">  client:</span><br><span class="line">    service-url:</span><br><span class="line">      defaultZone: http:&#x2F;&#x2F;localhost:8761&#x2F;eureka&#x2F;</span><br></pre></td></tr></table></figure><p>向容器中注入<code>RestTemplate</code>, 并使用<code>@EnableDiscoveryClient</code>开启发现服务功能</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@EnableDiscoveryClient &#x2F;&#x2F;开启发现服务功能</span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class ConsumerUserApplication &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(ConsumerUserApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @LoadBalanced &#x2F;&#x2F;使用负载均衡机制</span><br><span class="line">    @Bean</span><br><span class="line">    public RestTemplate restTemplate()&#123;</span><br><span class="line">        return new RestTemplate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写controller并使用<code>RestTemplate</code>发现服务</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class UserController &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;&#x2F;buy&quot;)</span><br><span class="line">    public String buyTicket(String name)&#123;</span><br><span class="line">        String s &#x3D; restTemplate.getForObject(&quot;http:&#x2F;&#x2F;PROVIDER-TICKET&#x2F;ticket&quot;, String.class);</span><br><span class="line">        return name+&quot;购买了&quot;+s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>向<code>http://localhost:8200/buy?username=zhangsan</code>发请求，则会响应</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">zhangsan购买了《厉害了，我的国》</span><br></pre></td></tr></table></figure><p>并且在使用了<code>@LoadBalanced</code>之后实现了负载均衡，如果创建不同端口的<code>provider</code>应用，则访问会被均衡到各个应用</p><h1 id="七-Spring-boot与热部署"><a href="#七-Spring-boot与热部署" class="headerlink" title="(七) Spring boot与热部署"></a>(七) Spring boot与热部署</h1><p>在开发中我们修改一个Java文件后想看到效果不得不重启应用，这导致大量时间花费，我们希望不重启应用的情况下，程序可以自动部署（热部署）。有以下四种情况，如何能实现热部署。</p><h2 id="一、模板引擎"><a href="#一、模板引擎" class="headerlink" title="一、模板引擎"></a>一、模板引擎</h2><p>在Spring Boot中开发情况下禁用模板引擎的cache<br>页面模板改变ctrl+F9可以重新编译当前页面并生效</p><h2 id="二、Spring-Loaded"><a href="#二、Spring-Loaded" class="headerlink" title="二、Spring Loaded"></a>二、Spring Loaded</h2><p>Spring官方提供的热部署程序，实现修改类文件的热部署</p><ul><li>下载Spring Loaded（项目地址<a href="https://github.com/spring-projects/spring-loaded）" target="_blank" rel="noopener">https://github.com/spring-projects/spring-loaded）</a></li><li>添加运行时参数；<ul><li>javaagent:C:/springloaded-1.2.5.RELEASE.jar –noverify</li></ul></li></ul><h2 id="三、JRebel"><a href="#三、JRebel" class="headerlink" title="三、JRebel"></a>三、JRebel</h2><p>收费的一个热部署软件<br>安装插件使用即可</p><h2 id="四、-Spring-Boot-Devtools（推荐）"><a href="#四、-Spring-Boot-Devtools（推荐）" class="headerlink" title="四、 Spring Boot Devtools（推荐）"></a>四、 Spring Boot Devtools（推荐）</h2><p>引入依赖</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-devtools&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><p>IDEA使用ctrl+F9重新编译实现热部署</p><h1 id="八-Spring-Boot与监控管理"><a href="#八-Spring-Boot与监控管理" class="headerlink" title="(八) Spring Boot与监控管理"></a>(八) Spring Boot与监控管理</h1><p>通过引入spring-boot-starter-actuator，可以使用Spring Boot为我们提供的准生产环境下的应用监控和管理功能。我们可以通过HTTP，JMX，SSH协议来进行操作，自动得到审计、健康及指标信息等</p><h2 id="一、-Actuator监控管理"><a href="#一、-Actuator监控管理" class="headerlink" title="一、 Actuator监控管理"></a>一、 Actuator监控管理</h2><p><strong>导入依赖</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-actuator&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><p>浏览器打开链接<code>http://localhost:8080/actuator/</code>,可以看到所有支持的连接，响应如下,默认只支持这些端点</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;_links&quot;: &#123;</span><br><span class="line">        &quot;self&quot;: &#123;</span><br><span class="line">            &quot;href&quot;: &quot;http:&#x2F;&#x2F;localhost:8080&#x2F;actuator&quot;,</span><br><span class="line">            &quot;templated&quot;: false</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;health&quot;: &#123;</span><br><span class="line">            &quot;href&quot;: &quot;http:&#x2F;&#x2F;localhost:8080&#x2F;actuator&#x2F;health&quot;,</span><br><span class="line">            &quot;templated&quot;: false</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;health-path&quot;: &#123;</span><br><span class="line">            &quot;href&quot;: &quot;http:&#x2F;&#x2F;localhost:8080&#x2F;actuator&#x2F;health&#x2F;&#123;*path&#125;&quot;,</span><br><span class="line">            &quot;templated&quot;: true</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;info&quot;: &#123;</span><br><span class="line">            &quot;href&quot;: &quot;http:&#x2F;&#x2F;localhost:8080&#x2F;actuator&#x2F;info&quot;,</span><br><span class="line">            &quot;templated&quot;: false</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要看到所有支持的状态查询，需要配置</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">management.endpoints.web.exposure.include&#x3D;*</span><br></pre></td></tr></table></figure><p>bean加载情况<code>http://localhost:8080/actuator/beans</code>,显示了容器中各类各项属性</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;contexts&quot;: &#123;</span><br><span class="line">        &quot;application&quot;: &#123;</span><br><span class="line">            &quot;beans&quot;: &#123;</span><br><span class="line">                &quot;endpointCachingOperationInvokerAdvisor&quot;: &#123;</span><br><span class="line">                    &quot;aliases&quot;: [],</span><br><span class="line">                    &quot;scope&quot;: &quot;singleton&quot;,</span><br><span class="line">                    &quot;type&quot;: &quot;org.springframework.boot.actuate.endpoint.invoker.cache.CachingOperationInvokerAdvisor&quot;,</span><br><span class="line">                    &quot;resource&quot;: &quot;class path resource [org&#x2F;springframework&#x2F;boot&#x2F;actuate&#x2F;autoconfigure&#x2F;endpoint&#x2F;EndpointAutoConfiguration.class]&quot;,</span><br><span class="line">                    &quot;dependencies&quot;: [</span><br><span class="line">                        &quot;environment&quot;</span><br><span class="line">                    ]</span><br><span class="line">                &#125;,</span><br><span class="line">                &quot;defaultServletHandlerMapping&quot;: &#123;</span><br><span class="line">                    &quot;aliases&quot;: [],</span><br><span class="line">                    &quot;scope&quot;: &quot;singleton&quot;,</span><br><span class="line">                    &quot;type&quot;: &quot;org.springframework.web.servlet.HandlerMapping&quot;,</span><br><span class="line">                    &quot;resource&quot;: &quot;class path resource [org&#x2F;springframework&#x2F;boot&#x2F;autoconfigure&#x2F;web&#x2F;servlet&#x2F;WebMvcAutoConfiguration$EnableWebMvcConfiguration.class]&quot;,</span><br><span class="line">                    &quot;dependencies&quot;: []</span><br><span class="line">                &#125;,</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br></pre></td></tr></table></figure><h2 id="二、-端点配置"><a href="#二、-端点配置" class="headerlink" title="二、 端点配置"></a>二、 端点配置</h2><p>默认情况下，除shutdown以外的所有端点均已启用。要配置单个端点的启用，请使用<code>management.endpoint..enabled</code>属性。以下示例启用<code>shutdown</code>端点：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">management.endpoint.shutdown.enabled&#x3D;true</span><br></pre></td></tr></table></figure><p>另外可以通过<code>management.endpoints.enabled-by-default</code>来修改全局端口默认配置,以下示例启用info端点并禁用所有其他端点：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">management.endpoints.enabled-by-default&#x3D;false</span><br><span class="line">management.endpoint.info.enabled&#x3D;true</span><br></pre></td></tr></table></figure><p>修改路径</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 修改根目录路径</span><br><span class="line">management.endpoints.web.base-path&#x3D;&#x2F;management</span><br><span class="line"># 修改&#x2F;health路径</span><br><span class="line">management.endpoints.web.path-mapping.health&#x3D;healthcheck</span><br></pre></td></tr></table></figure><p><a href="https://docs.spring.io/spring-boot/docs/2.2.6.RELEASE/reference/html/production-ready-features.html#production-ready-endpoints" target="_blank" rel="noopener">更多参阅spring-actuator官方文档</a></p>]]></content>
    
    <summary type="html">
    
      you can &quot;just run&quot;
    
    </summary>
    
    
      <category term="SpringBoot" scheme="https://SomunsTao.github.io/categories/SpringBoot/"/>
    
    
      <category term="SpringBoot" scheme="https://SomunsTao.github.io/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot：雷神笔记</title>
    <link href="https://somunstao.github.io/2020/03/30/SpringBoot22%EF%BC%9A%E9%9B%B7%E7%A5%9E%E7%AC%94%E8%AE%B0(%E5%88%9D%E7%BA%A7)/"/>
    <id>https://somunstao.github.io/2020/03/30/SpringBoot22%EF%BC%9A%E9%9B%B7%E7%A5%9E%E7%AC%94%E8%AE%B0(%E5%88%9D%E7%BA%A7)/</id>
    <published>2020-03-29T16:00:00.000Z</published>
    <updated>2020-04-30T16:13:42.222Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、Spring-Boot-入门"><a href="#一、Spring-Boot-入门" class="headerlink" title="一、Spring Boot 入门"></a><strong>一、</strong>Spring Boot 入门</h1><h2 id="1、Spring-Boot-简介"><a href="#1、Spring-Boot-简介" class="headerlink" title="1、Spring Boot 简介"></a>1、Spring Boot 简介</h2><blockquote><p>简化Spring应用开发的一个框架；</p><p>整个Spring技术栈的一个大整合；</p><p>J2EE开发的一站式解决方案；</p></blockquote><h2 id="2、微服务"><a href="#2、微服务" class="headerlink" title="2、微服务"></a>2、微服务</h2><p>2014，martin fowler</p><p>微服务：架构风格（服务微化）</p><p>一个应用应该是一组小型服务；可以通过HTTP的方式进行互通；</p><p>单体应用：ALL IN ONE</p><p>微服务：每一个功能元素最终都是一个可独立替换和独立升级的软件单元；</p><p><a href="https://martinfowler.com/articles/microservices.html#MicroservicesAndSoa" target="_blank" rel="noopener">详细参照微服务文档</a></p><h2 id="3、环境准备"><a href="#3、环境准备" class="headerlink" title="3、环境准备"></a>3、环境准备</h2><p><a href="http://www.gulixueyuan.com/" target="_blank" rel="noopener">http://www.gulixueyuan.com/</a> 谷粒学院</p><p>环境约束</p><p>–jdk1.8：Spring Boot 推荐jdk1.7及以上；java version “1.8.0_112”</p><p>–maven3.x：maven 3.3以上版本；Apache Maven 3.3.9</p><p>–IntelliJIDEA2017：IntelliJ IDEA 2017.2.2 x64、STS</p><p>–SpringBoot 1.5.9.RELEASE：1.5.9；</p><p>统一环境；</p><h3 id="1、MAVEN设置；"><a href="#1、MAVEN设置；" class="headerlink" title="1、MAVEN设置；"></a>1、MAVEN设置；</h3><p>给maven 的settings.xml配置文件的profiles标签添加</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span>&gt;</span>jdk-1.8<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>true<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">jdk</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">jdk</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.compilerVersion</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.compilerVersion</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2、IDEA设置"><a href="#2、IDEA设置" class="headerlink" title="2、IDEA设置"></a>2、IDEA设置</h3><p>整合maven进来；</p><p>![idea设置](F:/尚硅谷/springboot核心篇+整合篇-尚硅谷/01尚硅谷SpringBoot核心技术篇/Spring Boot 笔记+课件/images/搜狗截图20180129151045.png)</p><p>![images/](F:/尚硅谷/springboot核心篇+整合篇-尚硅谷/01尚硅谷SpringBoot核心技术篇/Spring Boot 笔记+课件/images/搜狗截图20180129151112.png)</p><h2 id="4、Spring-Boot-HelloWorld"><a href="#4、Spring-Boot-HelloWorld" class="headerlink" title="4、Spring Boot HelloWorld"></a>4、Spring Boot HelloWorld</h2><p>一个功能：</p><p>浏览器发送hello请求，服务器接受请求并处理，响应Hello World字符串；</p><h3 id="1、创建一个maven工程；（jar）"><a href="#1、创建一个maven工程；（jar）" class="headerlink" title="1、创建一个maven工程；（jar）"></a>1、创建一个maven工程；（jar）</h3><h3 id="2、导入spring-boot相关的依赖"><a href="#2、导入spring-boot相关的依赖" class="headerlink" title="2、导入spring boot相关的依赖"></a>2、导入spring boot相关的依赖</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3、编写一个主程序；启动Spring-Boot应用"><a href="#3、编写一个主程序；启动Spring-Boot应用" class="headerlink" title="3、编写一个主程序；启动Spring Boot应用"></a>3、编写一个主程序；启动Spring Boot应用</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@SpringBootApplication</span> 来标注一个主程序类，说明这是一个Spring Boot应用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldMainApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Spring应用启动起来</span></span><br><span class="line">        SpringApplication.run(HelloWorldMainApplication<span class="class">.<span class="keyword">class</span>,<span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4、编写相关的Controller、Service"><a href="#4、编写相关的Controller、Service" class="headerlink" title="4、编写相关的Controller、Service"></a>4、编写相关的Controller、Service</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello World!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5、运行主程序测试"><a href="#5、运行主程序测试" class="headerlink" title="5、运行主程序测试"></a>5、运行主程序测试</h3><h3 id="6、简化部署"><a href="#6、简化部署" class="headerlink" title="6、简化部署"></a>6、简化部署</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 这个插件，可以将应用打包成一个可执行的jar包；--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p>将这个应用打成jar包，直接使用java -jar的命令进行执行；</p><h2 id="5、Hello-World探究"><a href="#5、Hello-World探究" class="headerlink" title="5、Hello World探究"></a>5、Hello World探究</h2><h3 id="1、POM文件"><a href="#1、POM文件" class="headerlink" title="1、POM文件"></a>1、POM文件</h3><h4 id="1、父项目"><a href="#1、父项目" class="headerlink" title="1、父项目"></a>1、父项目</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">他的父项目是</span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">relativePath</span>&gt;</span>../../spring-boot-dependencies<span class="tag">&lt;/<span class="name">relativePath</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">他来真正管理Spring Boot应用里面的所有依赖版本；</span><br></pre></td></tr></table></figure><p>Spring Boot的版本仲裁中心；</p><p>以后我们导入依赖默认是不需要写版本；（没有在dependencies里面管理的依赖自然需要声明版本号）</p><h4 id="2、启动器"><a href="#2、启动器" class="headerlink" title="2、启动器"></a>2、启动器</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>spring-boot-starter</strong>-==web==：</p><p>​    spring-boot-starter：spring-boot场景启动器；帮我们导入了web模块正常运行所依赖的组件；</p><p>Spring Boot将所有的功能场景都抽取出来，做成一个个的starters（启动器），只需要在项目里面引入这些starter相关场景的所有依赖都会导入进来。要用什么功能就导入什么场景的启动器</p><h3 id="2、主程序类，主入口类"><a href="#2、主程序类，主入口类" class="headerlink" title="2、主程序类，主入口类"></a>2、主程序类，主入口类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@SpringBootApplication</span> 来标注一个主程序类，说明这是一个Spring Boot应用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldMainApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Spring应用启动起来</span></span><br><span class="line">        SpringApplication.run(HelloWorldMainApplication<span class="class">.<span class="keyword">class</span>,<span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@<strong>SpringBootApplication</strong>:    Spring Boot应用标注在某个类上说明这个类是SpringBoot的主配置类，SpringBoot就应该运行这个类的main方法来启动SpringBoot应用；</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(excludeFilters = &#123;</span><br><span class="line">      <span class="meta">@Filter</span>(type = FilterType.CUSTOM, classes = TypeExcludeFilter<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line"><span class="class">      @<span class="title">Filter</span>(<span class="title">type</span> </span>= FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter<span class="class">.<span class="keyword">class</span>) &#125;)</span></span><br><span class="line"><span class="class"><span class="title">public</span> @<span class="title">interface</span> <span class="title">SpringBootApplication</span> </span>&#123;</span><br></pre></td></tr></table></figure><p>@<strong>SpringBootConfiguration</strong>:Spring Boot的配置类；</p><p>​        标注在某个类上，表示这是一个Spring Boot的配置类；</p><p>​        @<strong>Configuration</strong>:配置类上来标注这个注解；</p><p>​            配置类 —–  配置文件；配置类也是容器中的一个组件；@Component</p><p>@<strong>EnableAutoConfiguration</strong>：开启自动配置功能；</p><p>​        以前我们需要配置的东西，Spring Boot帮我们自动配置；@<strong>EnableAutoConfiguration</strong>告诉SpringBoot开启自动配置功能；这样自动配置才能生效；</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@AutoConfigurationPackage</span></span><br><span class="line"><span class="meta">@Import</span>(EnableAutoConfigurationImportSelector<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> @<span class="title">interface</span> <span class="title">EnableAutoConfiguration</span> </span>&#123;</span><br></pre></td></tr></table></figure><p>​          @<strong>AutoConfigurationPackage</strong>：自动配置包</p><p>​        @<strong>Import</strong>(AutoConfigurationPackages.Registrar.class)：</p><p>​        Spring的底层注解@Import，给容器中导入一个组件；导入的组件由AutoConfigurationPackages.Registrar.class；</p><p>==将主配置类（@SpringBootApplication标注的类）的所在包及下面所有子包里面的所有组件扫描到Spring容器；==</p><p>​    @<strong>Import</strong>(EnableAutoConfigurationImportSelector.class)；</p><p>​        给容器中导入组件？</p><p>​        <strong>EnableAutoConfigurationImportSelector</strong>：导入哪些组件的选择器；</p><p>​        将所有需要导入的组件以全类名的方式返回；这些组件就会被添加到容器中；</p><p>​        会给容器中导入非常多的自动配置类（xxxAutoConfiguration）；就是给容器中导入这个场景需要的所有组件，并配置好这些组件；        ![自动配置类](F:/尚硅谷/springboot核心篇+整合篇-尚硅谷/01尚硅谷SpringBoot核心技术篇/Spring Boot 笔记+课件/images/搜狗截图20180129224104.png)</p><p>有了自动配置类，免去了我们手动编写配置注入功能组件等的工作；</p><p>​        SpringFactoriesLoader.loadFactoryNames(EnableAutoConfiguration.class,classLoader)；</p><p>==Spring Boot在启动的时候从类路径下的META-INF/spring.factories中获取EnableAutoConfiguration指定的值，将这些值作为自动配置类导入到容器中，自动配置类就生效，帮我们进行自动配置工作；==以前我们需要自己配置的东西，自动配置类都帮我们；</p><p>J2EE的整体整合解决方案和自动配置都在spring-boot-autoconfigure-1.5.9.RELEASE.jar；</p><p>​        </p><p>==Spring注解版（谷粒学院）==</p><h2 id="6、使用Spring-Initializer快速创建Spring-Boot项目"><a href="#6、使用Spring-Initializer快速创建Spring-Boot项目" class="headerlink" title="6、使用Spring Initializer快速创建Spring Boot项目"></a>6、使用Spring Initializer快速创建Spring Boot项目</h2><h3 id="1、IDEA：使用-Spring-Initializer快速创建项目"><a href="#1、IDEA：使用-Spring-Initializer快速创建项目" class="headerlink" title="1、IDEA：使用 Spring Initializer快速创建项目"></a>1、IDEA：使用 Spring Initializer快速创建项目</h3><p>IDE都支持使用Spring的项目创建向导快速创建一个Spring Boot项目；</p><p>选择我们需要的模块；向导会联网创建Spring Boot项目；</p><p>默认生成的Spring Boot项目；</p><ul><li>主程序已经生成好了，我们只需要我们自己的逻辑</li><li>resources文件夹中目录结构<ul><li>static：保存所有的静态资源； js css  images；</li><li>templates：保存所有的模板页面；（Spring Boot默认jar包使用嵌入式的Tomcat，默认不支持JSP页面）；可以使用模板引擎（freemarker、thymeleaf）；</li><li>application.properties：Spring Boot应用的配置文件；可以修改一些默认设置；</li></ul></li></ul><h3 id="2、STS使用-Spring-Starter-Project快速创建项目"><a href="#2、STS使用-Spring-Starter-Project快速创建项目" class="headerlink" title="2、STS使用 Spring Starter Project快速创建项目"></a>2、STS使用 Spring Starter Project快速创建项目</h3><hr><h1 id="二、配置文件"><a href="#二、配置文件" class="headerlink" title="二、配置文件"></a>二、配置文件</h1><h2 id="1、配置文件"><a href="#1、配置文件" class="headerlink" title="1、配置文件"></a>1、配置文件</h2><p>SpringBoot使用一个全局的配置文件，配置文件名是固定的；</p><p>•application.properties</p><p>•application.yml</p><p>配置文件的作用：修改SpringBoot自动配置的默认值；SpringBoot在底层都给我们自动配置好；</p><p>YAML（YAML Ain’t Markup Language）</p><p>​    YAML  A Markup Language：是一个标记语言</p><p>​    YAML   isn’t Markup Language：不是一个标记语言；</p><p>标记语言：</p><p>​    以前的配置文件；大多都使用的是  <strong>xxxx.xml</strong>文件；</p><p>​    YAML：<strong>以数据为中心</strong>，比json、xml等更适合做配置文件；</p><p>​    YAML：配置例子</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8081</span></span><br></pre></td></tr></table></figure><p>​    XML：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">server</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">port</span>&gt;</span>8081<span class="tag">&lt;/<span class="name">port</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">server</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="2、YAML语法："><a href="#2、YAML语法：" class="headerlink" title="2、YAML语法："></a>2、YAML语法：</h2><h3 id="1、基本语法"><a href="#1、基本语法" class="headerlink" title="1、基本语法"></a>1、基本语法</h3><p>k:(空格)v：表示一对键值对（空格必须有）；</p><p>以<strong>空格</strong>的缩进来控制层级关系；只要是左对齐的一列数据，都是同一个层级的</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">8081</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">/hello</span></span><br></pre></td></tr></table></figure><p>属性和值也是大小写敏感；</p><h3 id="2、值的写法"><a href="#2、值的写法" class="headerlink" title="2、值的写法"></a>2、值的写法</h3><h4 id="字面量：普通的值（数字，字符串，布尔）"><a href="#字面量：普通的值（数字，字符串，布尔）" class="headerlink" title="字面量：普通的值（数字，字符串，布尔）"></a>字面量：普通的值（数字，字符串，布尔）</h4><p>​    k: v：字面直接来写；</p><p>​        字符串默认不用加上单引号或者双引号；</p><p>​        “”：双引号；不会转义字符串里面的特殊字符；特殊字符会作为本身想表示的意思</p><p>​                name:   “zhangsan \n lisi”：输出；zhangsan 换行  lisi</p><p>​        ‘’：单引号；会转义特殊字符，特殊字符最终只是一个普通的字符串数据</p><p>​                name:   ‘zhangsan \n lisi’：输出；zhangsan \n  lisi</p><h4 id="对象、Map（属性和值）（键值对）："><a href="#对象、Map（属性和值）（键值对）：" class="headerlink" title="对象、Map（属性和值）（键值对）："></a>对象、Map（属性和值）（键值对）：</h4><p>​    k: v：在下一行来写对象的属性和值的关系；注意缩进</p><p>​        对象还是k: v的方式</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">friends:</span></span><br><span class="line"><span class="attr">lastName:</span> <span class="string">zhangsan</span></span><br><span class="line"><span class="attr">age:</span> <span class="number">20</span></span><br></pre></td></tr></table></figure><p>行内写法：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">friends:</span> <span class="string">&#123;lastName:</span> <span class="string">zhangsan,age:</span> <span class="number">18</span><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><h4 id="数组（List、Set）："><a href="#数组（List、Set）：" class="headerlink" title="数组（List、Set）："></a>数组（List、Set）：</h4><p>用- 值表示数组中的一个元素</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">pets:</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">cat</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">dog</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">pig</span></span><br></pre></td></tr></table></figure><p>行内写法</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">pets:</span> <span class="string">[cat,dog,pig]</span></span><br></pre></td></tr></table></figure><h2 id="3、配置文件值注入"><a href="#3、配置文件值注入" class="headerlink" title="3、配置文件值注入"></a>3、配置文件值注入</h2><p>配置文件</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">person:</span></span><br><span class="line">    <span class="attr">lastName:</span> <span class="string">hello</span></span><br><span class="line">    <span class="attr">age:</span> <span class="number">18</span></span><br><span class="line">    <span class="attr">boss:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">birth:</span> <span class="number">2017</span><span class="string">/12/12</span></span><br><span class="line">    <span class="attr">maps:</span> <span class="string">&#123;k1:</span> <span class="string">v1,k2:</span> <span class="number">12</span><span class="string">&#125;</span></span><br><span class="line">    <span class="attr">lists:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">lisi</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">zhaoliu</span></span><br><span class="line">    <span class="attr">dog:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">小狗</span></span><br><span class="line">      <span class="attr">age:</span> <span class="number">12</span></span><br></pre></td></tr></table></figure><p>javaBean：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将配置文件中配置的每一个属性的值，映射到这个组件中</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ConfigurationProperties</span>：告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定；</span></span><br><span class="line"><span class="comment"> *      prefix = "person"：配置文件中哪个下面的所有属性进行一一映射</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 只有这个组件是容器中的组件，才能容器提供的<span class="doctag">@ConfigurationProperties</span>功能；</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"person"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String lastName;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> Boolean boss;</span><br><span class="line">    <span class="keyword">private</span> Date birth;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,Object&gt; maps;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Object&gt; lists;</span><br><span class="line">    <span class="keyword">private</span> Dog dog;</span><br></pre></td></tr></table></figure><p>我们可以导入配置文件处理器，以后编写配置就有提示了</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--导入配置文件处理器，配置文件进行绑定就会有提示--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="1、properties配置文件在idea中默认utf-8可能会乱码"><a href="#1、properties配置文件在idea中默认utf-8可能会乱码" class="headerlink" title="1、properties配置文件在idea中默认utf-8可能会乱码"></a>1、properties配置文件在idea中默认utf-8可能会乱码</h4><p>调整</p><p>![idea配置乱码](F:/尚硅谷/springboot核心篇+整合篇-尚硅谷/01尚硅谷SpringBoot核心技术篇/Spring Boot 笔记+课件/images/搜狗截图20180130161620.png)</p><h4 id="2、-Value获取值和-ConfigurationProperties获取值比较"><a href="#2、-Value获取值和-ConfigurationProperties获取值比较" class="headerlink" title="2、@Value获取值和@ConfigurationProperties获取值比较"></a>2、@Value获取值和@ConfigurationProperties获取值比较</h4><table><thead><tr><th></th><th>@ConfigurationProperties</th><th>@Value</th></tr></thead><tbody><tr><td>功能</td><td>批量注入配置文件中的属性</td><td>一个个指定</td></tr><tr><td>松散绑定（松散语法）</td><td>支持</td><td>不支持</td></tr><tr><td>SpEL</td><td>不支持</td><td>支持</td></tr><tr><td>JSR303数据校验</td><td>支持</td><td>不支持</td></tr><tr><td>复杂类型封装</td><td>支持</td><td>不支持</td></tr></tbody></table><p>配置文件yml还是properties他们都能获取到值；</p><p>如果说，我们只是在某个业务逻辑中需要获取一下配置文件中的某项值，使用@Value；</p><p>如果说，我们专门编写了一个javaBean来和配置文件进行映射，我们就直接使用@ConfigurationProperties；</p><h4 id="3、配置文件注入值数据校验"><a href="#3、配置文件注入值数据校验" class="headerlink" title="3、配置文件注入值数据校验"></a>3、配置文件注入值数据校验</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"person"</span>)</span><br><span class="line"><span class="meta">@Validated</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;bean class="Person"&gt;</span></span><br><span class="line"><span class="comment">     *      &lt;property name="lastName" value="字面量/$&#123;key&#125;从环境变量、配置文件中获取值/#&#123;SpEL&#125;"&gt;&lt;/property&gt;</span></span><br><span class="line"><span class="comment">     * &lt;bean/&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//lastName必须是邮箱格式</span></span><br><span class="line">    <span class="meta">@Email</span></span><br><span class="line">    <span class="comment">//@Value("$&#123;person.last-name&#125;")</span></span><br><span class="line">    <span class="keyword">private</span> String lastName;</span><br><span class="line">    <span class="comment">//@Value("#&#123;11*2&#125;")</span></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="comment">//@Value("true")</span></span><br><span class="line">    <span class="keyword">private</span> Boolean boss;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Date birth;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,Object&gt; maps;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Object&gt; lists;</span><br><span class="line">    <span class="keyword">private</span> Dog dog;</span><br></pre></td></tr></table></figure><h4 id="4、-PropertySource-amp-ImportResource-amp-Bean"><a href="#4、-PropertySource-amp-ImportResource-amp-Bean" class="headerlink" title="4、@PropertySource&amp;@ImportResource&amp;@Bean"></a>4、@PropertySource&amp;@ImportResource&amp;@Bean</h4><p>@<strong>PropertySource</strong>：加载指定的配置文件；</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将配置文件中配置的每一个属性的值，映射到这个组件中</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ConfigurationProperties</span>：告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定；</span></span><br><span class="line"><span class="comment"> *      prefix = "person"：配置文件中哪个下面的所有属性进行一一映射</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 只有这个组件是容器中的组件，才能容器提供的<span class="doctag">@ConfigurationProperties</span>功能；</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@ConfigurationProperties</span>(prefix = "person")默认从全局配置文件中获取值；</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@PropertySource</span>(value = &#123;<span class="string">"classpath:person.properties"</span>&#125;)</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"person"</span>)</span><br><span class="line"><span class="comment">//@Validated</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;bean class="Person"&gt;</span></span><br><span class="line"><span class="comment">     *      &lt;property name="lastName" value="字面量/$&#123;key&#125;从环境变量、配置文件中获取值/#&#123;SpEL&#125;"&gt;&lt;/property&gt;</span></span><br><span class="line"><span class="comment">     * &lt;bean/&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//lastName必须是邮箱格式</span></span><br><span class="line">   <span class="comment">// @Email</span></span><br><span class="line">    <span class="comment">//@Value("$&#123;person.last-name&#125;")</span></span><br><span class="line">    <span class="keyword">private</span> String lastName;</span><br><span class="line">    <span class="comment">//@Value("#&#123;11*2&#125;")</span></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="comment">//@Value("true")</span></span><br><span class="line">    <span class="keyword">private</span> Boolean boss;</span><br></pre></td></tr></table></figure><p>@<strong>ImportResource</strong>：导入Spring的配置文件，让配置文件里面的内容生效；</p><p>Spring Boot里面没有Spring的配置文件，我们自己编写的配置文件，也不能自动识别；</p><p>想让Spring的配置文件生效，加载进来；@<strong>ImportResource</strong>标注在一个配置类上</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ImportResource</span>(locations = &#123;<span class="string">"classpath:beans.xml"</span>&#125;)</span><br><span class="line">导入Spring的配置文件让其生效</span><br></pre></td></tr></table></figure><p>不来编写Spring的配置文件</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"helloService"</span> <span class="attr">class</span>=<span class="string">"com.atguigu.springboot.service.HelloService"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>SpringBoot推荐给容器中添加组件的方式；推荐使用全注解的方式</p><p>1、配置类<strong>@Configuration</strong>——&gt;Spring配置文件</p><p>2、使用<strong>@Bean</strong>给容器中添加组件</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Configuration</span>：指明当前类是一个配置类；就是来替代之前的Spring配置文件</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 在配置文件中用&lt;bean&gt;&lt;bean/&gt;标签添加组件</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAppConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将方法的返回值添加到容器中；容器中这个组件默认的id就是方法名</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HelloService <span class="title">helloService02</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"配置类@Bean给容器中添加组件了..."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HelloService();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>##4、配置文件占位符</p><h3 id="1、随机数"><a href="#1、随机数" class="headerlink" title="1、随机数"></a>1、随机数</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">$&#123;random.value&#125;、$&#123;random.<span class="keyword">int</span>&#125;、$&#123;random.<span class="keyword">long</span>&#125;</span><br><span class="line">$&#123;random.<span class="keyword">int</span>(<span class="number">10</span>)&#125;、$&#123;random.<span class="keyword">int</span>[<span class="number">1024</span>,<span class="number">65536</span>]&#125;</span><br></pre></td></tr></table></figure><h3 id="2、占位符获取之前配置的值，如果没有可以是用-指定默认值"><a href="#2、占位符获取之前配置的值，如果没有可以是用-指定默认值" class="headerlink" title="2、占位符获取之前配置的值，如果没有可以是用:指定默认值"></a>2、占位符获取之前配置的值，如果没有可以是用:指定默认值</h3><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">person.last-name</span>=<span class="string">张三$&#123;random.uuid&#125;</span></span><br><span class="line"><span class="meta">person.age</span>=<span class="string">$&#123;random.int&#125;</span></span><br><span class="line"><span class="meta">person.birth</span>=<span class="string">2017/12/15</span></span><br><span class="line"><span class="meta">person.boss</span>=<span class="string">false</span></span><br><span class="line"><span class="meta">person.maps.k1</span>=<span class="string">v1</span></span><br><span class="line"><span class="meta">person.maps.k2</span>=<span class="string">14</span></span><br><span class="line"><span class="meta">person.lists</span>=<span class="string">a,b,c</span></span><br><span class="line"><span class="meta">person.dog.name</span>=<span class="string">$&#123;person.hello:hello&#125;_dog</span></span><br><span class="line"><span class="meta">person.dog.age</span>=<span class="string">15</span></span><br></pre></td></tr></table></figure><h2 id="5、Profile"><a href="#5、Profile" class="headerlink" title="5、Profile"></a>5、Profile</h2><h3 id="1、多Profile文件"><a href="#1、多Profile文件" class="headerlink" title="1、多Profile文件"></a>1、多Profile文件</h3><p>我们在主配置文件编写的时候，文件名可以是   application-{profile}.properties/yml</p><p>默认使用application.properties的配置；</p><h3 id="2、yml支持多文档块方式"><a href="#2、yml支持多文档块方式" class="headerlink" title="2、yml支持多文档块方式"></a>2、yml支持多文档块方式</h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8081</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">prod</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8083</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span> <span class="string">dev</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8084</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span> <span class="string">prod</span>  <span class="comment">#指定属于哪个环境</span></span><br></pre></td></tr></table></figure><h3 id="3、激活指定profile"><a href="#3、激活指定profile" class="headerlink" title="3、激活指定profile"></a>3、激活指定profile</h3><p>​    1、在配置文件中指定  spring.profiles.active=dev</p><p>​    2、命令行：</p><p>​        java -jar spring-boot-02-config-0.0.1-SNAPSHOT.jar –spring.profiles.active=dev；</p><p>​        可以直接在测试的时候，配置传入命令行参数</p><p>​    3、虚拟机参数；</p><p>​        -Dspring.profiles.active=dev</p><h2 id="6、配置文件加载位置"><a href="#6、配置文件加载位置" class="headerlink" title="6、配置文件加载位置"></a>6、配置文件加载位置</h2><p>springboot 启动会扫描以下位置的application.properties或者application.yml文件作为Spring boot的默认配置文件</p><p>–file:./config/</p><p>–file:./</p><p>–classpath:/config/</p><p>–classpath:/</p><p>优先级由高到底，高优先级的配置会覆盖低优先级的配置；</p><p>SpringBoot会从这四个位置全部加载主配置文件；<strong>互补配置</strong>；</p><p>==我们还可以通过spring.config.location来改变默认的配置文件位置==</p><p><strong>项目打包好以后，我们可以使用命令行参数的形式，启动项目的时候来指定配置文件的新位置；指定配置文件和默认加载的这些配置文件共同起作用形成互补配置；</strong></p><p>java -jar spring-boot-02-config-02-0.0.1-SNAPSHOT.jar –spring.config.location=G:/application.properties</p><h2 id="7、外部配置加载顺序"><a href="#7、外部配置加载顺序" class="headerlink" title="7、外部配置加载顺序"></a>7、外部配置加载顺序</h2><p><strong>==SpringBoot也可以从以下位置加载配置； 优先级从高到低；高优先级的配置覆盖低优先级的配置，所有的配置会形成互补配置==</strong></p><p><strong>1.命令行参数</strong></p><p>所有的配置都可以在命令行上进行指定</p><p>java -jar spring-boot-02-config-02-0.0.1-SNAPSHOT.jar –server.port=8087  –server.context-path=/abc</p><p>多个配置用空格分开； –配置项=值</p><p>2.来自java:comp/env的JNDI属性</p><p>3.Java系统属性（System.getProperties()）</p><p>4.操作系统环境变量</p><p>5.RandomValuePropertySource配置的random.*属性值</p><p>==<strong>由jar包外向jar包内进行寻找；</strong>==</p><p>==<strong>优先加载带profile</strong>==</p><p><strong>6.jar包外部的application-{profile}.properties或application.yml(带spring.profile)配置文件</strong></p><p><strong>7.jar包内部的application-{profile}.properties或application.yml(带spring.profile)配置文件</strong></p><p>==<strong>再来加载不带profile</strong>==</p><p><strong>8.jar包外部的application.properties或application.yml(不带spring.profile)配置文件</strong></p><p><strong>9.jar包内部的application.properties或application.yml(不带spring.profile)配置文件</strong></p><p>10.@Configuration注解类上的@PropertySource</p><p>11.通过SpringApplication.setDefaultProperties指定的默认属性</p><p>所有支持的配置加载来源；</p><p><a href="https://docs.spring.io/spring-boot/docs/1.5.9.RELEASE/reference/htmlsingle/#boot-features-external-config" target="_blank" rel="noopener">参考官方文档</a></p><h2 id="8、自动配置原理"><a href="#8、自动配置原理" class="headerlink" title="8、自动配置原理"></a>8、自动配置原理</h2><p>配置文件到底能写什么？怎么写？自动配置原理；</p><p><a href="https://docs.spring.io/spring-boot/docs/1.5.9.RELEASE/reference/htmlsingle/#common-application-properties" target="_blank" rel="noopener">配置文件能配置的属性参照</a></p><h3 id="1、自动配置原理："><a href="#1、自动配置原理：" class="headerlink" title="1、自动配置原理："></a>1、<strong>自动配置原理：</strong></h3><p>1）、SpringBoot启动的时候加载主配置类，开启了自动配置功能 ==@EnableAutoConfiguration==</p><p><strong>2）、@EnableAutoConfiguration 作用：</strong></p><ul><li>利用EnableAutoConfigurationImportSelector给容器中导入一些组件？</li></ul><ul><li><p>可以查看selectImports()方法的内容；</p></li><li><p>List<String> configurations = getCandidateConfigurations(annotationMetadata,      attributes);获取候选的配置</p><ul><li><pre><code class="java">SpringFactoriesLoader.loadFactoryNames()扫描所有jar包类路径下  META-INF/spring.factories把扫描到的这些文件的内容包装成properties对象从properties中获取到EnableAutoConfiguration<span class="class">.<span class="keyword">class</span>类（类名）对应的值，然后把他们添加在容器中</span><span class="class"></span><span class="class"><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">**&#x3D;&#x3D;将 类路径下  META-INF&#x2F;spring.factories 里面配置的所有EnableAutoConfiguration的值加入到了容器中；&#x3D;&#x3D;**</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;properties</span><br><span class="line"># Auto Configure</span><br><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration&#x3D;\</span><br><span class="line">org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.cloud.CloudAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.context.MessageSourceAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.couchbase.CouchbaseAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.dao.PersistenceExceptionTranslationAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.cassandra.CassandraDataAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.cassandra.CassandraRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.couchbase.CouchbaseDataAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.couchbase.CouchbaseRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchDataAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.jpa.JpaRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.ldap.LdapDataAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.ldap.LdapRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.mongo.MongoDataAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.mongo.MongoRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.neo4j.Neo4jDataAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.neo4j.Neo4jRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.solr.SolrRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.redis.RedisRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.rest.RepositoryRestMvcAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.web.SpringDataWebAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.elasticsearch.jest.JestAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.freemarker.FreeMarkerAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.gson.GsonAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.h2.H2ConsoleAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.hateoas.HypermediaAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.hazelcast.HazelcastAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.hazelcast.HazelcastJpaDependencyAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.info.ProjectInfoAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.integration.IntegrationAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jdbc.JdbcTemplateAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jdbc.JndiDataSourceAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jdbc.XADataSourceAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jms.JmsAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jmx.JmxAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jms.JndiConnectionFactoryAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jms.activemq.ActiveMQAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jms.artemis.ArtemisAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.flyway.FlywayAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.groovy.template.GroovyTemplateAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jersey.JerseyAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jooq.JooqAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.kafka.KafkaAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.ldap.embedded.EmbeddedLdapAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.ldap.LdapAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.liquibase.LiquibaseAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.mail.MailSenderAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.mail.MailSenderValidatorAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.mobile.DeviceResolverAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.mobile.DeviceDelegatingViewResolverAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.mobile.SitePreferenceAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.mongo.embedded.EmbeddedMongoAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.mustache.MustacheAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.reactor.ReactorAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.security.SecurityAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.security.SecurityFilterAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.security.FallbackWebSecurityAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.security.oauth2.OAuth2AutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.sendgrid.SendGridAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.session.SessionAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.social.SocialWebAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.social.FacebookAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.social.LinkedInAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.social.TwitterAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.solr.SolrAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.thymeleaf.ThymeleafAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.transaction.TransactionAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.transaction.jta.JtaAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.validation.ValidationAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.DispatcherServletAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.EmbeddedServletContainerAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.ErrorMvcAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.HttpEncodingAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.HttpMessageConvertersAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.MultipartAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.ServerPropertiesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.WebClientAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.WebMvcAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.websocket.WebSocketAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.websocket.WebSocketMessagingAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.webservices.WebServicesAutoConfiguration</span><br></pre></td></tr></table></figure></span><span class="class"></span></code></pre></li></ul></li></ul><p>每一个这样的  xxxAutoConfiguration类都是容器中的一个组件，都加入到容器中；用他们来做自动配置；</p><p>3）、每一个自动配置类进行自动配置功能；</p><p>4）、以<strong>HttpEncodingAutoConfiguration（Http编码自动配置）</strong>为例解释自动配置原理；</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>   <span class="comment">//表示这是一个配置类，以前编写的配置文件一样，也可以给容器中添加组件</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties</span>(HttpEncodingProperties<span class="class">.<span class="keyword">class</span>)  //启动指定类的<span class="title">ConfigurationProperties</span>功能；将配置文件中对应的值和<span class="title">HttpEncodingProperties</span>绑定起来；并把<span class="title">HttpEncodingProperties</span>加入到<span class="title">ioc</span>容器中</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">@<span class="title">ConditionalOnWebApplication</span> //<span class="title">Spring</span>底层@<span class="title">Conditional</span>注解（<span class="title">Spring</span>注解版），根据不同的条件，如果满足指定的条件，整个配置类里面的配置就会生效；    判断当前应用是否是<span class="title">web</span>应用，如果是，当前配置类生效</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">@<span class="title">ConditionalOnClass</span>(<span class="title">CharacterEncodingFilter</span>.<span class="title">class</span>)  //判断当前项目有没有这个类<span class="title">CharacterEncodingFilter</span>；<span class="title">SpringMVC</span>中进行乱码解决的过滤器；</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">@<span class="title">ConditionalOnProperty</span>(<span class="title">prefix</span> </span>= <span class="string">"spring.http.encoding"</span>, value = <span class="string">"enabled"</span>, matchIfMissing = <span class="keyword">true</span>)  <span class="comment">//判断配置文件中是否存在某个配置  spring.http.encoding.enabled；如果不存在，判断也是成立的</span></span><br><span class="line"><span class="comment">//即使我们配置文件中不配置pring.http.encoding.enabled=true，也是默认生效的；</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpEncodingAutoConfiguration</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//他已经和SpringBoot的配置文件映射了</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> HttpEncodingProperties properties;</span><br><span class="line">  </span><br><span class="line">   <span class="comment">//只有一个有参构造器的情况下，参数的值就会从容器中拿</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">HttpEncodingAutoConfiguration</span><span class="params">(HttpEncodingProperties properties)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.properties = properties;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Bean</span>   <span class="comment">//给容器中添加一个组件，这个组件的某些值需要从properties中获取</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span>(CharacterEncodingFilter<span class="class">.<span class="keyword">class</span>) //判断容器没有这个组件？</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">CharacterEncodingFilter</span> <span class="title">characterEncodingFilter</span>() </span>&#123;</span><br><span class="line">CharacterEncodingFilter filter = <span class="keyword">new</span> OrderedCharacterEncodingFilter();</span><br><span class="line">filter.setEncoding(<span class="keyword">this</span>.properties.getCharset().name());</span><br><span class="line">filter.setForceRequestEncoding(<span class="keyword">this</span>.properties.shouldForce(Type.REQUEST));</span><br><span class="line">filter.setForceResponseEncoding(<span class="keyword">this</span>.properties.shouldForce(Type.RESPONSE));</span><br><span class="line"><span class="keyword">return</span> filter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据当前不同的条件判断，决定这个配置类是否生效？</p><p>一但这个配置类生效；这个配置类就会给容器中添加各种组件；这些组件的属性是从对应的properties类中获取的，这些类里面的每一个属性又是和配置文件绑定的；</p><p>5）、所有在配置文件中能配置的属性都是在xxxxProperties类中封装者‘；配置文件能配置什么就可以参照某个功能对应的这个属性类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"spring.http.encoding"</span>)  <span class="comment">//从配置文件中获取指定的值和bean的属性进行绑定</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpEncodingProperties</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Charset DEFAULT_CHARSET = Charset.forName(<span class="string">"UTF-8"</span>);</span><br></pre></td></tr></table></figure><p><strong>精髓：</strong></p><p>​    <strong>1）、SpringBoot启动会加载大量的自动配置类</strong></p><p>​    <strong>2）、我们看我们需要的功能有没有SpringBoot默认写好的自动配置类；</strong></p><p>​    <strong>3）、我们再来看这个自动配置类中到底配置了哪些组件；（只要我们要用的组件有，我们就不需要再来配置了）</strong></p><p>​    <strong>4）、给容器中自动配置类添加组件的时候，会从properties类中获取某些属性。我们就可以在配置文件中指定这些属性的值；</strong></p><p>xxxxAutoConfigurartion：自动配置类；</p><p>给容器中添加组件</p><p>xxxxProperties:封装配置文件中相关属性；</p><h3 id="2、细节"><a href="#2、细节" class="headerlink" title="2、细节"></a>2、细节</h3><h4 id="1、-Conditional派生注解（Spring注解版原生的-Conditional作用）"><a href="#1、-Conditional派生注解（Spring注解版原生的-Conditional作用）" class="headerlink" title="1、@Conditional派生注解（Spring注解版原生的@Conditional作用）"></a>1、@Conditional派生注解（Spring注解版原生的@Conditional作用）</h4><p>作用：必须是@Conditional指定的条件成立，才给容器中添加组件，配置配里面的所有内容才生效；</p><table><thead><tr><th>@Conditional扩展注解</th><th>作用（判断是否满足当前指定条件）</th></tr></thead><tbody><tr><td>@ConditionalOnJava</td><td>系统的java版本是否符合要求</td></tr><tr><td>@ConditionalOnBean</td><td>容器中存在指定Bean；</td></tr><tr><td>@ConditionalOnMissingBean</td><td>容器中不存在指定Bean；</td></tr><tr><td>@ConditionalOnExpression</td><td>满足SpEL表达式指定</td></tr><tr><td>@ConditionalOnClass</td><td>系统中有指定的类</td></tr><tr><td>@ConditionalOnMissingClass</td><td>系统中没有指定的类</td></tr><tr><td>@ConditionalOnSingleCandidate</td><td>容器中只有一个指定的Bean，或者这个Bean是首选Bean</td></tr><tr><td>@ConditionalOnProperty</td><td>系统中指定的属性是否有指定的值</td></tr><tr><td>@ConditionalOnResource</td><td>类路径下是否存在指定资源文件</td></tr><tr><td>@ConditionalOnWebApplication</td><td>当前是web环境</td></tr><tr><td>@ConditionalOnNotWebApplication</td><td>当前不是web环境</td></tr><tr><td>@ConditionalOnJndi</td><td>JNDI存在指定项</td></tr></tbody></table><p><strong>自动配置类必须在一定的条件下才能生效；</strong></p><p>我们怎么知道哪些自动配置类生效；</p><p><strong>==我们可以通过启用  debug=true属性；来让控制台打印自动配置报告==</strong>，这样我们就可以很方便的知道哪些自动配置类生效；</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">=========================</span><br><span class="line">AUTO-CONFIGURATION REPORT</span><br><span class="line">=========================</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Positive matches:（自动配置类启用的）</span><br><span class="line">-----------------</span><br><span class="line"></span><br><span class="line">   DispatcherServletAutoConfiguration matched:</span><br><span class="line">      - <span class="meta">@ConditionalOnClass</span> found required <span class="class"><span class="keyword">class</span> '<span class="title">org</span>.<span class="title">springframework</span>.<span class="title">web</span>.<span class="title">servlet</span>.<span class="title">DispatcherServlet</span>'</span>; <span class="meta">@ConditionalOnMissingClass</span> <span class="function">did not find unwanted <span class="title">class</span> <span class="params">(OnClassCondition)</span></span></span><br><span class="line"><span class="function">      - @<span class="title">ConditionalOnWebApplication</span> <span class="params">(required)</span> found <span class="title">StandardServletEnvironment</span> <span class="params">(OnWebApplicationCondition)</span></span></span><br><span class="line"><span class="function">        </span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function">Negative matches:（没有启动，没有匹配成功的自动配置类）</span></span><br><span class="line"><span class="function">-----------------</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">   ActiveMQAutoConfiguration:</span></span><br><span class="line"><span class="function">      Did not match:</span></span><br><span class="line"><span class="function">         - @ConditionalOnClass did not find required classes 'javax.jms.ConnectionFactory', 'org.apache.activemq.ActiveMQConnectionFactory' <span class="params">(OnClassCondition)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">   AopAutoConfiguration:</span></span><br><span class="line"><span class="function">      Did not match:</span></span><br><span class="line"><span class="function">         - @ConditionalOnClass did not find required classes 'org.aspectj.lang.annotation.Aspect', 'org.aspectj.lang.reflect.Advice' <span class="params">(OnClassCondition)</span></span></span><br></pre></td></tr></table></figure><h1 id="三、日志"><a href="#三、日志" class="headerlink" title="三、日志"></a>三、日志</h1><h2 id="1、日志框架"><a href="#1、日志框架" class="headerlink" title="1、日志框架"></a>1、日志框架</h2><p> 小张；开发一个大型系统；</p><p>​        1、System.out.println(“”)；将关键数据打印在控制台；去掉？写在一个文件？</p><p>​        2、框架来记录系统的一些运行时信息；日志框架 ；  zhanglogging.jar；</p><p>​        3、高大上的几个功能？异步模式？自动归档？xxxx？  zhanglogging-good.jar？</p><p>​        4、将以前框架卸下来？换上新的框架，重新修改之前相关的API；zhanglogging-prefect.jar；</p><p>​        5、JDBC—数据库驱动；</p><p>​            写了一个统一的接口层；日志门面（日志的一个抽象层）；logging-abstract.jar；</p><p>​            给项目中导入具体的日志实现就行了；我们之前的日志框架都是实现的抽象层；</p><p><strong>市面上的日志框架；</strong></p><p>JUL、JCL、Jboss-logging、logback、log4j、log4j2、slf4j….</p><table><thead><tr><th>日志门面  （日志的抽象层）</th><th>日志实现</th></tr></thead><tbody><tr><td><del>JCL（Jakarta  Commons Logging）</del>    SLF4j（Simple  Logging Facade for Java）    <strong><del>jboss-logging</del></strong></td><td>Log4j  JUL（java.util.logging）  Log4j2  <strong>Logback</strong></td></tr></tbody></table><p>左边选一个门面（抽象层）、右边来选一个实现；</p><p>日志门面：  SLF4J；</p><p>日志实现：Logback；</p><p>SpringBoot：底层是Spring框架，Spring框架默认是用JCL；‘</p><p>​    <strong>==SpringBoot选用 SLF4j和logback；==</strong></p><h2 id="2、SLF4j使用"><a href="#2、SLF4j使用" class="headerlink" title="2、SLF4j使用"></a>2、SLF4j使用</h2><h3 id="1、如何在系统中使用SLF4j-https-www-slf4j-org"><a href="#1、如何在系统中使用SLF4j-https-www-slf4j-org" class="headerlink" title="1、如何在系统中使用SLF4j   https://www.slf4j.org"></a>1、如何在系统中使用SLF4j   <a href="https://www.slf4j.org" target="_blank" rel="noopener">https://www.slf4j.org</a></h3><p>以后开发的时候，日志记录方法的调用，不应该来直接调用日志的实现类，而是调用日志抽象层里面的方法；</p><p>给系统里面导入slf4j的jar和  logback的实现jar</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Logger logger = LoggerFactory.getLogger(HelloWorld<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    logger.info(<span class="string">"Hello World"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>图示；</p><p>![images/concrete-bindings.png](F:/尚硅谷/springboot核心篇+整合篇-尚硅谷/01尚硅谷SpringBoot核心技术篇/Spring Boot 笔记+课件/images/concrete-bindings.png)</p><p>每一个日志的实现框架都有自己的配置文件。使用slf4j以后，<strong>配置文件还是做成日志实现框架自己本身的配置文件；</strong></p><h3 id="2、遗留问题"><a href="#2、遗留问题" class="headerlink" title="2、遗留问题"></a>2、遗留问题</h3><p>a（slf4j+logback）: Spring（commons-logging）、Hibernate（jboss-logging）、MyBatis、xxxx</p><p>统一日志记录，即使是别的框架和我一起统一使用slf4j进行输出？</p><p>![](F:/尚硅谷/springboot核心篇+整合篇-尚硅谷/01尚硅谷SpringBoot核心技术篇/Spring Boot 笔记+课件/images/legacy.png)</p><p><strong>如何让系统中所有的日志都统一到slf4j；</strong></p><p>==1、将系统中其他日志框架先排除出去；==</p><p>==2、用中间包来替换原有的日志框架；==</p><p>==3、我们导入slf4j其他的实现==</p><h2 id="3、SpringBoot日志关系"><a href="#3、SpringBoot日志关系" class="headerlink" title="3、SpringBoot日志关系"></a>3、SpringBoot日志关系</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>SpringBoot使用它来做日志功能；</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>底层依赖关系</p><p>![](F:/尚硅谷/springboot核心篇+整合篇-尚硅谷/01尚硅谷SpringBoot核心技术篇/Spring Boot 笔记+课件/images/搜狗截图20180131220946.png)</p><p>总结：</p><p>​    1）、SpringBoot底层也是使用slf4j+logback的方式进行日志记录</p><p>​    2）、SpringBoot也把其他的日志都替换成了slf4j；</p><p>​    3）、中间替换包？</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"rawtypes"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">LogFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> String UNSUPPORTED_OPERATION_IN_JCL_OVER_SLF4J = <span class="string">"http://www.slf4j.org/codes.html#unsupported_operation_in_jcl_over_slf4j"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> LogFactory logFactory = <span class="keyword">new</span> SLF4JLogFactory();</span><br></pre></td></tr></table></figure><p>![](F:/尚硅谷/springboot核心篇+整合篇-尚硅谷/01尚硅谷SpringBoot核心技术篇/Spring Boot 笔记+课件/images/搜狗截图20180131221411.png)</p><p>​    4）、如果我们要引入其他框架？一定要把这个框架的默认日志依赖移除掉？</p><p>​            Spring框架用的是commons-logging；</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>==SpringBoot能自动适配所有的日志，而且底层使用slf4j+logback的方式记录日志，引入其他框架的时候，只需要把这个框架依赖的日志框架排除掉即可；==</strong></p><h2 id="4、日志使用；"><a href="#4、日志使用；" class="headerlink" title="4、日志使用；"></a>4、日志使用；</h2><h3 id="1、默认配置"><a href="#1、默认配置" class="headerlink" title="1、默认配置"></a>1、默认配置</h3><p>SpringBoot默认帮我们配置好了日志；</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//记录器</span></span><br><span class="line">Logger logger = LoggerFactory.getLogger(getClass());</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//System.out.println();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//日志的级别；</span></span><br><span class="line"><span class="comment">//由低到高   trace&lt;debug&lt;info&lt;warn&lt;error</span></span><br><span class="line"><span class="comment">//可以调整输出的日志级别；日志就只会在这个级别以以后的高级别生效</span></span><br><span class="line">logger.trace(<span class="string">"这是trace日志..."</span>);</span><br><span class="line">logger.debug(<span class="string">"这是debug日志..."</span>);</span><br><span class="line"><span class="comment">//SpringBoot默认给我们使用的是info级别的，没有指定级别的就用SpringBoot默认规定的级别；root级别</span></span><br><span class="line">logger.info(<span class="string">"这是info日志..."</span>);</span><br><span class="line">logger.warn(<span class="string">"这是warn日志..."</span>);</span><br><span class="line">logger.error(<span class="string">"这是error日志..."</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>日志输出格式：    %d表示日期时间，    %thread表示线程名，    %-5level：级别从左显示5个字符宽度    %logger{50} 表示logger名字最长50个字符，否则按照句点分割。     %msg：日志消息，    %n是换行符--&gt;%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%n</code></pre><p>SpringBoot修改日志的默认配置</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">logging.level.com.atguigu</span>=<span class="string">trace</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#logging.path=</span></span><br><span class="line"><span class="comment"># 不指定路径在当前项目下生成springboot.log日志</span></span><br><span class="line"><span class="comment"># 可以指定完整的路径；</span></span><br><span class="line"><span class="comment">#logging.file=G:/springboot.log</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在当前磁盘的根路径下创建spring文件夹和里面的log文件夹；使用 spring.log 作为默认文件</span></span><br><span class="line"><span class="meta">logging.path</span>=<span class="string">/spring/log</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#  在控制台输出的日志的格式</span></span><br><span class="line"><span class="meta">logging.pattern.console</span>=<span class="string">%d&#123;yyyy-MM-dd&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n</span></span><br><span class="line"><span class="comment"># 指定文件中日志输出的格式</span></span><br><span class="line"><span class="meta">logging.pattern.file</span>=<span class="string">%d&#123;yyyy-MM-dd&#125; === [%thread] === %-5level === %logger&#123;50&#125; ==== %msg%n</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>logging.file</th><th>logging.path</th><th>Example</th><th>Description</th></tr></thead><tbody><tr><td>(none)</td><td>(none)</td><td></td><td>只在控制台输出</td></tr><tr><td>指定文件名</td><td>(none)</td><td>my.log</td><td>输出日志到my.log文件</td></tr><tr><td>(none)</td><td>指定目录</td><td>/var/log</td><td>输出到指定目录的 spring.log 文件中</td></tr></tbody></table><h3 id="2、指定配置"><a href="#2、指定配置" class="headerlink" title="2、指定配置"></a>2、指定配置</h3><p>给类路径下放上每个日志框架自己的配置文件即可；SpringBoot就不使用他默认配置的了</p><table><thead><tr><th>Logging System</th><th>Customization</th></tr></thead><tbody><tr><td>Logback</td><td><code>logback-spring.xml</code>, <code>logback-spring.groovy</code>, <code>logback.xml</code> or <code>logback.groovy</code></td></tr><tr><td>Log4j2</td><td><code>log4j2-spring.xml</code> or <code>log4j2.xml</code></td></tr><tr><td>JDK (Java Util Logging)</td><td><code>logging.properties</code></td></tr></tbody></table><p>logback.xml：直接就被日志框架识别了；</p><p><strong>logback-spring.xml</strong>：日志框架就不直接加载日志的配置项，由SpringBoot解析日志配置，可以使用SpringBoot的高级Profile功能</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">springProfile</span> <span class="attr">name</span>=<span class="string">"staging"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- configuration to be enabled when the "staging" profile is active --&gt;</span></span><br><span class="line">  可以指定某段配置只在某个环境下生效</span><br><span class="line"><span class="tag">&lt;/<span class="name">springProfile</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"stdout"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.ConsoleAppender"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        日志输出格式：</span></span><br><span class="line"><span class="comment">%d表示日期时间，</span></span><br><span class="line"><span class="comment">%thread表示线程名，</span></span><br><span class="line"><span class="comment">%-5level：级别从左显示5个字符宽度</span></span><br><span class="line"><span class="comment">%logger&#123;50&#125; 表示logger名字最长50个字符，否则按照句点分割。 </span></span><br><span class="line"><span class="comment">%msg：日志消息，</span></span><br><span class="line"><span class="comment">%n是换行符</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">layout</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.PatternLayout"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">springProfile</span> <span class="attr">name</span>=<span class="string">"dev"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; ----&gt; [%thread] ---&gt; %-5level %logger&#123;50&#125; - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">springProfile</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">springProfile</span> <span class="attr">name</span>=<span class="string">"!dev"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; ==== [%thread] ==== %-5level %logger&#123;50&#125; - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">springProfile</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果使用logback.xml作为日志配置文件，还要使用profile功能，会有以下错误</p><p> <code>no applicable action for [springProfile]</code></p><h2 id="5、切换日志框架"><a href="#5、切换日志框架" class="headerlink" title="5、切换日志框架"></a>5、切换日志框架</h2><p>可以按照slf4j的日志适配图，进行相关的切换；</p><p>slf4j+log4j的方式；</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-classic<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-over-slf4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-log4j12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>切换为log4j2</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">   <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-log4j2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h1 id="四、Web开发"><a href="#四、Web开发" class="headerlink" title="四、Web开发"></a>四、Web开发</h1><h2 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h2><p>使用SpringBoot；</p><p><strong>1）、创建SpringBoot应用，选中我们需要的模块；</strong></p><p><strong>2）、SpringBoot已经默认将这些场景配置好了，只需要在配置文件中指定少量配置就可以运行起来</strong></p><p><strong>3）、自己编写业务代码；</strong></p><p><strong>自动配置原理？</strong></p><p>这个场景SpringBoot帮我们配置了什么？能不能修改？能修改哪些配置？能不能扩展？xxx</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xxxxAutoConfiguration：帮我们给容器中自动配置组件；</span><br><span class="line">xxxxProperties:配置类来封装配置文件的内容；</span><br></pre></td></tr></table></figure><h2 id="2、SpringBoot对静态资源的映射规则；"><a href="#2、SpringBoot对静态资源的映射规则；" class="headerlink" title="2、SpringBoot对静态资源的映射规则；"></a>2、SpringBoot对静态资源的映射规则；</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"spring.resources"</span>, ignoreUnknownFields = <span class="keyword">false</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResourceProperties</span> <span class="keyword">implements</span> <span class="title">ResourceLoaderAware</span> </span>&#123;</span><br><span class="line">  <span class="comment">//可以设置和静态资源有关的参数，缓存时间等</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">WebMvcAuotConfiguration：</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">this</span>.resourceProperties.isAddMappings()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Default resource handling disabled"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">Integer cachePeriod = <span class="keyword">this</span>.resourceProperties.getCachePeriod();</span><br><span class="line"><span class="keyword">if</span> (!registry.hasMappingForPattern(<span class="string">"/webjars/**"</span>)) &#123;</span><br><span class="line">customizeResourceHandlerRegistration(</span><br><span class="line">registry.addResourceHandler(<span class="string">"/webjars/**"</span>)</span><br><span class="line">.addResourceLocations(</span><br><span class="line"><span class="string">"classpath:/META-INF/resources/webjars/"</span>)</span><br><span class="line">.setCachePeriod(cachePeriod));</span><br><span class="line">&#125;</span><br><span class="line">String staticPathPattern = <span class="keyword">this</span>.mvcProperties.getStaticPathPattern();</span><br><span class="line">         <span class="comment">//静态资源文件夹映射</span></span><br><span class="line"><span class="keyword">if</span> (!registry.hasMappingForPattern(staticPathPattern)) &#123;</span><br><span class="line">customizeResourceHandlerRegistration(</span><br><span class="line">registry.addResourceHandler(staticPathPattern)</span><br><span class="line">.addResourceLocations(</span><br><span class="line"><span class="keyword">this</span>.resourceProperties.getStaticLocations())</span><br><span class="line">.setCachePeriod(cachePeriod));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//配置欢迎页映射</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> WelcomePageHandlerMapping <span class="title">welcomePageHandlerMapping</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">ResourceProperties resourceProperties)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> WelcomePageHandlerMapping(resourceProperties.getWelcomePage(),</span><br><span class="line"><span class="keyword">this</span>.mvcProperties.getStaticPathPattern());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//配置喜欢的图标</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty</span>(value = <span class="string">"spring.mvc.favicon.enabled"</span>, matchIfMissing = <span class="keyword">true</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">FaviconConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ResourceProperties resourceProperties;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FaviconConfiguration</span><span class="params">(ResourceProperties resourceProperties)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.resourceProperties = resourceProperties;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SimpleUrlHandlerMapping <span class="title">faviconHandlerMapping</span><span class="params">()</span> </span>&#123;</span><br><span class="line">SimpleUrlHandlerMapping mapping = <span class="keyword">new</span> SimpleUrlHandlerMapping();</span><br><span class="line">mapping.setOrder(Ordered.HIGHEST_PRECEDENCE + <span class="number">1</span>);</span><br><span class="line">             <span class="comment">//所有  **/favicon.ico </span></span><br><span class="line">mapping.setUrlMap(Collections.singletonMap(<span class="string">"**/favicon.ico"</span>,</span><br><span class="line">faviconRequestHandler()));</span><br><span class="line"><span class="keyword">return</span> mapping;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ResourceHttpRequestHandler <span class="title">faviconRequestHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">ResourceHttpRequestHandler requestHandler = <span class="keyword">new</span> ResourceHttpRequestHandler();</span><br><span class="line">requestHandler</span><br><span class="line">.setLocations(<span class="keyword">this</span>.resourceProperties.getFaviconLocations());</span><br><span class="line"><span class="keyword">return</span> requestHandler;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>==1）、所有 /webjars/** ，都去 classpath:/META-INF/resources/webjars/ 找资源；==</p><p>​    webjars：以jar包的方式引入静态资源；</p><p><a href="http://www.webjars.org/" target="_blank" rel="noopener">http://www.webjars.org/</a></p><p>![](F:/尚硅谷/springboot核心篇+整合篇-尚硅谷/01尚硅谷SpringBoot核心技术篇/Spring Boot 笔记+课件/images/搜狗截图20180203181751.png)</p><p>localhost:8080/webjars/jquery/3.3.1/jquery.js</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--引入jquery-webjar--&gt;</span>在访问的时候只需要写webjars下面资源的名称即可</span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.webjars<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jquery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>==2）、”/**” 访问当前项目的任何资源，都去（静态资源的文件夹）找映射==</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;classpath:&#x2F;META-INF&#x2F;resources&#x2F;&quot;, </span><br><span class="line">&quot;classpath:&#x2F;resources&#x2F;&quot;,</span><br><span class="line">&quot;classpath:&#x2F;static&#x2F;&quot;, </span><br><span class="line">&quot;classpath:&#x2F;public&#x2F;&quot; </span><br><span class="line">&quot;&#x2F;&quot;：当前项目的根路径</span><br></pre></td></tr></table></figure><p>localhost:8080/abc ===  去静态资源文件夹里面找abc</p><p>==3）、欢迎页； 静态资源文件夹下的所有index.html页面；被”/**”映射；==</p><p>​    localhost:8080/   找index页面</p><p>==4）、所有的 **/favicon.ico  都是在静态资源文件下找；==</p><h2 id="3、模板引擎"><a href="#3、模板引擎" class="headerlink" title="3、模板引擎"></a>3、模板引擎</h2><p>JSP、Velocity、Freemarker、Thymeleaf</p><p>![](F:/尚硅谷/springboot核心篇+整合篇-尚硅谷/01尚硅谷SpringBoot核心技术篇/Spring Boot 笔记+课件/images/template-engine.png)</p><p>SpringBoot推荐的Thymeleaf；</p><p>语法更简单，功能更强大；</p><h3 id="1、引入thymeleaf；"><a href="#1、引入thymeleaf；" class="headerlink" title="1、引入thymeleaf；"></a>1、引入thymeleaf；</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          2.1.6</span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">切换thymeleaf版本</span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">thymeleaf.version</span>&gt;</span>3.0.9.RELEASE<span class="tag">&lt;/<span class="name">thymeleaf.version</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 布局功能的支持程序  thymeleaf3主程序  layout2以上版本 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- thymeleaf2   layout1--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">thymeleaf-layout-dialect.version</span>&gt;</span>2.2.2<span class="tag">&lt;/<span class="name">thymeleaf-layout-dialect.version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2、Thymeleaf使用"><a href="#2、Thymeleaf使用" class="headerlink" title="2、Thymeleaf使用"></a>2、Thymeleaf使用</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"spring.thymeleaf"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThymeleafProperties</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Charset DEFAULT_ENCODING = Charset.forName(<span class="string">"UTF-8"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> MimeType DEFAULT_CONTENT_TYPE = MimeType.valueOf(<span class="string">"text/html"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_PREFIX = <span class="string">"classpath:/templates/"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_SUFFIX = <span class="string">".html"</span>;</span><br><span class="line">  <span class="comment">//</span></span><br></pre></td></tr></table></figure><p>只要我们把HTML页面放在classpath:/templates/，thymeleaf就能自动渲染；</p><p>使用：</p><p>1、导入thymeleaf的名称空间</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span> <span class="attr">xmlns:th</span>=<span class="string">"http://www.thymeleaf.org"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2、使用thymeleaf语法；</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span> <span class="attr">xmlns:th</span>=<span class="string">"http://www.thymeleaf.org"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>成功！<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--th:text 将div里面的文本内容设置为 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">th:text</span>=<span class="string">"$&#123;hello&#125;"</span>&gt;</span>这是显示欢迎信息<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3、语法规则"><a href="#3、语法规则" class="headerlink" title="3、语法规则"></a>3、语法规则</h3><p>1）、th:text；改变当前元素里面的文本内容；</p><p>​    th：任意html属性；来替换原生属性的值</p><p>![](F:/尚硅谷/springboot核心篇+整合篇-尚硅谷/01尚硅谷SpringBoot核心技术篇/Spring Boot 笔记+课件/images/2018-02-04_123955.png)</p><p>2）、表达式？</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">Simple</span> <span class="string">expressions:（表达式语法）</span></span><br><span class="line">    <span class="attr">Variable</span> <span class="string">Expressions: $&#123;...&#125;：获取变量值；OGNL；</span></span><br><span class="line">    <span class="attr">1）、获取对象的属性、调用方法</span></span><br><span class="line">    <span class="attr">2）、使用内置的基本对象：</span></span><br><span class="line"><span class="comment">    #ctx : the context object.</span></span><br><span class="line"><span class="comment">    #vars: the context variables.</span></span><br><span class="line"><span class="comment">                #locale : the context locale.</span></span><br><span class="line"><span class="comment">                #request : (only in Web Contexts) the HttpServletRequest object.</span></span><br><span class="line"><span class="comment">                #response : (only in Web Contexts) the HttpServletResponse object.</span></span><br><span class="line"><span class="comment">                #session : (only in Web Contexts) the HttpSession object.</span></span><br><span class="line"><span class="comment">                #servletContext : (only in Web Contexts) the ServletContext object.</span></span><br><span class="line">                </span><br><span class="line">                <span class="attr">$&#123;session.foo&#125;</span></span><br><span class="line">            <span class="attr">3）、内置的一些工具对象：</span></span><br><span class="line"><span class="comment">#execInfo : information about the template being processed.</span></span><br><span class="line"><span class="comment">#messages : methods for obtaining externalized messages inside variables expressions, in the same way as they would be obtained using #&#123;…&#125; syntax.</span></span><br><span class="line"><span class="comment">#uris : methods for escaping parts of URLs/URIs</span></span><br><span class="line"><span class="comment">#conversions : methods for executing the configured conversion service (if any).</span></span><br><span class="line"><span class="comment">#dates : methods for java.util.Date objects: formatting, component extraction, etc.</span></span><br><span class="line"><span class="comment">#calendars : analogous to #dates , but for java.util.Calendar objects.</span></span><br><span class="line"><span class="comment">#numbers : methods for formatting numeric objects.</span></span><br><span class="line"><span class="comment">#strings : methods for String objects: contains, startsWith, prepending/appending, etc.</span></span><br><span class="line"><span class="comment">#objects : methods for objects in general.</span></span><br><span class="line"><span class="comment">#bools : methods for boolean evaluation.</span></span><br><span class="line"><span class="comment">#arrays : methods for arrays.</span></span><br><span class="line"><span class="comment">#lists : methods for lists.</span></span><br><span class="line"><span class="comment">#sets : methods for sets.</span></span><br><span class="line"><span class="comment">#maps : methods for maps.</span></span><br><span class="line"><span class="comment">#aggregates : methods for creating aggregates on arrays or collections.</span></span><br><span class="line"><span class="comment">#ids : methods for dealing with id attributes that might be repeated (for example, as a result of an iteration).</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">Selection</span> <span class="string">Variable Expressions: *&#123;...&#125;：选择表达式：和$&#123;&#125;在功能上是一样；</span></span><br><span class="line">    <span class="meta">补充：配合</span> <span class="string">th:object="$&#123;session.user&#125;：</span></span><br><span class="line">   <span class="meta">&lt;div</span> <span class="string">th:object="$&#123;session.user&#125;"&gt;</span></span><br><span class="line">    <span class="meta">&lt;p&gt;Name</span>: <span class="string">&lt;span th:text="*&#123;firstName&#125;"&gt;Sebastian&lt;/span&gt;.&lt;/p&gt;</span></span><br><span class="line">    <span class="meta">&lt;p&gt;Surname</span>: <span class="string">&lt;span th:text="*&#123;lastName&#125;"&gt;Pepper&lt;/span&gt;.&lt;/p&gt;</span></span><br><span class="line">    <span class="meta">&lt;p&gt;Nationality</span>: <span class="string">&lt;span th:text="*&#123;nationality&#125;"&gt;Saturn&lt;/span&gt;.&lt;/p&gt;</span></span><br><span class="line">    <span class="attr">&lt;/div&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="attr">Message</span> <span class="string">Expressions: #&#123;...&#125;：获取国际化内容</span></span><br><span class="line">    <span class="attr">Link</span> <span class="string">URL Expressions: @&#123;...&#125;：定义URL；</span></span><br><span class="line">    <span class="meta">@&#123;/order/process(execId</span>=<span class="string">$&#123;execId&#125;,execType='FAST')&#125;</span></span><br><span class="line">    <span class="attr">Fragment</span> <span class="string">Expressions: ~&#123;...&#125;：片段引用表达式</span></span><br><span class="line">    <span class="meta">&lt;div</span> <span class="string">th:insert="~&#123;commons :: main&#125;"&gt;...&lt;/div&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="attr">Literals（字面量）</span></span><br><span class="line">      <span class="attr">Text</span> <span class="string">literals: 'one text' , 'Another one!' ,…</span></span><br><span class="line">      <span class="attr">Number</span> <span class="string">literals: 0 , 34 , 3.0 , 12.3 ,…</span></span><br><span class="line">      <span class="attr">Boolean</span> <span class="string">literals: true , false</span></span><br><span class="line">      <span class="attr">Null</span> <span class="string">literal: null</span></span><br><span class="line">      <span class="attr">Literal</span> <span class="string">tokens: one , sometext , main ,…</span></span><br><span class="line"><span class="attr">Text</span> <span class="string">operations:（文本操作）</span></span><br><span class="line">    <span class="attr">String</span> <span class="string">concatenation: +</span></span><br><span class="line">    <span class="attr">Literal</span> <span class="string">substitutions: |The name is $&#123;name&#125;|</span></span><br><span class="line"><span class="attr">Arithmetic</span> <span class="string">operations:（数学运算）</span></span><br><span class="line">    <span class="attr">Binary</span> <span class="string">operators: + , - , * , / , %</span></span><br><span class="line">    <span class="attr">Minus</span> <span class="string">sign (unary operator): -</span></span><br><span class="line"><span class="attr">Boolean</span> <span class="string">operations:（布尔运算）</span></span><br><span class="line">    <span class="attr">Binary</span> <span class="string">operators: and , or</span></span><br><span class="line">    <span class="attr">Boolean</span> <span class="string">negation (unary operator): ! , not</span></span><br><span class="line"><span class="attr">Comparisons</span> <span class="string">and equality:（比较运算）</span></span><br><span class="line">    <span class="attr">Comparators</span>: <span class="string">&gt; , &lt; , &gt;= , &lt;= ( gt , lt , ge , le )</span></span><br><span class="line">    <span class="attr">Equality</span> <span class="string">operators: == , != ( eq , ne )</span></span><br><span class="line"><span class="attr">Conditional</span> <span class="string">operators:条件运算（三元运算符）</span></span><br><span class="line">    <span class="meta">If-then</span>: <span class="string">(if) ? (then)</span></span><br><span class="line">    <span class="meta">If-then-else</span>: <span class="string">(if) ? (then) : (else)</span></span><br><span class="line">    <span class="attr">Default</span>: <span class="string">(value) ?: (defaultvalue)</span></span><br><span class="line"><span class="attr">Special</span> <span class="string">tokens:</span></span><br><span class="line">    <span class="meta">No-Operation</span>: <span class="string">_</span></span><br></pre></td></tr></table></figure><h2 id="4、SpringMVC自动配置"><a href="#4、SpringMVC自动配置" class="headerlink" title="4、SpringMVC自动配置"></a>4、SpringMVC自动配置</h2><p><a href="https://docs.spring.io/spring-boot/docs/1.5.10.RELEASE/reference/htmlsingle/#boot-features-developing-web-applications" target="_blank" rel="noopener">https://docs.spring.io/spring-boot/docs/1.5.10.RELEASE/reference/htmlsingle/#boot-features-developing-web-applications</a></p><h3 id="1-Spring-MVC-auto-configuration"><a href="#1-Spring-MVC-auto-configuration" class="headerlink" title="1. Spring MVC auto-configuration"></a>1. Spring MVC auto-configuration</h3><p>Spring Boot 自动配置好了SpringMVC</p><p>以下是SpringBoot对SpringMVC的默认配置:<strong>==（WebMvcAutoConfiguration）==</strong></p><ul><li><p>Inclusion of <code>ContentNegotiatingViewResolver</code> and <code>BeanNameViewResolver</code> beans.</p><ul><li>自动配置了ViewResolver（视图解析器：根据方法的返回值得到视图对象（View），视图对象决定如何渲染（转发？重定向？））</li><li>ContentNegotiatingViewResolver：组合所有的视图解析器的；</li><li>==如何定制：我们可以自己给容器中添加一个视图解析器；自动的将其组合进来；==</li></ul></li><li><p>Support for serving static resources, including support for WebJars (see below).静态资源文件夹路径,webjars</p></li><li><p>Static <code>index.html</code> support. 静态首页访问</p></li><li><p>Custom <code>Favicon</code> support (see below).  favicon.ico</p></li></ul><ul><li><p>自动注册了 of <code>Converter</code>, <code>GenericConverter</code>, <code>Formatter</code> beans.</p><ul><li>Converter：转换器；  public String hello(User user)：类型转换使用Converter</li><li><code>Formatter</code>  格式化器；  2017.12.17===Date；</li></ul></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty</span>(prefix = <span class="string">"spring.mvc"</span>, name = <span class="string">"date-format"</span>)<span class="comment">//在文件中配置日期格式化的规则</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Formatter&lt;Date&gt; <span class="title">dateFormatter</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> DateFormatter(<span class="keyword">this</span>.mvcProperties.getDateFormat());<span class="comment">//日期格式化组件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    ==自己添加的格式化器转换器，我们只需要放在容器中即可==</p><ul><li><p>Support for <code>HttpMessageConverters</code> (see below).</p><ul><li><p>HttpMessageConverter：SpringMVC用来转换Http请求和响应的；User—Json；</p></li><li><p><code>HttpMessageConverters</code> 是从容器中确定；获取所有的HttpMessageConverter；</p><p>==自己给容器中添加HttpMessageConverter，只需要将自己的组件注册容器中（@Bean,@Component）==</p></li></ul></li></ul><ul><li><p>Automatic registration of <code>MessageCodesResolver</code> (see below).定义错误代码生成规则</p></li><li><p>Automatic use of a <code>ConfigurableWebBindingInitializer</code> bean (see below).</p><p>==我们可以配置一个ConfigurableWebBindingInitializer来替换默认的；（添加到容器）==</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">初始化WebDataBinder；</span><br><span class="line">请求数据&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;JavaBean；</span><br></pre></td></tr></table></figure></li></ul><p><strong>org.springframework.boot.autoconfigure.web：web的所有自动场景；</strong></p><p>If you want to keep Spring Boot MVC features, and you just want to add additional <a href="https://docs.spring.io/spring/docs/4.3.14.RELEASE/spring-framework-reference/htmlsingle#mvc" target="_blank" rel="noopener">MVC configuration</a> (interceptors, formatters, view controllers etc.) you can add your own <code>@Configuration</code> class of type <code>WebMvcConfigurerAdapter</code>, but <strong>without</strong> <code>@EnableWebMvc</code>. If you wish to provide custom instances of <code>RequestMappingHandlerMapping</code>, <code>RequestMappingHandlerAdapter</code> or <code>ExceptionHandlerExceptionResolver</code> you can declare a <code>WebMvcRegistrationsAdapter</code> instance providing such components.</p><p>If you want to take complete control of Spring MVC, you can add your own <code>@Configuration</code> annotated with <code>@EnableWebMvc</code>.</p><h3 id="2、扩展SpringMVC"><a href="#2、扩展SpringMVC" class="headerlink" title="2、扩展SpringMVC"></a>2、扩展SpringMVC</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:view-controller</span> <span class="attr">path</span>=<span class="string">"/hello"</span> <span class="attr">view-name</span>=<span class="string">"success"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">"/hello"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>==编写一个配置类（@Configuration），是WebMvcConfigurerAdapter类型；不能标注@EnableWebMvc==</strong>;</p><p>既保留了所有的自动配置，也能用我们扩展的配置；</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用WebMvcConfigurerAdapter可以来扩展SpringMVC的功能</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMvcConfig</span> <span class="keyword">extends</span> <span class="title">WebMvcConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addViewControllers</span><span class="params">(ViewControllerRegistry registry)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// super.addViewControllers(registry);</span></span><br><span class="line">        <span class="comment">//浏览器发送 /atguigu 请求来到 success</span></span><br><span class="line">        registry.addViewController(<span class="string">"/atguigu"</span>).setViewName(<span class="string">"success"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原理：</p><p>​    1）、WebMvcAutoConfiguration是SpringMVC的自动配置类</p><p>​    2）、在做其他自动配置时会导入；@Import(<strong>EnableWebMvcConfiguration</strong>.class)</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">EnableWebMvcConfiguration</span> <span class="keyword">extends</span> <span class="title">DelegatingWebMvcConfiguration</span> </span>&#123;</span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">final</span> WebMvcConfigurerComposite configurers = <span class="keyword">new</span> WebMvcConfigurerComposite();</span><br><span class="line"></span><br><span class="line"> <span class="comment">//从容器中获取所有的WebMvcConfigurer</span></span><br><span class="line">     <span class="meta">@Autowired</span>(required = <span class="keyword">false</span>)</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setConfigurers</span><span class="params">(List&lt;WebMvcConfigurer&gt; configurers)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">if</span> (!CollectionUtils.isEmpty(configurers)) &#123;</span><br><span class="line">             <span class="keyword">this</span>.configurers.addWebMvcConfigurers(configurers);</span><br><span class="line">           <span class="comment">//一个参考实现；将所有的WebMvcConfigurer相关配置都来一起调用；  </span></span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">            <span class="comment">// public void addViewControllers(ViewControllerRegistry registry) &#123;</span></span><br><span class="line">             <span class="comment">//    for (WebMvcConfigurer delegate : this.delegates) &#123;</span></span><br><span class="line">              <span class="comment">//       delegate.addViewControllers(registry);</span></span><br><span class="line">              <span class="comment">//   &#125;</span></span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    3）、容器中所有的WebMvcConfigurer都会一起起作用；</p><p>​    4）、我们的配置类也会被调用；</p><p>​    效果：SpringMVC的自动配置和我们的扩展配置都会起作用；</p><h3 id="3、全面接管SpringMVC；"><a href="#3、全面接管SpringMVC；" class="headerlink" title="3、全面接管SpringMVC；"></a>3、全面接管SpringMVC；</h3><p>SpringBoot对SpringMVC的自动配置不需要了，所有都是我们自己配置；所有的SpringMVC的自动配置都失效了</p><p><strong>我们需要在配置类中添加@EnableWebMvc即可；</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用WebMvcConfigurerAdapter可以来扩展SpringMVC的功能</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMvcConfig</span> <span class="keyword">extends</span> <span class="title">WebMvcConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addViewControllers</span><span class="params">(ViewControllerRegistry registry)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// super.addViewControllers(registry);</span></span><br><span class="line">        <span class="comment">//浏览器发送 /atguigu 请求来到 success</span></span><br><span class="line">        registry.addViewController(<span class="string">"/atguigu"</span>).setViewName(<span class="string">"success"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原理：</p><p>为什么@EnableWebMvc自动配置就失效了；</p><p>1）@EnableWebMvc的核心</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Import</span>(DelegatingWebMvcConfiguration<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> @<span class="title">interface</span> <span class="title">EnableWebMvc</span> </span>&#123;</span><br></pre></td></tr></table></figure><p>2）、</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DelegatingWebMvcConfiguration</span> <span class="keyword">extends</span> <span class="title">WebMvcConfigurationSupport</span> </span>&#123;</span><br></pre></td></tr></table></figure><p>3）、</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnWebApplication</span></span><br><span class="line"><span class="meta">@ConditionalOnClass</span>(&#123; Servlet<span class="class">.<span class="keyword">class</span>, <span class="title">DispatcherServlet</span>.<span class="title">class</span>,</span></span><br><span class="line"><span class="class"><span class="title">WebMvcConfigurerAdapter</span>.<span class="title">class</span> &#125;)</span></span><br><span class="line"><span class="class">//容器中没有这个组件的时候，这个自动配置类才生效</span></span><br><span class="line"><span class="class">@<span class="title">ConditionalOnMissingBean</span>(<span class="title">WebMvcConfigurationSupport</span>.<span class="title">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">AutoConfigureOrder</span>(<span class="title">Ordered</span>.<span class="title">HIGHEST_PRECEDENCE</span> + 10)</span></span><br><span class="line"><span class="class">@<span class="title">AutoConfigureAfter</span>(</span>&#123; DispatcherServletAutoConfiguration<span class="class">.<span class="keyword">class</span>,</span></span><br><span class="line"><span class="class"><span class="title">ValidationAutoConfiguration</span>.<span class="title">class</span> &#125;)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">WebMvcAutoConfiguration</span> </span>&#123;</span><br></pre></td></tr></table></figure><p>4）、@EnableWebMvc将WebMvcConfigurationSupport组件导入进来；</p><p>5）、导入的WebMvcConfigurationSupport只是SpringMVC最基本的功能；</p><h2 id="5、如何修改SpringBoot的默认配置"><a href="#5、如何修改SpringBoot的默认配置" class="headerlink" title="5、如何修改SpringBoot的默认配置"></a>5、如何修改SpringBoot的默认配置</h2><p>模式：</p><p>​    1）、SpringBoot在自动配置很多组件的时候，先看容器中有没有用户自己配置的（@Bean、@Component）如果有就用用户配置的，如果没有，才自动配置；如果有些组件可以有多个（ViewResolver）将用户配置的和自己默认的组合起来；</p><p>​    2）、在SpringBoot中会有非常多的xxxConfigurer帮助我们进行扩展配置</p><p>​    3）、在SpringBoot中会有很多的xxxCustomizer帮助我们进行定制配置</p><h2 id="6、RestfulCRUD"><a href="#6、RestfulCRUD" class="headerlink" title="6、RestfulCRUD"></a>6、RestfulCRUD</h2><h3 id="1）、默认访问首页"><a href="#1）、默认访问首页" class="headerlink" title="1）、默认访问首页"></a>1）、默认访问首页</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用WebMvcConfigurerAdapter可以来扩展SpringMVC的功能</span></span><br><span class="line"><span class="comment">//@EnableWebMvc   不要接管SpringMVC</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMvcConfig</span> <span class="keyword">extends</span> <span class="title">WebMvcConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addViewControllers</span><span class="params">(ViewControllerRegistry registry)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// super.addViewControllers(registry);</span></span><br><span class="line">        <span class="comment">//浏览器发送 /atguigu 请求来到 success</span></span><br><span class="line">        registry.addViewController(<span class="string">"/atguigu"</span>).setViewName(<span class="string">"success"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//所有的WebMvcConfigurerAdapter组件都会一起起作用</span></span><br><span class="line">    <span class="meta">@Bean</span> <span class="comment">//将组件注册在容器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> WebMvcConfigurerAdapter <span class="title">webMvcConfigurerAdapter</span><span class="params">()</span></span>&#123;</span><br><span class="line">        WebMvcConfigurerAdapter adapter = <span class="keyword">new</span> WebMvcConfigurerAdapter() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addViewControllers</span><span class="params">(ViewControllerRegistry registry)</span> </span>&#123;</span><br><span class="line">                registry.addViewController(<span class="string">"/"</span>).setViewName(<span class="string">"login"</span>);</span><br><span class="line">                registry.addViewController(<span class="string">"/index.html"</span>).setViewName(<span class="string">"login"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> adapter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2）、国际化"><a href="#2）、国际化" class="headerlink" title="2）、国际化"></a>2）、国际化</h3><p><strong>1）、编写国际化配置文件；</strong></p><p>2）、使用ResourceBundleMessageSource管理国际化资源文件</p><p>3）、在页面使用fmt:message取出国际化内容</p><p>步骤：</p><p>1）、编写国际化配置文件，抽取页面需要显示的国际化消息</p><p>![](F:/尚硅谷/springboot核心篇+整合篇-尚硅谷/01尚硅谷SpringBoot核心技术篇/Spring Boot 笔记+课件/images/搜狗截图20180211130721.png)</p><p>2）、SpringBoot自动配置好了管理国际化资源文件的组件；</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"spring.messages"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageSourceAutoConfiguration</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Comma-separated list of basenames (essentially a fully-qualified classpath</span></span><br><span class="line"><span class="comment"> * location), each following the ResourceBundle convention with relaxed support for</span></span><br><span class="line"><span class="comment"> * slash based locations. If it doesn't contain a package qualifier (such as</span></span><br><span class="line"><span class="comment"> * "org.mypackage"), it will be resolved from the classpath root.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> String basename = <span class="string">"messages"</span>;  </span><br><span class="line">    <span class="comment">//我们的配置文件可以直接放在类路径下叫messages.properties；</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> MessageSource <span class="title">messageSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">ResourceBundleMessageSource messageSource = <span class="keyword">new</span> ResourceBundleMessageSource();</span><br><span class="line"><span class="keyword">if</span> (StringUtils.hasText(<span class="keyword">this</span>.basename)) &#123;</span><br><span class="line">            <span class="comment">//设置国际化资源文件的基础名（去掉语言国家代码的）</span></span><br><span class="line">messageSource.setBasenames(StringUtils.commaDelimitedListToStringArray(</span><br><span class="line">StringUtils.trimAllWhitespace(<span class="keyword">this</span>.basename)));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.encoding != <span class="keyword">null</span>) &#123;</span><br><span class="line">messageSource.setDefaultEncoding(<span class="keyword">this</span>.encoding.name());</span><br><span class="line">&#125;</span><br><span class="line">messageSource.setFallbackToSystemLocale(<span class="keyword">this</span>.fallbackToSystemLocale);</span><br><span class="line">messageSource.setCacheSeconds(<span class="keyword">this</span>.cacheSeconds);</span><br><span class="line">messageSource.setAlwaysUseMessageFormat(<span class="keyword">this</span>.alwaysUseMessageFormat);</span><br><span class="line"><span class="keyword">return</span> messageSource;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3）、去页面获取国际化的值；</p><p>![](F:/尚硅谷/springboot核心篇+整合篇-尚硅谷/01尚硅谷SpringBoot核心技术篇/Spring Boot 笔记+课件/images/搜狗截图20180211134506.png)</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>  <span class="attr">xmlns:th</span>=<span class="string">"http://www.thymeleaf.org"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Type"</span> <span class="attr">content</span>=<span class="string">"text/html; charset=UTF-8"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1, shrink-to-fit=no"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"description"</span> <span class="attr">content</span>=<span class="string">""</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"author"</span> <span class="attr">content</span>=<span class="string">""</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>Signin Template for Bootstrap<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Bootstrap core CSS --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"asserts/css/bootstrap.min.css"</span> <span class="attr">th:href</span>=<span class="string">"@&#123;/webjars/bootstrap/4.0.0/css/bootstrap.css&#125;"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Custom styles for this template --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"asserts/css/signin.css"</span> <span class="attr">th:href</span>=<span class="string">"@&#123;/asserts/css/signin.css&#125;"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">class</span>=<span class="string">"text-center"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">class</span>=<span class="string">"form-signin"</span> <span class="attr">action</span>=<span class="string">"dashboard.html"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">"mb-4"</span> <span class="attr">th:src</span>=<span class="string">"@&#123;/asserts/img/bootstrap-solid.svg&#125;"</span> <span class="attr">src</span>=<span class="string">"asserts/img/bootstrap-solid.svg"</span> <span class="attr">alt</span>=<span class="string">""</span> <span class="attr">width</span>=<span class="string">"72"</span> <span class="attr">height</span>=<span class="string">"72"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">"h3 mb-3 font-weight-normal"</span> <span class="attr">th:text</span>=<span class="string">"#&#123;login.tip&#125;"</span>&gt;</span>Please sign in<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">class</span>=<span class="string">"sr-only"</span> <span class="attr">th:text</span>=<span class="string">"#&#123;login.username&#125;"</span>&gt;</span>Username<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">class</span>=<span class="string">"form-control"</span> <span class="attr">placeholder</span>=<span class="string">"Username"</span> <span class="attr">th:placeholder</span>=<span class="string">"#&#123;login.username&#125;"</span> <span class="attr">required</span>=<span class="string">""</span> <span class="attr">autofocus</span>=<span class="string">""</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">class</span>=<span class="string">"sr-only"</span> <span class="attr">th:text</span>=<span class="string">"#&#123;login.password&#125;"</span>&gt;</span>Password<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span> <span class="attr">class</span>=<span class="string">"form-control"</span> <span class="attr">placeholder</span>=<span class="string">"Password"</span> <span class="attr">th:placeholder</span>=<span class="string">"#&#123;login.password&#125;"</span> <span class="attr">required</span>=<span class="string">""</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"checkbox mb-3"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">label</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">value</span>=<span class="string">"remember-me"</span>/&gt;</span> [[#&#123;login.remember&#125;]]</span><br><span class="line">        <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">"btn btn-lg btn-primary btn-block"</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">th:text</span>=<span class="string">"#&#123;login.btn&#125;"</span>&gt;</span>Sign in<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"mt-5 mb-3 text-muted"</span>&gt;</span>© 2017-2018<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"btn btn-sm"</span>&gt;</span>中文<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"btn btn-sm"</span>&gt;</span>English<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>效果：根据浏览器语言设置的信息切换了国际化；</p><p>原理：</p><p>​    国际化Locale（区域信息对象）；LocaleResolver（获取区域信息对象）；</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty</span>(prefix = <span class="string">"spring.mvc"</span>, name = <span class="string">"locale"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> LocaleResolver <span class="title">localeResolver</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.mvcProperties</span><br><span class="line">.getLocaleResolver() == WebMvcProperties.LocaleResolver.FIXED) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> FixedLocaleResolver(<span class="keyword">this</span>.mvcProperties.getLocale());</span><br><span class="line">&#125;</span><br><span class="line">AcceptHeaderLocaleResolver localeResolver = <span class="keyword">new</span> AcceptHeaderLocaleResolver();</span><br><span class="line">localeResolver.setDefaultLocale(<span class="keyword">this</span>.mvcProperties.getLocale());</span><br><span class="line"><span class="keyword">return</span> localeResolver;</span><br><span class="line">&#125;</span><br><span class="line">默认的就是根据请求头带来的区域信息获取Locale进行国际化</span><br></pre></td></tr></table></figure><p>4）、点击链接切换国际化</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 可以在连接上携带区域信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyLocaleResolver</span> <span class="keyword">implements</span> <span class="title">LocaleResolver</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Locale <span class="title">resolveLocale</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">        String l = request.getParameter(<span class="string">"l"</span>);</span><br><span class="line">        Locale locale = Locale.getDefault();</span><br><span class="line">        <span class="keyword">if</span>(!StringUtils.isEmpty(l))&#123;</span><br><span class="line">            String[] split = l.split(<span class="string">"_"</span>);</span><br><span class="line">            locale = <span class="keyword">new</span> Locale(split[<span class="number">0</span>],split[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> locale;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLocale</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Locale locale)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LocaleResolver <span class="title">localeResolver</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyLocaleResolver();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3）、登陆"><a href="#3）、登陆" class="headerlink" title="3）、登陆"></a>3）、登陆</h3><p>开发期间模板引擎页面修改以后，要实时生效</p><p>1）、禁用模板引擎的缓存</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 禁用缓存</span><br><span class="line">spring.thymeleaf.cache&#x3D;false</span><br></pre></td></tr></table></figure><p>2）、页面修改完成以后ctrl+f9：重新编译；</p><p>登陆错误消息的显示</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">"color: red"</span> <span class="attr">th:text</span>=<span class="string">"$&#123;msg&#125;"</span> <span class="attr">th:if</span>=<span class="string">"$&#123;not #strings.isEmpty(msg)&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="4）、拦截器进行登陆检查"><a href="#4）、拦截器进行登陆检查" class="headerlink" title="4）、拦截器进行登陆检查"></a>4）、拦截器进行登陆检查</h3><p>拦截器</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 登陆检查，</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginHandlerInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="comment">//目标方法执行之前</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Object user = request.getSession().getAttribute(<span class="string">"loginUser"</span>);</span><br><span class="line">        <span class="keyword">if</span>(user == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//未登陆，返回登陆页面</span></span><br><span class="line">            request.setAttribute(<span class="string">"msg"</span>,<span class="string">"没有权限请先登陆"</span>);</span><br><span class="line">            request.getRequestDispatcher(<span class="string">"/index.html"</span>).forward(request,response);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//已登陆，放行请求</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注册拦截器</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//所有的WebMvcConfigurerAdapter组件都会一起起作用</span></span><br><span class="line">  <span class="meta">@Bean</span> <span class="comment">//将组件注册在容器</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> WebMvcConfigurerAdapter <span class="title">webMvcConfigurerAdapter</span><span class="params">()</span></span>&#123;</span><br><span class="line">      WebMvcConfigurerAdapter adapter = <span class="keyword">new</span> WebMvcConfigurerAdapter() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addViewControllers</span><span class="params">(ViewControllerRegistry registry)</span> </span>&#123;</span><br><span class="line">              registry.addViewController(<span class="string">"/"</span>).setViewName(<span class="string">"login"</span>);</span><br><span class="line">              registry.addViewController(<span class="string">"/index.html"</span>).setViewName(<span class="string">"login"</span>);</span><br><span class="line">              registry.addViewController(<span class="string">"/main.html"</span>).setViewName(<span class="string">"dashboard"</span>);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">//注册拦截器</span></span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line">              <span class="comment">//super.addInterceptors(registry);</span></span><br><span class="line">              <span class="comment">//静态资源；  *.css , *.js</span></span><br><span class="line">              <span class="comment">//SpringBoot已经做好了静态资源映射</span></span><br><span class="line">              registry.addInterceptor(<span class="keyword">new</span> LoginHandlerInterceptor()).addPathPatterns(<span class="string">"/**"</span>)</span><br><span class="line">                      .excludePathPatterns(<span class="string">"/index.html"</span>,<span class="string">"/"</span>,<span class="string">"/user/login"</span>);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="keyword">return</span> adapter;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="5）、CRUD-员工列表"><a href="#5）、CRUD-员工列表" class="headerlink" title="5）、CRUD-员工列表"></a>5）、CRUD-员工列表</h3><p>实验要求：</p><p>1）、RestfulCRUD：CRUD满足Rest风格；</p><p>URI：  /资源名称/资源标识       HTTP请求方式区分对资源CRUD操作</p><table><thead><tr><th></th><th>普通CRUD（uri来区分操作）</th><th>RestfulCRUD</th></tr></thead><tbody><tr><td>查询</td><td>getEmp</td><td>emp—GET</td></tr><tr><td>添加</td><td>addEmp?xxx</td><td>emp—POST</td></tr><tr><td>修改</td><td>updateEmp?id=xxx&amp;xxx=xx</td><td>emp/{id}—PUT</td></tr><tr><td>删除</td><td>deleteEmp?id=1</td><td>emp/{id}—DELETE</td></tr></tbody></table><p>2）、实验的请求架构;</p><table><thead><tr><th>实验功能</th><th>请求URI</th><th>请求方式</th></tr></thead><tbody><tr><td>查询所有员工</td><td>emps</td><td>GET</td></tr><tr><td>查询某个员工(来到修改页面)</td><td>emp/1</td><td>GET</td></tr><tr><td>来到添加页面</td><td>emp</td><td>GET</td></tr><tr><td>添加员工</td><td>emp</td><td>POST</td></tr><tr><td>来到修改页面（查出员工进行信息回显）</td><td>emp/1</td><td>GET</td></tr><tr><td>修改员工</td><td>emp</td><td>PUT</td></tr><tr><td>删除员工</td><td>emp/1</td><td>DELETE</td></tr></tbody></table><p>3）、员工列表：</p><h4 id="thymeleaf公共页面元素抽取"><a href="#thymeleaf公共页面元素抽取" class="headerlink" title="thymeleaf公共页面元素抽取"></a>thymeleaf公共页面元素抽取</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">1、抽取公共片段</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">th:fragment</span>=<span class="string">"copy"</span>&gt;</span></span><br><span class="line"><span class="symbol">&amp;copy;</span> 2011 The Good Thymes Virtual Grocery</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">2、引入公共片段</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">th:insert</span>=<span class="string">"~&#123;footer :: copy&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">~&#123;templatename::selector&#125;：模板名::选择器</span><br><span class="line">~&#123;templatename::fragmentname&#125;:模板名::片段名</span><br><span class="line"></span><br><span class="line">3、默认效果：</span><br><span class="line">insert的公共片段在div标签中</span><br><span class="line">如果使用th:insert等属性进行引入，可以不用写~&#123;&#125;：</span><br><span class="line">行内写法可以加上：[[~&#123;&#125;]];[(~&#123;&#125;)]；</span><br></pre></td></tr></table></figure><p>三种引入公共片段的th属性：</p><p><strong>th:insert</strong>：将公共片段整个插入到声明引入的元素中</p><p><strong>th:replace</strong>：将声明引入的元素替换为公共片段</p><p><strong>th:include</strong>：将被引入的片段的内容包含进这个标签中</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">footer</span> <span class="attr">th:fragment</span>=<span class="string">"copy"</span>&gt;</span></span><br><span class="line"><span class="symbol">&amp;copy;</span> 2011 The Good Thymes Virtual Grocery</span><br><span class="line"><span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line"></span><br><span class="line">引入方式</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">th:insert</span>=<span class="string">"footer :: copy"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">th:replace</span>=<span class="string">"footer :: copy"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">th:include</span>=<span class="string">"footer :: copy"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">效果</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">footer</span>&gt;</span></span><br><span class="line">    <span class="symbol">&amp;copy;</span> 2011 The Good Thymes Virtual Grocery</span><br><span class="line">    <span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">footer</span>&gt;</span></span><br><span class="line"><span class="symbol">&amp;copy;</span> 2011 The Good Thymes Virtual Grocery</span><br><span class="line"><span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="symbol">&amp;copy;</span> 2011 The Good Thymes Virtual Grocery</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>引入片段的时候传入参数： </p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">nav</span> <span class="attr">class</span>=<span class="string">"col-md-2 d-none d-md-block bg-light sidebar"</span> <span class="attr">id</span>=<span class="string">"sidebar"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"sidebar-sticky"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"nav flex-column"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"nav-item"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"nav-link active"</span></span></span><br><span class="line"><span class="tag">                   <span class="attr">th:class</span>=<span class="string">"$&#123;activeUri=='main.html'?'nav-link active':'nav-link'&#125;"</span></span></span><br><span class="line"><span class="tag">                   <span class="attr">href</span>=<span class="string">"#"</span> <span class="attr">th:href</span>=<span class="string">"@&#123;/main.html&#125;"</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">svg</span> <span class="attr">xmlns</span>=<span class="string">"http://www.w3.org/2000/svg"</span> <span class="attr">width</span>=<span class="string">"24"</span> <span class="attr">height</span>=<span class="string">"24"</span> <span class="attr">viewBox</span>=<span class="string">"0 0 24 24"</span> <span class="attr">fill</span>=<span class="string">"none"</span> <span class="attr">stroke</span>=<span class="string">"currentColor"</span> <span class="attr">stroke-width</span>=<span class="string">"2"</span> <span class="attr">stroke-linecap</span>=<span class="string">"round"</span> <span class="attr">stroke-linejoin</span>=<span class="string">"round"</span> <span class="attr">class</span>=<span class="string">"feather feather-home"</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">path</span> <span class="attr">d</span>=<span class="string">"M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"</span>&gt;</span><span class="tag">&lt;/<span class="name">path</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">polyline</span> <span class="attr">points</span>=<span class="string">"9 22 9 12 15 12 15 22"</span>&gt;</span><span class="tag">&lt;/<span class="name">polyline</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br><span class="line">                    Dashboard <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"sr-only"</span>&gt;</span>(current)<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--引入侧边栏;传入参数--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">th:replace</span>=<span class="string">"commons/bar::#sidebar(activeUri='emps')"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="6）、CRUD-员工添加"><a href="#6）、CRUD-员工添加" class="headerlink" title="6）、CRUD-员工添加"></a>6）、CRUD-员工添加</h3><p>添加页面</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"form-group"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span>&gt;</span>LastName<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">class</span>=<span class="string">"form-control"</span> <span class="attr">placeholder</span>=<span class="string">"zhangsan"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"form-group"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span>&gt;</span>Email<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"email"</span> <span class="attr">class</span>=<span class="string">"form-control"</span> <span class="attr">placeholder</span>=<span class="string">"zhangsan@atguigu.com"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"form-group"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span>&gt;</span>Gender<span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"form-check form-check-inline"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">class</span>=<span class="string">"form-check-input"</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"gender"</span>  <span class="attr">value</span>=<span class="string">"1"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">label</span> <span class="attr">class</span>=<span class="string">"form-check-label"</span>&gt;</span>男<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"form-check form-check-inline"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">class</span>=<span class="string">"form-check-input"</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"gender"</span>  <span class="attr">value</span>=<span class="string">"0"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">label</span> <span class="attr">class</span>=<span class="string">"form-check-label"</span>&gt;</span>女<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"form-group"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span>&gt;</span>department<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">select</span> <span class="attr">class</span>=<span class="string">"form-control"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span>&gt;</span>1<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span>&gt;</span>2<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span>&gt;</span>3<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span>&gt;</span>4<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span>&gt;</span>5<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"form-group"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span>&gt;</span>Birth<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">class</span>=<span class="string">"form-control"</span> <span class="attr">placeholder</span>=<span class="string">"zhangsan"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">class</span>=<span class="string">"btn btn-primary"</span>&gt;</span>添加<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>提交的数据格式不对：生日：日期；</p><p>2017-12-12；2017/12/12；2017.12.12；</p><p>日期的格式化；SpringMVC将页面提交的值需要转换为指定的类型;</p><p>2017-12-12—Date； 类型转换，格式化;</p><p>默认日期是按照/的方式；</p><h3 id="7）、CRUD-员工修改"><a href="#7）、CRUD-员工修改" class="headerlink" title="7）、CRUD-员工修改"></a>7）、CRUD-员工修改</h3><p>修改添加二合一表单</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--需要区分是员工修改还是添加；--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">th:action</span>=<span class="string">"@&#123;/emp&#125;"</span> <span class="attr">method</span>=<span class="string">"post"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--发送put请求修改员工数据--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">1、SpringMVC中配置HiddenHttpMethodFilter;（SpringBoot自动配置好的）</span></span><br><span class="line"><span class="comment">2、页面创建一个post表单</span></span><br><span class="line"><span class="comment">3、创建一个input项，name="_method";值就是我们指定的请求方式</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">name</span>=<span class="string">"_method"</span> <span class="attr">value</span>=<span class="string">"put"</span> <span class="attr">th:if</span>=<span class="string">"$&#123;emp!=null&#125;"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">name</span>=<span class="string">"id"</span> <span class="attr">th:if</span>=<span class="string">"$&#123;emp!=null&#125;"</span> <span class="attr">th:value</span>=<span class="string">"$&#123;emp.id&#125;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"form-group"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span>&gt;</span>LastName<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">"lastName"</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">class</span>=<span class="string">"form-control"</span> <span class="attr">placeholder</span>=<span class="string">"zhangsan"</span> <span class="attr">th:value</span>=<span class="string">"$&#123;emp!=null&#125;?$&#123;emp.lastName&#125;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"form-group"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span>&gt;</span>Email<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">"email"</span> <span class="attr">type</span>=<span class="string">"email"</span> <span class="attr">class</span>=<span class="string">"form-control"</span> <span class="attr">placeholder</span>=<span class="string">"zhangsan@atguigu.com"</span> <span class="attr">th:value</span>=<span class="string">"$&#123;emp!=null&#125;?$&#123;emp.email&#125;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"form-group"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span>&gt;</span>Gender<span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"form-check form-check-inline"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">class</span>=<span class="string">"form-check-input"</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"gender"</span> <span class="attr">value</span>=<span class="string">"1"</span> <span class="attr">th:checked</span>=<span class="string">"$&#123;emp!=null&#125;?$&#123;emp.gender==1&#125;"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">label</span> <span class="attr">class</span>=<span class="string">"form-check-label"</span>&gt;</span>男<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"form-check form-check-inline"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">class</span>=<span class="string">"form-check-input"</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"gender"</span> <span class="attr">value</span>=<span class="string">"0"</span> <span class="attr">th:checked</span>=<span class="string">"$&#123;emp!=null&#125;?$&#123;emp.gender==0&#125;"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">label</span> <span class="attr">class</span>=<span class="string">"form-check-label"</span>&gt;</span>女<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"form-group"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span>&gt;</span>department<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--提交的是部门的id--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">select</span> <span class="attr">class</span>=<span class="string">"form-control"</span> <span class="attr">name</span>=<span class="string">"department.id"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span> <span class="attr">th:selected</span>=<span class="string">"$&#123;emp!=null&#125;?$&#123;dept.id == emp.department.id&#125;"</span> <span class="attr">th:value</span>=<span class="string">"$&#123;dept.id&#125;"</span> <span class="attr">th:each</span>=<span class="string">"dept:$&#123;depts&#125;"</span> <span class="attr">th:text</span>=<span class="string">"$&#123;dept.departmentName&#125;"</span>&gt;</span>1<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"form-group"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span>&gt;</span>Birth<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">"birth"</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">class</span>=<span class="string">"form-control"</span> <span class="attr">placeholder</span>=<span class="string">"zhangsan"</span> <span class="attr">th:value</span>=<span class="string">"$&#123;emp!=null&#125;?$&#123;#dates.format(emp.birth, 'yyyy-MM-dd HH:mm')&#125;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">class</span>=<span class="string">"btn btn-primary"</span> <span class="attr">th:text</span>=<span class="string">"$&#123;emp!=null&#125;?'修改':'添加'"</span>&gt;</span>添加<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="8）、CRUD-员工删除"><a href="#8）、CRUD-员工删除" class="headerlink" title="8）、CRUD-员工删除"></a>8）、CRUD-员工删除</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tr</span> <span class="attr">th:each</span>=<span class="string">"emp:$&#123;emps&#125;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">"$&#123;emp.id&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>[[$&#123;emp.lastName&#125;]]<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">"$&#123;emp.email&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">"$&#123;emp.gender&#125;==0?'女':'男'"</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">"$&#123;emp.department.departmentName&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">"$&#123;#dates.format(emp.birth, 'yyyy-MM-dd HH:mm')&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"btn btn-sm btn-primary"</span> <span class="attr">th:href</span>=<span class="string">"@&#123;/emp/&#125;+$&#123;emp.id&#125;"</span>&gt;</span>编辑<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">th:attr</span>=<span class="string">"del_uri=@&#123;/emp/&#125;+$&#123;emp.id&#125;"</span> <span class="attr">class</span>=<span class="string">"btn btn-sm btn-danger deleteBtn"</span>&gt;</span>删除<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    $(<span class="string">".deleteBtn"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="actionscript">        <span class="comment">//删除当前员工的</span></span></span><br><span class="line"><span class="javascript">        $(<span class="string">"#deleteEmpForm"</span>).attr(<span class="string">"action"</span>,$(<span class="keyword">this</span>).attr(<span class="string">"del_uri"</span>)).submit();</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">return</span> <span class="literal">false</span>;</span></span><br><span class="line">    &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="7、错误处理机制"><a href="#7、错误处理机制" class="headerlink" title="7、错误处理机制"></a>7、错误处理机制</h2><h3 id="1）、SpringBoot默认的错误处理机制"><a href="#1）、SpringBoot默认的错误处理机制" class="headerlink" title="1）、SpringBoot默认的错误处理机制"></a>1）、SpringBoot默认的错误处理机制</h3><p>默认效果：</p><p>​        1）、浏览器，返回一个默认的错误页面</p><p>![](F:/尚硅谷/springboot核心篇+整合篇-尚硅谷/01尚硅谷SpringBoot核心技术篇/Spring Boot 笔记+课件/images/搜狗截图20180226173408.png)</p><p>  浏览器发送请求的请求头：  请求头的accept不同</p><p>![](F:/尚硅谷/springboot核心篇+整合篇-尚硅谷/01尚硅谷SpringBoot核心技术篇/Spring Boot 笔记+课件/images/搜狗截图20180226180347.png)</p><p>​        2）、如果是其他客户端，默认响应一个json数据</p><p>![](F:/尚硅谷/springboot核心篇+整合篇-尚硅谷/01尚硅谷SpringBoot核心技术篇/Spring Boot 笔记+课件/images/搜狗截图20180226173527.png)</p><p>​        ![](F:/尚硅谷/springboot核心篇+整合篇-尚硅谷/01尚硅谷SpringBoot核心技术篇/Spring Boot 笔记+课件/images/搜狗截图20180226180504.png)</p><p>原理：</p><p>​    可以参照ErrorMvcAutoConfiguration；错误处理的自动配置；</p><pre><code>给容器中添加了以下组件</code></pre><p>​    1、DefaultErrorAttributes：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">帮我们在页面共享信息；</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">getErrorAttributes</span><span class="params">(RequestAttributes requestAttributes,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">boolean</span> includeStackTrace)</span> </span>&#123;</span><br><span class="line">Map&lt;String, Object&gt; errorAttributes = <span class="keyword">new</span> LinkedHashMap&lt;String, Object&gt;();</span><br><span class="line">errorAttributes.put(<span class="string">"timestamp"</span>, <span class="keyword">new</span> Date());</span><br><span class="line">addStatus(errorAttributes, requestAttributes);</span><br><span class="line">addErrorDetails(errorAttributes, requestAttributes, includeStackTrace);</span><br><span class="line">addPath(errorAttributes, requestAttributes);</span><br><span class="line"><span class="keyword">return</span> errorAttributes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    2、BasicErrorController：处理默认/error请求</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"$&#123;server.error.path:$&#123;error.path:/error&#125;&#125;"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BasicErrorController</span> <span class="keyword">extends</span> <span class="title">AbstractErrorController</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@RequestMapping</span>(produces = <span class="string">"text/html"</span>)<span class="comment">//产生html类型的数据；浏览器发送的请求来到这个方法处理</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">errorHtml</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">HttpServletResponse response)</span> </span>&#123;</span><br><span class="line">HttpStatus status = getStatus(request);</span><br><span class="line">Map&lt;String, Object&gt; model = Collections.unmodifiableMap(getErrorAttributes(</span><br><span class="line">request, isIncludeStackTrace(request, MediaType.TEXT_HTML)));</span><br><span class="line">response.setStatus(status.value());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//去哪个页面作为错误页面；modelAndView包含页面地址和页面内容</span></span><br><span class="line">ModelAndView modelAndView = resolveErrorView(request, response, status, model);</span><br><span class="line"><span class="keyword">return</span> (modelAndView == <span class="keyword">null</span> ? <span class="keyword">new</span> ModelAndView(<span class="string">"error"</span>, model) : modelAndView);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping</span></span><br><span class="line"><span class="meta">@ResponseBody</span>    <span class="comment">//产生json数据，其他客户端来到这个方法处理；</span></span><br><span class="line"><span class="keyword">public</span> ResponseEntity&lt;Map&lt;String, Object&gt;&gt; error(HttpServletRequest request) &#123;</span><br><span class="line">Map&lt;String, Object&gt; body = getErrorAttributes(request,</span><br><span class="line">isIncludeStackTrace(request, MediaType.ALL));</span><br><span class="line">HttpStatus status = getStatus(request);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ResponseEntity&lt;Map&lt;String, Object&gt;&gt;(body, status);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    3、ErrorPageCustomizer：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Value</span>(<span class="string">"$&#123;error.path:/error&#125;"</span>)</span><br><span class="line"><span class="keyword">private</span> String path = <span class="string">"/error"</span>;  系统出现错误以后来到error请求进行处理；（web.xml注册的错误页面规则）</span><br></pre></td></tr></table></figure><p>​    4、DefaultErrorViewResolver：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">resolveErrorView</span><span class="params">(HttpServletRequest request, HttpStatus status,</span></span></span><br><span class="line"><span class="function"><span class="params">Map&lt;String, Object&gt; model)</span> </span>&#123;</span><br><span class="line">ModelAndView modelAndView = resolve(String.valueOf(status), model);</span><br><span class="line"><span class="keyword">if</span> (modelAndView == <span class="keyword">null</span> &amp;&amp; SERIES_VIEWS.containsKey(status.series())) &#123;</span><br><span class="line">modelAndView = resolve(SERIES_VIEWS.get(status.series()), model);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> modelAndView;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> ModelAndView <span class="title">resolve</span><span class="params">(String viewName, Map&lt;String, Object&gt; model)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//默认SpringBoot可以去找到一个页面？  error/404</span></span><br><span class="line">String errorViewName = <span class="string">"error/"</span> + viewName;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//模板引擎可以解析这个页面地址就用模板引擎解析</span></span><br><span class="line">TemplateAvailabilityProvider provider = <span class="keyword">this</span>.templateAvailabilityProviders</span><br><span class="line">.getProvider(errorViewName, <span class="keyword">this</span>.applicationContext);</span><br><span class="line"><span class="keyword">if</span> (provider != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//模板引擎可用的情况下返回到errorViewName指定的视图地址</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ModelAndView(errorViewName, model);</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">//模板引擎不可用，就在静态资源文件夹下找errorViewName对应的页面   error/404.html</span></span><br><span class="line"><span class="keyword">return</span> resolveResource(errorViewName, model);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    步骤：</p><p>​        一但系统出现4xx或者5xx之类的错误；ErrorPageCustomizer就会生效（定制错误的响应规则）；就会来到/error请求；就会被<strong>BasicErrorController</strong>处理；</p><p>​        1）响应页面；去哪个页面是由<strong>DefaultErrorViewResolver</strong>解析得到的；</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ModelAndView <span class="title">resolveErrorView</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">      HttpServletResponse response, HttpStatus status, Map&lt;String, Object&gt; model)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//所有的ErrorViewResolver得到ModelAndView</span></span><br><span class="line">   <span class="keyword">for</span> (ErrorViewResolver resolver : <span class="keyword">this</span>.errorViewResolvers) &#123;</span><br><span class="line">      ModelAndView modelAndView = resolver.resolveErrorView(request, status, model);</span><br><span class="line">      <span class="keyword">if</span> (modelAndView != <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> modelAndView;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2）、如果定制错误响应："><a href="#2）、如果定制错误响应：" class="headerlink" title="2）、如果定制错误响应："></a>2）、如果定制错误响应：</h3><h4 id="1）、如何定制错误的页面；"><a href="#1）、如何定制错误的页面；" class="headerlink" title="1）、如何定制错误的页面；"></a><strong>1）、如何定制错误的页面；</strong></h4><p>​            <strong>1）、有模板引擎的情况下；error/状态码;</strong> 【将错误页面命名为  错误状态码.html 放在模板引擎文件夹里面的 error文件夹下】，发生此状态码的错误就会来到  对应的页面；</p><p>​            我们可以使用4xx和5xx作为错误页面的文件名来匹配这种类型的所有错误，精确优先（优先寻找精确的状态码.html）；        </p><p>​            页面能获取的信息；</p><p>​                timestamp：时间戳</p><p>​                status：状态码</p><p>​                error：错误提示</p><p>​                exception：异常对象</p><p>​                message：异常消息</p><p>​                errors：JSR303数据校验的错误都在这里</p><p>​            2）、没有模板引擎（模板引擎找不到这个错误页面），静态资源文件夹下找；</p><p>​            3）、以上都没有错误页面，就是默认来到SpringBoot默认的错误提示页面；</p><h4 id="2）、如何定制错误的json数据；"><a href="#2）、如何定制错误的json数据；" class="headerlink" title="2）、如何定制错误的json数据；"></a>2）、如何定制错误的json数据；</h4><p>​        1）、自定义异常处理&amp;返回定制json数据；</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyExceptionHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(UserNotExistException<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">Map</span>&lt;<span class="title">String</span>,<span class="title">Object</span>&gt; <span class="title">handleException</span>(<span class="title">Exception</span> <span class="title">e</span>)</span>&#123;</span><br><span class="line">        Map&lt;String,Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">"code"</span>,<span class="string">"user.notexist"</span>);</span><br><span class="line">        map.put(<span class="string">"message"</span>,e.getMessage());</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//没有自适应效果...</span></span><br></pre></td></tr></table></figure><p>​        2）、转发到/error进行自适应响应效果处理</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ExceptionHandler</span>(UserNotExistException<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">   <span class="title">public</span> <span class="title">String</span> <span class="title">handleException</span>(<span class="title">Exception</span> <span class="title">e</span>, <span class="title">HttpServletRequest</span> <span class="title">request</span>)</span>&#123;</span><br><span class="line">       Map&lt;String,Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">       <span class="comment">//传入我们自己的错误状态码  4xx 5xx，否则就不会进入定制错误页面的解析流程</span></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Integer statusCode = (Integer) request</span></span><br><span class="line"><span class="comment">        .getAttribute("javax.servlet.error.status_code");</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       request.setAttribute(<span class="string">"javax.servlet.error.status_code"</span>,<span class="number">500</span>);</span><br><span class="line">       map.put(<span class="string">"code"</span>,<span class="string">"user.notexist"</span>);</span><br><span class="line">       map.put(<span class="string">"message"</span>,e.getMessage());</span><br><span class="line">       <span class="comment">//转发到/error</span></span><br><span class="line">       <span class="keyword">return</span> <span class="string">"forward:/error"</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="3）、将我们的定制数据携带出去；"><a href="#3）、将我们的定制数据携带出去；" class="headerlink" title="3）、将我们的定制数据携带出去；"></a>3）、将我们的定制数据携带出去；</h4><p>出现错误以后，会来到/error请求，会被BasicErrorController处理，响应出去可以获取的数据是由getErrorAttributes得到的（是AbstractErrorController（ErrorController）规定的方法）；</p><p>​    1、完全来编写一个ErrorController的实现类【或者是编写AbstractErrorController的子类】，放在容器中；</p><p>​    2、页面上能用的数据，或者是json返回能用的数据都是通过errorAttributes.getErrorAttributes得到；</p><p>​            容器中DefaultErrorAttributes.getErrorAttributes()；默认进行数据处理的；</p><p>自定义ErrorAttributes</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//给容器中加入我们自己定义的ErrorAttributes</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyErrorAttributes</span> <span class="keyword">extends</span> <span class="title">DefaultErrorAttributes</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">getErrorAttributes</span><span class="params">(RequestAttributes requestAttributes, <span class="keyword">boolean</span> includeStackTrace)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; map = <span class="keyword">super</span>.getErrorAttributes(requestAttributes, includeStackTrace);</span><br><span class="line">        map.put(<span class="string">"company"</span>,<span class="string">"atguigu"</span>);</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终的效果：响应是自适应的，可以通过定制ErrorAttributes改变需要返回的内容，</p><p>![](F:/尚硅谷/springboot核心篇+整合篇-尚硅谷/01尚硅谷SpringBoot核心技术篇/Spring Boot 笔记+课件/images/搜狗截图20180228135513.png)</p><h2 id="8、配置嵌入式Servlet容器"><a href="#8、配置嵌入式Servlet容器" class="headerlink" title="8、配置嵌入式Servlet容器"></a>8、配置嵌入式Servlet容器</h2><p>SpringBoot默认使用Tomcat作为嵌入式的Servlet容器；</p><p>![](F:/尚硅谷/springboot核心篇+整合篇-尚硅谷/01尚硅谷SpringBoot核心技术篇/Spring Boot 笔记+课件/images/搜狗截图20180301142915.png)</p><p>问题？</p><h3 id="1）、如何定制和修改Servlet容器的相关配置；"><a href="#1）、如何定制和修改Servlet容器的相关配置；" class="headerlink" title="1）、如何定制和修改Servlet容器的相关配置；"></a>1）、如何定制和修改Servlet容器的相关配置；</h3><p>1、修改和server有关的配置（ServerProperties【也是EmbeddedServletContainerCustomizer】）；1写个容器 或在配置文件修改</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">server.port</span>=<span class="string">8081</span></span><br><span class="line"><span class="meta">server.context-path</span>=<span class="string">/crud</span></span><br><span class="line"></span><br><span class="line"><span class="meta">server.tomcat.uri-encoding</span>=<span class="string">UTF-8</span></span><br><span class="line"></span><br><span class="line"><span class="attr">//通用的Servlet容器设置</span></span><br><span class="line"><span class="attr">server.xxx</span></span><br><span class="line"><span class="attr">//Tomcat的设置</span></span><br><span class="line"><span class="attr">server.tomcat.xxx</span></span><br></pre></td></tr></table></figure><p>2、编写一个<strong>EmbeddedServletContainerCustomizer</strong>：嵌入式的Servlet容器的定制器；来修改Servlet容器的配置</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span>  <span class="comment">//一定要将这个定制器加入到容器中</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> EmbeddedServletContainerCustomizer <span class="title">embeddedServletContainerCustomizer</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> EmbeddedServletContainerCustomizer() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//定制嵌入式的Servlet容器相关的规则</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">customize</span><span class="params">(ConfigurableEmbeddedServletContainer container)</span> </span>&#123;</span><br><span class="line">            container.setPort(<span class="number">8083</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2）、注册Servlet三大组件【Servlet、Filter、Listener】"><a href="#2）、注册Servlet三大组件【Servlet、Filter、Listener】" class="headerlink" title="2）、注册Servlet三大组件【Servlet、Filter、Listener】"></a>2）、注册Servlet三大组件【Servlet、Filter、Listener】</h3><p>由于SpringBoot默认是以jar包的方式启动嵌入式的Servlet容器来启动SpringBoot的web应用，没有web.xml文件。</p><p>注册三大组件用以下方式</p><p>以前是在 webapp/WEB-INF/web.xml配置</p><p>现在写一个配置类</p><p>ServletRegistrationBean</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//注册三大组件</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ServletRegistrationBean <span class="title">myServlet</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ServletRegistrationBean registrationBean = <span class="keyword">new</span> ServletRegistrationBean(<span class="keyword">new</span> MyServlet(),<span class="string">"/myServlet"</span>);</span><br><span class="line">    <span class="keyword">return</span> registrationBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FilterRegistrationBean</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> FilterRegistrationBean <span class="title">myFilter</span><span class="params">()</span></span>&#123;</span><br><span class="line">    FilterRegistrationBean registrationBean = <span class="keyword">new</span> FilterRegistrationBean();</span><br><span class="line">    registrationBean.setFilter(<span class="keyword">new</span> MyFilter());</span><br><span class="line">    registrationBean.setUrlPatterns(Arrays.asList(<span class="string">"/hello"</span>,<span class="string">"/myServlet"</span>));</span><br><span class="line">    <span class="keyword">return</span> registrationBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ServletListenerRegistrationBean</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ServletListenerRegistrationBean <span class="title">myListener</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ServletListenerRegistrationBean&lt;MyListener&gt; registrationBean = <span class="keyword">new</span> ServletListenerRegistrationBean&lt;&gt;(<span class="keyword">new</span> MyListener());</span><br><span class="line">    <span class="keyword">return</span> registrationBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SpringBoot帮我们自动SpringMVC的时候，自动的注册SpringMVC的前端控制器；DIspatcherServlet；</p><p>DispatcherServletAutoConfiguration中：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span>(name = DEFAULT_DISPATCHER_SERVLET_REGISTRATION_BEAN_NAME)</span><br><span class="line"><span class="meta">@ConditionalOnBean</span>(value = DispatcherServlet<span class="class">.<span class="keyword">class</span>, <span class="title">name</span> </span>= DEFAULT_DISPATCHER_SERVLET_BEAN_NAME)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ServletRegistrationBean <span class="title">dispatcherServletRegistration</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      DispatcherServlet dispatcherServlet)</span> </span>&#123;</span><br><span class="line">   ServletRegistrationBean registration = <span class="keyword">new</span> ServletRegistrationBean(</span><br><span class="line">         dispatcherServlet, <span class="keyword">this</span>.serverProperties.getServletMapping());</span><br><span class="line">    <span class="comment">//默认拦截： /  所有请求；包静态资源，但是不拦截jsp请求；   /*会拦截jsp</span></span><br><span class="line">    <span class="comment">//可以通过server.servletPath来修改SpringMVC前端控制器默认拦截的请求路径</span></span><br><span class="line">    </span><br><span class="line">   registration.setName(DEFAULT_DISPATCHER_SERVLET_BEAN_NAME);</span><br><span class="line">   registration.setLoadOnStartup(</span><br><span class="line">         <span class="keyword">this</span>.webMvcProperties.getServlet().getLoadOnStartup());</span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">this</span>.multipartConfig != <span class="keyword">null</span>) &#123;</span><br><span class="line">      registration.setMultipartConfig(<span class="keyword">this</span>.multipartConfig);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> registration;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2）、SpringBoot能不能支持其他的Servlet容器；</p><h3 id="3）、替换为其他嵌入式Servlet容器"><a href="#3）、替换为其他嵌入式Servlet容器" class="headerlink" title="3）、替换为其他嵌入式Servlet容器"></a>3）、替换为其他嵌入式Servlet容器</h3><p>![](F:/尚硅谷/springboot核心篇+整合篇-尚硅谷/01尚硅谷SpringBoot核心技术篇/Spring Boot 笔记+课件/images/搜狗截图20180302114401.png)</p><p>默认支持：</p><p>Tomcat（默认使用）</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   引入web模块默认就是使用嵌入式的Tomcat作为Servlet容器；</span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Jetty</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 引入web模块 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--引入其他的Servlet容器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jetty<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Undertow</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 引入web模块 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--引入其他的Servlet容器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-undertow<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="4）、嵌入式Servlet容器自动配置原理；"><a href="#4）、嵌入式Servlet容器自动配置原理；" class="headerlink" title="4）、嵌入式Servlet容器自动配置原理；"></a>4）、嵌入式Servlet容器自动配置原理；</h3><p>EmbeddedServletContainerAutoConfiguration：嵌入式的Servlet容器自动配置？</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@AutoConfigureOrder</span>(Ordered.HIGHEST_PRECEDENCE)</span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnWebApplication</span></span><br><span class="line"><span class="meta">@Import</span>(BeanPostProcessorsRegistrar<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">//导入<span class="title">BeanPostProcessorsRegistrar</span>：<span class="title">Spring</span>注解版；给容器中导入一些组件</span></span><br><span class="line"><span class="class">//导入了<span class="title">EmbeddedServletContainerCustomizerBeanPostProcessor</span>：</span></span><br><span class="line"><span class="class">//后置处理器：<span class="title">bean</span>初始化前后（创建完对象，还没赋值赋值）执行初始化工作</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">EmbeddedServletContainerAutoConfiguration</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnClass</span>(&#123; Servlet<span class="class">.<span class="keyword">class</span>, <span class="title">Tomcat</span>.<span class="title">class</span> &#125;)//判断当前是否引入了<span class="title">Tomcat</span>依赖；</span></span><br><span class="line"><span class="class">@<span class="title">ConditionalOnMissingBean</span>(<span class="title">value</span> </span>= EmbeddedServletContainerFactory<span class="class">.<span class="keyword">class</span>, <span class="title">search</span> </span>= SearchStrategy.CURRENT)<span class="comment">//判断当前容器没有用户自己定义EmbeddedServletContainerFactory：嵌入式的Servlet容器工厂；作用：创建嵌入式的Servlet容器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">EmbeddedTomcat</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> TomcatEmbeddedServletContainerFactory <span class="title">tomcatEmbeddedServletContainerFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> TomcatEmbeddedServletContainerFactory();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Nested configuration if Jetty is being used.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnClass</span>(&#123; Servlet<span class="class">.<span class="keyword">class</span>, <span class="title">Server</span>.<span class="title">class</span>, <span class="title">Loader</span>.<span class="title">class</span>,</span></span><br><span class="line"><span class="class"><span class="title">WebAppContext</span>.<span class="title">class</span> &#125;)</span></span><br><span class="line"><span class="class">@<span class="title">ConditionalOnMissingBean</span>(<span class="title">value</span> </span>= EmbeddedServletContainerFactory<span class="class">.<span class="keyword">class</span>, <span class="title">search</span> </span>= SearchStrategy.CURRENT)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">EmbeddedJetty</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> JettyEmbeddedServletContainerFactory <span class="title">jettyEmbeddedServletContainerFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> JettyEmbeddedServletContainerFactory();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Nested configuration if Undertow is being used.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnClass</span>(&#123; Servlet<span class="class">.<span class="keyword">class</span>, <span class="title">Undertow</span>.<span class="title">class</span>, <span class="title">SslClientAuthMode</span>.<span class="title">class</span> &#125;)</span></span><br><span class="line"><span class="class">@<span class="title">ConditionalOnMissingBean</span>(<span class="title">value</span> </span>= EmbeddedServletContainerFactory<span class="class">.<span class="keyword">class</span>, <span class="title">search</span> </span>= SearchStrategy.CURRENT)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">EmbeddedUndertow</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> UndertowEmbeddedServletContainerFactory <span class="title">undertowEmbeddedServletContainerFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> UndertowEmbeddedServletContainerFactory();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1）、EmbeddedServletContainerFactory（嵌入式Servlet容器工厂）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">EmbeddedServletContainerFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//获取嵌入式的Servlet容器</span></span><br><span class="line">   <span class="function">EmbeddedServletContainer <span class="title">getEmbeddedServletContainer</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">         ServletContextInitializer... initializers)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>![](F:/尚硅谷/springboot核心篇+整合篇-尚硅谷/01尚硅谷SpringBoot核心技术篇/Spring Boot 笔记+课件/images/搜狗截图20180302144835.png)</p><p>2）、EmbeddedServletContainer：（嵌入式的Servlet容器）</p><p>![](F:/尚硅谷/springboot核心篇+整合篇-尚硅谷/01尚硅谷SpringBoot核心技术篇/Spring Boot 笔记+课件/images/搜狗截图20180302144910.png)</p><p>3）、以<strong>TomcatEmbeddedServletContainerFactory</strong>为例</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> EmbeddedServletContainer <span class="title">getEmbeddedServletContainer</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      ServletContextInitializer... initializers)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建一个Tomcat</span></span><br><span class="line">   Tomcat tomcat = <span class="keyword">new</span> Tomcat();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//配置Tomcat的基本环节</span></span><br><span class="line">   File baseDir = (<span class="keyword">this</span>.baseDirectory != <span class="keyword">null</span> ? <span class="keyword">this</span>.baseDirectory</span><br><span class="line">         : createTempDir(<span class="string">"tomcat"</span>));</span><br><span class="line">   tomcat.setBaseDir(baseDir.getAbsolutePath());</span><br><span class="line">   Connector connector = <span class="keyword">new</span> Connector(<span class="keyword">this</span>.protocol);</span><br><span class="line">   tomcat.getService().addConnector(connector);</span><br><span class="line">   customizeConnector(connector);</span><br><span class="line">   tomcat.setConnector(connector);</span><br><span class="line">   tomcat.getHost().setAutoDeploy(<span class="keyword">false</span>);</span><br><span class="line">   configureEngine(tomcat.getEngine());</span><br><span class="line">   <span class="keyword">for</span> (Connector additionalConnector : <span class="keyword">this</span>.additionalTomcatConnectors) &#123;</span><br><span class="line">      tomcat.getService().addConnector(additionalConnector);</span><br><span class="line">   &#125;</span><br><span class="line">   prepareContext(tomcat.getHost(), initializers);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将配置好的Tomcat传入进去，返回一个EmbeddedServletContainer；并且启动Tomcat服务器</span></span><br><span class="line">   <span class="keyword">return</span> getTomcatEmbeddedServletContainer(tomcat);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4）、我们对嵌入式容器的配置修改是怎么生效？</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ServerProperties、EmbeddedServletContainerCustomizer</span><br></pre></td></tr></table></figure><p><strong>EmbeddedServletContainerCustomizer</strong>：定制器帮我们修改了Servlet容器的配置？</p><p>怎么修改的原理？</p><p>5）、容器中导入了<strong>EmbeddedServletContainerCustomizerBeanPostProcessor</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化之前</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    <span class="comment">//如果当前初始化的是一个ConfigurableEmbeddedServletContainer类型的组件</span></span><br><span class="line">   <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> ConfigurableEmbeddedServletContainer) &#123;</span><br><span class="line">       <span class="comment">//</span></span><br><span class="line">      postProcessBeforeInitialization((ConfigurableEmbeddedServletContainer) bean);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postProcessBeforeInitialization</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">ConfigurableEmbeddedServletContainer bean)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取所有的定制器，调用每一个定制器的customize方法来给Servlet容器进行属性赋值；</span></span><br><span class="line">    <span class="keyword">for</span> (EmbeddedServletContainerCustomizer customizer : getCustomizers()) &#123;</span><br><span class="line">        customizer.customize(bean);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Collection&lt;EmbeddedServletContainerCustomizer&gt; <span class="title">getCustomizers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.customizers == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Look up does not include the parent context</span></span><br><span class="line">        <span class="keyword">this</span>.customizers = <span class="keyword">new</span> ArrayList&lt;EmbeddedServletContainerCustomizer&gt;(</span><br><span class="line">            <span class="keyword">this</span>.beanFactory</span><br><span class="line">            <span class="comment">//从容器中获取所有这葛类型的组件：EmbeddedServletContainerCustomizer</span></span><br><span class="line">            <span class="comment">//定制Servlet容器，给容器中可以添加一个EmbeddedServletContainerCustomizer类型的组件</span></span><br><span class="line">            .getBeansOfType(EmbeddedServletContainerCustomizer<span class="class">.<span class="keyword">class</span>,</span></span><br><span class="line"><span class="class">                            <span class="title">false</span>, <span class="title">false</span>)</span></span><br><span class="line"><span class="class">            .<span class="title">values</span>())</span>;</span><br><span class="line">        Collections.sort(<span class="keyword">this</span>.customizers, AnnotationAwareOrderComparator.INSTANCE);</span><br><span class="line">        <span class="keyword">this</span>.customizers = Collections.unmodifiableList(<span class="keyword">this</span>.customizers);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.customizers;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ServerProperties也是定制器</span><br></pre></td></tr></table></figure><p>步骤：</p><p>1）、SpringBoot根据导入的依赖情况，给容器中添加相应的EmbeddedServletContainerFactory【TomcatEmbeddedServletContainerFactory】</p><p>2）、容器中某个组件要创建对象就会惊动后置处理器；EmbeddedServletContainerCustomizerBeanPostProcessor；</p><p>只要是嵌入式的Servlet容器工厂，后置处理器就工作；</p><p>3）、后置处理器，从容器中获取所有的<strong>EmbeddedServletContainerCustomizer</strong>，调用定制器的定制方法</p><p>###5）、嵌入式Servlet容器启动原理；</p><p>什么时候创建嵌入式的Servlet容器工厂？什么时候获取嵌入式的Servlet容器并启动Tomcat；</p><p>获取嵌入式的Servlet容器工厂：</p><p>1）、SpringBoot应用启动运行run方法</p><p>2）、refreshContext(context);SpringBoot刷新IOC容器【创建IOC容器对象，并初始化容器，创建容器中的每一个组件】；如果是web应用创建<strong>AnnotationConfigEmbeddedWebApplicationContext</strong>，否则：<strong>AnnotationConfigApplicationContext</strong></p><p>3）、refresh(context);<strong>刷新刚才创建好的ioc容器；</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line">   <span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">      <span class="comment">// Prepare this context for refreshing.</span></span><br><span class="line">      prepareRefresh();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Tell the subclass to refresh the internal bean factory.</span></span><br><span class="line">      ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Prepare the bean factory for use in this context.</span></span><br><span class="line">      prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// Allows post-processing of the bean factory in context subclasses.</span></span><br><span class="line">         postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Invoke factory processors registered as beans in the context.</span></span><br><span class="line">         invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Register bean processors that intercept bean creation.</span></span><br><span class="line">         registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Initialize message source for this context.</span></span><br><span class="line">         initMessageSource();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Initialize event multicaster for this context.</span></span><br><span class="line">         initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Initialize other special beans in specific context subclasses.</span></span><br><span class="line">         onRefresh();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Check for listener beans and register them.</span></span><br><span class="line">         registerListeners();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">         finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Last step: publish corresponding event.</span></span><br><span class="line">         finishRefresh();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">         <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">            logger.warn(<span class="string">"Exception encountered during context initialization - "</span> +</span><br><span class="line">                  <span class="string">"cancelling refresh attempt: "</span> + ex);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Destroy already created singletons to avoid dangling resources.</span></span><br><span class="line">         destroyBeans();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Reset 'active' flag.</span></span><br><span class="line">         cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Propagate exception to caller.</span></span><br><span class="line">         <span class="keyword">throw</span> ex;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">finally</span> &#123;</span><br><span class="line">         <span class="comment">// Reset common introspection caches in Spring's core, since we</span></span><br><span class="line">         <span class="comment">// might not ever need metadata for singleton beans anymore...</span></span><br><span class="line">         resetCommonCaches();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4）、  onRefresh(); web的ioc容器重写了onRefresh方法</p><p>5）、webioc容器会创建嵌入式的Servlet容器；<strong>createEmbeddedServletContainer</strong>();</p><p><strong>6）、获取嵌入式的Servlet容器工厂：</strong></p><p>EmbeddedServletContainerFactory containerFactory = getEmbeddedServletContainerFactory();</p><p>​    从ioc容器中获取EmbeddedServletContainerFactory 组件；<strong>TomcatEmbeddedServletContainerFactory</strong>创建对象，后置处理器一看是这个对象，就获取所有的定制器来先定制Servlet容器的相关配置；</p><p>7）、<strong>使用容器工厂获取嵌入式的Servlet容器</strong>：this.embeddedServletContainer = containerFactory      .getEmbeddedServletContainer(getSelfInitializer());</p><p>8）、嵌入式的Servlet容器创建对象并启动Servlet容器；</p><p><strong>先启动嵌入式的Servlet容器，再将ioc容器中剩下没有创建出的对象获取出来；</strong></p><p><strong>==IOC容器启动创建嵌入式的Servlet容器==</strong></p><h2 id="9、使用外置的Servlet容器"><a href="#9、使用外置的Servlet容器" class="headerlink" title="9、使用外置的Servlet容器"></a>9、使用外置的Servlet容器</h2><p>嵌入式Servlet容器：应用打成可执行的jar</p><p>​        优点：简单、便携；</p><p>​        缺点：默认不支持JSP、优化定制比较复杂（使用定制器【ServerProperties、自定义EmbeddedServletContainerCustomizer】，自己编写嵌入式Servlet容器的创建工厂【EmbeddedServletContainerFactory】）；</p><p>外置的Servlet容器：外面安装Tomcat—应用war包的方式打包；</p><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><p>1）、必须创建一个war项目；（利用idea创建好目录结构）</p><p>2）、将嵌入式的Tomcat指定为provided；</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>3）、必须编写一个<strong>SpringBootServletInitializer</strong>的子类，并调用configure方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServletInitializer</span> <span class="keyword">extends</span> <span class="title">SpringBootServletInitializer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> SpringApplicationBuilder <span class="title">configure</span><span class="params">(SpringApplicationBuilder application)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//传入SpringBoot应用的主程序</span></span><br><span class="line">      <span class="keyword">return</span> application.sources(SpringBoot04WebJspApplication<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4）、启动服务器就可以使用；</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>jar包：执行SpringBoot主类的main方法，启动ioc容器，创建嵌入式的Servlet容器；</p><p>war包：启动服务器，<strong>服务器启动SpringBoot应用</strong>【SpringBootServletInitializer】，启动ioc容器；</p><p>servlet3.0（Spring注解版）：</p><p>8.2.4 Shared libraries / runtimes pluggability：</p><p>规则：</p><p>​    1）、服务器启动（web应用启动）会创建当前web应用里面每一个jar包里面ServletContainerInitializer实例：</p><p>​    2）、ServletContainerInitializer的实现放在jar包的META-INF/services文件夹下，有一个名为javax.servlet.ServletContainerInitializer的文件，内容就是ServletContainerInitializer的实现类的全类名</p><p>​    3）、还可以使用@HandlesTypes，在应用启动的时候加载我们感兴趣的类；</p><p>流程：</p><p>1）、启动Tomcat</p><p>2）、org\springframework\spring-web\4.3.14.RELEASE\spring-web-4.3.14.RELEASE.jar!\META-INF\services\javax.servlet.ServletContainerInitializer：</p><p>Spring的web模块里面有这个文件：<strong>org.springframework.web.SpringServletContainerInitializer</strong></p><p>3）、SpringServletContainerInitializer将@HandlesTypes(WebApplicationInitializer.class)标注的所有这个类型的类都传入到onStartup方法的Set&lt;Class&lt;?&gt;&gt;；为这些WebApplicationInitializer类型的类创建实例；</p><p>4）、每一个WebApplicationInitializer都调用自己的onStartup；</p><p>![](F:/尚硅谷/springboot核心篇+整合篇-尚硅谷/01尚硅谷SpringBoot核心技术篇/Spring Boot 笔记+课件/images/搜狗截图20180302221835.png)</p><p>5）、相当于我们的SpringBootServletInitializer的类会被创建对象，并执行onStartup方法</p><p>6）、SpringBootServletInitializer实例执行onStartup的时候会createRootApplicationContext；创建容器</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> WebApplicationContext <span class="title">createRootApplicationContext</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      ServletContext servletContext)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1、创建SpringApplicationBuilder</span></span><br><span class="line">   SpringApplicationBuilder builder = createSpringApplicationBuilder();</span><br><span class="line">   StandardServletEnvironment environment = <span class="keyword">new</span> StandardServletEnvironment();</span><br><span class="line">   environment.initPropertySources(servletContext, <span class="keyword">null</span>);</span><br><span class="line">   builder.environment(environment);</span><br><span class="line">   builder.main(getClass());</span><br><span class="line">   ApplicationContext parent = getExistingRootWebApplicationContext(servletContext);</span><br><span class="line">   <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.logger.info(<span class="string">"Root context already created (using as parent)."</span>);</span><br><span class="line">      servletContext.setAttribute(</span><br><span class="line">            WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, <span class="keyword">null</span>);</span><br><span class="line">      builder.initializers(<span class="keyword">new</span> ParentContextApplicationContextInitializer(parent));</span><br><span class="line">   &#125;</span><br><span class="line">   builder.initializers(</span><br><span class="line">         <span class="keyword">new</span> ServletContextApplicationContextInitializer(servletContext));</span><br><span class="line">   builder.contextClass(AnnotationConfigEmbeddedWebApplicationContext<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//调用configure方法，子类重写了这个方法，将SpringBoot的主程序类传入了进来</span></span><br><span class="line">   builder = configure(builder);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//使用builder创建一个Spring应用</span></span><br><span class="line">   SpringApplication application = builder.build();</span><br><span class="line">   <span class="keyword">if</span> (application.getSources().isEmpty() &amp;&amp; AnnotationUtils</span><br><span class="line">         .findAnnotation(getClass(), Configuration<span class="class">.<span class="keyword">class</span>) !</span>= <span class="keyword">null</span>) &#123;</span><br><span class="line">      application.getSources().add(getClass());</span><br><span class="line">   &#125;</span><br><span class="line">   Assert.state(!application.getSources().isEmpty(),</span><br><span class="line">         <span class="string">"No SpringApplication sources have been defined. Either override the "</span></span><br><span class="line">               + <span class="string">"configure method or add an @Configuration annotation"</span>);</span><br><span class="line">   <span class="comment">// Ensure error pages are registered</span></span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">this</span>.registerErrorPageFilter) &#123;</span><br><span class="line">      application.getSources().add(ErrorPageFilterConfiguration<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="comment">//启动Spring应用</span></span><br><span class="line">   <span class="keyword">return</span> run(application);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>7）、Spring的应用就启动并且创建IOC容器</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ConfigurableApplicationContext <span class="title">run</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">   StopWatch stopWatch = <span class="keyword">new</span> StopWatch();</span><br><span class="line">   stopWatch.start();</span><br><span class="line">   ConfigurableApplicationContext context = <span class="keyword">null</span>;</span><br><span class="line">   FailureAnalyzers analyzers = <span class="keyword">null</span>;</span><br><span class="line">   configureHeadlessProperty();</span><br><span class="line">   SpringApplicationRunListeners listeners = getRunListeners(args);</span><br><span class="line">   listeners.starting();</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      ApplicationArguments applicationArguments = <span class="keyword">new</span> DefaultApplicationArguments(</span><br><span class="line">            args);</span><br><span class="line">      ConfigurableEnvironment environment = prepareEnvironment(listeners,</span><br><span class="line">            applicationArguments);</span><br><span class="line">      Banner printedBanner = printBanner(environment);</span><br><span class="line">      context = createApplicationContext();</span><br><span class="line">      analyzers = <span class="keyword">new</span> FailureAnalyzers(context);</span><br><span class="line">      prepareContext(context, environment, listeners, applicationArguments,</span><br><span class="line">            printedBanner);</span><br><span class="line">       </span><br><span class="line">       <span class="comment">//刷新IOC容器</span></span><br><span class="line">      refreshContext(context);</span><br><span class="line">      afterRefresh(context, applicationArguments);</span><br><span class="line">      listeners.finished(context, <span class="keyword">null</span>);</span><br><span class="line">      stopWatch.stop();</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.logStartupInfo) &#123;</span><br><span class="line">         <span class="keyword">new</span> StartupInfoLogger(<span class="keyword">this</span>.mainApplicationClass)</span><br><span class="line">               .logStarted(getApplicationLog(), stopWatch);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> context;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">      handleRunFailure(context, listeners, analyzers, ex);</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(ex);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>==启动Servlet容器，再启动SpringBoot应用==</strong></p><h1 id="五、Docker"><a href="#五、Docker" class="headerlink" title="五、Docker"></a>五、Docker</h1><h2 id="1、简介-1"><a href="#1、简介-1" class="headerlink" title="1、简介"></a>1、简介</h2><p><strong>Docker</strong>是一个开源的应用容器引擎；是一个轻量级容器技术；</p><p>Docker支持将软件编译成一个镜像；然后在镜像中各种软件做好配置，将镜像发布出去，其他使用者可以直接使用这个镜像；</p><p>运行中的这个镜像称为容器，容器启动是非常快速的。</p><p>![](F:/尚硅谷/springboot核心篇+整合篇-尚硅谷/01尚硅谷SpringBoot核心技术篇/Spring Boot 笔记+课件/images/搜狗截图20180303145450.png)</p><p>![](F:/尚硅谷/springboot核心篇+整合篇-尚硅谷/01尚硅谷SpringBoot核心技术篇/Spring Boot 笔记+课件/images/搜狗截图20180303145531.png)</p><h2 id="2、核心概念"><a href="#2、核心概念" class="headerlink" title="2、核心概念"></a>2、核心概念</h2><p>docker主机(Host)：安装了Docker程序的机器（Docker直接安装在操作系统之上）；</p><p>docker客户端(Client)：连接docker主机进行操作；</p><p>docker仓库(Registry)：用来保存各种打包好的软件镜像；</p><p>docker镜像(Images)：软件打包好的镜像；放在docker仓库中；</p><p>docker容器(Container)：镜像启动后的实例称为一个容器；容器是独立运行的一个或一组应用</p><p>![](F:/尚硅谷/springboot核心篇+整合篇-尚硅谷/01尚硅谷SpringBoot核心技术篇/Spring Boot 笔记+课件/images/搜狗截图20180303165113.png)</p><p>使用Docker的步骤：</p><p>1）、安装Docker</p><p>2）、去Docker仓库找到这个软件对应的镜像；</p><p>3）、使用Docker运行这个镜像，这个镜像就会生成一个Docker容器；</p><p>4）、对容器的启动停止就是对软件的启动停止；</p><h2 id="3、安装Docker"><a href="#3、安装Docker" class="headerlink" title="3、安装Docker"></a>3、安装Docker</h2><h4 id="1）、安装linux虚拟机"><a href="#1）、安装linux虚拟机" class="headerlink" title="1）、安装linux虚拟机"></a>1）、安装linux虚拟机</h4><p>​    1）、VMWare、VirtualBox（安装）；</p><p>​    2）、导入虚拟机文件centos7-atguigu.ova；</p><p>​    3）、双击启动linux虚拟机;使用  root/ 123456登陆</p><p>​    4）、使用客户端连接linux服务器进行命令操作；</p><p>​    5）、设置虚拟机网络；</p><p>​        桥接网络===选好网卡====接入网线；</p><p>​    6）、设置好网络以后使用命令重启虚拟机的网络</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">service network restart</span><br></pre></td></tr></table></figure><p>​    7）、查看linux的ip地址</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ip addr</span><br></pre></td></tr></table></figure><p>​    8）、使用客户端连接linux；</p><h4 id="2）、在linux虚拟机上安装docker"><a href="#2）、在linux虚拟机上安装docker" class="headerlink" title="2）、在linux虚拟机上安装docker"></a>2）、在linux虚拟机上安装docker</h4><p>步骤：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1、检查内核版本，必须是3.10及以上</span><br><span class="line">uname -r</span><br><span class="line">2、安装docker</span><br><span class="line">yum install docker</span><br><span class="line">3、输入y确认安装</span><br><span class="line">4、启动docker</span><br><span class="line">[root@localhost ~]# systemctl start docker</span><br><span class="line">[root@localhost ~]# docker -v</span><br><span class="line">Docker version 1.12.6, build 3e8e77d/1.12.6</span><br><span class="line">5、开机启动docker</span><br><span class="line">[root@localhost ~]# systemctl enable docker</span><br><span class="line">Created symlink from /etc/systemd/system/multi-user.target.wants/docker.service to /usr/lib/systemd/system/docker.service.</span><br><span class="line">6、停止docker</span><br><span class="line">systemctl stop docker</span><br></pre></td></tr></table></figure><h2 id="4、Docker常用命令-amp-操作"><a href="#4、Docker常用命令-amp-操作" class="headerlink" title="4、Docker常用命令&amp;操作"></a>4、Docker常用命令&amp;操作</h2><h3 id="1）、镜像操作"><a href="#1）、镜像操作" class="headerlink" title="1）、镜像操作"></a>1）、镜像操作</h3><table><thead><tr><th>操作</th><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>检索</td><td>docker  search 关键字  eg：docker  search redis</td><td>我们经常去docker  hub上检索镜像的详细信息，如镜像的TAG。</td></tr><tr><td>拉取</td><td>docker pull 镜像名:tag</td><td>:tag是可选的，tag表示标签，多为软件的版本，默认是latest</td></tr><tr><td>列表</td><td>docker images</td><td>查看所有本地镜像</td></tr><tr><td>删除</td><td>docker rmi image-id</td><td>删除指定的本地镜像</td></tr></tbody></table><p><a href="https://hub.docker.com/" target="_blank" rel="noopener">https://hub.docker.com/</a></p><h3 id="2）、容器操作"><a href="#2）、容器操作" class="headerlink" title="2）、容器操作"></a>2）、容器操作</h3><p>软件镜像（QQ安装程序）—-运行镜像—-产生一个容器（正在运行的软件，运行的QQ）；</p><p>步骤：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1、搜索镜像</span><br><span class="line">[root@localhost ~]# docker search tomcat</span><br><span class="line">2、拉取镜像</span><br><span class="line">[root@localhost ~]# docker pull tomcat</span><br><span class="line">3、根据镜像启动容器</span><br><span class="line">docker run --name mytomcat -d tomcat:latest</span><br><span class="line">4、docker ps  </span><br><span class="line">查看运行中的容器</span><br><span class="line">5、 停止运行中的容器</span><br><span class="line">docker stop  容器的id</span><br><span class="line">6、查看所有的容器</span><br><span class="line">docker ps -a</span><br><span class="line">7、启动容器</span><br><span class="line">docker start 容器id</span><br><span class="line">8、删除一个容器</span><br><span class="line"> docker rm 容器id</span><br><span class="line">9、启动一个做了端口映射的tomcat</span><br><span class="line">[root@localhost ~]# docker run -d -p 8888:8080 tomcat</span><br><span class="line">-d：后台运行</span><br><span class="line">-p: 将主机的端口映射到容器的一个端口    主机端口:容器内部的端口</span><br><span class="line"></span><br><span class="line">10、为了演示简单关闭了linux的防火墙</span><br><span class="line">service firewalld status ；查看防火墙状态</span><br><span class="line">service firewalld stop：关闭防火墙</span><br><span class="line">11、查看容器的日志</span><br><span class="line">docker logs container-name/container-id</span><br><span class="line"></span><br><span class="line">更多命令参看</span><br><span class="line">https://docs.docker.com/engine/reference/commandline/docker/</span><br><span class="line">可以参考每一个镜像的文档</span><br></pre></td></tr></table></figure><h3 id="3）、安装MySQL示例"><a href="#3）、安装MySQL示例" class="headerlink" title="3）、安装MySQL示例"></a>3）、安装MySQL示例</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull mysql</span><br></pre></td></tr></table></figure><p>错误的启动</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# docker run --name mysql01 -d mysql</span><br><span class="line">42f09819908bb72dd99ae19e792e0a5d03c48638421fa64cce5f8ba0f40f5846</span><br><span class="line"></span><br><span class="line">mysql退出了</span><br><span class="line">[root@localhost ~]# docker ps -a</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                           PORTS               NAMES</span><br><span class="line">42f09819908b        mysql               "docker-entrypoint.sh"   34 seconds ago      Exited (1) 33 seconds ago                            mysql01</span><br><span class="line">538bde63e500        tomcat              "catalina.sh run"        About an hour ago   Exited (143) About an hour ago                       compassionate_</span><br><span class="line">goldstine</span><br><span class="line">c4f1ac60b3fc        tomcat              "catalina.sh run"        About an hour ago   Exited (143) About an hour ago                       lonely_fermi</span><br><span class="line">81ec743a5271        tomcat              "catalina.sh run"        About an hour ago   Exited (143) About an hour ago                       sick_ramanujan</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//错误日志</span><br><span class="line">[root@localhost ~]# docker logs 42f09819908b</span><br><span class="line">error: database is uninitialized and password option is not specified </span><br><span class="line">  You need to specify one of MYSQL_ROOT_PASSWORD, MYSQL_ALLOW_EMPTY_PASSWORD and MYSQL_RANDOM_ROOT_PASSWORD；这个三个参数必须指定一个</span><br></pre></td></tr></table></figure><p>正确的启动</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# docker run --name mysql01 -e MYSQL_ROOT_PASSWORD=123456 -d mysql</span><br><span class="line">b874c56bec49fb43024b3805ab51e9097da779f2f572c22c695305dedd684c5f</span><br><span class="line">[root@localhost ~]# docker ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS               NAMES</span><br><span class="line">b874c56bec49        mysql               "docker-entrypoint.sh"   4 seconds ago       Up 3 seconds        3306/tcp            mysql01</span><br></pre></td></tr></table></figure><p>做了端口映射</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# docker run -p 3306:3306 --name mysql02 -e MYSQL_ROOT_PASSWORD=123456 -d mysql</span><br><span class="line">ad10e4bc5c6a0f61cbad43898de71d366117d120e39db651844c0e73863b9434</span><br><span class="line">[root@localhost ~]# docker ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                    NAMES</span><br><span class="line">ad10e4bc5c6a        mysql               "docker-entrypoint.sh"   4 seconds ago       Up 2 seconds        0.0.0.0:3306-&gt;3306/tcp   mysql02</span><br></pre></td></tr></table></figure><p>几个其他的高级操作</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run --name mysql03 -v &#x2F;conf&#x2F;mysql:&#x2F;etc&#x2F;mysql&#x2F;conf.d -e MYSQL_ROOT_PASSWORD&#x3D;my-secret-pw -d mysql:tag</span><br><span class="line">把主机的&#x2F;conf&#x2F;mysql文件夹挂载到 mysqldocker容器的&#x2F;etc&#x2F;mysql&#x2F;conf.d文件夹里面</span><br><span class="line">改mysql的配置文件就只需要把mysql配置文件放在自定义的文件夹下（&#x2F;conf&#x2F;mysql）</span><br><span class="line"></span><br><span class="line">docker run --name some-mysql -e MYSQL_ROOT_PASSWORD&#x3D;my-secret-pw -d mysql:tag --character-set-server&#x3D;utf8mb4 --collation-server&#x3D;utf8mb4_unicode_ci</span><br><span class="line">指定mysql的一些配置参数</span><br></pre></td></tr></table></figure><h1 id="六、SpringBoot与数据访问"><a href="#六、SpringBoot与数据访问" class="headerlink" title="六、SpringBoot与数据访问"></a>六、SpringBoot与数据访问</h1><h2 id="1、JDBC"><a href="#1、JDBC" class="headerlink" title="1、JDBC"></a>1、JDBC</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://192.168.15.22:3306/jdbc</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br></pre></td></tr></table></figure><p>效果：</p><p>​    默认是用org.apache.tomcat.jdbc.pool.DataSource作为数据源；</p><p>​    数据源的相关配置都在DataSourceProperties里面；</p><p>自动配置原理：</p><p>org.springframework.boot.autoconfigure.jdbc：</p><p>1、参考DataSourceConfiguration，根据配置创建数据源，默认使用Tomcat连接池；可以使用spring.datasource.type指定自定义的数据源类型；</p><p>2、SpringBoot默认可以支持；</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">org.apache.tomcat.jdbc.pool.DataSource、HikariDataSource、BasicDataSource、</span><br></pre></td></tr></table></figure><p>3、自定义数据源类型</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Generic DataSource configuration.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span>(DataSource<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">ConditionalOnProperty</span>(<span class="title">name</span> </span>= <span class="string">"spring.datasource.type"</span>)</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Generic</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">(DataSourceProperties properties)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//使用DataSourceBuilder创建数据源，利用反射创建响应type的数据源，并且绑定相关属性</span></span><br><span class="line">      <span class="keyword">return</span> properties.initializeDataSourceBuilder().build();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、<strong>DataSourceInitializer    实现ApplicationListener</strong>；</p><p>​    作用：</p><p>​        1）、runSchemaScripts();运行建表语句；</p><p>​        2）、runDataScripts();运行插入数据的sql语句；</p><p>默认只需要将文件命名为：</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">schema-*.sql、data-*.sql</span></span><br><span class="line"><span class="attr">默认规则：schema.sql，schema-all.sql；</span></span><br><span class="line"><span class="meta">可以使用</span>   <span class="string"></span></span><br><span class="line"><span class="attr">schema</span>:<span class="string"></span></span><br><span class="line">      <span class="meta">-</span> <span class="string">classpath:department.sql</span></span><br><span class="line">      <span class="attr">指定位置</span></span><br></pre></td></tr></table></figure><p>5、操作数据库：自动配置了JdbcTemplate操作数据库</p><h2 id="2、整合Druid数据源"><a href="#2、整合Druid数据源" class="headerlink" title="2、整合Druid数据源"></a>2、整合Druid数据源</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">导入druid数据源  <span class="comment">//修改配置文件数据源</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DruidConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"spring.datasource"</span>)</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">druid</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="keyword">return</span>  <span class="keyword">new</span> DruidDataSource();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//配置Druid的监控</span></span><br><span class="line">    <span class="comment">//1、配置一个管理后台的Servlet</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServletRegistrationBean <span class="title">statViewServlet</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ServletRegistrationBean bean = <span class="keyword">new</span> ServletRegistrationBean(<span class="keyword">new</span> StatViewServlet(), <span class="string">"/druid/*"</span>);</span><br><span class="line">        Map&lt;String,String&gt; initParams = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        initParams.put(<span class="string">"loginUsername"</span>,<span class="string">"admin"</span>);</span><br><span class="line">        initParams.put(<span class="string">"loginPassword"</span>,<span class="string">"123456"</span>);</span><br><span class="line">        initParams.put(<span class="string">"allow"</span>,<span class="string">""</span>);<span class="comment">//默认就是允许所有访问</span></span><br><span class="line">        initParams.put(<span class="string">"deny"</span>,<span class="string">"192.168.15.21"</span>);</span><br><span class="line"></span><br><span class="line">        bean.setInitParameters(initParams);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、配置一个web监控的filter</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FilterRegistrationBean <span class="title">webStatFilter</span><span class="params">()</span></span>&#123;</span><br><span class="line">        FilterRegistrationBean bean = <span class="keyword">new</span> FilterRegistrationBean();</span><br><span class="line">        bean.setFilter(<span class="keyword">new</span> WebStatFilter());</span><br><span class="line"></span><br><span class="line">        Map&lt;String,String&gt; initParams = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        initParams.put(<span class="string">"exclusions"</span>,<span class="string">"*.js,*.css,/druid/*"</span>);</span><br><span class="line"></span><br><span class="line">        bean.setInitParameters(initParams);</span><br><span class="line"></span><br><span class="line">        bean.setUrlPatterns(Arrays.asList(<span class="string">"/*"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>  bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3、整合MyBatis"><a href="#3、整合MyBatis" class="headerlink" title="3、整合MyBatis"></a>3、整合MyBatis</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>![](F:/尚硅谷/springboot核心篇+整合篇-尚硅谷/01尚硅谷SpringBoot核心技术篇/Spring Boot 笔记+课件/images/搜狗截图20180305194443.png)</p><p>步骤：</p><p>​    1）、配置数据源相关属性（见上一节Druid）</p><p>​    2）、给数据库建表</p><p>​    3）、创建JavaBean</p><h3 id="4）、注解版"><a href="#4）、注解版" class="headerlink" title="4）、注解版"></a>4）、注解版</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//指定这是一个操作数据库的mapper</span></span><br><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DepartmentMapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Select</span>(<span class="string">"select * from department where id=#&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Department <span class="title">getDeptById</span><span class="params">(Integer id)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Delete</span>(<span class="string">"delete from department where id=#&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">deleteDeptById</span><span class="params">(Integer id)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Options</span>(useGeneratedKeys = <span class="keyword">true</span>,keyProperty = <span class="string">"id"</span>)</span><br><span class="line">    <span class="meta">@Insert</span>(<span class="string">"insert into department(departmentName) values(#&#123;departmentName&#125;)"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">insertDept</span><span class="params">(Department department)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Update</span>(<span class="string">"update department set departmentName=#&#123;departmentName&#125; where id=#&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">updateDept</span><span class="params">(Department department)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问题：</p><p>自定义MyBatis的配置规则；给容器中添加一个ConfigurationCustomizer；</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@org</span>.springframework.context.annotation.Configuration</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBatisConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ConfigurationCustomizer <span class="title">configurationCustomizer</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConfigurationCustomizer()&#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">customize</span><span class="params">(Configuration configuration)</span> </span>&#123;</span><br><span class="line">                configuration.setMapUnderscoreToCamelCase(<span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">使用MapperScan批量扫描所有的Mapper接口；</span><br><span class="line"><span class="meta">@MapperScan</span>(value = <span class="string">"com.atguigu.springboot.mapper"</span>)</span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringBoot06DataMybatisApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">SpringApplication.run(SpringBoot06DataMybatisApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5）、配置文件版"><a href="#5）、配置文件版" class="headerlink" title="5）、配置文件版"></a>5）、配置文件版</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">mybatis:</span></span><br><span class="line">  <span class="attr">config-location:</span> <span class="string">classpath:mybatis/mybatis-config.xml</span> <span class="string">指定全局配置文件的位置</span></span><br><span class="line">  <span class="attr">mapper-locations:</span> <span class="string">classpath:mybatis/mapper/*.xml</span>  <span class="string">指定sql映射文件的位置</span></span><br></pre></td></tr></table></figure><p>更多使用参照</p><p><a href="http://www.mybatis.org/spring-boot-starter/mybatis-spring-boot-autoconfigure/" target="_blank" rel="noopener">http://www.mybatis.org/spring-boot-starter/mybatis-spring-boot-autoconfigure/</a></p><h2 id="4、整合SpringData-JPA"><a href="#4、整合SpringData-JPA" class="headerlink" title="4、整合SpringData JPA"></a>4、整合SpringData JPA</h2><h3 id="1）、SpringData简介"><a href="#1）、SpringData简介" class="headerlink" title="1）、SpringData简介"></a>1）、SpringData简介</h3><p>![](F:/尚硅谷/springboot核心篇+整合篇-尚硅谷/01尚硅谷SpringBoot核心技术篇/Spring Boot 笔记+课件/images/搜狗截图20180306105412.png)</p><h3 id="2）、整合SpringData-JPA"><a href="#2）、整合SpringData-JPA" class="headerlink" title="2）、整合SpringData JPA"></a>2）、整合SpringData JPA</h3><p>JPA:ORM（Object Relational Mapping）；</p><p>1）、编写一个实体类（bean）和数据表进行映射，并且配置好映射关系；</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用JPA注解配置映射关系</span></span><br><span class="line"><span class="meta">@Entity</span> <span class="comment">//告诉JPA这是一个实体类（和数据表映射的类）</span></span><br><span class="line"><span class="meta">@Table</span>(name = <span class="string">"tbl_user"</span>) <span class="comment">//@Table来指定和哪个数据表对应;如果省略默认表名就是user；</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span> <span class="comment">//这是一个主键</span></span><br><span class="line">    <span class="meta">@GeneratedValue</span>(strategy = GenerationType.IDENTITY)<span class="comment">//自增主键</span></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"last_name"</span>,length = <span class="number">50</span>) <span class="comment">//这是和数据表对应的一个列</span></span><br><span class="line">    <span class="keyword">private</span> String lastName;</span><br><span class="line">    <span class="meta">@Column</span> <span class="comment">//省略默认列名就是属性名</span></span><br><span class="line">    <span class="keyword">private</span> String email;</span><br></pre></td></tr></table></figure><p>2）、编写一个Dao接口来操作实体类对应的数据表（Repository）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//继承JpaRepository来完成对数据库的操作</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">User</span>,<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3）、基本的配置JpaProperties</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span>  </span><br><span class="line"> <span class="attr">jpa:</span></span><br><span class="line">    <span class="attr">hibernate:</span></span><br><span class="line"><span class="comment">#     更新或者创建数据表结构</span></span><br><span class="line">      <span class="attr">ddl-auto:</span> <span class="string">update</span></span><br><span class="line"><span class="comment">#    控制台显示SQL</span></span><br><span class="line">    <span class="attr">show-sql:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h1 id="七、启动配置原理"><a href="#七、启动配置原理" class="headerlink" title="七、启动配置原理"></a>七、启动配置原理</h1><p>几个重要的事件回调机制</p><p>要配置在META-INF/spring.factories</p><p><strong>ApplicationContextInitializer</strong></p><p><strong>SpringApplicationRunListener</strong></p><p>只需要放在ioc容器中</p><p><strong>ApplicationRunner</strong></p><p><strong>CommandLineRunner</strong></p><p>启动流程：</p><h2 id="1、创建SpringApplication对象"><a href="#1、创建SpringApplication对象" class="headerlink" title="1、创建SpringApplication对象"></a><strong>1、创建SpringApplication对象</strong></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">initialize(sources);</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(Object[] sources)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//保存主配置类  就知道在哪了</span></span><br><span class="line">    <span class="keyword">if</span> (sources != <span class="keyword">null</span> &amp;&amp; sources.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.sources.addAll(Arrays.asList(sources));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断当前是否一个web应用</span></span><br><span class="line">    <span class="keyword">this</span>.webEnvironment = deduceWebEnvironment();</span><br><span class="line">    <span class="comment">//从类路径下找到META-INF/spring.factories配置的所有ApplicationContextInitializer；然后保存起来</span></span><br><span class="line">    setInitializers((Collection) getSpringFactoriesInstances(</span><br><span class="line">        ApplicationContextInitializer<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">    <span class="comment">//从类路径下找到ETA-INF/spring.factories配置的所有ApplicationListener</span></span><br><span class="line">    setListeners((Collection) getSpringFactoriesInstances(ApplicationListener<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">    <span class="comment">//从多个配置类中找到有main方法的主配置类</span></span><br><span class="line">    <span class="keyword">this</span>.mainApplicationClass = deduceMainApplicationClass();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>![](F:/尚硅谷/springboot核心篇+整合篇-尚硅谷/01尚硅谷SpringBoot核心技术篇/Spring Boot 笔记+课件/images/搜狗截图20180306145727.png)</p><p>![](F:/尚硅谷/springboot核心篇+整合篇-尚硅谷/01尚硅谷SpringBoot核心技术篇/Spring Boot 笔记+课件/images/搜狗截图20180306145855.png)</p><h2 id="2、运行run方法"><a href="#2、运行run方法" class="headerlink" title="2、运行run方法"></a>2、运行run方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ConfigurableApplicationContext <span class="title">run</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">   StopWatch stopWatch = <span class="keyword">new</span> StopWatch();</span><br><span class="line">   stopWatch.start();</span><br><span class="line">   ConfigurableApplicationContext context = <span class="keyword">null</span>;</span><br><span class="line">   FailureAnalyzers analyzers = <span class="keyword">null</span>;</span><br><span class="line">   configureHeadlessProperty();</span><br><span class="line">    </span><br><span class="line">   <span class="comment">//获取SpringApplicationRunListeners；从类路径下META-INF/spring.factories</span></span><br><span class="line">   SpringApplicationRunListeners listeners = getRunListeners(args);</span><br><span class="line">    <span class="comment">//回调所有的获取SpringApplicationRunListener.starting()方法</span></span><br><span class="line">   listeners.starting();</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="comment">//封装命令行参数</span></span><br><span class="line">      ApplicationArguments applicationArguments = <span class="keyword">new</span> DefaultApplicationArguments(</span><br><span class="line">            args);</span><br><span class="line">      <span class="comment">//准备环境</span></span><br><span class="line">      ConfigurableEnvironment environment = prepareEnvironment(listeners,</span><br><span class="line">            applicationArguments);</span><br><span class="line">       <span class="comment">//创建环境完成后回调SpringApplicationRunListener.environmentPrepared()；表示环境准备完成</span></span><br><span class="line">       </span><br><span class="line">      Banner printedBanner = printBanner(environment);</span><br><span class="line">       </span><br><span class="line">       <span class="comment">//创建ApplicationContext；判断决定创建web的ioc还是普通的ioc</span></span><br><span class="line">      context = createApplicationContext();</span><br><span class="line">       </span><br><span class="line">      analyzers = <span class="keyword">new</span> FailureAnalyzers(context);</span><br><span class="line">       <span class="comment">//准备上下文环境;将environment保存到ioc中；而且applyInitializers()；</span></span><br><span class="line">       <span class="comment">//applyInitializers()：回调之前保存的所有的ApplicationContextInitializer的initialize方法     //一开始时候的initialize方发</span></span><br><span class="line">       <span class="comment">//回调所有的SpringApplicationRunListener的contextPrepared()；</span></span><br><span class="line">       <span class="comment">//</span></span><br><span class="line">      prepareContext(context, environment, listeners, applicationArguments,</span><br><span class="line">            printedBanner);</span><br><span class="line">       <span class="comment">//prepareContext运行完成以后回调所有的SpringApplicationRunListener的contextLoaded（）；</span></span><br><span class="line">       </span><br><span class="line">       <span class="comment">//s刷新容器；ioc容器初始化（如果是web应用还会创建嵌入式的Tomcat）；Spring注解版</span></span><br><span class="line">       <span class="comment">//ioc容器初始化 就是扫描，创建，加载所有组件的地方；（配置类，组件，自动配置）</span></span><br><span class="line">      refreshContext(context);</span><br><span class="line">       <span class="comment">//从ioc容器中获取所有的ApplicationRunner和CommandLineRunner进行回调</span></span><br><span class="line">       <span class="comment">//ApplicationRunner先回调，CommandLineRunner再回调</span></span><br><span class="line">      afterRefresh(context, applicationArguments);</span><br><span class="line">       <span class="comment">//所有的SpringApplicationRunListener回调finished方法</span></span><br><span class="line">      listeners.finished(context, <span class="keyword">null</span>);</span><br><span class="line">      stopWatch.stop();</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.logStartupInfo) &#123;</span><br><span class="line">         <span class="keyword">new</span> StartupInfoLogger(<span class="keyword">this</span>.mainApplicationClass)</span><br><span class="line">               .logStarted(getApplicationLog(), stopWatch);</span><br><span class="line">      &#125;</span><br><span class="line">       <span class="comment">//整个SpringBoot应用启动完成以后返回启动的ioc容器；</span></span><br><span class="line">      <span class="keyword">return</span> context;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">      handleRunFailure(context, listeners, analyzers, ex);</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(ex);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3、事件监听机制"><a href="#3、事件监听机制" class="headerlink" title="3、事件监听机制"></a>3、事件监听机制</h2><p>配置在META-INF/spring.factories</p><p><strong>ApplicationContextInitializer</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloApplicationContextInitializer</span> <span class="keyword">implements</span> <span class="title">ApplicationContextInitializer</span>&lt;<span class="title">ConfigurableApplicationContext</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(ConfigurableApplicationContext applicationContext)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"ApplicationContextInitializer...initialize..."</span>+applicationContext);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>SpringApplicationRunListener</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloSpringApplicationRunListener</span> <span class="keyword">implements</span> <span class="title">SpringApplicationRunListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//必须有的构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HelloSpringApplicationRunListener</span><span class="params">(SpringApplication application, String[] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">starting</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"SpringApplicationRunListener...starting..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">environmentPrepared</span><span class="params">(ConfigurableEnvironment environment)</span> </span>&#123;</span><br><span class="line">        Object o = environment.getSystemProperties().get(<span class="string">"os.name"</span>);</span><br><span class="line">        System.out.println(<span class="string">"SpringApplicationRunListener...environmentPrepared.."</span>+o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextPrepared</span><span class="params">(ConfigurableApplicationContext context)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"SpringApplicationRunListener...contextPrepared..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextLoaded</span><span class="params">(ConfigurableApplicationContext context)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"SpringApplicationRunListener...contextLoaded..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">finished</span><span class="params">(ConfigurableApplicationContext context, Throwable exception)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"SpringApplicationRunListener...finished..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置（META-INF/spring.factories）</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">org.springframework.context.ApplicationContextInitializer</span>=<span class="string">\</span></span><br><span class="line"><span class="attr">com.atguigu.springboot.listener.HelloApplicationContextInitializer</span></span><br><span class="line"></span><br><span class="line"><span class="meta">org.springframework.boot.SpringApplicationRunListener</span>=<span class="string">\</span></span><br><span class="line"><span class="attr">com.atguigu.springboot.listener.HelloSpringApplicationRunListener</span></span><br></pre></td></tr></table></figure><p>只需要放在ioc容器中</p><p><strong>ApplicationRunner</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloApplicationRunner</span> <span class="keyword">implements</span> <span class="title">ApplicationRunner</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(ApplicationArguments args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"ApplicationRunner...run...."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>CommandLineRunner</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloCommandLineRunner</span> <span class="keyword">implements</span> <span class="title">CommandLineRunner</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String... args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"CommandLineRunner...run..."</span>+ Arrays.asList(args));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="八、自定义starter"><a href="#八、自定义starter" class="headerlink" title="八、自定义starter"></a>八、自定义starter</h1><p>starter：</p><p>​    1、这个场景需要使用到的依赖是什么？</p><p>​    2、如何编写自动配置</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>  <span class="comment">//指定这个类是一个配置类</span></span><br><span class="line"><span class="meta">@ConditionalOnXXX</span>  <span class="comment">//在指定条件成立的情况下自动配置类生效</span></span><br><span class="line"><span class="meta">@AutoConfigureAfter</span>  <span class="comment">//指定自动配置类的顺序</span></span><br><span class="line"><span class="meta">@Bean</span>  <span class="comment">//给容器中添加组件</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@ConfigurationPropertie</span>结合相关xxxProperties类来绑定相关的配置</span><br><span class="line"><span class="meta">@EnableConfigurationProperties</span> <span class="comment">//让xxxProperties生效加入到容器中</span></span><br><span class="line"></span><br><span class="line">自动配置类要能加载</span><br><span class="line">将需要启动就加载的自动配置类，配置在META-INF/spring.factories</span><br><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\</span><br></pre></td></tr></table></figure><p>​    3、模式：</p><p>启动器只用来做依赖导入；</p><p>专门来写一个自动配置模块；</p><p>启动器依赖自动配置；别人只需要引入启动器（starter）</p><p>mybatis-spring-boot-starter；自定义启动器名-spring-boot-starter</p><p>步骤：</p><p>1）、启动器模块</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.atguigu.starter<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>atguigu-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--启动器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--引入自动配置模块--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.atguigu.starter<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>atguigu-spring-boot-starter-autoconfigurer<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2）、自动配置模块</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">   <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.atguigu.starter<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>atguigu-spring-boot-starter-autoconfigurer<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">name</span>&gt;</span>atguigu-spring-boot-starter-autoconfigurer<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project for Spring Boot<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.10.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.reporting.outputEncoding</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">&lt;!--引入spring-boot-starter；所有starter的基本配置--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.starter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"atguigu.hello"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloProperties</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String prefix;</span><br><span class="line">    <span class="keyword">private</span> String suffix;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPrefix</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> prefix;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPrefix</span><span class="params">(String prefix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.prefix = prefix;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSuffix</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> suffix;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSuffix</span><span class="params">(String suffix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.suffix = suffix;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.starter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    HelloProperties helloProperties;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HelloProperties <span class="title">getHelloProperties</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helloProperties;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHelloProperties</span><span class="params">(HelloProperties helloProperties)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.helloProperties = helloProperties;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHellAtguigu</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helloProperties.getPrefix()+<span class="string">"-"</span> +name + helloProperties.getSuffix();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.starter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.condition.ConditionalOnWebApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.context.properties.EnableConfigurationProperties;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnWebApplication</span> <span class="comment">//web应用才生效</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties</span>(HelloProperties<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">HelloServiceAutoConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    HelloProperties helloProperties;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HelloService <span class="title">helloService</span><span class="params">()</span></span>&#123;</span><br><span class="line">        HelloService service = <span class="keyword">new</span> HelloService();</span><br><span class="line">        service.setHelloProperties(helloProperties);</span><br><span class="line">        <span class="keyword">return</span> service;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="更多SpringBoot整合示例"><a href="#更多SpringBoot整合示例" class="headerlink" title="更多SpringBoot整合示例"></a>更多SpringBoot整合示例</h1><p><a href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-samples" target="_blank" rel="noopener">https://github.com/spring-projects/spring-boot/tree/master/spring-boot-samples</a></p>]]></content>
    
    <summary type="html">
    
      you can &quot;just run&quot;
    
    </summary>
    
    
      <category term="SpringBoot" scheme="https://SomunsTao.github.io/categories/SpringBoot/"/>
    
    
      <category term="SpringBoot" scheme="https://SomunsTao.github.io/tags/SpringBoot/"/>
    
  </entry>
  
</feed>
