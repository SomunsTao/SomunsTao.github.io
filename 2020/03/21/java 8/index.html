<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>java 8 新特性 | Somuns ` Tao</title><meta name="description" content="java8 新特性"><meta name="keywords" content="java"><meta name="author" content="陈涛"><meta name="copyright" content="陈涛"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="dns-prefetch" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="dns-prefetch" href="https://fonts.googleapis.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="dns-prefetch" href="//busuanzi.ibruce.info"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="java 8 新特性"><meta name="twitter:description" content="java8 新特性"><meta name="twitter:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><meta property="og:type" content="article"><meta property="og:title" content="java 8 新特性"><meta property="og:url" content="https://somunstao.github.io/2020/03/21/java%208/"><meta property="og:site_name" content="Somuns ` Tao"><meta property="og:description" content="java8 新特性"><meta property="og:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><meta property="article:published_time" content="2020-03-20T16:00:00.000Z"><meta property="article:modified_time" content="2020-05-05T10:07:52.108Z"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>var autoChangeMode = '1'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="https://somunstao.github.io/2020/03/21/java%208/"><link rel="prev" title="Spring系列之Spring常用注解总结" href="https://somunstao.github.io/2020/03/21/Spring%E7%B3%BB%E5%88%97%E4%B9%8BSpring%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3%E6%80%BB%E7%BB%93/"><link rel="next" title="你，真有进步吗？" href="https://somunstao.github.io/2020/03/21/my-first-blog%20%E9%B8%A1%E6%B1%A4/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: 'false',
  isFontAwesomeV5: true,
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="Somuns ` Tao" type="application/atom+xml">
</head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">77</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">9</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">9</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 時間軸</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 留言板</span></a></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#java8-新特性精心整理-全-转载"><span class="toc-number">1.</span> <span class="toc-text">java8 新特性精心整理(全) 转载</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#前言"><span class="toc-number">1.1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#适合读者及目标"><span class="toc-number">1.2.</span> <span class="toc-text">适合读者及目标</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#目标人群"><span class="toc-number">1.2.1.</span> <span class="toc-text">目标人群</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#目标"><span class="toc-number">1.2.2.</span> <span class="toc-text">目标</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Java-语言的新特性"><span class="toc-number">1.3.</span> <span class="toc-text">1. Java 语言的新特性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-Lambda-表达式和函数式接口"><span class="toc-number">1.3.1.</span> <span class="toc-text">1.1 Lambda 表达式和函数式接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Lambda-表达式"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">Lambda 表达式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#函数式接口"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">函数式接口</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#已经存在的-Java8-定义的函数式接口"><span class="toc-number">1.3.1.2.1.</span> <span class="toc-text">已经存在的 Java8 定义的函数式接口</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-方法引用"><span class="toc-number">1.3.2.</span> <span class="toc-text">1.2 方法引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-重复注解"><span class="toc-number">1.3.3.</span> <span class="toc-text">1.3 重复注解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-更好的类型推断"><span class="toc-number">1.3.4.</span> <span class="toc-text">1.4 更好的类型推断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-拓宽注解的应用场景"><span class="toc-number">1.3.5.</span> <span class="toc-text">1.5 拓宽注解的应用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Java-编译器的新特性"><span class="toc-number">1.4.</span> <span class="toc-text">2. Java 编译器的新特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-JVM-的新特性"><span class="toc-number">1.5.</span> <span class="toc-text">3. JVM 的新特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-Java-官方库的新特性"><span class="toc-number">1.6.</span> <span class="toc-text">4. Java 官方库的新特性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-Streams"><span class="toc-number">1.6.1.</span> <span class="toc-text">4.1 Streams</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-1-forEach-遍历Collection-数据"><span class="toc-number">1.6.1.1.</span> <span class="toc-text">4.1.1 forEach 遍历Collection 数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-2-forEach-遍历-Map-数据"><span class="toc-number">1.6.1.2.</span> <span class="toc-text">4.1.2 forEach 遍历 Map 数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-3-filter-数据过滤"><span class="toc-number">1.6.1.3.</span> <span class="toc-text">4.1.3 filter 数据过滤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-4-map-对象映射"><span class="toc-number">1.6.1.4.</span> <span class="toc-text">4.1.4 map 对象映射</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-5-groupBy-按照某个属性进行分组"><span class="toc-number">1.6.1.5.</span> <span class="toc-text">4.1.5 groupBy 按照某个属性进行分组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-6-sort-按照某个属性排序-，及多列排序"><span class="toc-number">1.6.1.6.</span> <span class="toc-text">4.1.6 sort 按照某个属性排序 ，及多列排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-7-flatMap-扁平化数据处理"><span class="toc-number">1.6.1.7.</span> <span class="toc-text">4.1.7 flatMap 扁平化数据处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-8-mapReduce-数据处理"><span class="toc-number">1.6.1.8.</span> <span class="toc-text">4.1.8 mapReduce 数据处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-9-综合处理示例"><span class="toc-number">1.6.1.9.</span> <span class="toc-text">4.1.9 综合处理示例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-Optional"><span class="toc-number">1.6.2.</span> <span class="toc-text">4.2 Optional</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-Date-Time-API-JSR-310"><span class="toc-number">1.6.3.</span> <span class="toc-text">4.3 Date&#x2F;Time API(JSR 310)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-1-新-Date-Time-API-设计原则"><span class="toc-number">1.6.3.1.</span> <span class="toc-text">4.3.1 新 Date&#x2F;Time API 设计原则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-2-常用类及其使用"><span class="toc-number">1.6.3.2.</span> <span class="toc-text">4.3.2 常用类及其使用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#4-3-2-1-Instant-表示时间线上的一个点-瞬时"><span class="toc-number">1.6.3.2.1.</span> <span class="toc-text">4.3.2.1 Instant 表示时间线上的一个点(瞬时)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-3-2-2-LocalDate、LocalTime、LocalDateTime、ZonedDateTime-可以规为一组，用于表示时间的"><span class="toc-number">1.6.3.2.2.</span> <span class="toc-text">4.3.2.2 LocalDate、LocalTime、LocalDateTime、ZonedDateTime 可以规为一组，用于表示时间的</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-3-2-3-ZoneId-用来操作时区，它提供了获取所有时区和本地时区的方法"><span class="toc-number">1.6.3.2.3.</span> <span class="toc-text">4.3.2.3 ZoneId 用来操作时区，它提供了获取所有时区和本地时区的方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-3-2-4-Period，Duration-可以视为一组，用于计算时间间隔"><span class="toc-number">1.6.3.2.4.</span> <span class="toc-text">4.3.2.4 Period，Duration 可以视为一组，用于计算时间间隔</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-Base64"><span class="toc-number">1.6.4.</span> <span class="toc-text">4.4 Base64</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-JUC-工具包扩充"><span class="toc-number">1.6.5.</span> <span class="toc-text">4.5 JUC 工具包扩充</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-新的工具"><span class="toc-number">1.7.</span> <span class="toc-text">5. 新的工具</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-类依赖分析器：jdeps"><span class="toc-number">1.7.1.</span> <span class="toc-text">5.1 类依赖分析器：jdeps</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#一点小推广"><span class="toc-number">1.8.</span> <span class="toc-text">一点小推广</span></a></li></ol></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">Somuns ` Tao</a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 時間軸</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 留言板</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">java 8 新特性</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2020-03-21 00:00:00"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2020-03-21</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2020-05-05 18:07:52"><i class="fa fa-history" aria-hidden="true"></i> 更新于 2020-05-05</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/java/">java</a></span></div><div class="meta-secondline"> </div><div class="meta-thirdline"><span class="post-meta-pv-cv"><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h1 id="java8-新特性精心整理-全-转载"><a href="#java8-新特性精心整理-全-转载" class="headerlink" title="java8 新特性精心整理(全) 转载"></a><a href="https://www.cnblogs.com/xichji/p/11570387.html" target="_blank" rel="noopener">java8 新特性精心整理(全)</a> 转载</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>越来越多的项目已经使用 <a href="http://www.oracle.com/technetwork/java/javase/8train-relnotes-latest-2153846.html" target="_blank" rel="noopener">Java 8</a> 了，毫无疑问，<a href="http://www.oracle.com/technetwork/java/javase/8train-relnotes-latest-2153846.html" target="_blank" rel="noopener">Java 8</a> 是Java自Java 5（发布于2004年）之后的最重要的版本。这个版本包含语言、编译器、库、工具和 JVM 等方面的十多个新特性。在本文中我们将学习这些新特性，并用实际的例子说明在什么场景下适合使用。</p>
<p><strong>引用：</strong>本文参考了这两篇文章，加以自己的理解，整理成一份最容易理解的 Java8 新特性文章，有少部分章节可能内容一致，但绝对不是抄袭，只是为了文章的完整性，大部分常用的地方加了我自己的理解和示例。</p>
<p><a href="https://blog.csdn.net/yczz/article/details/50896975" target="_blank" rel="noopener">https://blog.csdn.net/yczz/article/details/50896975</a></p>
<p><a href="https://blog.csdn.net/maosijunzi/article/details/38658095" target="_blank" rel="noopener">https://blog.csdn.net/maosijunzi/article/details/38658095</a></p>
<h2 id="适合读者及目标"><a href="#适合读者及目标" class="headerlink" title="适合读者及目标"></a>适合读者及目标</h2><h3 id="目标人群"><a href="#目标人群" class="headerlink" title="目标人群"></a>目标人群</h3><ul>
<li>适合有用过 lambda 表达式的同学，想彻底了解清楚</li>
<li>学习 Java8 的新特定</li>
</ul>
<h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><ul>
<li>了解 java8 的函数式接口和 Lambda 表达式</li>
<li>方法引用的使用</li>
<li>接口的静态方法和默认方法</li>
<li>Date/Time Api 的使用</li>
<li>Stream API 的使用</li>
</ul>
<h2 id="1-Java-语言的新特性"><a href="#1-Java-语言的新特性" class="headerlink" title="1. Java 语言的新特性"></a>1. Java 语言的新特性</h2><p>Java8 的 lambda 的使用确实方便了许多，但也使初次了解的人感觉到难以阅读，其实是你不习惯的原因。很多语言从一开始就支持了 Lambda 表达式，像 Groovy,Scala 等。</p>
<h3 id="1-1-Lambda-表达式和函数式接口"><a href="#1-1-Lambda-表达式和函数式接口" class="headerlink" title="1.1 Lambda 表达式和函数式接口"></a>1.1 Lambda 表达式和函数式接口</h3><p>在 Java8 以前，我们想要让一个方法可以与用户进行交互，比如说使用方法内的局部变量；这时候就只能使用接口做为参数，让用户实现这个接口或使用匿名内部类的形式，把局部变量通过接口方法传给用户。</p>
<p><strong>传统匿名内部类缺点：</strong>代码臃肿，难以阅读</p>
<h4 id="Lambda-表达式"><a href="#Lambda-表达式" class="headerlink" title="Lambda 表达式"></a>Lambda 表达式</h4><p>Lambda 表达式将函数当成参数传递给某个方法，或者把代码本身当作数据处理；</p>
<p><strong>语法格式：</strong></p>
<ul>
<li>用逗号分隔的参数列表</li>
<li><code>-&gt;</code> 符号</li>
<li>和 语句块 组成</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Arrays.asList( &quot;a&quot;, &quot;b&quot;, &quot;d&quot; ).forEach( e -&gt; System.out.println( e ) );</span><br></pre></td></tr></table></figure>

<p>等价于</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list &#x3D; Arrays.asList( &quot;a&quot;, &quot;b&quot;, &quot;d&quot; );</span><br><span class="line">for(String e:list)&#123;</span><br><span class="line">    System.out.println(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果语句块比较复杂，使用 <code>{}</code> 包起来</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Arrays.asList( &quot;a&quot;, &quot;b&quot;, &quot;d&quot; ).forEach( e -&gt; &#123;</span><br><span class="line">    String m &#x3D; &quot;9420 &quot;+e;</span><br><span class="line">    System.out.print( m );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>Lambda 本质上是匿名内部类的改装，所以它使用到的变量都会隐式的转成 <code>final</code> 的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String separator &#x3D; &quot;,&quot;;</span><br><span class="line">Arrays.asList( &quot;a&quot;, &quot;b&quot;, &quot;d&quot; ).forEach( </span><br><span class="line">    e -&gt; System.out.print( e + separator ) );</span><br></pre></td></tr></table></figure>

<p>等价于</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">final String separator &#x3D; &quot;,&quot;;</span><br><span class="line">Arrays.asList( &quot;a&quot;, &quot;b&quot;, &quot;d&quot; ).forEach( </span><br><span class="line">    e -&gt; System.out.print( e + separator ) );</span><br></pre></td></tr></table></figure>

<p>Lambda 的返回值和参数类型由编译器推理得出，不需要显示定义，如果只有一行代码可以不写 <strong>return</strong> 语句</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Arrays.asList( &quot;a&quot;, &quot;b&quot;, &quot;d&quot; ).sort( ( e1, e2 ) -&gt; e1.compareTo( e2 ) );</span><br></pre></td></tr></table></figure>

<p>等价于</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list &#x3D; Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);</span><br><span class="line">Collections.sort(list, new Comparator&lt;String&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public int compare(String o1, String o2) &#123;</span><br><span class="line">        return o1.compareTo(o2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h4><ul>
<li>接口中只能有一个接口方法</li>
<li>可以有静态方法和默认方法</li>
<li>使用 <code>@FunctionalInterface</code> 标记</li>
<li>默认方法可以被覆写</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">public interface FunctionalDefaultMethods &#123;</span><br><span class="line">    void method();</span><br><span class="line"> </span><br><span class="line">    default void defaultMethod() &#123;            </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    static void staticMethod()&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">private interface Defaulable &#123;</span><br><span class="line">    &#x2F;&#x2F; Interfaces now allow default methods, the implementer may or </span><br><span class="line">    &#x2F;&#x2F; may not implement (override) them.</span><br><span class="line">    default String notRequired() &#123; </span><br><span class="line">        return &quot;Default implementation&quot;; </span><br><span class="line">    &#125;        </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">private static class DefaultableImpl implements Defaulable &#123;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">private static class OverridableImpl implements Defaulable &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public String notRequired() &#123;</span><br><span class="line">        return &quot;Overridden implementation&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 也可以由接口覆盖 </span><br><span class="line">public interface OverridableInterface extends Defaulable&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public String notRequired() &#123;</span><br><span class="line">        return &quot;interface Overridden implementation&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于JVM上的默认方法的实现在字节码层面提供了支持，因此效率非常高。默认方法允许在不打破现有继承体系的基础上改进接口。该特性在官方库中的应用是：给 <strong>java.util.Collection</strong>接口添加新方法，如 <strong>stream()</strong>、<strong>parallelStream()</strong>、<strong>forEach()</strong>和<strong>removeIf()</strong> 等等。</p>
<h5 id="已经存在的-Java8-定义的函数式接口"><a href="#已经存在的-Java8-定义的函数式接口" class="headerlink" title="已经存在的 Java8 定义的函数式接口"></a>已经存在的 Java8 定义的函数式接口</h5><p>我们基本不需要定义自己的函数式接口，Java8 已经给我们提供了大量的默认函数式接口，基本够用，在 <code>rt.jar</code> 包的 <code>java.util.function</code> 目录下可以看到所有默认的函数式接口，大致分为几类</p>
<ul>
<li><code>Function</code> <strong>T</strong> 作为输入，返回的 <strong>R</strong> 作为输出</li>
<li><code>Predicate</code> <strong>T</strong> 作为输入 ，返回 <strong>boolean</strong> 值的输出</li>
<li><code>Consumer</code> <strong>T</strong> 作为输入 ，没有输出</li>
<li><code>Supplier</code> 没有输入 , <strong>R</strong> 作为输出</li>
<li><code>BinaryOperator</code> <strong>两个 T</strong> 作为输入 ，<strong>T</strong> 同样是输出</li>
<li><code>UnaryOperator</code> 是 <code>Function</code> 的变种 ，输入输出者是 <strong>T</strong></li>
</ul>
<p>其它的都是上面几种的各种扩展，只为更方便的使用，下面演示示例，你可以把其当成正常的接口使用，由用户使用 Lambda 传入。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; hello world 示例</span><br><span class="line">Function&lt;String,String&gt; function &#x3D; (x) -&gt; &#123;return x+&quot;Function&quot;;&#125;;</span><br><span class="line">System.out.println(function.apply(&quot;hello world&quot;));  &#x2F;&#x2F; hello world Function</span><br><span class="line"></span><br><span class="line">UnaryOperator&lt;String&gt; unaryOperator &#x3D; x -&gt; x + 2;</span><br><span class="line">System.out.println(unaryOperator.apply(&quot;9420-&quot;));   &#x2F;&#x2F; 9420-2</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 判断输入值是否为偶数示例</span><br><span class="line">Predicate&lt;Integer&gt; predicate &#x3D; (x) -&gt;&#123;return x % 2 &#x3D;&#x3D; 0 ;&#125;;</span><br><span class="line">System.out.println(predicate.test(1));              &#x2F;&#x2F; false</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 这个没有返回值</span><br><span class="line">Consumer&lt;String&gt; consumer &#x3D; (x) -&gt; &#123;System.out.println(x);&#125;;</span><br><span class="line">consumer.accept(&quot;hello world &quot;);                    &#x2F;&#x2F; hello world</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 这个没有输入 </span><br><span class="line">Supplier&lt;String&gt; supplier &#x3D; () -&gt; &#123;return &quot;Supplier&quot;;&#125;;</span><br><span class="line">System.out.println(supplier.get());                 &#x2F;&#x2F; Supplier</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 找出大数</span><br><span class="line">BinaryOperator&lt;Integer&gt; bina &#x3D; (x, y) -&gt;&#123;return x &gt; y ? x : y;&#125;;</span><br><span class="line">bina.apply(1,2);                                    &#x2F;&#x2F; 2</span><br></pre></td></tr></table></figure>

<h3 id="1-2-方法引用"><a href="#1-2-方法引用" class="headerlink" title="1.2 方法引用"></a>1.2 方法引用</h3><p>方法引用使得开发者可以直接引用现存的方法、Java类的构造方法或者实例对象。方法引用和Lambda表达式配合使用，使得java类的构造方法看起来紧凑而简洁，没有很多复杂的模板代码。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static class Car &#123;</span><br><span class="line">    public static Car create( final Supplier&lt; Car &gt; supplier ) &#123;</span><br><span class="line">        return supplier.get();</span><br><span class="line">    &#125;              </span><br><span class="line"> </span><br><span class="line">    public static void collide( final Car car ) &#123;</span><br><span class="line">        System.out.println( &quot;Collided &quot; + car.toString() );</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public void follow( final Car another ) &#123;</span><br><span class="line">        System.out.println( &quot;Following the &quot; + another.toString() );</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public void repair() &#123;   </span><br><span class="line">        System.out.println( &quot;Repaired &quot; + this.toString() );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一种方法引用的类型是构造器引用，语法是<strong>Class::new</strong>，或者更一般的形式：<strong>Class::new</strong>。注意：这个构造器没有参数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">final Car car &#x3D; Car.create( Car::new );</span><br></pre></td></tr></table></figure>

<p>等价于</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Car car &#x3D; Car.create(() -&gt; new Car());</span><br></pre></td></tr></table></figure>

<p>第二种方法引用的类型是静态方法引用，语法是<strong>Class::static_method</strong>。注意：这个方法接受一个Car类型的参数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cars.forEach( Car::collide );</span><br></pre></td></tr></table></figure>

<p><code>forEach</code> 原型为 <code>forEach(Consumer action)</code> 使用的是 <strong>Consumer</strong> 只有参数，没有返回值；这个参数 T 就是 car 类型，因为是 <code>cars.forEach</code> 嘛，所以上面的方法引用等价于</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cars.forEach(car -&gt; Car.collide(car));</span><br></pre></td></tr></table></figure>

<p>第三种方法引用的类型是某个类的成员方法的引用，语法是<strong>Class::method</strong>，注意，这个方法没有定义入参：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cars.forEach( Car::repair );</span><br></pre></td></tr></table></figure>

<p>它等价于</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cars.forEach(car -&gt; car.repair());</span><br></pre></td></tr></table></figure>

<h3 id="1-3-重复注解"><a href="#1-3-重复注解" class="headerlink" title="1.3 重复注解"></a>1.3 重复注解</h3><p>自从Java 5中引入<a href="http://www.javacodegeeks.com/2012/08/java-annotations-explored-explained.html" target="_blank" rel="noopener">注解</a>以来，这个特性开始变得非常流行，并在各个框架和项目中被广泛使用。不过，注解有一个很大的限制是：在同一个地方不能多次使用同一个注解。Java 8打破了这个限制，引入了重复注解的概念，允许在同一个地方多次使用同一个注解。</p>
<p>在Java 8中使用 <strong>@Repeatable</strong> 注解定义重复注解，实际上，这并不是语言层面的改进，而是编译器做的一个trick，底层的技术仍然相同。可以利用下面的代码说明：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Target( ElementType.TYPE )</span><br><span class="line">@Retention( RetentionPolicy.RUNTIME )</span><br><span class="line">@Repeatable( Filters.class )</span><br><span class="line">public @interface Filter &#123;</span><br><span class="line">    String value();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">@Filter( &quot;filter1&quot; )</span><br><span class="line">@Filter( &quot;filter2&quot; )</span><br><span class="line">public interface Filterable &#123;        </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    for( Filter filter: Filterable.class.getAnnotationsByType( Filter.class ) ) &#123;</span><br><span class="line">        System.out.println( filter.value() );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正如我们所见，这里的<strong>Filter</strong>类使用 <code>@Repeatable(Filters.class)</code> 注解修饰，而<strong>Filters</strong>是存放<strong>Filter</strong>注解的容器，编译器尽量对开发者屏蔽这些细节。这样，<strong>Filterable</strong>接口可以用两个<strong>Filter</strong>注解注释（这里并没有提到任何关于Filters的信息）。</p>
<p>另外，反射API提供了一个新的方法：<strong>getAnnotationsByType()</strong>，可以返回某个类型的重复注解，例如<code>Filterable.class.getAnnoation(Filters.class)</code>将返回两个Filter实例。</p>
<h3 id="1-4-更好的类型推断"><a href="#1-4-更好的类型推断" class="headerlink" title="1.4 更好的类型推断"></a>1.4 更好的类型推断</h3><p>Java 8编译器在类型推断方面有很大的提升，在很多场景下编译器可以推导出某个参数的数据类型，从而使得代码更为简洁。例子代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Value&lt; T &gt; &#123;</span><br><span class="line">    public static&lt; T &gt; T defaultValue() &#123; </span><br><span class="line">        return null; </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public T getOrDefault( T value, T defaultValue ) &#123;</span><br><span class="line">        return ( value !&#x3D; null ) ? value : defaultValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class TypeInference &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        final Value&lt; String &gt; value &#x3D; new Value&lt;&gt;();</span><br><span class="line">        value.getOrDefault( &quot;22&quot;, Value.defaultValue() );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参数 <strong>Value.defaultValue()</strong> 的类型由编译器推导得出，不需要显式指明。在Java 7中这段代码会有编译错误，除非使用<code>Value.defaultValue()</code></p>
<h3 id="1-5-拓宽注解的应用场景"><a href="#1-5-拓宽注解的应用场景" class="headerlink" title="1.5 拓宽注解的应用场景"></a>1.5 拓宽注解的应用场景</h3><p>Java 8拓宽了注解的应用场景。现在，注解几乎可以使用在任何元素上：局部变量、接口类型、超类和接口实现类，甚至可以用在函数的异常定义上。下面是一些例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.javacodegeeks.java8.annotations;</span><br><span class="line"> </span><br><span class="line">import java.lang.annotation.ElementType;</span><br><span class="line">import java.lang.annotation.Retention;</span><br><span class="line">import java.lang.annotation.RetentionPolicy;</span><br><span class="line">import java.lang.annotation.Target;</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Collection;</span><br><span class="line"> </span><br><span class="line">public class Annotations &#123;</span><br><span class="line">    @Retention( RetentionPolicy.RUNTIME )</span><br><span class="line">    @Target( &#123; ElementType.TYPE_USE, ElementType.TYPE_PARAMETER &#125; )</span><br><span class="line">    public @interface NonEmpty &#123;        </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static class Holder&lt; @NonEmpty T &gt; extends @NonEmpty Object &#123;</span><br><span class="line">        public void method() throws @NonEmpty Exception &#123;            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @SuppressWarnings( &quot;unused&quot; )</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        final Holder&lt; String &gt; holder &#x3D; new @NonEmpty Holder&lt; String &gt;();        </span><br><span class="line">        @NonEmpty Collection&lt; @NonEmpty String &gt; strings &#x3D; new ArrayList&lt;&gt;();        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>ElementType.TYPE_USER</strong> 和 <strong>ElementType.TYPE_PARAMETER</strong> 是Java 8新增的两个注解，用于描述注解的使用场景。Java 语言也做了对应的改变，以识别这些新增的注解。</p>
<h2 id="2-Java-编译器的新特性"><a href="#2-Java-编译器的新特性" class="headerlink" title="2. Java 编译器的新特性"></a>2. Java 编译器的新特性</h2><p>Java 8 开始正式支持参数名称，终于不需要读 class 字节码来获取参数名称了，这对于经常使用反射的人特别有用。</p>
<p>在 Java8 这个特性默认是关闭的，需要开启参数才能获取参数名称：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;plugin&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.maven.plugins&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;maven-compiler-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.1&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;configuration&gt;</span><br><span class="line">        &lt;compilerArgument&gt;-parameters&lt;&#x2F;compilerArgument&gt;</span><br><span class="line">        &lt;source&gt;1.8&lt;&#x2F;source&gt;</span><br><span class="line">        &lt;target&gt;1.8&lt;&#x2F;target&gt;</span><br><span class="line">    &lt;&#x2F;configuration&gt;</span><br><span class="line">&lt;&#x2F;plugin&gt;</span><br></pre></td></tr></table></figure>

<h2 id="3-JVM-的新特性"><a href="#3-JVM-的新特性" class="headerlink" title="3. JVM 的新特性"></a>3. JVM 的新特性</h2><p>使用<strong>Metaspace</strong>（<a href="http://openjdk.java.net/jeps/122" target="_blank" rel="noopener">JEP 122</a>）代替持久代（<strong>PermGen</strong> space）。在JVM参数方面，使用<strong>-XX:MetaSpaceSize</strong>和<strong>-XX:MaxMetaspaceSize</strong>代替原来的<strong>-XX:PermSize</strong>和<strong>-XX:MaxPermSize</strong>。</p>
<h2 id="4-Java-官方库的新特性"><a href="#4-Java-官方库的新特性" class="headerlink" title="4. Java 官方库的新特性"></a>4. Java 官方库的新特性</h2><p>Java 8增加了很多新的工具类（date/time类），并扩展了现存的工具类，以支持现代的并发编程、函数式编程等，本章节参考原文，并提取出常用功能。</p>
<h3 id="4-1-Streams"><a href="#4-1-Streams" class="headerlink" title="4.1 Streams"></a>4.1 Streams</h3><p>Streams 操作分为中间操作和晚期操作，中间操作会返回一个新的 Stream ，只是把要做的操作记录起来而已，并不会真的执行，晚期操作才会真的遍历列表并执行所有操作</p>
<p>Stream 的另一个价值就是支持了并行处理 <code>parallel</code> 方法。</p>
<p>Stream API 简化了集合的操作，并扩展了集合的分组，求和，mapReduce，flatMap ，排序等功能，下面列出项目中经常用到的功能，会以使用频率排序。</p>
<ol>
<li>准备一个用于下面例子测试的对象</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import lombok.AllArgsConstructor;</span><br><span class="line">import lombok.Data;</span><br><span class="line">import lombok.NoArgsConstructor;</span><br><span class="line"></span><br><span class="line">@Data</span><br><span class="line">@NoArgsConstructor</span><br><span class="line">@AllArgsConstructor</span><br><span class="line">public class Vehicle &#123;</span><br><span class="line">    &#x2F;&#x2F;车架号</span><br><span class="line">    private String vin;</span><br><span class="line">    &#x2F;&#x2F; 车主手机号</span><br><span class="line">    private String phone;</span><br><span class="line">    &#x2F;&#x2F; 车主姓名</span><br><span class="line">    private String name;</span><br><span class="line">    &#x2F;&#x2F; 所属车租车公司</span><br><span class="line">    private Integer companyId;</span><br><span class="line">    &#x2F;&#x2F; 个人评分</span><br><span class="line">    private Double score;</span><br><span class="line">    &#x2F;&#x2F;安装的设备列表imei,使用逗号分隔</span><br><span class="line">    private String deviceNos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>准备一些车辆数据</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static List&lt;Vehicle&gt; vehicles &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">@Before</span><br><span class="line">public void init()&#123;</span><br><span class="line">    List&lt;String&gt; imeis &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    for (int i &#x3D; 0; i &lt;5 ; i++) &#123;</span><br><span class="line">        List&lt;String&gt; singleVehicleDevices &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">        for (int j &#x3D; 0; j &lt; 3; j++) &#123;</span><br><span class="line">            String imei &#x3D; RandomStringUtils.randomAlphanumeric(15);</span><br><span class="line">            singleVehicleDevices.add(imei);</span><br><span class="line">        &#125;</span><br><span class="line">        imeis.add(StringUtils.join(singleVehicleDevices,&#39;,&#39;));</span><br><span class="line">    &#125;</span><br><span class="line">    vehicles.add(new Vehicle(&quot;KPTSOA1K67P081452&quot;,&quot;17620411498&quot;,&quot;9420&quot;,1,4.5,imeis.get(0)));</span><br><span class="line">    vehicles.add(new Vehicle(&quot;KPTCOB1K18P057071&quot;,&quot;15073030945&quot;,&quot;张玲&quot;,2,1.4,imeis.get(1)));</span><br><span class="line">    vehicles.add(new Vehicle(&quot;KPTS0A1K87P080237&quot;,&quot;19645871598&quot;,&quot;sanri1993&quot;,1,3.0,imeis.get(2)));</span><br><span class="line">    vehicles.add(new Vehicle(&quot;KNAJC526975740490&quot;,&quot;15879146974&quot;,&quot;李种&quot;,1,3.9,imeis.get(3)));</span><br><span class="line">    vehicles.add(new Vehicle(&quot;KNAJC521395884849&quot;,&quot;13520184976&quot;,&quot;袁绍&quot;,2,4.9,imeis.get(4)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-1-1-forEach-遍历Collection-数据"><a href="#4-1-1-forEach-遍历Collection-数据" class="headerlink" title="4.1.1 forEach 遍历Collection 数据"></a>4.1.1 forEach 遍历Collection 数据</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vehicles.forEach(vehicle -&gt; System.out.println(vehicle));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;这样就可以遍历打印</span><br><span class="line">vehicles.forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<h4 id="4-1-2-forEach-遍历-Map-数据"><a href="#4-1-2-forEach-遍历-Map-数据" class="headerlink" title="4.1.2 forEach 遍历 Map 数据"></a>4.1.2 forEach 遍历 Map 数据</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Map&lt;String,Integer&gt; map &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">map.put(&quot;a&quot;,1);map.put(&quot;b&quot;,2);map.put(&quot;c&quot;,3);</span><br><span class="line"></span><br><span class="line">map.forEach((k,v) -&gt; System.out.println(&quot;key:&quot;+k+&quot;,value:&quot;+v));</span><br></pre></td></tr></table></figure>

<h4 id="4-1-3-filter-数据过滤"><a href="#4-1-3-filter-数据过滤" class="headerlink" title="4.1.3 filter 数据过滤"></a>4.1.3 filter 数据过滤</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 去掉评分为 3 分以下的车</span><br><span class="line">List&lt;Vehicle&gt; collect &#x3D; vehicles.stream().filter(vehicle -&gt; vehicle.getScore() &gt;&#x3D; 3).collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<h4 id="4-1-4-map-对象映射"><a href="#4-1-4-map-对象映射" class="headerlink" title="4.1.4 map 对象映射"></a>4.1.4 map 对象映射</h4><p>对一个 <code>List</code> 大部分情况下，我们只需要列表中的某一列，或者需要把里面的每一个对象转换成其它的对象，这时候可以使用 map 映射,示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 取出所有的车架号列表</span><br><span class="line"> List&lt;String&gt; vins &#x3D; vehicles.stream().map(Vehicle::getVin).collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<h4 id="4-1-5-groupBy-按照某个属性进行分组"><a href="#4-1-5-groupBy-按照某个属性进行分组" class="headerlink" title="4.1.5 groupBy 按照某个属性进行分组"></a>4.1.5 groupBy 按照某个属性进行分组</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 按照公司 Id 进行分组</span><br><span class="line">Map&lt;Integer, List&lt;Vehicle&gt;&gt; companyVehicles &#x3D; vehicles.stream().collect(Collectors.groupingBy(Vehicle::getCompanyId));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 按照公司分组求司机打分和</span><br><span class="line">Map&lt;Integer, Double&gt; collect &#x3D; vehicles.stream().collect(Collectors.groupingBy(Vehicle::getCompanyId, Collectors.summingDouble(Vehicle::getScore)));</span><br></pre></td></tr></table></figure>

<h4 id="4-1-6-sort-按照某个属性排序-，及多列排序"><a href="#4-1-6-sort-按照某个属性排序-，及多列排序" class="headerlink" title="4.1.6 sort 按照某个属性排序 ，及多列排序"></a>4.1.6 sort 按照某个属性排序 ，及多列排序</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 单列排序 </span><br><span class="line">vehicles.sort((v1,v2) -&gt; v2.getScore().compareTo(v1.getScore()));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 或使用 Comparator 类来构建比较器，流处理不会改变原列表，需要接收返回值才能得到预期结果</span><br><span class="line"> List&lt;Vehicle&gt; collect &#x3D; vehicles.stream().sorted(Comparator.comparing(Vehicle::getScore).reversed()).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 多列排序，score 降序，companyId 升序排列</span><br><span class="line">List&lt;Vehicle&gt; collect &#x3D; vehicles.stream().sorted(Comparator.comparing(Vehicle::getScore).reversed()</span><br><span class="line">                .thenComparing(Comparator.comparing(Vehicle::getCompanyId)))</span><br><span class="line">                .collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<h4 id="4-1-7-flatMap-扁平化数据处理"><a href="#4-1-7-flatMap-扁平化数据处理" class="headerlink" title="4.1.7 flatMap 扁平化数据处理"></a>4.1.7 flatMap 扁平化数据处理</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 查出所有车绑定的所有设备</span><br><span class="line">List&lt;String&gt; collect &#x3D; vehicles.stream().map(vehicle -&gt; &#123;</span><br><span class="line">    String deviceNos &#x3D; vehicle.getDeviceNos();</span><br><span class="line">    return StringUtils.split(deviceNos,&#39;,&#39;);</span><br><span class="line">&#125;).flatMap(Arrays::stream).collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<p>flatMap 很适合 <code>List</code> 或 <code>List</code> 这种结构，可以当成一个列表来处理；像上面的设备列表，在数据库中存储的结构就是以逗号分隔的数据，而车辆列表又是一个列表数据。</p>
<h4 id="4-1-8-mapReduce-数据处理"><a href="#4-1-8-mapReduce-数据处理" class="headerlink" title="4.1.8 mapReduce 数据处理"></a>4.1.8 mapReduce 数据处理</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 对所有司机的总分求和</span><br><span class="line">Double reduce &#x3D; vehicles.stream().parallel().map(Vehicle::getScore).reduce(0d, Double::sum);</span><br></pre></td></tr></table></figure>

<h4 id="4-1-9-综合处理示例"><a href="#4-1-9-综合处理示例" class="headerlink" title="4.1.9 综合处理示例"></a>4.1.9 综合处理示例</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 总的分值</span><br><span class="line">Double totalScore &#x3D; vehicles.stream().parallel().map(Vehicle::getScore).reduce(0d, Double::sum);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 查看每一个司机占的分值比重</span><br><span class="line">List&lt;String&gt; collect &#x3D; vehicles.stream()</span><br><span class="line">    .mapToDouble(vehicle -&gt; vehicle.getScore() &#x2F; totalScore)</span><br><span class="line">    .mapToLong(weight -&gt; (long) (weight * 100))</span><br><span class="line">    .mapToObj(percentage -&gt; percentage + &quot;%&quot;)</span><br><span class="line">    .collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<p>原文的 boxed 不知道是什么意思，希望有大神能帮忙解答下，不用 boxed 也是可以的</p>
<h3 id="4-2-Optional"><a href="#4-2-Optional" class="headerlink" title="4.2 Optional"></a>4.2 Optional</h3><p>Optional 用来解决 Java 中经常出现的 <strong>NullPointerException</strong> ，从而避免源码被各种空检查污染，使源码更加简洁和更加容易阅读</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 假设有一个对象 obj ,你不知道它是不是为空的，但是你想用它的方法，可以这么玩</span><br><span class="line">Optional&lt;T&gt; canUseObj &#x3D; Optional.ofNullable(obj);</span><br><span class="line">canUseObj.ifPresent(System.out::println);       &#x2F;&#x2F;如果 obj 不为空，则可以使用 obj 的方法，这里做个简单输出</span><br></pre></td></tr></table></figure>

<h3 id="4-3-Date-Time-API-JSR-310"><a href="#4-3-Date-Time-API-JSR-310" class="headerlink" title="4.3 Date/Time API(JSR 310)"></a>4.3 Date/Time API(JSR 310)</h3><p>新的日期时间工具全部都在 <code>java.time</code> 及其子包中。</p>
<h4 id="4-3-1-新-Date-Time-API-设计原则"><a href="#4-3-1-新-Date-Time-API-设计原则" class="headerlink" title="4.3.1 新 Date/Time API 设计原则"></a>4.3.1 新 Date/Time API 设计原则</h4><p>Java 8日期/时间API是 <a href="https://jcp.org/en/jsr/detail?id=310" target="_blank" rel="noopener">JSR-310</a> 规范的实现，它的目标是克服旧的日期/时间API实现中所有的缺陷，新的日期/时间API的一些设计原则如下：</p>
<ul>
<li>不变性：新的日期/时间API中，所有的类都是不可变的，这种设计有利于并发编程。</li>
<li>关注点分离：新的API将人可读的日期时间和机器时间（unix timestamp）明确分离，它为日期（Date）、时间（Time）、日期时间（DateTime）、时间戳（unix timestamp）以及时区定义了不同的类。</li>
<li>清晰：在所有的类中，方法都被明确定义用以完成相同的行为。举个例子，要拿到当前实例我们可以使用now()方法，在所有的类中都定义了format()和parse()方法，而不是像以前那样专门有一个独立的类。为了更好的处理问题，所有的类都使用了工厂模式和策略模式，一旦你使用了其中某个类的方法，与其他类协同工作并不困难。</li>
<li>实用操作：所有新的日期/时间API类都实现了一系列方法用以完成通用的任务，如：加、减、格式化、解析、从日期/时间中提取单独部分等操作。</li>
<li>可扩展性：新的日期/时间API是工作在ISO-8601日历系统上的，但我们也可以将其应用在非IOS的日历上。</li>
</ul>
<h4 id="4-3-2-常用类及其使用"><a href="#4-3-2-常用类及其使用" class="headerlink" title="4.3.2 常用类及其使用"></a>4.3.2 常用类及其使用</h4><p>时间大致可以分为三个部分：日期、时间、时区</p>
<p>其中日期又细分为年、月、日；时间又细分为时、分、秒</p>
<p>一般机器时间用从 1970-01-01T00:00 到现在的秒数来表示时间; 这里纠正大部分人犯的一个错误概念，时间戳指的是秒数，而不是毫秒数。</p>
<p>几乎所有的时间对象都实现了 <code>Temporal</code> 接口，所以接口参数一般都是 <code>Temporal</code></p>
<ul>
<li><strong>Instant：</strong> 表示时间线上的一个点，参考点是标准的Java纪元(epoch)，即1970-01-01T00：00：00Z（1970年1月1日00:00 GMT）</li>
<li><strong>LocalDate：</strong> 日期值对象如 2019-09-22</li>
<li><strong>LocalTime：</strong>时间值对象如 21:25:36</li>
<li><strong>LocalDateTime：</strong>日期+时间值对象</li>
<li><strong>ZoneId：</strong>时区</li>
<li><strong>ZonedDateTime：</strong>日期+时间+时区值对象</li>
<li><strong>DateTimeFormatter：</strong>用于日期时间的格式化</li>
<li><strong>Period：</strong>用于计算日期间隔</li>
<li><strong>Duration：</strong>用于计算时间间隔</li>
</ul>
<h5 id="4-3-2-1-Instant-表示时间线上的一个点-瞬时"><a href="#4-3-2-1-Instant-表示时间线上的一个点-瞬时" class="headerlink" title="4.3.2.1 Instant 表示时间线上的一个点(瞬时)"></a>4.3.2.1 <code>Instant</code> 表示时间线上的一个点(瞬时)</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 测试执行一个 new 操作使用的时间(纳秒值)</span><br><span class="line">Instant begin &#x3D; Instant.now();</span><br><span class="line">StreamMain streamMain &#x3D; new StreamMain();</span><br><span class="line">Instant end &#x3D; Instant.now();</span><br><span class="line">System.out.println(Duration.between(begin,end).toNanos());</span><br></pre></td></tr></table></figure>

<h5 id="4-3-2-2-LocalDate、LocalTime、LocalDateTime、ZonedDateTime-可以规为一组，用于表示时间的"><a href="#4-3-2-2-LocalDate、LocalTime、LocalDateTime、ZonedDateTime-可以规为一组，用于表示时间的" class="headerlink" title="4.3.2.2 LocalDate、LocalTime、LocalDateTime、ZonedDateTime 可以规为一组，用于表示时间的"></a>4.3.2.2 <code>LocalDate</code>、<code>LocalTime</code>、<code>LocalDateTime</code>、<code>ZonedDateTime</code> 可以规为一组，用于表示时间的</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 可以使用 of 方法构建它们的实例,如下面创建了一个 2019-9-22 21:42:59 东八区 的时间对象 </span><br><span class="line">LocalDate localDate &#x3D; LocalDate.of(2019, Month.SEPTEMBER, 22);</span><br><span class="line">LocalTime localTime &#x3D; LocalTime.of(21, 42, 59);</span><br><span class="line">LocalDateTime localDateTime &#x3D; LocalDateTime.of(localDate, localTime);</span><br><span class="line">ZonedDateTime zonedDateTime &#x3D; ZonedDateTime.of(localDateTime, ZoneId.systemDefault());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 获取现在的时间，这是一个静态方法</span><br><span class="line">LocalDate now &#x3D; LocalDate.now();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 每个实例可以获取它们的 part 信息,如获取年 </span><br><span class="line">int year &#x3D; localDate.getYear();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 可以修改 part 信息，这将返回一个新对象，如增加一年</span><br><span class="line">LocalDate localDatePlus &#x3D; localDate.plusYears(1);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 设置 part 信息，也会返回新的对象，如设置为 2017 年 </span><br><span class="line">LocalDate localDateWithYear &#x3D; localDate.withYear(2017);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 比较两个日期 isAfter,isBefore</span><br><span class="line">boolean after &#x3D; localDate.isAfter(LocalDate.now());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 格式化日期时间</span><br><span class="line">&#x2F;&#x2F; yyyy-MM-dd</span><br><span class="line">System.out.println(now.format(DateTimeFormatter.ISO_DATE));</span><br><span class="line">&#x2F;&#x2F; yyyy-MM-ddTHH:mm:ss</span><br><span class="line">System.out.println(now.format(DateTimeFormatter.ISO_DATE_TIME));</span><br><span class="line">&#x2F;&#x2F; yyyy-MM-dd HH:mm:ss</span><br><span class="line">System.out.println(now.format(DateTimeFormatter.ofLocalizedDateTime(FormatStyle.MEDIUM)));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 日期解析 </span><br><span class="line">System.out.println(LocalDate.parse(&quot;2019-09-22&quot;));</span><br><span class="line">System.out.println(LocalDateTime.parse(&quot;2019-09-22T21:05:22&quot;));</span><br><span class="line">System.out.println(LocalDateTime.parse(&quot;2019-09-22 21:05:22&quot;,DateTimeFormatter.ofLocalizedDateTime(FormatStyle.MEDIUM)));</span><br></pre></td></tr></table></figure>

<h5 id="4-3-2-3-ZoneId-用来操作时区，它提供了获取所有时区和本地时区的方法"><a href="#4-3-2-3-ZoneId-用来操作时区，它提供了获取所有时区和本地时区的方法" class="headerlink" title="4.3.2.3 ZoneId 用来操作时区，它提供了获取所有时区和本地时区的方法"></a>4.3.2.3 <code>ZoneId</code> 用来操作时区，它提供了获取所有时区和本地时区的方法</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ZoneId zoneId &#x3D; ZoneId.systemDefault();</span><br><span class="line">Set&lt;String&gt; availableZoneIds &#x3D; ZoneId.getAvailableZoneIds();</span><br></pre></td></tr></table></figure>

<h5 id="4-3-2-4-Period，Duration-可以视为一组，用于计算时间间隔"><a href="#4-3-2-4-Period，Duration-可以视为一组，用于计算时间间隔" class="headerlink" title="4.3.2.4 Period，Duration 可以视为一组，用于计算时间间隔"></a>4.3.2.4 <code>Period</code>，<code>Duration</code> 可以视为一组，用于计算时间间隔</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 创建一个两周的间隔</span><br><span class="line">Period periodWeeks &#x3D; Period.ofWeeks(2);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 一年三个月零二天的间隔</span><br><span class="line">Period custom &#x3D; Period.of(1, 3, 2);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 一天的时长</span><br><span class="line">Duration duration &#x3D; Duration.ofDays(1);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 计算2015&#x2F;6&#x2F;16 号到现在 2019&#x2F;09&#x2F;22 过了多久，它这个把间隔分到每个 part 了</span><br><span class="line">LocalDate now &#x3D; LocalDate.now();</span><br><span class="line">LocalDate customDate &#x3D; LocalDate.of(2015, 6, 16);</span><br><span class="line">Period between &#x3D; Period.between(customDate, now);</span><br><span class="line">&#x2F;&#x2F; 结果为 4:3:6 即过去了 4年3个月6天了</span><br><span class="line">System.out.println(between.getYears()+&quot;:&quot;+between.getMonths()+&quot;:&quot;+between.getDays());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 比较两个瞬时的时间间隔 </span><br><span class="line">Instant begin &#x3D; Instant.now();</span><br><span class="line">Instant end &#x3D; Instant.now();</span><br><span class="line">Duration.between(begin,end);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 同样可以修改 part 信息和设置 part 信息，都是返回新的对象来表示设置过的值，原来的对象不变</span><br><span class="line">Period plusDays &#x3D; between.plusDays(1);</span><br><span class="line">Period withDays &#x3D; between.withDays(4);</span><br></pre></td></tr></table></figure>

<h3 id="4-4-Base64"><a href="#4-4-Base64" class="headerlink" title="4.4 Base64"></a>4.4 Base64</h3><p>对于 Base64 终于不用引用第三方包了，使用 java 库就可以完成</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 编码</span><br><span class="line">final String encoded &#x3D; Base64.getEncoder().encodeToString( text.getBytes( StandardCharsets.UTF_8 ) );</span><br><span class="line">&#x2F;&#x2F; 解码</span><br><span class="line">final String decoded &#x3D; new String( Base64.getDecoder().decode( encoded ),StandardCharsets.UTF_8 );</span><br></pre></td></tr></table></figure>

<h3 id="4-5-JUC-工具包扩充"><a href="#4-5-JUC-工具包扩充" class="headerlink" title="4.5 JUC 工具包扩充"></a>4.5 JUC 工具包扩充</h3><p>基于新增的lambda表达式和steam特性，为Java 8中为<strong>java.util.concurrent.ConcurrentHashMap</strong>类添加了新的方法来支持聚焦操作；另外，也为<strong>java.util.concurrentForkJoinPool</strong>类添加了新的方法来支持通用线程池操作（更多内容可以参考<a href="http://academy.javacodegeeks.com/course/java-concurrency-essentials/" target="_blank" rel="noopener">我们的并发编程课程</a>）。</p>
<p>Java 8还添加了新的<strong>java.util.concurrent.locks.StampedLock</strong>类，用于支持基于容量的锁——该锁有三个模型用于支持读写操作（可以把这个锁当做是<strong>java.util.concurrent.locks.ReadWriteLock</strong>的替代者）。</p>
<p>在<strong>java.util.concurrent.atomic</strong>包中也新增了不少工具类，列举如下：</p>
<ul>
<li>DoubleAccumulator</li>
<li>DoubleAdder</li>
<li>LongAccumulator</li>
<li>LongAdder</li>
</ul>
<h2 id="5-新的工具"><a href="#5-新的工具" class="headerlink" title="5. 新的工具"></a>5. 新的工具</h2><p>Java 8提供了一些新的命令行工具，这部分会讲解一些对开发者最有用的工具。</p>
<h3 id="5-1-类依赖分析器：jdeps"><a href="#5-1-类依赖分析器：jdeps" class="headerlink" title="5.1 类依赖分析器：jdeps"></a>5.1 类依赖分析器：jdeps</h3><p><strong>deps</strong>是一个相当棒的命令行工具，它可以展示包层级和类层级的Java类依赖关系，它以<strong>.class</strong>文件、目录或者Jar文件为输入，然后会把依赖关系输出到控制台。</p>
<p>我们可以利用jedps分析下<a href="https://blog.csdn.net/yczz/article/details/50896975" target="_blank" rel="noopener">Spring Framework库</a>，为了让结果少一点，仅仅分析一个JAR文件：<strong>org.springframework.core-3.0.5.RELEASE.jar</strong>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jdeps org.springframework.core-3.0.5.RELEASE.jar</span><br></pre></td></tr></table></figure>

<p>这个命令会输出很多结果，我们仅看下其中的一部分：依赖关系按照包分组，如果在classpath上找不到依赖，则显示”not found”.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">org.springframework.core-3.0.5.RELEASE.jar -&gt; C:\Program Files\Java\jdk1.8.0\jre\lib\rt.jar</span><br><span class="line">   org.springframework.core (org.springframework.core-3.0.5.RELEASE.jar)</span><br><span class="line">      -&gt; java.io                                            </span><br><span class="line">      -&gt; java.lang                                          </span><br><span class="line">      -&gt; java.lang.annotation                               </span><br><span class="line">      -&gt; java.lang.ref                                      </span><br><span class="line">      -&gt; java.lang.reflect                                  </span><br><span class="line">      -&gt; java.util                                          </span><br><span class="line">      -&gt; java.util.concurrent                               </span><br><span class="line">      -&gt; org.apache.commons.logging                         not found</span><br><span class="line">      -&gt; org.springframework.asm                            not found</span><br><span class="line">      -&gt; org.springframework.asm.commons                    not found</span><br><span class="line">   org.springframework.core.annotation (org.springframework.core-3.0.5.RELEASE.jar)</span><br><span class="line">      -&gt; java.lang                                          </span><br><span class="line">      -&gt; java.lang.annotation                               </span><br><span class="line">      -&gt; java.lang.reflect                                  </span><br><span class="line">      -&gt; java.util</span><br></pre></td></tr></table></figure>

<h2 id="一点小推广"><a href="#一点小推广" class="headerlink" title="一点小推广"></a>一点小推广</h2><p>创作不易，希望可以支持下我的开源软件，及我的小工具，欢迎来 gitee 点星，fork ，提 bug 。</p>
<p>Excel 通用导入导出，支持 Excel 公式<br>博客地址：<a href="https://blog.csdn.net/sanri1993/article/details/100601578" target="_blank" rel="noopener">https://blog.csdn.net/sanri1993/article/details/100601578</a><br>gitee：<a href="https://gitee.com/sanri/sanri-excel-poi" target="_blank" rel="noopener">https://gitee.com/sanri/sanri-excel-poi</a></p>
<p>使用模板代码 ，从数据库生成代码 ，及一些项目中经常可以用到的小工具<br>博客地址：<a href="https://blog.csdn.net/sanri1993/article/details/98664034" target="_blank" rel="noopener">https://blog.csdn.net/sanri1993/article/details/98664034</a><br>gitee：<a href="https://gitee.com/sanri/sanri-tools-maven" target="_blank" rel="noopener">https://gitee.com/sanri/sanri-tools-maven</a></p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">陈涛</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://somunstao.github.io/2020/03/21/java%208/">https://somunstao.github.io/2020/03/21/java 8/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://SomunsTao.github.io" target="_blank">Somuns ` Tao</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/java/">java</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="post-qr-code__img" src="/img/wechat.jpg" alt="微信"/><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="post-qr-code__img" src="/img/alipay.jpg" alt="支付寶"/><div class="post-qr-code__desc">支付寶</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2020/03/21/Spring%E7%B3%BB%E5%88%97%E4%B9%8BSpring%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3%E6%80%BB%E7%BB%93/"><img class="prev_cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Spring系列之Spring常用注解总结</div></div></a></div><div class="next-post pull_right"><a href="/2020/03/21/my-first-blog%20%E9%B8%A1%E6%B1%A4/"><img class="next_cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">你，真有进步吗？</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2020/03/21/my-first-blog 鸡汤/" title="你，真有进步吗？"><img class="relatedPosts_cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-03-21</div><div class="relatedPosts_title">你，真有进步吗？</div></div></a></div><div class="relatedPosts_item"><a href="/2020/03/21/java 复习/" title="java 基础知识点复习"><img class="relatedPosts_cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-03-21</div><div class="relatedPosts_title">java 基础知识点复习</div></div></a></div></div><div class="clear_both"></div></div><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div id="lv-container" data-id="city" data-uid="MTAyMC80OTk1Ni8yNjQ0Nw=="><script>(function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
})(document, 'script');</script></div></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 By 陈涛</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">簡</a><i class="darkmode far fa-moon" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script defer id="ribbon" src="/js/third-party/canvas-ribbon.js" size="150" alpha="0.6" zIndex="-1" mobile="true" data-click="true"></script><script id="ribbon_piao" mobile="true" src="/js/third-party/piao.js"></script><script id="canvas_nest" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="true" src="/js/third-party/canvas-nest.js"></script><script src="/js/third-party/activate-power-mode.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
document.body.addEventListener('input', POWERMODE);
</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="/js/third-party/click_heart.js"></script></body></html>