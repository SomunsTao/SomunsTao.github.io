<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Spring 13：Spring框架总结【无比详细】 | Somuns ` Tao</title><meta name="description" content="Spring"><meta name="keywords" content="Spring"><meta name="author" content="陈涛"><meta name="copyright" content="陈涛"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="dns-prefetch" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="dns-prefetch" href="https://fonts.googleapis.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="dns-prefetch" href="//busuanzi.ibruce.info"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Spring 13：Spring框架总结【无比详细】"><meta name="twitter:description" content="Spring"><meta name="twitter:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><meta property="og:type" content="article"><meta property="og:title" content="Spring 13：Spring框架总结【无比详细】"><meta property="og:url" content="https://somunstao.github.io/2020/03/21/Spring%2013%EF%BC%9Aspring%E6%A1%86%E6%9E%B6%E6%80%BB%E7%BB%93/"><meta property="og:site_name" content="Somuns ` Tao"><meta property="og:description" content="Spring"><meta property="og:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><meta property="article:published_time" content="2020-03-20T16:00:00.000Z"><meta property="article:modified_time" content="2020-08-02T09:08:03.589Z"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>var autoChangeMode = '1'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="https://somunstao.github.io/2020/03/21/Spring%2013%EF%BC%9Aspring%E6%A1%86%E6%9E%B6%E6%80%BB%E7%BB%93/"><link rel="prev" title="Redis学习〖二〗Redis实战场景大全" href="https://somunstao.github.io/2020/03/21/Redis%E5%AD%A6%E4%B9%A0%E3%80%96%E4%BA%8C%E3%80%97Redis%E5%AE%9E%E6%88%98%E5%9C%BA%E6%99%AF%E5%A4%A7%E5%85%A8/"><link rel="next" title="SpringBoot21：整合springsecurity" href="https://somunstao.github.io/2020/03/21/SpringBoot21%E2%80%94%E2%80%94%E6%95%B4%E5%90%88springsecurity/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: 'false',
  isFontAwesomeV5: true,
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="Somuns ` Tao" type="application/atom+xml">
</head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">149</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">11</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">11</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 時間軸</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 留言板</span></a></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Spring-13：Spring框架总结【无比详细】"><span class="toc-number">1.</span> <span class="toc-text">Spring 13：Spring框架总结【无比详细】</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1、IOC和DI"><span class="toc-number">1.1.</span> <span class="toc-text">1、IOC和DI</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-applicationContext-amp-BeanFactory区别"><span class="toc-number">1.2.</span> <span class="toc-text">2.applicationContext &amp; BeanFactory区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-spring配置详解"><span class="toc-number">1.3.</span> <span class="toc-text">3.spring配置详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1、元素属性"><span class="toc-number">1.3.1.</span> <span class="toc-text">3.1、元素属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2、bean元素进阶-scope属性-生命周期属性-—————单例多例"><span class="toc-number">1.3.2.</span> <span class="toc-text">3.2、bean元素进阶(  scope属性  生命周期属性)—————单例多例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3、spring三种对象的创建方式"><span class="toc-number">1.3.3.</span> <span class="toc-text">3.3、spring三种对象的创建方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-空参数构造-重要"><span class="toc-number">1.3.4.</span> <span class="toc-text">(1)空参数构造(重要)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-静态工厂创建-调用静态方法创建-调用UserFactory类的静态createUser方法创建名为user的对象-放入容器"><span class="toc-number">1.3.5.</span> <span class="toc-text">(2)静态工厂创建(调用静态方法创建) 调用UserFactory类的静态createUser方法创建名为user的对象,放入容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-实例工厂创建-调用非静态方法创建-——需要配置两个bean，因为无法通过类名调用非静态方法"><span class="toc-number">1.3.6.</span> <span class="toc-text">(3)实例工厂创建(调用非静态方法创建)——需要配置两个bean，因为无法通过类名调用非静态方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4、spring注入方式"><span class="toc-number">1.3.7.</span> <span class="toc-text">3.4、spring注入方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-set方式注入-重点-————值类型用value注入-引用类型用ref注入"><span class="toc-number">1.3.8.</span> <span class="toc-text">(1)set方式注入(重点)————值类型用value注入   引用类型用ref注入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-构造方法注入"><span class="toc-number">1.3.9.</span> <span class="toc-text">(2)构造方法注入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-array数组的注入"><span class="toc-number">1.3.10.</span> <span class="toc-text">1.array数组的注入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-list集合的注入"><span class="toc-number">1.3.11.</span> <span class="toc-text">2.list集合的注入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-map集合的注入"><span class="toc-number">1.3.12.</span> <span class="toc-text">3.map集合的注入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-properties的注入"><span class="toc-number">1.3.13.</span> <span class="toc-text">4.properties的注入</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4、防止创建多个applicationContext取值-并指定记载spring配置文件的位置——web-xml"><span class="toc-number">1.4.</span> <span class="toc-text">4、防止创建多个applicationContext取值&#x2F;并指定记载spring配置文件的位置——web.xml</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5、使用注解方式代替配置文件-官方推荐使用注解"><span class="toc-number">1.5.</span> <span class="toc-text">5、使用注解方式代替配置文件(官方推荐使用注解)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-在applicationContext-xml中书写指定扫描注解"><span class="toc-number">1.5.1.</span> <span class="toc-text">1.在applicationContext.xml中书写指定扫描注解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-在类中书写Component"><span class="toc-number">1.5.2.</span> <span class="toc-text">2.在类中书写Component</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-指定对象的作用范围Scope"><span class="toc-number">1.5.3.</span> <span class="toc-text">3.指定对象的作用范围Scope</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-值类型的注入"><span class="toc-number">1.5.4.</span> <span class="toc-text">4.值类型的注入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-引用类型的注入"><span class="toc-number">1.5.5.</span> <span class="toc-text">5.引用类型的注入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-创建与销毁方法"><span class="toc-number">1.5.6.</span> <span class="toc-text">6.创建与销毁方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-spring整合junit测试-spring创建容器"><span class="toc-number">1.5.7.</span> <span class="toc-text">7.spring整合junit测试(spring创建容器)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6、spring中AOP名词解释"><span class="toc-number">1.6.</span> <span class="toc-text">6、spring中AOP名词解释</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7、spring中的aop使用注解配置"><span class="toc-number">1.7.</span> <span class="toc-text">7、spring中的aop使用注解配置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8、spring整合jdbc"><span class="toc-number">1.8.</span> <span class="toc-text">8、spring整合jdbc</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9、spring中的aop事务"><span class="toc-number">1.9.</span> <span class="toc-text">9、spring中的aop事务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#事务的四大基本特性："><span class="toc-number">1.10.</span> <span class="toc-text">事务的四大基本特性：</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#事物的概述"><span class="toc-number">2.</span> <span class="toc-text">事物的概述</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#⑴-原子性（-Atomicity-）"><span class="toc-number">2.1.</span> <span class="toc-text">\⑴\ *原子性（**Atomicity**）***</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#⑵-一致性（-Consistency-）"><span class="toc-number">2.2.</span> <span class="toc-text">\⑵\ *一致性（**Consistency**）***</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#⑶-隔离性（-Isolation-）"><span class="toc-number">2.3.</span> <span class="toc-text">\⑶\ *隔离性（**Isolation**）***</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#⑷-持久性（-Durability-）"><span class="toc-number">2.4.</span> <span class="toc-text">\⑷\ *持久性（**Durability**）***</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#spring中事务的分类："><span class="toc-number">2.5.</span> <span class="toc-text">spring中事务的分类：</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#10、spring中aop管理事务-注解使用步骤"><span class="toc-number">3.</span> <span class="toc-text">10、spring中aop管理事务 注解使用步骤</span></a></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">Somuns ` Tao</a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 時間軸</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 留言板</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">Spring 13：Spring框架总结【无比详细】</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2020-03-21 00:00:00"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2020-03-21</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2020-08-02 17:08:03"><i class="fa fa-history" aria-hidden="true"></i> 更新于 2020-08-02</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Spring/">Spring</a></span></div><div class="meta-secondline"> </div><div class="meta-thirdline"><span class="post-meta-pv-cv"><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><p>​    </p>
<h1 id="Spring-13：Spring框架总结【无比详细】"><a href="#Spring-13：Spring框架总结【无比详细】" class="headerlink" title="Spring 13：Spring框架总结【无比详细】"></a>Spring 13：Spring框架总结【无比详细】</h1><p>以下内容是我在初学spring时候做的笔记，当时是把比较放在了备忘录里面，如今把笔记重整到csdn上，为了复习也为了分析给大家，笔记写的算比较完整，回看自己做的还是有点羞涩。如有错误之处，欢迎指正，当我日后更强大的时候，我会不断的对内容进行补充和完善。当然学习也就是这么一个过程，学习-实践-总结-实践-总结…  转载请申明原文地址，希望大家支持，谢谢。</p>
<h2 id="1、IOC和DI"><a href="#1、IOC和DI" class="headerlink" title="1、IOC和DI"></a>1、IOC和DI</h2><p><strong>IOC: 控制反转</strong><br>即控制权的转移，将我们创建对象的方式反转了,以前对象的创建是由我们开发人员自己维护,包括依赖关系也是自己注入。使用了spring之后，对象的创建以及依赖关系可以由spring完成创建以及注入，反转控制就是反转了对象的创建方式，从我们自己创建反转给了程序创建(spring)</p>
<p><strong>DI:  Dependency Injection  依赖注入</strong><br>spring这个容器中，替你管理着一系列的类，前提是你需要将这些类交给spring容器进行管理，然后在你需要的时候，不是自己去定义，而是直接向spring容器索取，当spring容器知道你的需求之后，就会去它所管理的组件中进行查找，然后直接给你所需要的组件.<br>实现IOC思想需要DI做支持<br>注入方式:  1.set方式注入   2.构造方法注入  3.字段注入<br>注入类型:  1.值类型注入    2.引用类型注入</p>
<p>好处: </p>
<blockquote>
<p>1.降低组件之间的耦合度，实现软件各层之间的解耦. </p>
<p>2.可以使容器提供众多服务如事务管理消息服务处理等等。当我们使用容器管理事务时，开发人员就不需要手工 控制事务，也不需要处理复杂的事务传播</p>
<p> 3.容器提供单例模式支持，开发人员不需要自己编写实现代码.</p>
<p> 4.容器提供了AOP技术，利用它很容易实现如权限拦截，运行期监控等功能 </p>
<p>5.容器提供众多的辅佐类，使这些类可以加快应用的开发.如jdbcTemplate HibernateTemplate</p>
</blockquote>
<h2 id="2-applicationContext-amp-BeanFactory区别"><a href="#2-applicationContext-amp-BeanFactory区别" class="headerlink" title="2.applicationContext &amp; BeanFactory区别"></a>2.applicationContext &amp; BeanFactory区别</h2><p><strong>BeanFactory接口</strong><br>(1) spring的原始接口，针对原始接口的实现类功能较为单一<br>(2)BeanFactory接口实现类的容器，特点是每次在获得对象时才会创建对象</p>
<p><strong>ApplicationContext接口</strong><br>(1)每次容器启动时就会创建容器中配置的所有对象<br>(2)提供了更多功能<br>(3)从类路径下加载配置文件: ClassPathXmlApplicationContext<br>从硬盘的绝对路径下加载配置文件:FileSystemXmlApplication</p>
<h2 id="3-spring配置详解"><a href="#3-spring配置详解" class="headerlink" title="3.spring配置详解"></a>3.spring配置详解</h2><h3 id="3-1、元素属性"><a href="#3-1、元素属性" class="headerlink" title="3.1、元素属性"></a>3.1、元素属性</h3><p>  bean元素:使用该元素描述需要spring容器管理对象<br>   name属性:给被管理的对象起个名字,获得对象时getBean(“name值”)<br>   class属性:被管理对象的完整类名<br>   id属性:与name属性一模一样，名称不可重复，不能使用特殊字符</p>
<p><strong><em>\</em>name和id之间的一些注意点：**</strong><br>1、配置两个相同的 id 或者 name 都不能通过。<br>2、如果既配置了 id ，也配置了 name ，则两个都生效。如果id和name都没有指定，则用类全名作为name，如<bean class="com.stamen.BeanLifeCycleImpl">,则你可以通过getBean(“com.stamen.BeanLifeCycleImpl”)返回该实例。<br>3、如果配置基本类的时候，注解和配置文件都使用的时候，注解和配置文件中 name 相同的时候， 则两个冲突，配置文件生效。<br>   如果配置基本类的时候，注解和配置文件都使用的时候，注解和配置文件中 name 不相同的时候， 则两个不冲突，都能够生效。</p>
<h3 id="3-2、bean元素进阶-scope属性-生命周期属性-—————单例多例"><a href="#3-2、bean元素进阶-scope属性-生命周期属性-—————单例多例" class="headerlink" title="3.2、bean元素进阶(  scope属性  生命周期属性)—————单例多例"></a>3.2、bean元素进阶(  scope属性  生命周期属性)—————单例多例</h3><p><strong>(1)scope属性</strong><br>   (1)singleton  默认值<br>单例对象  :被标识为单例的对象在spring容器中只会存在一个实例<br>  (2)prototype<br>多例原型:被标识为多例的对象,每次在获得才会被创建,每次创建都是新的对象<br>  (3)request<br>Web环境下,对象与request生命周期一致<br>   (4)session<br>Web环境下,对象与session生命周期一致<br>总结:绝大多数情况下，使用单例singleton(默认值)，但是在与struts整合时候，务必要用prototype多例，因为struts2在每次请求都会创建一个新的Action，若为单例，在多请求情况下，每个请求找找spring拿的都是同一个action。</p>
<p><strong>(2)生命周期属性(了解)———初始化和销毁</strong><br>   (1)配置一个方法作为生命周期初始化方法,spring会在对象<strong>创建之后</strong>立刻调用 init-method<br>   (2)配置一个方法作为生命周期的销毁方法,spring容器在关闭并销毁所有容器中的对象<strong>之前</strong>调用destory-method<br>  <bean init-method=“init”  destory-method=“destory”></bean>     <strong>对应注解为@PostConstruct</strong></p>
<p>  <bean name=“hello” class=“完整类名”></bean>                 <strong>对应注解为@PreDestory</strong></p>
<p><strong>(3)模块化配置,即分模块配置(导入其他spring配置文件)</strong><br><beans><br>   <import resource = “spring配置文件的全路径名” /><br></beans></p>
<h3 id="3-3、spring三种对象的创建方式"><a href="#3-3、spring三种对象的创建方式" class="headerlink" title="3.3、spring三种对象的创建方式"></a>3.3、spring三种对象的创建方式</h3><h3 id="1-空参数构造-重要"><a href="#1-空参数构造-重要" class="headerlink" title="(1)空参数构造(重要)"></a><strong>(1)空参数构造(重要)</strong></h3><p><img src="https://img-blog.csdn.net/20180807144403876?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2l0Y2F0c19jbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<h3 id="2-静态工厂创建-调用静态方法创建-调用UserFactory类的静态createUser方法创建名为user的对象-放入容器"><a href="#2-静态工厂创建-调用静态方法创建-调用UserFactory类的静态createUser方法创建名为user的对象-放入容器" class="headerlink" title="(2)静态工厂创建(调用静态方法创建) 调用UserFactory类的静态createUser方法创建名为user的对象,放入容器"></a><strong>(2)静态工厂创建(调用静态方法创建)</strong> 调用UserFactory类的静态createUser方法创建名为user的对象,放入容器</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;bean name=<span class="string">"user"</span> class=<span class="string">"cn.itcats.UserFactory"</span> factory-method=<span class="string">"createUser"</span>&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<h3 id="3-实例工厂创建-调用非静态方法创建-——需要配置两个bean，因为无法通过类名调用非静态方法"><a href="#3-实例工厂创建-调用非静态方法创建-——需要配置两个bean，因为无法通过类名调用非静态方法" class="headerlink" title="(3)实例工厂创建(调用非静态方法创建)——需要配置两个bean，因为无法通过类名调用非静态方法"></a><strong>(3)实例工厂创建(调用非静态方法创建)——需要配置两个bean，因为无法通过类名调用非静态方法</strong></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;bean name=<span class="string">"user2"</span> factory-bean=<span class="string">"userFactory"</span> factory-method=<span class="string">"createUser"</span>&gt;&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;bean name=“userFactory” class=“cn.itcats.UserFactory”&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure>



<h3 id="3-4、spring注入方式"><a href="#3-4、spring注入方式" class="headerlink" title="3.4、spring注入方式"></a>3.4、spring注入方式</h3><h3 id="1-set方式注入-重点-————值类型用value注入-引用类型用ref注入"><a href="#1-set方式注入-重点-————值类型用value注入-引用类型用ref注入" class="headerlink" title="(1)set方式注入(重点)————值类型用value注入   引用类型用ref注入"></a><strong>(1)set方式注入(重点)————值类型用value注入   引用类型用ref注入</strong></h3><p><img src="https://img-blog.csdn.net/20180807145109555?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2l0Y2F0c19jbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<h3 id="2-构造方法注入"><a href="#2-构造方法注入" class="headerlink" title="(2)构造方法注入"></a><strong>(2)构造方法注入</strong></h3><p><img src="https://img-blog.csdn.net/20180807145407221?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2l0Y2F0c19jbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<p><strong>函数注入</strong><br>(3)p名称空间注入———<strong>实际上set注入，spring特有，为了简化写法</strong></p>
<p>  1、applicationContext.xml中<beans>标签头部导入p命名空间</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xmlns:p=<span class="string">"http://www.springframework.org/schema/p"</span></span><br></pre></td></tr></table></figure>

<p>  2、书写格式：值类型注入——  p:属性名=”值”    引用类型注入——  p:属性名-ref=”引用的<bean> name属性”</p>
<p>​    把Run类中的name属性值设置为haha，age属性设置为20，引用属性hello引用<bean name="hello" class="..."></bean></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;bean name=<span class="string">"run2"</span> class=<span class="string">"cn.itcats.thread.Run"</span> p:name=<span class="string">"haha"</span> p:age=<span class="string">"20"</span> p:hello-ref=<span class="string">"hello"</span>&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure>



<p> (4)spel注入: spring Expression Language spring表达式语言</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;bean name=<span class="string">"runSpel"</span> class=<span class="string">"cn.itcats.thread.Run"</span>&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;!-- 取bean标签中name为<span class="string">"user"</span>中property为<span class="string">"name"</span>中的value值 --!&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;property name=<span class="string">"name"</span> value=<span class="string">"#&#123;user.name&#125;"</span>&gt;&lt;/property&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<p>SpEL特性：(1)、使用Bean的ID来引用Bean；(2)、调用方法和访问对象的属性；(3)、对值进行算术、关系和逻辑运算；(4)、正则表达式匹配；(5)、集合操作</p>
<p>关于spel  <a href="https://www.cnblogs.com/goodcheap/p/6490896.html" target="_blank" rel="noopener">https://www.cnblogs.com/goodcheap/p/6490896.html</a></p>
<p><strong>复杂类型注入</strong></p>
<h3 id="1-array数组的注入"><a href="#1-array数组的注入" class="headerlink" title="1.array数组的注入"></a>1.array数组的注入</h3><p><img src="https://img-blog.csdn.net/20180807153348350?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2l0Y2F0c19jbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<h3 id="2-list集合的注入"><a href="#2-list集合的注入" class="headerlink" title="2.list集合的注入"></a>2.list集合的注入</h3><p><img src="https://img-blog.csdn.net/20180807153635976?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2l0Y2F0c19jbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<h3 id="3-map集合的注入"><a href="#3-map集合的注入" class="headerlink" title="3.map集合的注入"></a>3.map集合的注入</h3><p><img src="https://img-blog.csdn.net/20180807153659740?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2l0Y2F0c19jbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<h3 id="4-properties的注入"><a href="#4-properties的注入" class="headerlink" title="4.properties的注入"></a>4.properties的注入</h3><p><img src="https://img-blog.csdn.net/20180807153755364?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2l0Y2F0c19jbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<h2 id="4、防止创建多个applicationContext取值-并指定记载spring配置文件的位置——web-xml"><a href="#4、防止创建多个applicationContext取值-并指定记载spring配置文件的位置——web-xml" class="headerlink" title="4、防止创建多个applicationContext取值/并指定记载spring配置文件的位置——web.xml"></a>4、防止创建多个applicationContext取值/并指定记载spring配置文件的位置——web.xml</h2><p>  1、需要导入包spring-web<br>  2、在web.xml中配置<strong><em>\</em>监听器**</strong></p>
<p><img src="https://img-blog.csdn.net/20180807154046934?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2l0Y2F0c19jbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<h2 id="5、使用注解方式代替配置文件-官方推荐使用注解"><a href="#5、使用注解方式代替配置文件-官方推荐使用注解" class="headerlink" title="5、使用注解方式代替配置文件(官方推荐使用注解)"></a>5、使用注解方式代替配置文件(官方推荐使用注解)</h2><h3 id="1-在applicationContext-xml中书写指定扫描注解"><a href="#1-在applicationContext-xml中书写指定扫描注解" class="headerlink" title="1.在applicationContext.xml中书写指定扫描注解"></a><strong>1.在applicationContext.xml中书写指定扫描注解</strong></h3><p><img src="https://img-blog.csdn.net/20180807154739325?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2l0Y2F0c19jbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<h3 id="2-在类中书写Component"><a href="#2-在类中书写Component" class="headerlink" title="2.在类中书写Component"></a><strong>2.在类中书写Component</strong></h3><p><img src="https://img-blog.csdn.net/20180807155042318?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2l0Y2F0c19jbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<p>注意：假如不写括号内的值(即name或id)，默认使用类名首字母小写作为搜索，为什么意思呢？</p>
<p>比如Student类中使用了@Component  没有书写括号和值，那么默认搜索id或name为student。</p>
<h3 id="3-指定对象的作用范围Scope"><a href="#3-指定对象的作用范围Scope" class="headerlink" title="3.指定对象的作用范围Scope"></a><strong>3.指定对象的作用范围Scope</strong></h3><p><img src="https://img-blog.csdn.net/20180807155504829?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2l0Y2F0c19jbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<p>​     声明Student类对象为多例    下面是对singleton和prototype的一些补充</p>
<blockquote>
<ul>
<li>singleton作用域：当把一个Bean定义设置为singleton作用域是，Spring IoC容器中只会存在一个共享的Bean实例，并且所有对Bean的请求，只要id与该Bean定义相匹配，则只会返回该Bean的同一实例。值得强调的是singleton作用域是Spring中的缺省作用域。</li>
<li>prototype作用域：prototype作用域的Bean会导致在每次对该Bean请求（将其注入到另一个Bean中，或者以程序的方式调用容器的getBean()方法）时都会创建一个新的Bean实例。根据经验，对有状态的Bean应使用prototype作用域，而对无状态的Bean则应该使用singleton作用域。对于具有prototype作用域的Bean，有一点很重要，即Spring不能对该Bean的整个生命周期负责。具有prototype作用域的Bean创建后交由调用者负责销毁对象回收资源。简单的说：</li>
<li>singleton 只有一个实例，也即是<a href="https://www.baidu.com/s?wd=单例模式&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">单例模式</a>。</li>
<li>prototype访问一次创建一个实例，相当于new。</li>
</ul>
</blockquote>
<h3 id="4-值类型的注入"><a href="#4-值类型的注入" class="headerlink" title="4.值类型的注入"></a><strong>4.值类型的注入</strong></h3><p>​                                            <strong>实际通过反射field赋值</strong></p>
<p><img src="https://img-blog.csdn.net/20180807160601898?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2l0Y2F0c19jbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<p>​                                            <strong>实际通过set方式赋值</strong></p>
<p><img src="https://img-blog.csdn.net/20180807160655555?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2l0Y2F0c19jbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<h3 id="5-引用类型的注入"><a href="#5-引用类型的注入" class="headerlink" title="5.引用类型的注入"></a><strong>5.引用类型的注入</strong></h3><p><strong>面试题: @AutoWired和@Resource的区别?</strong></p>
<p><strong>@AutoWired默认以类型进行查找，@Resource默认以名称进行查找</strong></p>
<p><strong>@AutoWired(required=false)   +  @Qualifier(“user”)   ==  @Resource(name=”user”)</strong></p>
<p><strong>其中@Resource注解是jdk1.6后才有的</strong></p>
<p><img src="https://img-blog.csdn.net/20180807160824814?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2l0Y2F0c19jbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<p><img src="https://img-blog.csdn.net/20180807160946214?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2l0Y2F0c19jbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<h3 id="6-创建与销毁方法"><a href="#6-创建与销毁方法" class="headerlink" title="6.创建与销毁方法"></a><strong>6.创建与销毁方法</strong></h3><p><img src="https://img-blog.csdn.net/20180807161040371?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2l0Y2F0c19jbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<h3 id="7-spring整合junit测试-spring创建容器"><a href="#7-spring整合junit测试-spring创建容器" class="headerlink" title="7.spring整合junit测试(spring创建容器)"></a>7.spring整合junit测试(spring创建容器)</h3><blockquote>
<p>   @RunWith(SpringJUnit4ClassRunner.class)<br>   @ContextConfiguration(“classpath:applicationContext.xml”)  </p>
</blockquote>
<p><img src="https://img-blog.csdn.net/20180807161406945?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2l0Y2F0c19jbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<h2 id="6、spring中AOP名词解释"><a href="#6、spring中AOP名词解释" class="headerlink" title="6、spring中AOP名词解释"></a>6、spring中AOP名词解释</h2><blockquote>
<p>JoinPoint(连接点):目标对象中,所有可以增强的方法，就是spring允许你是通知（Advice）的地方，那可就真多了，基本每个方法的前、后（两者都有也行），或抛出异常是时都可以是连接点，spring只支持方法连接点。</p>
<p>Pointcut(切入点):目标对象中,已经被增强的方法。调用这几个方法之前、之后或者抛出异常时干点什么，那么就用切入点来定义这几个方法。</p>
<p>Advice(通知/增强) :增强方法的代码、想要的功能。</p>
<p>Target(目标对象):被代理对象，被通知的对象，被增强的类对象。</p>
<p>Weaving(织入):将通知应用到连接点形成切入点的过程</p>
<p>Proxy(代理):将通知织入到目标对象之后形成的代理对象</p>
<p>aspect(切面):切入点+通知————通知(Advice)说明了干什么的内容(即方法体代码)和什么时候干（什么时候通过方法名中的before，after，around等就能知道），二切入点说明了在哪干（指定到底是哪个方法），切点表达式等定义。</p>
</blockquote>
<p>虽然现在都用Maven项目构建，但是不能忘记，使用aop需要用到的包：spring-aop + spring-aspects   + springsource.org.aopalliance  + springsource.org.aspectj.weaver </p>
<p>关于AOP看一个小例子：</p>
<p> <strong>1、准备目标对象(被代理对象，被通知的对象，被增强的类对象)</strong></p>
<p><img src="https://img-blog.csdn.net/20180807164638982?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2l0Y2F0c19jbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<p>   <strong>2、准备通知(被增强方法的代码，想要实现功能的方法代码)</strong></p>
<p><img src="https://img-blog.csdn.net/20180807164847918?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2l0Y2F0c19jbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<p>​    <strong>3、配置 applicationContext.xml</strong><br>​      1.导入aop(约束)命名空间<br>​      2.配置目标对象<br>​      3.配置通知对象<br>​      4.配置将通知织入目标对象</p>
<p><img src="https://img-blog.csdn.net/20180807165310404?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2l0Y2F0c19jbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<p>​    <strong>4、测试</strong></p>
<p><img src="https://img-blog.csdn.net/20180807170443480?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2l0Y2F0c19jbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<blockquote>
<p>总结：通知的几种类型<br>   1.前置通知———目标方法运行之前调用<br>   2.后置通知———目标方法运行之后调用(如果出现异常不调用)<br>   3.环绕通知———目标方法之前和之后都调用<br>   4.异常拦截通知———如果出现异常，就会调用<br>   5.后置通知———目标方法运行之后调用(无论是否出现异常都会调用)</p>
</blockquote>
<h2 id="7、spring中的aop使用注解配置"><a href="#7、spring中的aop使用注解配置" class="headerlink" title="7、spring中的aop使用注解配置"></a>7、spring中的aop使用注解配置</h2><p>​    <strong>1、applicationContext.xml中配置目标对象，通知对象，开启使用注解完成织入</strong></p>
<p><img src="https://img-blog.csdn.net/20180807172145664?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2l0Y2F0c19jbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<p>   2、<strong>@Aspect</strong>注解代表该类是个通知类，书写切点表达式<strong>@Pointcut</strong>(“execution(返回值 全类名.方法名(参数))”)</p>
<p><img src="https://img-blog.csdn.net/20180807172350874?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2l0Y2F0c19jbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<p>注意环绕通知需要这么写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">around</span><span class="params">(ProceedingJoinPoint proceedingJoinPoint)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	    <span class="comment">//环绕方法执行前</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">//proceedingJoinPoint.proceed();表示对拦截的方法进行放行</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">//若注释proceedingJoinPoint.proceed()则不会执行被AOP匹配的方法</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">			proceedingJoinPoint.proceed();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">//环绕方法执行后</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>AOP注解解析：</p>
<blockquote>
<p><code>@Before</code> 前置通知（Before advice） ：在某连接点（JoinPoint）——核心代码（类或者方法）之前执行的通知，但这个通知不能阻止连接点前的执行。为啥不能阻止线程进入核心代码呢？因为@Before注解的方法入参不能传ProceedingJoinPoint，而只能传入JoinPoint。要知道从aop走到核心代码就是通过调用ProceedingJionPoint的proceed()方法。而JoinPoint没有这个方法。<br>这里牵扯区别这两个类：Proceedingjoinpoint 继承了 JoinPoint 。是在JoinPoint的基础上暴露出 proceed 这个方法。proceed很重要，这个是aop代理链执行的方法。暴露出这个方法，就能支持 aop:around 这种切面（而其他的几种切面只需要用到JoinPoint，这跟切面类型有关）， 能决定是否走代理链还是走自己拦截的其他逻辑。建议看一下 JdkDynamicAopProxy的invoke方法，了解一下代理链的执行原理。这样你就能明白 proceed方法的重要性。</p>
<p><code>@After</code> 后通知（After advice） ：当某连接点退出的时候执行的通知（不论是正常返回还是异常退出）。</p>
<p><code>@AfterReturning</code> 返回后通知（After return advice） ：在某连接点正常完成后执行的通知，不包括抛出异常的情况。</p>
<p><code>@Around</code> 环绕通知（Around advice） ：包围一个连接点的通知，类似Web中Servlet规范中的Filter的doFilter方法。可以在方法的调用前后完成自定义的行为，也可以选择不执行。这时aop的最重要的，最常用的注解。用这个注解的方法入参传的是ProceedingJionPoint pjp，可以决定当前线程能否进入核心方法中——通过调用pjp.proceed();</p>
<p><code>@AfterThrowing</code> 抛出异常后通知（After throwing advice） ： 在方法抛出异常退出时执行的通知。</p>
</blockquote>
<h2 id="8、spring整合jdbc"><a href="#8、spring整合jdbc" class="headerlink" title="8、spring整合jdbc"></a>8、spring整合jdbc</h2><p>   spring中提供了一个可以操作数据库的对象，对象封装了jdbc技术 ————JDBCTemplate JDBC模板对象，而JdbcDaoSupport则对JdbcTemplate进行了封装，所以要操作JdbcTemplate，或只需要继承JdbcDaoSupport即可。</p>
<p><img src="https://img-blog.csdn.net/20180807174204755?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2l0Y2F0c19jbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<p><img src="https://img-blog.csdn.net/2018080717424540?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2l0Y2F0c19jbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<p>​     依赖关系配置：</p>
<p><img src="https://img-blog.csdn.net/20180807175348552?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2l0Y2F0c19jbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<p>​        <strong>测试：</strong></p>
<p><img src="https://img-blog.csdn.net/20180807175618666?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2l0Y2F0c19jbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<p>​         </p>
<h2 id="9、spring中的aop事务"><a href="#9、spring中的aop事务" class="headerlink" title="9、spring中的aop事务"></a>9、spring中的aop事务</h2><p><img src="https://img-blog.csdn.net/20180807195216838?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2l0Y2F0c19jbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<h2 id="事务的四大基本特性："><a href="#事务的四大基本特性：" class="headerlink" title="事务的四大基本特性："></a>事务的四大基本特性：</h2><blockquote>
<h1 id="事物的概述"><a href="#事物的概述" class="headerlink" title="事物的概述"></a><strong>事物的概述</strong></h1><h2 id="⑴-原子性（-Atomicity-）"><a href="#⑴-原子性（-Atomicity-）" class="headerlink" title="\⑴\ *原子性（**Atomicity**）***"></a><strong><em>\</em>⑴\</strong> *<em>原子性（*</em>*<em>Atomicity*</em>*<em>）***</em></h2><p>　　原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚，因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。</p>
<h2 id="⑵-一致性（-Consistency-）"><a href="#⑵-一致性（-Consistency-）" class="headerlink" title="\⑵\ *一致性（**Consistency**）***"></a><strong><em>\</em>⑵\</strong> *<em>一致性（*</em>*<em>Consistency*</em>*<em>）***</em></h2><p>　　一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。</p>
<p>　　拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性。</p>
<h2 id="⑶-隔离性（-Isolation-）"><a href="#⑶-隔离性（-Isolation-）" class="headerlink" title="\⑶\ *隔离性（**Isolation**）***"></a><strong><em>\</em>⑶\</strong> *<em>隔离性（*</em>*<em>Isolation*</em>*<em>）***</em></h2><p>　　隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。</p>
<p>　　即要达到这么一种效果：对于任意两个并发的事务T1和T2，在事务T1看来，T2要么在T1开始之前就已经结束，要么在T1结束之后才开始，这样每个事务都感觉不到有其他事务在并发地执行。</p>
<p>　　关于事务的隔离性数据库提供了多种隔离级别，稍后会介绍到。</p>
<h2 id="⑷-持久性（-Durability-）"><a href="#⑷-持久性（-Durability-）" class="headerlink" title="\⑷\ *持久性（**Durability**）***"></a><strong><em>\</em>⑷\</strong> *<em>持久性（*</em>*<em>Durability*</em>*<em>）***</em></h2><p>　　持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。</p>
<p>　　例如我们在使用JDBC操作数据库时，在提交事务方法后，提示用户事务操作完成，当我们程序执行完成直到看到提示后，就可以认定事务以及正确提交，即使这时候数据库出现了问题，也必须要将我们的事务完全执行完成，否则就会造成我们看到提示事务处理完毕，但是数据库因为故障而没有执行事务的重大错误。</p>
</blockquote>
<p><strong>关于事务的隔离级别我之前发布了一篇文章</strong>：<a href="https://blog.csdn.net/itcats_cn/article/details/81487466" target="_blank" rel="noopener">https://blog.csdn.net/itcats_cn/article/details/81487466</a></p>
<h2 id="spring中事务的分类："><a href="#spring中事务的分类：" class="headerlink" title="spring中事务的分类："></a>spring中事务的分类：</h2><p>spring中事务可以分为编程式事务控制和声明式事务控制。</p>
<blockquote>
<p><strong><em>\</em>编程式事务控制**</strong></p>
<p>​    自己手动控制事务，就叫做编程式事务控制。</p>
<p>​    Jdbc代码：</p>
<p>​       Conn.setAutoCommit(false); // 设置手动控制事务</p>
<p>​    Hibernate代码：</p>
<p>​       Session.beginTransaction();  // 开启一个事务</p>
<p>​    【细粒度的事务控制： 可以对指定的方法、指定的方法的某几行添加事务控制】</p>
<p>​    (比较灵活，但开发起来比较繁琐： 每次都要开启、提交、回滚.)</p>
<p><strong><em>\</em>声明式事务控制**</strong></p>
<p>​    Spring提供了对事务的管理, 这个就叫声明式事务管理。</p>
<p>​    Spring提供了对事务控制的实现。用户如果想用Spring的声明式事务管理，只需要在配置文件中配置即可； 不想使用时直接移除配置。这个实现了对事务控制的最大程度的解耦。</p>
<p>​    Spring声明式事务管理，核心实现就是基于Aop。</p>
<p>​    【粗粒度的事务控制： 只能给整个方法应用事务，不可以对方法的某几行应用事务。】</p>
<p>​    (因为aop拦截的是方法。)</p>
<p>​    Spring声明式事务管理器类：</p>
<p>​       Jdbc技术：<strong><em>\</em>DataSourceTransactionManager**</strong></p>
<p>​       Hibernate技术：<strong><em>\</em>HibernateTransactionManager**</strong></p>
</blockquote>
<p>有一点需要注意的：若为<strong><em>\</em>编程式事务控制**</strong>，则开启事务后一定要手动释放(提交或回滚)，否则长期占用内存，有可能报事务异常</p>
<p>spring封装了事务管理的代码(打开，提交，回滚事务)<br>事务操作对象,因为在不同平台,操作事务的代码各不相同.spring提供了一个接口<br>————— PlatformTransactionManager 接口<br>————— 在不同平台,实现不同的接口即可<br>————— 注意:在spring中玩事务管理.最为核心的对象就是TransactionManager对象</p>
<p><img src="https://img-blog.csdn.net/20180807234619190?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2l0Y2F0c19jbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<p>spring管理事务的属性介绍<br>     (1)事务的隔离级别<br>     (2)是否只读<br>     (3)事务的传播行为</p>
<p>配置事务的核心管理器，它封装了所有事务，依赖于连接池(DataSourceTransactionManager)</p>
<p><img src="https://img-blog.csdn.net/2018080723485451?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2l0Y2F0c19jbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<p>xml中配置通知</p>
<p><img src="https://img-blog.csdn.net/201808072350066?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2l0Y2F0c19jbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<p>配置将通知织入目标</p>
<p><img src="https://img-blog.csdn.net/20180808000556851?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2l0Y2F0c19jbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<h1 id="10、spring中aop管理事务-注解使用步骤"><a href="#10、spring中aop管理事务-注解使用步骤" class="headerlink" title="10、spring中aop管理事务 注解使用步骤"></a>10、<strong>spring中aop管理事务 注解使用步骤</strong></h1><p><img src="https://img-blog.csdn.net/20180808000840926?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2l0Y2F0c19jbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<p>在需要管理的方法或者类中声明配置事务管理</p>
<p>@Transactional(isolation=Isolation.REPEATABLE_READ,readOnly=false,propagation=Propagation.REQUIRED)</p>
<p><img src="https://img-blog.csdn.net/20180808001009352?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2l0Y2F0c19jbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">陈涛</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://somunstao.github.io/2020/03/21/Spring%2013%EF%BC%9Aspring%E6%A1%86%E6%9E%B6%E6%80%BB%E7%BB%93/">https://somunstao.github.io/2020/03/21/Spring 13：spring框架总结/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://SomunsTao.github.io" target="_blank">Somuns ` Tao</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Spring/">Spring</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="post-qr-code__img" src="/img/wechat.jpg" alt="微信"/><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="post-qr-code__img" src="/img/alipay.jpg" alt="支付寶"/><div class="post-qr-code__desc">支付寶</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2020/03/21/Redis%E5%AD%A6%E4%B9%A0%E3%80%96%E4%BA%8C%E3%80%97Redis%E5%AE%9E%E6%88%98%E5%9C%BA%E6%99%AF%E5%A4%A7%E5%85%A8/"><img class="prev_cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Redis学习〖二〗Redis实战场景大全</div></div></a></div><div class="next-post pull_right"><a href="/2020/03/21/SpringBoot21%E2%80%94%E2%80%94%E6%95%B4%E5%90%88springsecurity/"><img class="next_cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">SpringBoot21：整合springsecurity</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2020/03/11/Spring 01：Spring — Spring简介、入门、配置 , IoC和DI思想/" title="Spring 01：Spring简介、入门、配置 , IoC和DI思想"><img class="relatedPosts_cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-03-11</div><div class="relatedPosts_title">Spring 01：Spring简介、入门、配置 , IoC和DI思想</div></div></a></div><div class="relatedPosts_item"><a href="/2020/03/12/Spring 02：IoC核心(基于XML)、DI核心(基于XML)/" title="Spring 02：IoC核心(基于XML)、DI核心(基于XML)"><img class="relatedPosts_cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-03-12</div><div class="relatedPosts_title">Spring 02：IoC核心(基于XML)、DI核心(基于XML)</div></div></a></div><div class="relatedPosts_item"><a href="/2020/03/13/Spring 03：使用IoC和DI模拟注册案例、注解配置IoC和DI/" title="Spring 03：使用IoC和DI模拟注册案例、注解配置IoC和DI"><img class="relatedPosts_cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-03-13</div><div class="relatedPosts_title">Spring 03：使用IoC和DI模拟注册案例、注解配置IoC和DI</div></div></a></div><div class="relatedPosts_item"><a href="/2020/03/14/Spring 04：静态代理、动态代理、拦截器思想/" title="Spring 04：静态代理、动态代理、拦截器思想"><img class="relatedPosts_cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-03-14</div><div class="relatedPosts_title">Spring 04：静态代理、动态代理、拦截器思想</div></div></a></div><div class="relatedPosts_item"><a href="/2020/03/15/Spring 05：AOP思想、AOP开发、Pointcut语法、注解配置AOP/" title="Spring 05：AOP思想、AOP开发、Pointcut语法、注解配置AOP"><img class="relatedPosts_cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-03-15</div><div class="relatedPosts_title">Spring 05：AOP思想、AOP开发、Pointcut语法、注解配置AOP</div></div></a></div><div class="relatedPosts_item"><a href="/2020/03/17/Spring 06：什么是AOP/" title="Spring 06：什么是AOP"><img class="relatedPosts_cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-03-17</div><div class="relatedPosts_title">Spring 06：什么是AOP</div></div></a></div></div><div class="clear_both"></div></div><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div id="lv-container" data-id="city" data-uid="MTAyMC80OTk1Ni8yNjQ0Nw=="><script>(function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
})(document, 'script');</script></div></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 By 陈涛</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">簡</a><i class="darkmode far fa-moon" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script defer id="ribbon" src="/js/third-party/canvas-ribbon.js" size="150" alpha="0.6" zIndex="-1" mobile="true" data-click="true"></script><script id="ribbon_piao" mobile="true" src="/js/third-party/piao.js"></script><script id="canvas_nest" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="true" src="/js/third-party/canvas-nest.js"></script><script src="/js/third-party/activate-power-mode.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
document.body.addEventListener('input', POWERMODE);
</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="/js/third-party/click_heart.js"></script></body></html>