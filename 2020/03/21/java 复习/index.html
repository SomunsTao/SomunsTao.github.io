<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>java 基础知识点复习 | Somuns ` Tao</title><meta name="description" content="java 复习"><meta name="keywords" content="java"><meta name="author" content="陈涛"><meta name="copyright" content="陈涛"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="dns-prefetch" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="dns-prefetch" href="https://fonts.googleapis.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="dns-prefetch" href="//busuanzi.ibruce.info"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="java 基础知识点复习"><meta name="twitter:description" content="java 复习"><meta name="twitter:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><meta property="og:type" content="article"><meta property="og:title" content="java 基础知识点复习"><meta property="og:url" content="https://somunstao.github.io/2020/03/21/java%20%E5%A4%8D%E4%B9%A0/"><meta property="og:site_name" content="Somuns ` Tao"><meta property="og:description" content="java 复习"><meta property="og:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><meta property="article:published_time" content="2020-03-20T16:00:00.000Z"><meta property="article:modified_time" content="2020-03-26T08:02:09.052Z"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>var autoChangeMode = '1'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="https://somunstao.github.io/2020/03/21/java%20%E5%A4%8D%E4%B9%A0/"><link rel="prev" title="java 8 新特性" href="https://somunstao.github.io/2020/03/21/java%208/"><link rel="next" title="你，真有进步吗？" href="https://somunstao.github.io/2020/03/21/my-first-blog%20%E9%B8%A1%E6%B1%A4/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: 'false',
  isFontAwesomeV5: true,
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="Somuns ` Tao" type="application/atom+xml">
</head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">81</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">9</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">9</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 時間軸</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 留言板</span></a></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-开发环境"><span class="toc-number">1.</span> <span class="toc-text">Java 开发环境</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-的特点"><span class="toc-number">1.1.</span> <span class="toc-text">Java 的特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#开发-Java-的流程"><span class="toc-number">1.2.</span> <span class="toc-text">开发 Java 的流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-程序规范"><span class="toc-number">1.3.</span> <span class="toc-text">Java 程序规范</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-基本语法"><span class="toc-number">2.</span> <span class="toc-text">Java 基本语法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#数据类型"><span class="toc-number">2.1.</span> <span class="toc-text">数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8进制与16进制表示"><span class="toc-number">2.2.</span> <span class="toc-text">8进制与16进制表示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#转义字符"><span class="toc-number">2.3.</span> <span class="toc-text">转义字符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#基本类型与引用类型的区别"><span class="toc-number">2.4.</span> <span class="toc-text">基本类型与引用类型的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#强制类型转换"><span class="toc-number">2.5.</span> <span class="toc-text">强制类型转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#关键字"><span class="toc-number">2.6.</span> <span class="toc-text">关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#运算符优先级表"><span class="toc-number">2.7.</span> <span class="toc-text">运算符优先级表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#短路原则"><span class="toc-number">2.8.</span> <span class="toc-text">短路原则</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数组和字符串"><span class="toc-number">3.</span> <span class="toc-text">数组和字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#声明数组变量"><span class="toc-number">3.1.</span> <span class="toc-text">声明数组变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#常用属性"><span class="toc-number">3.2.</span> <span class="toc-text">常用属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#常用数组方法（在-Arrays-类中-）"><span class="toc-number">3.3.</span> <span class="toc-text">常用数组方法（在 Arrays 类中 ）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#遍历数组"><span class="toc-number">3.4.</span> <span class="toc-text">遍历数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String类的常用方法"><span class="toc-number">3.5.</span> <span class="toc-text">String类的常用方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-面向对象基础"><span class="toc-number">4.</span> <span class="toc-text">Java 面向对象基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#基本概念："><span class="toc-number">4.1.</span> <span class="toc-text">基本概念：</span></a></li></ol></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">Somuns ` Tao</a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 時間軸</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 留言板</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">java 基础知识点复习</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2020-03-21 00:00:00"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2020-03-21</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2020-03-26 16:02:09"><i class="fa fa-history" aria-hidden="true"></i> 更新于 2020-03-26</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/java/">java</a></span></div><div class="meta-secondline"> </div><div class="meta-thirdline"><span class="post-meta-pv-cv"><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h2 id="Java-开发环境"><a href="#Java-开发环境" class="headerlink" title="Java 开发环境"></a><strong>Java 开发环境</strong></h2><h3 id="Java-的特点"><a href="#Java-的特点" class="headerlink" title="Java 的特点"></a>Java 的特点</h3><p>面向对象、跨平台、能把中小型程序写成大型程序</p>
<h3 id="开发-Java-的流程"><a href="#开发-Java-的流程" class="headerlink" title="开发 Java 的流程"></a>开发 Java 的流程</h3><ol>
<li>设计类</li>
<li>写代码</li>
<li>重构</li>
</ol>
<h3 id="Java-程序规范"><a href="#Java-程序规范" class="headerlink" title="Java 程序规范"></a>Java 程序规范</h3><ul>
<li>Javadoc 风格注释</li>
<li>接口以 able 结尾</li>
<li>接口、类使用 Pascal 风格命名</li>
<li>成员方法，成员变量使用 camel 风格命名</li>
<li>高内聚，低耦合</li>
</ul>
<h2 id="Java-基本语法"><a href="#Java-基本语法" class="headerlink" title="Java 基本语法"></a><strong>Java 基本语法</strong></h2><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><table>
<thead>
<tr>
<th>基本类型</th>
<th>字节个数</th>
<th>默认初始值</th>
<th>取值范围</th>
</tr>
</thead>
<tbody><tr>
<td>byte</td>
<td>1</td>
<td>0</td>
<td>-128~127</td>
</tr>
<tr>
<td>short</td>
<td>2</td>
<td>0</td>
<td>-32769~32767</td>
</tr>
<tr>
<td>int</td>
<td>4</td>
<td>0</td>
<td>-2,147,483,648（-231）~2,147,485,647（231 - 1）</td>
</tr>
<tr>
<td>long</td>
<td>8</td>
<td>0L</td>
<td>-9,223,372,036,854,775,808（-263）~9,223,372,036,854,775,807（263 -1）</td>
</tr>
<tr>
<td>float</td>
<td>4</td>
<td>0.0f</td>
<td>符合IEEE 754标准的浮点数</td>
</tr>
<tr>
<td>double</td>
<td>8</td>
<td>0.0d</td>
<td>符合IEEE 754标准的浮点数</td>
</tr>
<tr>
<td>boolean</td>
<td>1位</td>
<td>false</td>
<td>true/false</td>
</tr>
<tr>
<td>char</td>
<td>2</td>
<td>必须手动初始化</td>
<td>‘\u0000’~’\uffff’</td>
</tr>
</tbody></table>
<h3 id="8进制与16进制表示"><a href="#8进制与16进制表示" class="headerlink" title="8进制与16进制表示"></a>8进制与16进制表示</h3><p>前缀0表示8进制，而前缀0x代表16进制。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int octal &#x3D; 0144;</span><br><span class="line">int hexa &#x3D;  0x64;</span><br></pre></td></tr></table></figure>

<h3 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h3><table>
<thead>
<tr>
<th>符号</th>
<th>字符含义</th>
</tr>
</thead>
<tbody><tr>
<td>\n</td>
<td>换行 (0x0a)</td>
</tr>
<tr>
<td>\r</td>
<td>回车 (0x0d)</td>
</tr>
<tr>
<td>\f</td>
<td>换页符(0x0c)</td>
</tr>
<tr>
<td>\b</td>
<td>退格 (0x08)</td>
</tr>
<tr>
<td>\t</td>
<td>制表符</td>
</tr>
<tr>
<td>“</td>
<td>双引号</td>
</tr>
<tr>
<td>‘</td>
<td>单引号</td>
</tr>
<tr>
<td>\</td>
<td>反斜杠</td>
</tr>
<tr>
<td>\ddd</td>
<td>八进制字符 (ddd)</td>
</tr>
<tr>
<td>\uxxxx</td>
<td>16进制Unicode字符 (xxxx)</td>
</tr>
</tbody></table>
<h3 id="基本类型与引用类型的区别"><a href="#基本类型与引用类型的区别" class="headerlink" title="基本类型与引用类型的区别"></a>基本类型与引用类型的区别</h3><ol>
<li><strong>从概念方面来说</strong><br>基本类型：变量名指向具体的数值<br>引用类型：变量名指向存数据对象的内存地址</li>
<li><strong>从内存构建方面来说</strong><br>基本类型：基本数据类型在被创建时，在<strong>栈</strong>上给其划分一块内存，将数值直接存储在<strong>栈</strong>上；<br>引用类型：引用数据类型在被创建时，<strong>首先</strong>要在<strong>栈</strong>上给其引用（句柄）分配一块内存，而对象的<strong>具体信息</strong>都存储在<strong>堆</strong>内存上，然后由栈上面的引用指向堆中对象的地址。</li>
<li><strong>从使用方面来说</strong><br>基本类型：使用时需要赋具体值,判断时使用“==”号<br>引用类型：使用时可以赋null,判断时使用equals方法</li>
</ol>
<h3 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(target_type)variable;</span><br></pre></td></tr></table></figure>

<h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><table>
<thead>
<tr>
<th>关键字</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>break</td>
<td>用来改变程序执行流程，立刻从当前语句的下一句开始执行从。如果后面跟有一个标签，则从标签对应的地方开始执行</td>
</tr>
<tr>
<td>case</td>
<td>用来定义一组分支选择，如果某个值和switch中给出的值一样，就会从该分支开始执行</td>
</tr>
<tr>
<td>catch</td>
<td>用来声明当try语句块中发生运行时错误或非运行时异常时运行的一个块</td>
</tr>
<tr>
<td>continue</td>
<td>用来打断当前循环过程，从当前循环的最后重新开始执行，如果后面跟有一个标签，则从标签对应的地方开始执行</td>
</tr>
<tr>
<td>do</td>
<td>用来声明一个循环，这个循环的结束条件可以通过while关键字设置</td>
</tr>
<tr>
<td>else</td>
<td>如果if语句的条件不满足就会执行该语句</td>
</tr>
<tr>
<td>final</td>
<td><strong>final 修饰的类不能被继承</strong>。<strong>final 修饰的方法不能被子类重写</strong>。<strong>final 修饰的变量（成员变量或局部变量）即成为常量，只能赋值一次</strong>。final 修饰的成员变量必须在声明的同时赋值，如果在声明的时候没有赋值，那么只有 一次赋值的机会，而且只能在构造方法中显式赋值，然后才能使用。final 修饰的局部变量可以只声明不赋值，然后再进行一次性的赋值。</td>
</tr>
<tr>
<td>finally</td>
<td>用来执行一段代码不管在前面定义的try语句中是否有异常或运行时错误发生</td>
</tr>
<tr>
<td>for</td>
<td>用来声明一个循环。程序员可以指定要循环的语句，推出条件和初始化变量</td>
</tr>
<tr>
<td>if</td>
<td>用来生成一个条件测试，如果条件为真，就执行if下的语句</td>
</tr>
<tr>
<td>implements</td>
<td>在类的声明中是可选的，用来指明当前类实现的接口</td>
</tr>
<tr>
<td>import</td>
<td>在源文件的开始部分指明后面将要引用的一个类或整个包，这样就不必在使用的时候加上包的名字</td>
</tr>
<tr>
<td>instanceof</td>
<td>用来测试第一个参数的运行时类型是否和第二个参数兼容</td>
</tr>
<tr>
<td>interface</td>
<td>用来定义一系列的方法和常量。它可以被类实现，通过 <code>implements</code> 关键字</td>
</tr>
<tr>
<td>private</td>
<td>用在方法或变量的声中。它表示这个方法或变量只能被这个类的其它元素所访问</td>
</tr>
<tr>
<td>protected</td>
<td>在方法和变量的声明中使用，它表示这个方法或变量只能被同一个类中的，子类中的或者同一个包中的类中的元素所访问</td>
</tr>
<tr>
<td>public</td>
<td>在方法和变量的声明中使用，它表示这个方法或变量能够被其它类中的元素访问</td>
</tr>
<tr>
<td>return</td>
<td>用来结束一个方法的执行。它后面可以跟一个方法声明中要求的值</td>
</tr>
<tr>
<td>static</td>
<td>用来定义一个变量为类变量。类只维护一个类变量的拷贝，不管该类当前有多少个实例。 <code>static</code> 同样能够用来定义一个方法为类方法。类方法通过类名调用而不是特定的实例，并且只能操作类变量</td>
</tr>
<tr>
<td>this</td>
<td>用来代表它出现的类的一个实例。this可以用来访问类变量和类方法</td>
</tr>
<tr>
<td>throw</td>
<td>允许用户抛出一个exception对象或者任何实现throwable的对象</td>
</tr>
<tr>
<td>throws</td>
<td>用在方法的声明中来说明哪些异常这个方法是不处理的，而是提交到程序的更高一层</td>
</tr>
<tr>
<td>try</td>
<td>用来定义一个可能抛出异常语句块。如果一个异常被抛出，一个可选的catch语句块会处理try语句块中抛出的异常。同时，一个finally语句块会被执行，无论一个异常是否被抛出</td>
</tr>
<tr>
<td>void</td>
<td>用在Java语言的方法声明中说明这个方法没有任何返回值。”void”也可以用来表示一句没有任何功能的语句</td>
</tr>
<tr>
<td>while</td>
<td>用来定义一段反复执行的循环语句。循环的退出条件是while语句的一部分</td>
</tr>
</tbody></table>
<h3 id="运算符优先级表"><a href="#运算符优先级表" class="headerlink" title="运算符优先级表"></a>运算符优先级表</h3><table>
<thead>
<tr>
<th>优先级</th>
<th>运算符</th>
<th>结合性</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>() [] .</td>
<td>从左到右</td>
</tr>
<tr>
<td>2</td>
<td>! +(正) -(负) ~ ++ –</td>
<td>从右向左</td>
</tr>
<tr>
<td>3</td>
<td>* / %</td>
<td>从左向右</td>
</tr>
<tr>
<td>4</td>
<td>+(加) -(减)</td>
<td>从左向右</td>
</tr>
<tr>
<td>5</td>
<td>&lt;&lt; &gt;&gt; &gt;&gt;&gt;</td>
<td>从左向右</td>
</tr>
<tr>
<td>6</td>
<td>&lt; &lt;= &gt; &gt;= instanceof</td>
<td>从左向右</td>
</tr>
<tr>
<td>7</td>
<td>== !=</td>
<td>从左向右</td>
</tr>
<tr>
<td>8</td>
<td>&amp;(按位与)</td>
<td>从左向右</td>
</tr>
<tr>
<td>9</td>
<td>^</td>
<td>从左向右</td>
</tr>
<tr>
<td>10</td>
<td>|</td>
<td>从左向右</td>
</tr>
<tr>
<td>11</td>
<td>&amp;&amp;</td>
<td>从左向右</td>
</tr>
<tr>
<td>12</td>
<td>||</td>
<td>从左向右</td>
</tr>
<tr>
<td>13</td>
<td>?:</td>
<td>从右向左</td>
</tr>
<tr>
<td>14</td>
<td>= += -= *= /= %= &amp;= |= ^= ~= &lt;&lt;= &gt;&gt;= &gt;&gt;&gt;=</td>
<td>从右向左</td>
</tr>
</tbody></table>
<p>说明：</p>
<ol>
<li>该表中优先级按照从高到低的顺序书写，也就是优先级为1的优先级最高，优先级14的优先级最低。</li>
<li>结合性是指运算符结合的顺序，通常都是从左到右。从右向左的运算符最典型的就是负号，例如3+-4，则意义为3加-4，符号首先和运算符右侧的内容结合。 　　</li>
<li>instanceof作用是判断对象是否为某个类或接口类型</li>
</ol>
<h3 id="短路原则"><a href="#短路原则" class="headerlink" title="短路原则"></a>短路原则</h3><ul>
<li>对于a &amp;&amp; b，只有当a和b同时为true时，整个表达式才为true，在java中，首先运算表达式a，如果a为true，则继续运算表达式b，如果表达式a为false，那么整个表达式也肯定为false，所以表达式b不会被运算。</li>
<li>对于a || b，至少有一个为true，则表达式为true，如果a为false，整个表达式的值等于表达式b的值，因此继续运算表达式b，如果a为true，整个表达式的值为true，则没有必要再运算表达式b。</li>
</ul>
<h2 id="数组和字符串"><a href="#数组和字符串" class="headerlink" title="数组和字符串"></a>数组和字符串</h2><h3 id="声明数组变量"><a href="#声明数组变量" class="headerlink" title="声明数组变量"></a>声明数组变量</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">double[] array;   &#x2F;&#x2F; 首选的方法</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;或</span><br><span class="line"></span><br><span class="line">double array[];  &#x2F;&#x2F; 效果相同，但不是首选方法</span><br></pre></td></tr></table></figure>

<p>数组变量的声明，和创建数组可以用一条语句完成，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 数组大小</span><br><span class="line">int size &#x3D; 10;</span><br><span class="line">&#x2F;&#x2F; 定义数组</span><br><span class="line">double[] myList &#x3D; new double[size];</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;或者</span><br><span class="line"></span><br><span class="line">double[] myList &#x3D; &#123;1.9, 2.9, 3.4, 3.5&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="常用属性"><a href="#常用属性" class="headerlink" title="常用属性"></a>常用属性</h3><p><code>length</code> , 获取数组的长度</p>
<h3 id="常用数组方法（在-Arrays-类中-）"><a href="#常用数组方法（在-Arrays-类中-）" class="headerlink" title="常用数组方法（在 Arrays 类中 ）"></a>常用数组方法（在 <code>Arrays</code> 类中 ）</h3><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>public static int binarySearch(Object[] a, Object key)</code></td>
<td>用二分查找算法在给定数组中搜索给定值的对象(Byte,Int,double等)。数组在调用前必须排序好的。如果查找值包含在数组中，则返回搜索键的索引；否则返回 (-(插入点) - 1)。</td>
</tr>
<tr>
<td><code>public static boolean equals(long[] a, long[] a2)</code></td>
<td>如果两个指定的 <code>long</code> 型数组彼此相等，则返回 <code>true</code>。如果两个数组包含相同数量的元素，并且两个数组中的所有相应元素对都是相等的，则认为这两个数组是相等的。换句话说，如果两个数组以相同顺序包含相同的元素，则两个数组是相等的。同样的方法适用于所有的其他基本数据类型（<code>Byte</code>，<code>short</code>，<code>int</code>等）。</td>
</tr>
<tr>
<td><code>public static void fill(int[] a, int val)</code></td>
<td>将指定的 <code>int</code> 值分配给指定 <code>int</code> 型数组指定范围中的每个元素。同样的方法适用于所有的其他基本数据类型（<code>byte</code>，<code>short</code>，<code>int</code>等）。</td>
</tr>
<tr>
<td><code>public static void sort(Object[] a)</code></td>
<td>对指定对象数组根据其元素的自然顺序进行升序排列。同样的方法适用于所有的其他基本数据类型（<code>byte</code>，<code>short</code>，<code>int</code>等）。</td>
</tr>
</tbody></table>
<h3 id="遍历数组"><a href="#遍历数组" class="headerlink" title="遍历数组"></a>遍历数组</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for (double item:arrays)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;do something here</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="String类的常用方法"><a href="#String类的常用方法" class="headerlink" title="String类的常用方法"></a><code>String</code>类的常用方法</h3><table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>int length()</code></td>
<td>返回字符串对象包含的字符数</td>
</tr>
<tr>
<td><code>String format()</code></td>
<td>创建格式化字符串</td>
</tr>
<tr>
<td><code>int charAt(int index)</code></td>
<td>返回指定索引处的 char 值</td>
</tr>
<tr>
<td><code>int compareTo(String anotherString)</code></td>
<td>按字典顺序比较两个字符串</td>
</tr>
<tr>
<td><code>int compareToIgnoreCase(String str)</code></td>
<td>按字典顺序比较两个字符串，不考虑大小写</td>
</tr>
<tr>
<td><code>boolean endsWith(String suffix)</code></td>
<td>测试此字符串是否以指定的后缀结束</td>
</tr>
<tr>
<td><code>boolean equalsIgnoreCase(String anotherString)</code></td>
<td>将此 String 与另一个 String 比较，不考虑大小写</td>
</tr>
<tr>
<td><code>boolean equals(String anotherString)</code></td>
<td>将此 String 与另一个 String 比较</td>
</tr>
<tr>
<td><code>String replace(char oldChar, char newChar)</code></td>
<td>返回一个新的字符串，它是通过用 newChar 替换此字符串中出现的所有 oldChar 得到的</td>
</tr>
<tr>
<td><code>boolean startsWith(String prefix)</code></td>
<td>测试此字符串是否以指定的前缀开始</td>
</tr>
<tr>
<td><code>String toLowerCase()</code></td>
<td>使用默认语言环境的规则将此 String 中的所有字符都转换为小写</td>
</tr>
<tr>
<td><code>String toUpperCase()</code></td>
<td>使用默认语言环境的规则将此 String 中的所有字符都转换为大写</td>
</tr>
<tr>
<td><code>String trim()</code></td>
<td>返回字符串的副本，忽略前导空白和尾部空白</td>
</tr>
</tbody></table>
<p><strong>String 类的 == 判断的是变量是否引用的同一个实例，而不是他们所引用的实例的内容是否相等</strong></p>
<h2 id="Java-面向对象基础"><a href="#Java-面向对象基础" class="headerlink" title="Java 面向对象基础"></a><strong>Java 面向对象基础</strong></h2><h3 id="基本概念："><a href="#基本概念：" class="headerlink" title="基本概念："></a>基本概念：</h3><ul>
<li><p>成员变量</p>
</li>
<li><p>成员方法</p>
</li>
<li><p>创建对象的关键字 <code>new</code></p>
</li>
<li><p>构造函数的定义：无返回值，与类同名</p>
</li>
<li><pre><code>this
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">表示当前实例，</span><br></pre></td></tr></table></figure>
super
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  表示父类</span><br><span class="line"></span><br><span class="line">  - 当使用 &#96;super(someargs)&#96; 来继承父类的构造函数的时候，这句话必须放在最前面</span><br><span class="line">  - &#96;this(someargs)&#96;表示调用此类中与参数相符的构造函数重载，也必须放在构造函数的最前面</span><br><span class="line">  - 上面两个语句不能出现在同一个构造函数中</span><br><span class="line">  - 本质上来说，&#96;this&#96; 是一个指向当前对象的指针，&#96;super&#96; 是一个关键字</span><br><span class="line"></span><br><span class="line">- &#96;static&#96; 关键字修饰的成员变量和成员方法独立于该类的任何对象。也就是说，它不依赖类特定的实例，被类的所有实例共享。</span><br><span class="line"></span><br><span class="line">-</span><br></pre></td></tr></table></figure>
final
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  关键字有一下几种含义：</span><br><span class="line"></span><br><span class="line">  - 一个编译时恒定不变的常量</span><br><span class="line">  - 一个在运行时初始化，而你不希望它被改变的变量</span><br><span class="line">  - 参数列表中的参数以声明的方式声指明为final，这意味着你无法改变参数所指向的对象</span><br><span class="line">  - 把方法锁定，以防止任何继承它的类修改它的含义</span><br><span class="line"></span><br><span class="line">### 类的继承</span><br></pre></td></tr></table></figure>
// A.java
public class A {
  private int i;
  protected int j;

  public void func() {

  }
}
</code></pre></li>
</ul>
<p>// B.java<br>public class B extends A {<br>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 类只能有一个爸爸（父类），但可以实现多个接口</span><br><span class="line">- 子类可以继承父类所有的方法和属性，但是无法使用 &#96;private&#96;(私有) 的方法和属性</span><br><span class="line">- 通过使用&#96;instanceof&#96; 操作符，能够确定对象是否是一个类或者其子类的实例</span><br><span class="line">- 继承基本类和抽象类用&#96;extends&#96;关键字，实现接口类的继承用&#96;implements&#96;关键字。</span><br><span class="line"></span><br><span class="line">### 重写与重载</span><br><span class="line"></span><br><span class="line">#### **重写**</span><br><span class="line"></span><br><span class="line">*重写是子类对父类的允许访问的方法的实现过程进行重新编写！返回值和形参都不能改变。即外壳不变，核心重写！*</span><br><span class="line"></span><br><span class="line">#### **方法的重写规则**</span><br><span class="line"></span><br><span class="line">- 参数列表必须完全与被重写方法的相同；</span><br><span class="line">- 返回类型必须完全与被重写方法的返回类型相同；</span><br><span class="line">- 访问权限不能比父类中被重写的方法的访问权限更高。例如：如果父类的一个方法被声明为&#96;public&#96;，那么在子类中重写该方法就不能声明为&#96;protected&#96;。</span><br><span class="line">- 父类的成员方法只能被它的子类重写。</span><br><span class="line">- 声明为final的方法不能被重写。</span><br><span class="line">- 声明为static的方法不能被重写，但是能够被再次声明。</span><br><span class="line">- 子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为&#96;private&#96;和&#96;final&#96;的方法。</span><br><span class="line">- 子类和父类不在同一个包中，那么子类只能够重写父类的声明为&#96;public&#96;和&#96;protected&#96;的非&#96;final&#96;方法。</span><br><span class="line">- 重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。</span><br><span class="line">- 构造方法不能被重写。</span><br><span class="line">- 如果不能继承一个方法，则不能重写这个方法。</span><br><span class="line"></span><br><span class="line">#### **重载**</span><br><span class="line"></span><br><span class="line">重载(overloading) 是在一个类里面，方法名字相同，而参数不同。返回类型呢？可以相同也可以不同。</span><br><span class="line"></span><br><span class="line">#### **重载规则**</span><br><span class="line"></span><br><span class="line">- 被重载的方法必须改变参数列表；</span><br><span class="line">- 被重载的方法可以改变返回类型；</span><br><span class="line">- 被重载的方法可以改变访问修饰符；</span><br><span class="line">- 被重载的方法可以声明新的或更广的检查异常；</span><br><span class="line">- 方法能够在同一个类中或者在一个子类中被重载。</span><br><span class="line"></span><br><span class="line">#### **重写与重载的区别**</span><br><span class="line"></span><br><span class="line">| 区别点   | 重载方法 | 重写方法                                       |</span><br><span class="line">| -------- | -------- | ---------------------------------------------- |</span><br><span class="line">| 参数列表 | 必须修改 | 一定不能修改                                   |</span><br><span class="line">| 返回类型 | 可以修改 | 一定不能修改                                   |</span><br><span class="line">| 异常     | 可以修改 | 可以减少或删除，一定不能抛出新的或者更广的异常 |</span><br><span class="line">| 访问     | 可以修改 | 一定不能做更严格的限制（可以降低限制）         |</span><br><span class="line"></span><br><span class="line">### 多态性</span><br><span class="line"></span><br><span class="line">多态是同一个行为具有多个不同表现形式或形态的能力。</span><br><span class="line">多态存在的三个必要条件:</span><br><span class="line"></span><br><span class="line">- 继承</span><br><span class="line">- 重写</span><br><span class="line">- 父类引用指向子类对象</span><br><span class="line"></span><br><span class="line">### Java 包(package)</span><br><span class="line"></span><br><span class="line">#### 包的作用</span><br><span class="line"></span><br><span class="line">1. 把功能相似或相关的类或接口组织在同一个包中，方便类的查找和使用。</span><br><span class="line">2. 如同文件夹一样，包也采用了树形目录的存储方式。同一个包中的类名字是不同的，不同的包中的类的名字是可以相同的，当同时调用两个不同包中相同类名的类时，应该加上包名加以区别。因此，包可以避免名字冲突。</span><br><span class="line">3. 包也限定了访问权限，拥有包访问权限的类才能访问某个包中的类。</span><br><span class="line"></span><br><span class="line">默认导入的包是&#96;java.lang&#96;</span><br><span class="line"></span><br><span class="line">### 抽象方法：</span><br></pre></td></tr></table></figure>
<p>public abstract <returnType> <methodName>(…);</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">仅有方法头，而没有方法体和操作实现，具体实现由当前类的不同子类在它们各自的类声明中完成，抽象类可以包含抽象方法</span><br><span class="line">**注意**</span><br><span class="line"></span><br><span class="line">- 一个抽象类的子类如果不是抽象类，则它必须为父类中的所有抽象方法书写方法体，即重写父类中的所有抽象方法</span><br><span class="line">- 只**有抽象类才能具有抽象方法**，即如果一个类中含有抽象方法，则必须将这个类声明为抽象类</span><br><span class="line">- 除了抽象方法，抽象类中还可以包括非抽象方法</span><br><span class="line"></span><br><span class="line">### 抽象类</span><br></pre></td></tr></table></figure>
<p>abstract class Number<br>{<br>    //. . .<br>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 没有具体实例对象的类，不能使用&#96;new&#96;方法进行实例化</span><br><span class="line">- 类前需加修饰符&#96;abstract&#96;</span><br><span class="line">- 可包含常规类能够包含的任何东西，例如构造方法，非抽象方法</span><br><span class="line">- 也可包含抽象方法，这种方法只有方法的声明，而没有方法的实现</span><br><span class="line"></span><br><span class="line">## **集合类**</span><br><span class="line"></span><br><span class="line">### Set</span><br><span class="line"></span><br><span class="line">- 集合中的对象不按特定的方式排序，**并且没有重复对象**。</span><br><span class="line">- 实现：</span><br><span class="line">  - HashSet： HashSet类按照哈希算法来存取集合中的对象，存取速度比较快</span><br><span class="line">  - TreeSet ：TreeSet类实现了SortedSet接口，能够对集合中的对象进行排序</span><br><span class="line"></span><br><span class="line">### List</span><br><span class="line"></span><br><span class="line">- 元素以线性方式存储，集合中可以存放重复对象。</span><br><span class="line">- 实现：</span><br><span class="line">  - ArrayList : 代表长度可以改变的数组。可以对元素进行随机的访问，向ArrayList()中插入与删除元素的速度慢</span><br><span class="line">  - LinkedList : 在实现中采用链表数据结构。插入和删除速度快，访问速度慢。</span><br><span class="line"></span><br><span class="line">### Map</span><br><span class="line"></span><br><span class="line">一种把键对象和值对象映射的集合，它的每一个元素都包含一对键对象和值对象</span><br><span class="line">常用操作：</span><br></pre></td></tr></table></figure>
<p>Object put(Object key, Object value)    //向集合中加入元素<br>Object remove(Object key)               //删除与KEY相关的元素<br>void putAll(Map t)                      //将来自特定映像的所有元素添加给该映像<br>void clear()                            //从映像中删除所有映射<br>Object get(Object key)                  //获得与关键字key相关的值<br>put(Object key, Object value)           //添加一个“值”(想要得东西)和与“值”相关联的“键”(key)(使用它来查找)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">### 数组、List相互转换</span><br></pre></td></tr></table></figure>
<p>//List to array<br>Employee[] employees = employeeList.toArray(new Employee[employeeList.size()]);</p>
<p>//Array to list<br>employeeList = Arrays.asList(employees);</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">### 常用集合操作</span><br></pre></td></tr></table></figure>
<p>//遍历<br>employeeList<br>    .stream()<br>    .forEach(employee -&gt;<br>    {<br>        //Do something here<br>    }));</p>
<p>//去重<br>employeeList = employeeList<br>        .stream()<br>        .distinct()  //使用 equals()方法<br>        .collect(Collectors.toList());</p>
<p>//字符串列表转小写并去重<br>list = list<br>        .stream()<br>        .map(s-&gt;s.toLowerCase()+”或者你也可以在这里加上自己喜欢的话”)<br>        .distinct()<br>        .collect(Collectors.toList()); //list 必须是 List 接口类型变量</p>
<p>//或者我们还可以排个序<br>list.sort((s1,s2)-&gt;<br>        {<br>            //或者在这里写你自己的比较方法<br>            //返回类型是 int<br>            return s1.compareTo(s2);<br>        });</p>
<p>//最后我们还可以删库跑路<br>list.clear();</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">## **IO 操作**</span><br><span class="line"></span><br><span class="line">常用的读写文件的操作</span><br></pre></td></tr></table></figure>
<p>//从控制台读入<br>//先背一波类名<br>BufferedReader brConsole = new BufferedReader(new InputStreamReader(System.in));<br>        try<br>        {<br>        //读取文件<br>            BufferedWriter bwFile = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(“worldcup.txt”,true)));</p>
<pre><code>String line = null;
while((line=brConsole.readLine())!=null)
{
    if (&quot;Done&quot;.equalsIgnoreCase(line))
    {
        break;
    }
    else
    {
        bwFile.write(line);
        bwFile.newLine();
    }
}
bwFile.flush();</code></pre><p>//好烦啊，其他的都差不多了，不写了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">## **自定义异常**</span><br><span class="line"></span><br><span class="line">### 声明一个异常</span><br></pre></td></tr></table></figure>
<p>class MyException extends Exception<br>{<br>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">### 捕获异常</span><br></pre></td></tr></table></figure>
<p>try<br>{<br>   // 程序代码<br>}<br>catch(ExceptionName e1)<br>{<br>   //Catch 块<br>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">### 捕获多重异常</span><br></pre></td></tr></table></figure>
<p> try<br> {<br>    // 程序代码<br> }<br> catch(异常类型1 异常的变量名1)<br> {<br>    // 程序代码<br> }<br> catch(异常类型2 异常的变量名2)<br> {<br>    // 程序代码<br> }<br> catch(异常类型3 异常的变量名3)<br> {<br>    // 程序代码<br> }</p>
<p> //或者</p>
<p>  try<br> {<br>    // 程序代码<br> }<br> catch(异常类型1 | 异常类型2 | 异常类型3 异常的变量名)<br> {<br>    // 程序代码<br> }<br>```</p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">陈涛</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://somunstao.github.io/2020/03/21/java%20%E5%A4%8D%E4%B9%A0/">https://somunstao.github.io/2020/03/21/java 复习/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://SomunsTao.github.io" target="_blank">Somuns ` Tao</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/java/">java</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="post-qr-code__img" src="/img/wechat.jpg" alt="微信"/><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="post-qr-code__img" src="/img/alipay.jpg" alt="支付寶"/><div class="post-qr-code__desc">支付寶</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2020/03/21/java%208/"><img class="prev_cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">java 8 新特性</div></div></a></div><div class="next-post pull_right"><a href="/2020/03/21/my-first-blog%20%E9%B8%A1%E6%B1%A4/"><img class="next_cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">你，真有进步吗？</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2020/03/21/java 8/" title="java 8 新特性"><img class="relatedPosts_cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-03-21</div><div class="relatedPosts_title">java 8 新特性</div></div></a></div><div class="relatedPosts_item"><a href="/2020/03/21/my-first-blog 鸡汤/" title="你，真有进步吗？"><img class="relatedPosts_cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-03-21</div><div class="relatedPosts_title">你，真有进步吗？</div></div></a></div><div class="relatedPosts_item"><a href="/2020/04/01/java 复习 - 副本/" title="JVM和JUC复习"><img class="relatedPosts_cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-04-01</div><div class="relatedPosts_title">JVM和JUC复习</div></div></a></div></div><div class="clear_both"></div></div><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div id="lv-container" data-id="city" data-uid="MTAyMC80OTk1Ni8yNjQ0Nw=="><script>(function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
})(document, 'script');</script></div></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 By 陈涛</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">簡</a><i class="darkmode far fa-moon" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script defer id="ribbon" src="/js/third-party/canvas-ribbon.js" size="150" alpha="0.6" zIndex="-1" mobile="true" data-click="true"></script><script id="ribbon_piao" mobile="true" src="/js/third-party/piao.js"></script><script id="canvas_nest" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="true" src="/js/third-party/canvas-nest.js"></script><script src="/js/third-party/activate-power-mode.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
document.body.addEventListener('input', POWERMODE);
</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="/js/third-party/click_heart.js"></script></body></html>