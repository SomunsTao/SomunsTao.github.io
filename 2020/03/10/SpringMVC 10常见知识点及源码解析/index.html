<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Spring MVC常见知识点及源码解析 | Somuns ` Tao</title><meta name="description" content="SpringMVC 是一款优秀的轻量级Web框架"><meta name="keywords" content="SpringMVC"><meta name="author" content="陈涛"><meta name="copyright" content="陈涛"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="dns-prefetch" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="dns-prefetch" href="https://fonts.googleapis.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="dns-prefetch" href="//busuanzi.ibruce.info"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Spring MVC常见知识点及源码解析"><meta name="twitter:description" content="SpringMVC 是一款优秀的轻量级Web框架"><meta name="twitter:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><meta property="og:type" content="article"><meta property="og:title" content="Spring MVC常见知识点及源码解析"><meta property="og:url" content="https://somunstao.github.io/2020/03/10/SpringMVC%2010%E5%B8%B8%E8%A7%81%E7%9F%A5%E8%AF%86%E7%82%B9%E5%8F%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"><meta property="og:site_name" content="Somuns ` Tao"><meta property="og:description" content="SpringMVC 是一款优秀的轻量级Web框架"><meta property="og:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><meta property="article:published_time" content="2020-03-09T16:00:00.000Z"><meta property="article:modified_time" content="2020-08-02T06:44:54.459Z"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>var autoChangeMode = '1'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="https://somunstao.github.io/2020/03/10/SpringMVC%2010%E5%B8%B8%E8%A7%81%E7%9F%A5%E8%AF%86%E7%82%B9%E5%8F%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"><link rel="prev" title="SpringBoot10：日志框架介绍" href="https://somunstao.github.io/2020/03/10/SpringBoot10%EF%BC%9A%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%BB%8D/"><link rel="next" title="SpringBoot09：SpringMVC自动配置原理" href="https://somunstao.github.io/2020/03/09/SpringBoot09%EF%BC%9ASpringMVC%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: 'false',
  isFontAwesomeV5: true,
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="Somuns ` Tao" type="application/atom+xml">
</head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">150</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">11</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">11</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 時間軸</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 留言板</span></a></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Spring-MVC常见知识点及源码解析"><span class="toc-number">1.</span> <span class="toc-text">Spring MVC常见知识点及源码解析</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Spring-MVC常见知识点及源码解析-1"><span class="toc-number">2.</span> <span class="toc-text">Spring MVC常见知识点及源码解析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#MVC-是什么-有什么优点"><span class="toc-number">2.0.1.</span> <span class="toc-text">MVC 是什么 &#x2F; 有什么优点?</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#什么是-Spring-MVC"><span class="toc-number">2.0.1.1.</span> <span class="toc-text">什么是 Spring MVC?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Spring-MVC的优缺点"><span class="toc-number">2.0.1.2.</span> <span class="toc-text">Spring MVC的优缺点?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#什么是DispatcherServlet"><span class="toc-number">2.0.1.3.</span> <span class="toc-text">什么是DispatcherServlet?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Spring-MVC有哪些组件-见-DispatcherServlet源码"><span class="toc-number">2.0.1.4.</span> <span class="toc-text">Spring MVC有哪些组件?(见:DispatcherServlet源码)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#简述SpringMVC原理-执行流程"><span class="toc-number">2.0.1.5.</span> <span class="toc-text">简述SpringMVC原理&#x2F;执行流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Spring-MVC-拦截器是什么-有什么作用-与-Filter有什么区别"><span class="toc-number">2.0.1.6.</span> <span class="toc-text">Spring MVC  拦截器是什么 &#x2F; 有什么作用 &#x2F; 与 Filter有什么区别?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Component-Controller-Service-Repository-区别"><span class="toc-number">2.0.1.7.</span> <span class="toc-text">@Component @Controller @Service @Repository 区别?</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring的源码分析"><span class="toc-number">2.0.2.</span> <span class="toc-text">Spring的源码分析</span></a></li></ol></li></ol></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">Somuns ` Tao</a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 時間軸</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 留言板</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">Spring MVC常见知识点及源码解析</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2020-03-10 00:00:00"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2020-03-10</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2020-08-02 14:44:54"><i class="fa fa-history" aria-hidden="true"></i> 更新于 2020-08-02</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/SpringMVC/">SpringMVC</a></span></div><div class="meta-secondline"> </div><div class="meta-thirdline"><span class="post-meta-pv-cv"><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h1 id="Spring-MVC常见知识点及源码解析"><a href="#Spring-MVC常见知识点及源码解析" class="headerlink" title="Spring MVC常见知识点及源码解析"></a>Spring MVC常见知识点及源码解析</h1><!-- TOC -->

<ul>
<li><a href="#spring-mvc常见知识点及源码解析">Spring MVC常见知识点及源码解析</a><ul>
<li><a href="#mvc-是什么--有什么优点">MVC 是什么 / 有什么优点?</a><ul>
<li><a href="#什么是-spring-mvc">什么是 Spring MVC?</a></li>
<li><a href="#spring-mvc的优缺点">Spring MVC的优缺点?</a></li>
<li><a href="#什么是dispatcherservlet">什么是DispatcherServlet?</a></li>
<li><a href="#spring-mvc有哪些组件见dispatcherservlet源码">Spring MVC有哪些组件?(见:DispatcherServlet源码)</a></li>
<li><a href="#简述springmvc原理执行流程">简述SpringMVC原理/执行流程</a></li>
<li><a href="#spring-mvc--拦截器是什么--有什么作用--与-filter有什么区别">Spring MVC  拦截器是什么 / 有什么作用 / 与 Filter有什么区别?</a></li>
<li><a href="#component-controller-service-repository-区别">@Component @Controller @Service @Repository 区别?</a></li>
</ul>
</li>
<li><a href="#spring的源码分析">Spring的源码分析</a></li>
</ul>
</li>
</ul>
<!-- /TOC -->

<h1 id="Spring-MVC常见知识点及源码解析-1"><a href="#Spring-MVC常见知识点及源码解析-1" class="headerlink" title="Spring MVC常见知识点及源码解析"></a>Spring MVC常见知识点及源码解析</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">如有错误之处，敬请指教。</span><br></pre></td></tr></table></figure>

<h3 id="MVC-是什么-有什么优点"><a href="#MVC-是什么-有什么优点" class="headerlink" title="MVC 是什么 / 有什么优点?"></a>MVC 是什么 / 有什么优点?</h3><p>MVC是一种设计模式，遵循 模型(Model),视图(View) 和 控制器(Controller)的架构设计。<br>MVC的优点很明显: 应用层次分明，职责分明，使得系统的耦合性降低，并有利于系统的维护。</p>
<h4 id="什么是-Spring-MVC"><a href="#什么是-Spring-MVC" class="headerlink" title="什么是 Spring MVC?"></a>什么是 Spring MVC?</h4><p>Spring MVC是一个基于Spring框架的轻量级的MVC Web应用框架。</p>
<h4 id="Spring-MVC的优缺点"><a href="#Spring-MVC的优缺点" class="headerlink" title="Spring MVC的优缺点?"></a>Spring MVC的优缺点?</h4><p>优点：</p>
<ol>
<li>基于Spring，拥有Spring的所有优点</li>
<li>Spring MVC中的组件:角色分明，耦合性低，非常有利于应用的维护。</li>
<li>支持多种视图技术:不仅支持JSP，还支持各种模板视图。</li>
<li>功能特性强大:轻松的文件上传，数据校验与格式转换，异常处理，RESTful风格的API等等。</li>
<li>支持前后端分离。</li>
</ol>
<p>缺点:</p>
<ol>
<li>Spring MVC是基于Spring的，这既是它的优点也是它的缺点，它必须与Spring一起使用，<br>个人认为这应该是它最大的一个限制了。</li>
</ol>
<h4 id="什么是DispatcherServlet"><a href="#什么是DispatcherServlet" class="headerlink" title="什么是DispatcherServlet?"></a>什么是DispatcherServlet?</h4><p>DispatcherServlet是Spring MVC的核心,<br>可以说SpringMVC就是这个DispatcherServlet。<br>它是一个Servlet，负责拦截所有的请求，并以调用各种组件来对请求进行分发并处理。</p>
<h4 id="Spring-MVC有哪些组件-见-DispatcherServlet源码"><a href="#Spring-MVC有哪些组件-见-DispatcherServlet源码" class="headerlink" title="Spring MVC有哪些组件?(见:DispatcherServlet源码)"></a>Spring MVC有哪些组件?(见:DispatcherServlet源码)</h4><ol>
<li><p>MultipartResolver: 核心组件之一，处理文件上传请求。MultipartResolver负责判断普通请求是否为文件上传请求，<br>并将普通请求(HttpServletRequest)解析为文件上传请求(MultipartHttpServletRequest)。</p>
</li>
<li><p>LocalResolver: 区域解析器。它主要被用于国际化的资源方面的解析。</p>
</li>
<li><p>ThemeResolver: 主题资源解析器。SpringMVC允许用户提供不同主题，主题就是一系列资源的集合使用这些主题可以提高用户体验。</p>
</li>
<li><p>ViewResolver: 核心组件之一，视图解析器。在Handler执行完请求后，ViewResolver将ModelAndView解析成物理视图，<br>并对物理视图进行model渲染。</p>
</li>
<li><p>HandlerMapping: 核心组件之一，请求处理器。根据用户的请求来匹配对应的Handler。</p>
</li>
<li><p>HandlerAdapter: 核心组件之一，Handler适配器。使用Handler处理请求，并返回处理后的视图(ModelAndView)。</p>
</li>
<li><p>HandlerExceptionResolver: 核心组件之一，异常处理解析器。在Handler执行请求的过程中可能出现异常，<br>HandlerExceptionResolver就负责处理Handler执行请求过程中的异常。</p>
</li>
<li><p>RequestToViewNameTranslator: 核心组件之一,请求到视图的转换器。根据Request设置最终的视图名,当Handler执行完请求后，它会将Request解析成视图名。</p>
</li>
<li><p>FlashMapManager: 核心组件之一，在请求进行重定向时，FlashMapManager用于保存请求中的参数。</p>
</li>
</ol>
<h4 id="简述SpringMVC原理-执行流程"><a href="#简述SpringMVC原理-执行流程" class="headerlink" title="简述SpringMVC原理/执行流程"></a>简述SpringMVC原理/执行流程</h4><ol>
<li><p>用户发出的请求被DispatcherServlet拦截。</p>
</li>
<li><p>DispatcherServlet使用HandlerMapping根据请求匹配到相应的Handler。Handler实际上是一个(HandlerMethod)。</p>
</li>
<li><p>DispatcherServlet根据Handler适配合适的HandlerAdapter。</p>
</li>
<li><p>HandlerAdapter使用Handler执行请求，并返回ModelAndView。</p>
</li>
<li><p>使用RequestToViewNameTranslator,HandlerExceptionResolver和ViewResolver等解析器，<br>解析并渲染ModelAndView，并处理相关异常信息。</p>
</li>
<li><p>渲染后的结果反馈给用户。</p>
</li>
</ol>
<h4 id="Spring-MVC-拦截器是什么-有什么作用-与-Filter有什么区别"><a href="#Spring-MVC-拦截器是什么-有什么作用-与-Filter有什么区别" class="headerlink" title="Spring MVC  拦截器是什么 / 有什么作用 / 与 Filter有什么区别?"></a>Spring MVC  拦截器是什么 / 有什么作用 / 与 Filter有什么区别?</h4><ul>
<li><p>HandlerInterceptor: Spring MVC拦截器是Spring MVC提供的对用户请求的目标资源做出拦截扩展的处理器。<br>它允许在目标方法执行前后以及View渲染后做出处理。</p>
</li>
<li><p>Servlet Filter: Filter是Servlet提供的过滤器，它会在目标方法执行前后做出拦截处理。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">要说Servlet Filter和HandlerInterceptor有啥区别，</span><br><span class="line">个人认为除了它们提供的拦截时机不同，目的都是相同的，没啥区别。</span><br></pre></td></tr></table></figure>

<h4 id="Component-Controller-Service-Repository-区别"><a href="#Component-Controller-Service-Repository-区别" class="headerlink" title="@Component @Controller @Service @Repository 区别?"></a>@Component @Controller @Service @Repository 区别?</h4><blockquote>
<p>@Component 声明一个类为IOC容器的组件，会被IOC容器管理。<br>而@Controller,@Service和@Repository则拥有更细分的语义。</p>
</blockquote>
<ul>
<li><p><strong>@Controller通常用于Web应用，被@Controller注解的类，应该作为一个处理请求的控制器。</strong></p>
</li>
<li><p><strong>@Service则是声明一个类为Service类，处理业务逻辑。</strong></p>
</li>
<li><p><strong>被@Repository注解的类，应该被用于处理与数据库交互和持久化相关的功能。</strong></p>
</li>
</ul>
<hr>
<h3 id="Spring的源码分析"><a href="#Spring的源码分析" class="headerlink" title="Spring的源码分析"></a>Spring的源码分析</h3><p>在分析SpringMVC源码之前我想先回顾一下JavaWeb的知识.JavaWeb的核心是Servlet,一个Servlet对应一个URL,<br>每次一个Http请求访问,那么对应URL的Servlet就会调用service方法处理。</p>
<p>其实这里我是对SpringMVC的一个复习,所以我先说说就我目前SpringMVC的理解吧。<br>大家都知道SpringMVC是一个MVC框架,但它还是脱离不了Tomcat,Undertow,Jetty这样的Servlet容器,<br>因为SpringMVC的核心还是是Servlet。</p>
<p>在初学SpringMVC的时候,各位同学可能都在web.xml里配置过DispatcherServlet,可能当时都没有想过为什么要去配置这个类,<br>甚至把它拦截的url配置成/**,我当时确实也没有想过,不过后来在学习的时候,已经明白了为什么这样去做,<br>并且已经明白了SpringMVC的设计思想。</p>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">前方高能</span><br></pre></td></tr></table></figure>

<p>SpringMVC通过一个DispatcherServlet拦截所有请求,也就是url为 /** 。<br>通过拦截所有请求,在内部通过路由匹配的方式把请求转给对应Controller的某个RequestMapping处理。<br>这就是SpringMVC的基本工作流程,我们传统的JavaWeb是一个Servlet对应一个URL,<br>而DispatcherServlet是一个Servlet拦截全部URL,并做分发处理.<br>这也是SpringMVC的设计的精妙之处。</p>
<p>当然上面只是简单的一个流程,在这个过程中肯定有很多细节值得我们细细揣摩。</p>
<p>我是以SpringBoot搭建的调试环境,再加上已经知晓DispatcherServlet是核心,<br>几乎可以直接定位到这个类了,但是在这之前可以看看DispatcherServlet的父类:FrameworkServlet。<br>上面说过,Servlet是以service方法处理请求的,所以直接定位到FrameworkServlet的service方法:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line">    HttpMethod httpMethod &#x3D; HttpMethod.resolve(request.getMethod());</span><br><span class="line">    if (httpMethod !&#x3D; HttpMethod.PATCH &amp;&amp; httpMethod !&#x3D; null) &#123;</span><br><span class="line">        super.service(request, response);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      </span><br><span class="line">        &#x2F;&#x2F;就是你了,骚年</span><br><span class="line">        this.processRequest(request, response);</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个明显的方法 processRequest就进入了眼帘,看看这个processRequest做了什么吧:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected final void processRequest(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line">    ...</span><br><span class="line">    try &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;就是这个方法了</span><br><span class="line">        this.doService(request, response);</span><br><span class="line"></span><br><span class="line">    &#125; catch (IOException | ServletException var16) &#123;</span><br><span class="line">        failureCause &#x3D; var16;</span><br><span class="line">        throw var16;</span><br><span class="line">    &#125; catch (Throwable var17) &#123;</span><br><span class="line">        failureCause &#x3D; var17;</span><br><span class="line">        throw new NestedServletException(&quot;Request processing failed&quot;, var17);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        this.resetContextHolders(request, previousLocaleContext, previousAttributes);</span><br><span class="line">        if (requestAttributes !&#x3D; null) &#123;</span><br><span class="line">            requestAttributes.requestCompleted();</span><br><span class="line">        &#125;</span><br><span class="line">        this.logResult(request, response, (Throwable)failureCause, asyncManager);</span><br><span class="line">        this.publishRequestHandledEvent(request, response, startTime, (Throwable)failureCause);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到一大坨代码都是try这个doService方法,而这个doService方法肯定是核心了,<br>但是这个doService方法在FrameworkServlet类中是个abstract方法,所以直接回到<br>DispatcherServlet找到doService方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected void doService(HttpServletRequest request, HttpServletResponse response) throws Exception &#123;</span><br><span class="line">    &#x2F;&#x2F;...此处省略一大坨看不懂的代码</span><br><span class="line">    try &#123;</span><br><span class="line">        &#x2F;&#x2F;从这里开始分析</span><br><span class="line">        this.doDispatch(request, response);</span><br><span class="line"></span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (!WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted() &amp;&amp; attributesSnapshot !&#x3D; null) &#123;</span><br><span class="line">            this.restoreAttributesAfterInclude(request, attributesSnapshot);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>已经找到了目标:doDispatch,听名字这个方法就是做事情的方法了,<br>所谓的做事情当然就是处理request了,如果各位同学学到现在,<br>肯定有一个意识:在SpringMVC框架中,所有的核心方法几乎都是do开头,<br>并且都有2个必要的参数:HttpServletRequest和HttpServletResponse.</p>
<p>但是DispatcherServlet是我接触的所有框架依赖不那么扯的,<br>就是这个doDispatch方法,它里面几乎包含了我们即将要学习的所有知识了,<br>所以接下来的核心就是doDispatch方法,各位同学在做源码阅读的时候,建议一行也不要放过(实在看不懂就别为难自己了^-^)。</p>
<p>不过在看DispatcherServlet源码之前,我们最后看下这个DispatcherServlet究竟何德何能,<br>能够这么厉害,可以完成我们几乎所有的需求方法:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class DispatcherServlet extends FrameworkServlet &#123;</span><br><span class="line">    ....</span><br><span class="line">    @Nullable</span><br><span class="line">    private MultipartResolver multipartResolver;</span><br><span class="line">    @Nullable</span><br><span class="line">    private LocaleResolver localeResolver;</span><br><span class="line">    @Nullable</span><br><span class="line">    private ThemeResolver themeResolver;</span><br><span class="line">    @Nullable</span><br><span class="line">    private List&lt;HandlerMapping&gt; handlerMappings;</span><br><span class="line">    @Nullable</span><br><span class="line">    private List&lt;HandlerAdapter&gt; handlerAdapters;</span><br><span class="line">    @Nullable</span><br><span class="line">    private List&lt;HandlerExceptionResolver&gt; handlerExceptionResolvers;</span><br><span class="line">    @Nullable</span><br><span class="line">    private RequestToViewNameTranslator viewNameTranslator;</span><br><span class="line">    @Nullable</span><br><span class="line">    private FlashMapManager flashMapManager;</span><br><span class="line">    @Nullable</span><br><span class="line">    private List&lt;ViewResolver&gt; viewResolvers;</span><br><span class="line">    ....</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>这就是DispatcherServlet的九大组件,正是这九大组件,<br>DispatcherServlet才能在支持请求和相应的同时,对许多功能和细节做出完善。</p>
<p>再看看doDispatch方法的源码,其实都是上面组件之间的配合完成任务:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception &#123;</span><br><span class="line">    HttpServletRequest processedRequest &#x3D; request;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;核心对象:HanderExecutorChain</span><br><span class="line">    HandlerExecutionChain mappedHandler &#x3D; null;</span><br><span class="line"></span><br><span class="line">    boolean multipartRequestParsed &#x3D; false;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;管理异步请求</span><br><span class="line">    WebAsyncManager asyncManager &#x3D; WebAsyncUtils.getAsyncManager(request);</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            ModelAndView mv &#x3D; null;</span><br><span class="line">            Object dispatchException &#x3D; null;</span><br><span class="line"></span><br><span class="line">            try &#123;</span><br><span class="line">                &#x2F;&#x2F;检查请求是否存在文件上传</span><br><span class="line">                processedRequest &#x3D; this.checkMultipart(request);</span><br><span class="line">                multipartRequestParsed &#x3D; processedRequest !&#x3D; request;</span><br><span class="line">            </span><br><span class="line">                &#x2F;&#x2F;getHandler方法是根据请求获取对应的Controller和方法</span><br><span class="line">                mappedHandler &#x3D; this.getHandler(processedRequest);</span><br><span class="line"></span><br><span class="line">                if (mappedHandler &#x3D;&#x3D; null) &#123;</span><br><span class="line"></span><br><span class="line">                    &#x2F;&#x2F;如果没有获取到匹配的handler,就要么抛出异常要么设置响应码404</span><br><span class="line">                    this.noHandlerFound(processedRequest, response);</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                &#x2F;&#x2F;通过handler获取HandlerAdapter,由HandlerAdapter完成方法的执行</span><br><span class="line">                HandlerAdapter ha &#x3D; this.getHandlerAdapter(mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line">                String method &#x3D; request.getMethod();</span><br><span class="line">                boolean isGet &#x3D; &quot;GET&quot;.equals(method);</span><br><span class="line">                if (isGet || &quot;HEAD&quot;.equals(method)) &#123;</span><br><span class="line">                    long lastModified &#x3D; ha.getLastModified(request, mappedHandler.getHandler());</span><br><span class="line">                    if ((new ServletWebRequest(request, response)).checkNotModified(lastModified) &amp;&amp; isGet) &#123;</span><br><span class="line">                        return;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                &#x2F;&#x2F;执行拦截器的preHandle方法,它内部如果执行不成功就会先执行afterCompletion,然后返回false,然后程序就退出</span><br><span class="line">                &#x2F;&#x2F;这也是为什么拦截器的前置方法为什么返回false,程序就不会执行我们的逻辑了,等下会分析源码</span><br><span class="line">                if (!mappedHandler.applyPreHandle(processedRequest, response)) &#123;</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                &#x2F;&#x2F;执行方法</span><br><span class="line">                mv &#x3D; ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line">                if (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                &#x2F;&#x2F;根据Request使用RequestToViewNameTranslator设置默认的视图</span><br><span class="line">                this.applyDefaultViewName(processedRequest, mv);</span><br><span class="line"></span><br><span class="line">              &#x2F;&#x2F;倒序执行拦截器的postHandle方法    </span><br><span class="line">                mappedHandler.applyPostHandle(processedRequest, response, mv);</span><br><span class="line"></span><br><span class="line">            &#125; catch (Exception var20) &#123;</span><br><span class="line">                dispatchException &#x3D; var20;</span><br><span class="line">            &#125; catch (Throwable var21) &#123;</span><br><span class="line">                dispatchException &#x3D; new NestedServletException(&quot;Handler dispatch failed&quot;, var21);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;解析并渲染ModelAndView</span><br><span class="line">            this.processDispatchResult(processedRequest, response, mappedHandler, mv, (Exception)dispatchException);</span><br><span class="line">      </span><br><span class="line">        &#125; catch (Exception var22) &#123;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;发生异常会倒序执行afterCompletion方法</span><br><span class="line">            this.triggerAfterCompletion(processedRequest, response, mappedHandler, var22);</span><br><span class="line"></span><br><span class="line">        &#125; catch (Throwable var23) &#123;</span><br><span class="line"></span><br><span class="line">          &#x2F;&#x2F;发生异常会倒序执行afterCompletion方法</span><br><span class="line">            this.triggerAfterCompletion(processedRequest, response, mappedHandler, new NestedServletException(&quot;Handler processing failed&quot;, var23));</span><br><span class="line">     </span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">            if (mappedHandler !&#x3D; null) &#123;</span><br><span class="line">                mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else if (multipartRequestParsed) &#123;</span><br><span class="line">            this.cleanupMultipart(processedRequest);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先看看MultiPartResolver是如何检查文件上传请求的吧(checkMultipart方法):</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected HttpServletRequest checkMultipart(HttpServletRequest request) throws MultipartException &#123;</span><br><span class="line">   </span><br><span class="line">    &#x2F;&#x2F;关键在isMultpart方法</span><br><span class="line">    if (this.multipartResolver !&#x3D; null &amp;&amp; this.multipartResolver.  isMultipart(request)  ) &#123;</span><br><span class="line"></span><br><span class="line">        if (WebUtils.getNativeRequest(request, MultipartHttpServletRequest.class) !&#x3D; null) &#123;</span><br><span class="line">            if (request.getDispatcherType().equals(DispatcherType.REQUEST)) &#123;</span><br><span class="line">                this.logger.trace(&quot;Request already resolved to MultipartHttpServletRequest, e.g. by MultipartFilter&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else if (this.hasMultipartException(request)) &#123;</span><br><span class="line">            this.logger.debug(&quot;Multipart resolution previously failed for current request - skipping re-resolution for undisturbed error rendering&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">               </span><br><span class="line">                &#x2F;&#x2F;执行到这里就说明HttpServletRequest是一个文件上传请求,那么就把HttpServletRequest包装成</span><br><span class="line">                &#x2F;&#x2F;MultpartHttpServletRequest返回</span><br><span class="line">                return this.multipartResolver.resolveMultipart(request);</span><br><span class="line">           </span><br><span class="line">            &#125; catch (MultipartException var3) &#123;</span><br><span class="line">                if (request.getAttribute(&quot;javax.servlet.error.exception&quot;) &#x3D;&#x3D; null) &#123;</span><br><span class="line">                    throw var3;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            this.logger.debug(&quot;Multipart resolution failed for error dispatch&quot;, var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return request;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先看看isMultiPart是怎么判断请求是否为文件上传请求的吧(isMultipart方法)：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public boolean isMultipart(HttpServletRequest request) &#123;</span><br><span class="line">      &#x2F;&#x2F;判断Http请求包头的Content-Type</span><br><span class="line">      return StringUtils.startsWithIgnoreCase(request.getContentType(), &quot;multipart&#x2F;&quot;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>着重看看MultipartResolver是如何把普通请求包装成MultipartHttpServletRequest的吧(resolveMultipart方法):</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public MultipartHttpServletRequest resolveMultipart(HttpServletRequest request) throws MultipartException &#123;</span><br><span class="line">      &#x2F;&#x2F;原来我们处理文件上传时拿到的请求是这个请求</span><br><span class="line">      return new StandardMultipartHttpServletRequest(request, this.resolveLazily);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>从上面代码分析出,文件上传时,拿到的请求被包装成了StandardMultipartHttpServletRequest,<br>但是我不再深入,因为MultipartResolver是DispatcherServlet的一个<br>组件而已,再深入,就跑题了…也不是说跑题,毕竟都是SpringMVC的组成,<br>只是相信各位同学看到这里已经有能力去看看这个源码了,<br>可以明确的告诉各位这个地方不存在什么封装之类的曲折,单纯的就是<br>StandardMultipartHttpServletRequest内部对请求做了解析,并使用集合把解析的结果存储起来了而已 .</p>
<p>回到doDispatch方法,在执行完checkMultipart方法后,就通过getHandler方法,<br>获取了mappedHandler(HandlerExecutionChain)对象,这个HandlerExecutionChain是什么,<br>为什么getHandler返回它?先看看HandlerExecutionChain类的源码吧:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class HandlerExecutionChain &#123;</span><br><span class="line">    private static final Log logger &#x3D; LogFactory.getLog(HandlerExecutionChain.class);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;handler,至于为什么设计成Object类型,我想可能是handler是执行method的关键,所以隐藏了细节,不对外暴露真实类型.</span><br><span class="line">    &#x2F;&#x2F;也有可能是在适配Controller的method的过程中需要多种类型的转换,总之不管哪种理由设计成Object类型,只有好好研究了.</span><br><span class="line">    private final Object handler;</span><br><span class="line"></span><br><span class="line">    @Nullable</span><br><span class="line">    &#x2F;&#x2F;一堆 HandlerInterceptor</span><br><span class="line">    private HandlerInterceptor[] interceptors;</span><br><span class="line"></span><br><span class="line">    @Nullable</span><br><span class="line">    private List&lt;HandlerInterceptor&gt; interceptorList;</span><br><span class="line">    private int interceptorIndex;</span><br><span class="line"></span><br><span class="line">    public HandlerExecutionChain(Object handler) &#123;</span><br><span class="line">        this(handler, (HandlerInterceptor[])null);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><strong>这个HandlerExecutionChain包含了handler和它的所有HandleInterceptor.</strong></p>
<p>再看看DispatcherServlet是如何根据HttpServletRequest获取HandlerExecutionChain的吧(getHandler方法):</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception &#123;</span><br><span class="line">    if (this.handlerMappings !&#x3D; null) &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;之前说过HandlerMapping是DispatcherServlet的9大组件之一,所以这里它遍历HandlerMapping来获取</span><br><span class="line">        Iterator var2 &#x3D; this.handlerMappings.iterator();</span><br><span class="line"></span><br><span class="line">        while(var2.hasNext()) &#123;</span><br><span class="line">            HandlerMapping mapping &#x3D; (HandlerMapping)var2.next();</span><br><span class="line">          </span><br><span class="line">            &#x2F;&#x2F;调用HandlerMapping的getHandler方法来获取HandlerExecutionChain</span><br><span class="line">            HandlerExecutionChain handler &#x3D; mapping.getHandler(request);</span><br><span class="line"></span><br><span class="line">            if (handler !&#x3D; null) &#123;</span><br><span class="line">                return handler;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继续看看HandlerMapping的getHandler怎么实现的:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public final HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception &#123;</span><br><span class="line">    &#x2F;&#x2F;首先就获取Handler</span><br><span class="line">    Object handler &#x3D; this.getHandlerInternal(request);</span><br><span class="line"></span><br><span class="line">    if (handler &#x3D;&#x3D; null) &#123;</span><br><span class="line">        handler &#x3D; this.getDefaultHandler();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (handler &#x3D;&#x3D; null) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (handler instanceof String) &#123;</span><br><span class="line">            String handlerName &#x3D; (String)handler;</span><br><span class="line">            handler &#x3D; this.obtainApplicationContext().getBean(handlerName);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        &#x2F;&#x2F;这一步就构造了HandlerExecutionChain</span><br><span class="line">        HandlerExecutionChain executionChain &#x3D; this.getHandlerExecutionChain(handler, request);</span><br><span class="line"></span><br><span class="line">        if (this.logger.isTraceEnabled()) &#123;</span><br><span class="line">            this.logger.trace(&quot;Mapped to &quot; + handler);</span><br><span class="line">        &#125; else if (this.logger.isDebugEnabled() &amp;&amp; !request.getDispatcherType().equals(DispatcherType.ASYNC)) &#123;</span><br><span class="line">            this.logger.debug(&quot;Mapped to &quot; + executionChain.getHandler());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (this.hasCorsConfigurationSource(handler)) &#123;</span><br><span class="line">            CorsConfiguration config &#x3D; this.corsConfigurationSource !&#x3D; null ? this.corsConfigurationSource.getCorsConfiguration(request) : null;</span><br><span class="line">            CorsConfiguration handlerConfig &#x3D; this.getCorsConfiguration(handler, request);</span><br><span class="line">            config &#x3D; config !&#x3D; null ? config.combine(handlerConfig) : handlerConfig;</span><br><span class="line">            executionChain &#x3D; this.getCorsHandlerExecutionChain(request, executionChain, config);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return executionChain;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在说上面一段代码之前,先回顾下,<br>之前介绍了HandlerExecutionChain由Handler和HandlerInterceptor组成,<br>那么我们就需要在getHandler里找到这2个关键的地方.<br>而第一行的getHandlerInternal方法就获取到了Handler,<br>后面又通过getHandlerExecutionChain直接构造出来了HandlerExecutionChain,<br>所以可以肯定:getHandlerInternal是根据URL映射找到了Handler<br>getHandlerExecutionChain通过HandlerInterceptor和Handler构造了HandlerExecutionChain对象,<br>至于我为什么这么肯定,<br>自然是因为我已经阅读过了源码啦…这里留个空子,希望有缘看到这里的同学能够自己看看实现的细节.</p>
<p>回到doDispatch方法,在获取到handler(HandlerExecutionChain)后,<br>紧接着判断获取的handler是否为空,如果为空,说明url不对,<br>没有匹配的handler,就会调用noHandlerFound方法处理.</p>
<p>接下来 DispatcherServlet调用了getHandlerAdapter方法获取了又一个9大组件,<br>开始的时候介绍过:HandlerMapping是通过Request获取匹配的handler(HandlerExecutionChain)对象,<br>而HandlerAdapter才是指挥handler干活的,<br>所以这一步相当重要,看看这个getHandlerAdapter是如何获 HandlerAdapter的吧：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected HandlerAdapter getHandlerAdapter(Object handler) throws ServletException &#123;</span><br><span class="line">    if (this.handlerAdapters !&#x3D; null) &#123;</span><br><span class="line">        Iterator var2 &#x3D; this.handlerAdapters.iterator();</span><br><span class="line"></span><br><span class="line">        while(var2.hasNext()) &#123;</span><br><span class="line">            HandlerAdapter adapter &#x3D; (HandlerAdapter)var2.next();</span><br><span class="line">            &#x2F;&#x2F;判断HandlerAdapter是否支持handler</span><br><span class="line">            if (adapter.supports(handler)) &#123;</span><br><span class="line">                return adapter;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    throw new ServletException(&quot;No adapter for handler [&quot; + handler + &quot;]: The DispatcherServlet configuration needs to include a HandlerAdapter that supports this handler&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到getHandlerAdapter方法遍历DispatcherServlet的HandlerAdapter集合,<br>并且调用 HandlerAdapter 的 supports方法来选择合适的<br>HandlerAdapter,看看 supports 方法具体实现:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public final boolean supports(Object handler) &#123;</span><br><span class="line">     &#x2F;&#x2F;这里的主要是第一个判断: handler instanceof HandlerMethod</span><br><span class="line">     return handler instanceof HandlerMethod &amp;&amp; this.supportsInternal((HandlerMethod)handler);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> &#x2F;&#x2F;鉴于方便,我直接把supportsInternal方法贴过来</span><br><span class="line"> protected boolean supportsInternal(HandlerMethod handlerMethod) &#123;</span><br><span class="line">     return true;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>可以看到supportsInternal方法对于HandlerMethod类型的参数直接返回true,当然这只是一个HandlerAdapter的实现,但也足够说明问题了,最重要的是第一个判断:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">handler instanceof HandlerMethod</span><br></pre></td></tr></table></figure>

<p>我们之前说过handler在HandlerExecutionChain内部是一个Object类型,<br>到了这里为什么就变成了HandlerMethod类型了。<br>其实早在getHandler那一步就变成了Handler,<br>到这一步只是适配确认一下.那来看看HandlerMethod是什么吧,<br>它为什么可以执行我们的RequestMapping方法呢?</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class HandlerMethod &#123;</span><br><span class="line">    ...</span><br><span class="line">    &#x2F;&#x2F;bean既可以作为Controller,也可以作为Controller的name</span><br><span class="line">    private final Object bean;</span><br><span class="line">   </span><br><span class="line">    &#x2F;&#x2F;Controller所在的容器</span><br><span class="line">    private final BeanFactory beanFactory;</span><br><span class="line">   </span><br><span class="line">    &#x2F;&#x2F;Controller的 Class</span><br><span class="line">    private final Class&lt;?&gt; beanType;</span><br><span class="line">  </span><br><span class="line">    &#x2F;&#x2F;关键之处:requestmapping 对应的方法</span><br><span class="line">    private final Method method;</span><br><span class="line">   </span><br><span class="line">    &#x2F;&#x2F;桥接方法,我google了下,他是起兼容作用的,应该是与method有互补作用</span><br><span class="line">    &#x2F;&#x2F;这是那位大神的分析:[bregedmethod]( https:&#x2F;&#x2F;www.cnblogs.com&#x2F;guangshan&#x2F;p&#x2F;4661305.html )</span><br><span class="line">    private final Method bridgedMethod;</span><br><span class="line">  </span><br><span class="line">    &#x2F;&#x2F;方法的参数</span><br><span class="line">    private final MethodParameter[] parameters;</span><br><span class="line">   </span><br><span class="line">    &#x2F;&#x2F;Http状态码</span><br><span class="line">    private HttpStatus responseStatus;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;不得不说Spring真是流比,像我等之流,只能仰望,返回状态码还得给个原因</span><br><span class="line">    private String responseStatusReason;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;保留的一份HandlerMethod,这个是解析当前HttpMethod实例的那个HttpMethod</span><br><span class="line">    private HandlerMethod resolvedFromHandlerMethod;</span><br><span class="line">    ....  </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>其实到这里基本就知道SpringMVC到底是怎么通过反射执行我们的方法了,<br>还是不断的封装和反射,对于这些框架来说,万物皆可封装,<br>你不服就封装的你服,不管你服不服,我是服了.</p>
<p>再回到doDispatcher方法吧,这个时候已经获取到了需要的handler了,<br>那么就该执行拦截器的preHandle方法了吧,看接下来的applyPreHandle方法:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">boolean applyPreHandle(HttpServletRequest request, HttpServletResponse response) throws Exception &#123;</span><br><span class="line">     HandlerInterceptor[] interceptors &#x3D; this.getInterceptors();</span><br><span class="line">     if (!ObjectUtils.isEmpty(interceptors)) &#123;</span><br><span class="line">         for(int i &#x3D; 0; i &lt; interceptors.length; this.interceptorIndex &#x3D; i++) &#123;</span><br><span class="line">             HandlerInterceptor interceptor &#x3D; interceptors[i];</span><br><span class="line"></span><br><span class="line">             &#x2F;&#x2F;执行拦截器的preHandle方法,如果preHandle方法返回false,那么直接执行所有拦截器的afterCompletion方法</span><br><span class="line">             if (!interceptor.preHandle(request, response, this.handler)) &#123;</span><br><span class="line">                 this.triggerAfterCompletion(request, response, (Exception)null);</span><br><span class="line">                 return false;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     return true;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>再回到doDispatcher方法,执行完拦截器的preHandle方法后<br>,就直接调用HandlerAdapter的handle方法了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public final ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;</span><br><span class="line">      &#x2F;&#x2F;调用了handleInternal方法</span><br><span class="line">      return this.handleInternal(request, response, (HandlerMethod)handler);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;handleInteral方法</span><br><span class="line">  protected ModelAndView handleInternal(HttpServletRequest request, HttpServletResponse response, HandlerMethod handlerMethod) throws Exception &#123;</span><br><span class="line">      &#x2F;&#x2F;检查是否支持请求的类型和是否需要session</span><br><span class="line">      this.checkRequest(request);</span><br><span class="line">     </span><br><span class="line">      ModelAndView mav;</span><br><span class="line">      if (this.synchronizeOnSession) &#123;</span><br><span class="line">          HttpSession session &#x3D; request.getSession(false);</span><br><span class="line">          if (session !&#x3D; null) &#123;</span><br><span class="line">              Object mutex &#x3D; WebUtils.getSessionMutex(session);</span><br><span class="line">              synchronized(mutex) &#123;</span><br><span class="line">                  &#x2F;&#x2F;终于执行目标方法了 ~-~</span><br><span class="line">                  mav &#x3D; this.invokeHandlerMethod(request, response, handlerMethod);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">              mav &#x3D; this.invokeHandlerMethod(request, response, handlerMethod);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">          mav &#x3D; this.invokeHandlerMethod(request, response, handlerMethod);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if (!response.containsHeader(&quot;Cache-Control&quot;)) &#123;</span><br><span class="line">          if (this.getSessionAttributesHandler(handlerMethod).hasSessionAttributes()) &#123;</span><br><span class="line">              this.applyCacheSeconds(response, this.cacheSecondsForSessionAttributeHandlers);</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">              this.prepareResponse(response);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return mav;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>直接看 invokeHandlerMethod ,到底是如何执行method的:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected ModelAndView invokeHandlerMethod(HttpServletRequest request, HttpServletResponse response, HandlerMethod handlerMethod) throws Exception &#123;</span><br><span class="line">    ServletWebRequest webRequest &#x3D; new ServletWebRequest(request, response);</span><br><span class="line"></span><br><span class="line">    ModelAndView var15;</span><br><span class="line">    try &#123;</span><br><span class="line">        WebDataBinderFactory binderFactory &#x3D; this.getDataBinderFactory(handlerMethod);</span><br><span class="line">        ModelFactory modelFactory &#x3D; this.getModelFactory(handlerMethod, binderFactory);</span><br><span class="line">        ServletInvocableHandlerMethod invocableMethod &#x3D; this.createInvocableHandlerMethod(handlerMethod);</span><br><span class="line">        if (this.argumentResolvers !&#x3D; null) &#123;</span><br><span class="line">            invocableMethod.setHandlerMethodArgumentResolvers(this.argumentResolvers);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (this.returnValueHandlers !&#x3D; null) &#123;</span><br><span class="line">            invocableMethod.setHandlerMethodReturnValueHandlers(this.returnValueHandlers);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        invocableMethod.setDataBinderFactory(binderFactory);</span><br><span class="line">        invocableMethod.setParameterNameDiscoverer(this.parameterNameDiscoverer);</span><br><span class="line">        ModelAndViewContainer mavContainer &#x3D; new ModelAndViewContainer();</span><br><span class="line">        mavContainer.addAllAttributes(RequestContextUtils.getInputFlashMap(request));</span><br><span class="line">        modelFactory.initModel(webRequest, mavContainer, invocableMethod);</span><br><span class="line">        mavContainer.setIgnoreDefaultModelOnRedirect(this.ignoreDefaultModelOnRedirect);</span><br><span class="line">        AsyncWebRequest asyncWebRequest &#x3D; WebAsyncUtils.createAsyncWebRequest(request, response);</span><br><span class="line">        asyncWebRequest.setTimeout(this.asyncRequestTimeout);</span><br><span class="line">        WebAsyncManager asyncManager &#x3D; WebAsyncUtils.getAsyncManager(request);</span><br><span class="line">        asyncManager.setTaskExecutor(this.taskExecutor);</span><br><span class="line">        asyncManager.setAsyncWebRequest(asyncWebRequest);</span><br><span class="line">        asyncManager.registerCallableInterceptors(this.callableInterceptors);</span><br><span class="line">        asyncManager.registerDeferredResultInterceptors(this.deferredResultInterceptors);</span><br><span class="line">        Object result;</span><br><span class="line">        if (asyncManager.hasConcurrentResult()) &#123;</span><br><span class="line">            result &#x3D; asyncManager.getConcurrentResult();</span><br><span class="line">            mavContainer &#x3D; (ModelAndViewContainer)asyncManager.getConcurrentResultContext()[0];</span><br><span class="line">            asyncManager.clearConcurrentResult();</span><br><span class="line">            LogFormatUtils.traceDebug(this.logger, (traceOn) -&gt; &#123;</span><br><span class="line">                String formatted &#x3D; LogFormatUtils.formatValue(result, !traceOn);</span><br><span class="line">                return &quot;Resume with async result [&quot; + formatted + &quot;]&quot;;</span><br><span class="line">            &#125;);</span><br><span class="line">            invocableMethod &#x3D; invocableMethod.wrapConcurrentResult(result);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        invocableMethod.invokeAndHandle(webRequest, mavContainer, new Object[0]);</span><br><span class="line">        if (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">            result &#x3D; null;</span><br><span class="line">            return (ModelAndView)result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        var15 &#x3D; this.getModelAndView(mavContainer, modelFactory, webRequest);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        webRequest.requestCompleted();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return var15;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这个代码…我哭了….^^^—-^^^——^^^,总之我就看到了关于数据绑定,<br>SpringMVC的异步核心管理器,ModelAndViewContainer(看名字就知道,容纳了当前handler的很多数据,恩…)<br>其实吧,我没哭,只是确实以我的功力,<br>还是有很多知识没有理解…好吧,我差点哭了…..(说好的轻量级框架呢?)</p>
<p>继续看doDispatcher,逻辑方法执行完了,<br>RequestToViewNameTranslator 就会调用 applyDefaultViewName 方法设置默认的视图.<br>然后就会执行拦截器的 postHandle方法了:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void applyPostHandle(HttpServletRequest request, HttpServletResponse response, @Nullable ModelAndView mv) throws Exception &#123;</span><br><span class="line">    HandlerInterceptor[] interceptors &#x3D; this.getInterceptors();</span><br><span class="line">    if (!ObjectUtils.isEmpty(interceptors)) &#123;</span><br><span class="line">        for(int i &#x3D; interceptors.length - 1; i &gt;&#x3D; 0; --i) &#123;</span><br><span class="line">            HandlerInterceptor interceptor &#x3D; interceptors[i];</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;执行postHandle方法</span><br><span class="line">            interceptor.postHandle(request, response, this.handler, mv);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后,会通过processDispatchResult方法处理最终的结果:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void processDispatchResult(HttpServletRequest request, HttpServletResponse response, @Nullable HandlerExecutionChain mappedHandler, @Nullable ModelAndView mv, @Nullable Exception exception) throws Exception &#123;</span><br><span class="line">    boolean errorView &#x3D; false;</span><br><span class="line">    if (exception !&#x3D; null) &#123;</span><br><span class="line">        if (exception instanceof ModelAndViewDefiningException) &#123;</span><br><span class="line">            this.logger.debug(&quot;ModelAndViewDefiningException encountered&quot;, exception);</span><br><span class="line">            mv &#x3D; ((ModelAndViewDefiningException)exception).getModelAndView();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            Object handler &#x3D; mappedHandler !&#x3D; null ? mappedHandler.getHandler() : null;</span><br><span class="line">            &#x2F;&#x2F;通过HandlerExceptionResolver处理异常</span><br><span class="line">            mv &#x3D; this.processHandlerException(request, response, handler, exception);</span><br><span class="line">            errorView &#x3D; mv !&#x3D; null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (mv !&#x3D; null &amp;&amp; !mv.wasCleared()) &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;通过View的render方法渲染视图</span><br><span class="line">        this.render(mv, request, response);</span><br><span class="line">        if (errorView) &#123;</span><br><span class="line">            WebUtils.clearErrorRequestAttributes(request);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else if (this.logger.isTraceEnabled()) &#123;</span><br><span class="line">        this.logger.trace(&quot;No view rendering, null ModelAndView returned.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (!WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) &#123;</span><br><span class="line">        if (mappedHandler !&#x3D; null) &#123;</span><br><span class="line">            mappedHandler.triggerAfterCompletion(request, response, (Exception)null);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>这样一份源码也算是勉勉强强过了一遍,其实我发现从这个项目的第一份源码分析起到现在,<br>其中的一些知识不懂不是我笨,其实顺藤蘑摸瓜倒也好寻到一些线索。<br>只是像这样的框架我发现我根本没有去了解它的全貌.</p>
<p>我说一个现象:可能有很多同学在分析一份源码的时候,<br>不知道从哪就蹦出来一个比较陌生的对象,你知道它大概是干什么的,<br>与哪些你认识的类有关,但是你就是不知道它哪来了,久而久之,就会对这些框架形成敬畏感。<br>其实我确实对这些框架有敬畏感,毕竟从代码量和各种设计来说,就不得不有敬畏感,<br>到了他们这个体量,也很难再通过HelloWorld去了解他们的全貌了。</p>
<p>简单总结下SpringMVC工作的流程:</p>
<p>**SpringMVC通过DispatcherServlet拦截所有的请求,<br>并通过HandlerMapping与指定的请求找出匹配的handler,<br>handler实际是HandlerMethod对象。<br>再通过与handler适配的HandlerAdapter执行目标方法,<br>执行完目标方法后会返回ModelAndView对象,<br>最后通过ViewResolver解析Mo</p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">陈涛</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://somunstao.github.io/2020/03/10/SpringMVC%2010%E5%B8%B8%E8%A7%81%E7%9F%A5%E8%AF%86%E7%82%B9%E5%8F%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">https://somunstao.github.io/2020/03/10/SpringMVC 10常见知识点及源码解析/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://SomunsTao.github.io" target="_blank">Somuns ` Tao</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/SpringMVC/">SpringMVC</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="post-qr-code__img" src="/img/wechat.jpg" alt="微信"/><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="post-qr-code__img" src="/img/alipay.jpg" alt="支付寶"/><div class="post-qr-code__desc">支付寶</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2020/03/10/SpringBoot10%EF%BC%9A%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%BB%8D/"><img class="prev_cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">SpringBoot10：日志框架介绍</div></div></a></div><div class="next-post pull_right"><a href="/2020/03/09/SpringBoot09%EF%BC%9ASpringMVC%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86/"><img class="next_cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">SpringBoot09：SpringMVC自动配置原理</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2020/03/01/SpringMVC 1概述、编写第一个SpringMVC程序/" title="SpringMVC 1——MVC思想、前端控制器、SpringMVC概述、编写第一个SpringMVC程序"><img class="relatedPosts_cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-03-01</div><div class="relatedPosts_title">SpringMVC 1——MVC思想、前端控制器、SpringMVC概述、编写第一个SpringMVC程序</div></div></a></div><div class="relatedPosts_item"><a href="/2020/03/02/SpringMVC 2——SpringMVC的执行原理、核心组件、第一个SpringMVC程序(注解版)/" title="SpringMVC 2——SpringMVC的执行原理、核心组件、第一个SpringMVC程序(注解版)"><img class="relatedPosts_cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-03-02</div><div class="relatedPosts_title">SpringMVC 2——SpringMVC的执行原理、核心组件、第一个SpringMVC程序(注解版)</div></div></a></div><div class="relatedPosts_item"><a href="/2020/03/03/SpringMVC 3——静态资源访问问题、处理器方法响应类型、请求转发、URL重定向/" title="SpringMVC 3——静态资源访问问题、处理器方法响应类型、请求转发、URL重定向"><img class="relatedPosts_cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-03-03</div><div class="relatedPosts_title">SpringMVC 3——静态资源访问问题、处理器方法响应类型、请求转发、URL重定向</div></div></a></div><div class="relatedPosts_item"><a href="/2020/03/04/SpringMVC 4——处理器方法参数的处理/" title="SpringMVC 4——处理器方法参数的处理"><img class="relatedPosts_cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-03-04</div><div class="relatedPosts_title">SpringMVC 4——处理器方法参数的处理</div></div></a></div><div class="relatedPosts_item"><a href="/2020/03/05/SpringMVC 5——CRUD操作/" title="SpringMVC 5——CRUD操作"><img class="relatedPosts_cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-03-05</div><div class="relatedPosts_title">SpringMVC 5——CRUD操作</div></div></a></div><div class="relatedPosts_item"><a href="/2020/03/06/SpringMVC 6 SpringMVC拦截器简单使用/" title="SpringMVC 6——SpringMVC拦截器简单使用"><img class="relatedPosts_cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-03-06</div><div class="relatedPosts_title">SpringMVC 6——SpringMVC拦截器简单使用</div></div></a></div></div><div class="clear_both"></div></div><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div id="lv-container" data-id="city" data-uid="MTAyMC80OTk1Ni8yNjQ0Nw=="><script>(function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
})(document, 'script');</script></div></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 By 陈涛</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">簡</a><i class="darkmode far fa-moon" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script defer id="ribbon" src="/js/third-party/canvas-ribbon.js" size="150" alpha="0.6" zIndex="-1" mobile="true" data-click="true"></script><script id="ribbon_piao" mobile="true" src="/js/third-party/piao.js"></script><script id="canvas_nest" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="true" src="/js/third-party/canvas-nest.js"></script><script src="/js/third-party/activate-power-mode.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
document.body.addEventListener('input', POWERMODE);
</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="/js/third-party/click_heart.js"></script></body></html>