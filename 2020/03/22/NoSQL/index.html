<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Redis NoSQL | Somuns ` Tao</title><meta name="description" content="Redis"><meta name="keywords" content="Redis"><meta name="author" content="陈涛"><meta name="copyright" content="陈涛"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="dns-prefetch" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="dns-prefetch" href="https://fonts.googleapis.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="dns-prefetch" href="//busuanzi.ibruce.info"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Redis NoSQL"><meta name="twitter:description" content="Redis"><meta name="twitter:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><meta property="og:type" content="article"><meta property="og:title" content="Redis NoSQL"><meta property="og:url" content="https://somunstao.github.io/2020/03/22/NoSQL/"><meta property="og:site_name" content="Somuns ` Tao"><meta property="og:description" content="Redis"><meta property="og:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><meta property="article:published_time" content="2020-03-21T16:00:00.000Z"><meta property="article:modified_time" content="2020-08-02T04:39:21.708Z"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>var autoChangeMode = '1'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="https://somunstao.github.io/2020/03/22/NoSQL/"><link rel="prev" title="Java -- 枚举类" href="https://somunstao.github.io/2020/03/22/Java%20--%20%E6%9E%9A%E4%B8%BE%E7%B1%BB/"><link rel="next" title="SpringCloud 笔记" href="https://somunstao.github.io/2020/03/22/SpringCloud%20%E7%AC%94%E8%AE%B0/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: 'false',
  isFontAwesomeV5: true,
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="Somuns ` Tao" type="application/atom+xml">
</head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">132</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">11</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">11</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 時間軸</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 留言板</span></a></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis-NoSQL"><span class="toc-number">1.</span> <span class="toc-text">Redis NoSQL</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#NoSQL-Not-only-SQL"><span class="toc-number">2.</span> <span class="toc-text">NoSQL(Not-only SQL)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#什么是NoSQL数据库"><span class="toc-number">2.1.</span> <span class="toc-text">什么是NoSQL数据库?</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么要有NoSQL数据库"><span class="toc-number">2.1.1.</span> <span class="toc-text">为什么要有NoSQL数据库?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#非关系型数据库与关系型数据库的区别"><span class="toc-number">2.1.2.</span> <span class="toc-text">非关系型数据库与关系型数据库的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#有哪些类型的NoSQL数据库"><span class="toc-number">2.1.3.</span> <span class="toc-text">有哪些类型的NoSQL数据库?</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis"><span class="toc-number">2.2.</span> <span class="toc-text">Redis</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是Redis"><span class="toc-number">2.2.1.</span> <span class="toc-text">什么是Redis?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis常见知识点"><span class="toc-number">2.2.2.</span> <span class="toc-text">Redis常见知识点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Redis优缺点"><span class="toc-number">2.2.2.1.</span> <span class="toc-text">Redis优缺点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redis为什么这么快"><span class="toc-number">2.2.2.2.</span> <span class="toc-text">Redis为什么这么快?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redis应用场景"><span class="toc-number">2.2.2.3.</span> <span class="toc-text">Redis应用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#为什么不用Map或Guava做缓存"><span class="toc-number">2.2.2.4.</span> <span class="toc-text">为什么不用Map或Guava做缓存?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redis和Memcached异同"><span class="toc-number">2.2.2.5.</span> <span class="toc-text">Redis和Memcached异同</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis-IO模型"><span class="toc-number">2.2.3.</span> <span class="toc-text">Redis IO模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Redis-6-之前"><span class="toc-number">2.2.3.1.</span> <span class="toc-text">Redis 6 之前</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redis-6-之后"><span class="toc-number">2.2.3.2.</span> <span class="toc-text">Redis 6 之后</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis事务"><span class="toc-number">2.2.4.</span> <span class="toc-text">Redis事务</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Redis事务执行过程"><span class="toc-number">2.2.4.1.</span> <span class="toc-text">Redis事务执行过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redis事务队列"><span class="toc-number">2.2.4.2.</span> <span class="toc-text">Redis事务队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redis事务错误"><span class="toc-number">2.2.4.3.</span> <span class="toc-text">Redis事务错误</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis数据结构"><span class="toc-number">2.2.5.</span> <span class="toc-text">Redis数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis缓存淘汰策略-key回收"><span class="toc-number">2.2.6.</span> <span class="toc-text">Redis缓存淘汰策略(key回收)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#noeviction"><span class="toc-number">2.2.6.1.</span> <span class="toc-text">noeviction</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#volatile"><span class="toc-number">2.2.6.2.</span> <span class="toc-text">volatile</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#allkeys"><span class="toc-number">2.2.6.3.</span> <span class="toc-text">allkeys</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis持久化"><span class="toc-number">2.2.7.</span> <span class="toc-text">Redis持久化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#RDB-Redis-Data-Base"><span class="toc-number">2.2.7.1.</span> <span class="toc-text">RDB(Redis Data Base)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RDB优缺点"><span class="toc-number">2.2.7.2.</span> <span class="toc-text">RDB优缺点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AOF-Append-Only-File"><span class="toc-number">2.2.7.3.</span> <span class="toc-text">AOF(Append Only File)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AOF优缺点"><span class="toc-number">2.2.7.4.</span> <span class="toc-text">AOF优缺点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#如何选择持久化策略"><span class="toc-number">2.2.7.5.</span> <span class="toc-text">如何选择持久化策略?</span></a></li></ol></li></ol></li></ol></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">Somuns ` Tao</a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 時間軸</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 留言板</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">Redis NoSQL</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2020-03-22 00:00:00"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2020-03-22</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2020-08-02 12:39:21"><i class="fa fa-history" aria-hidden="true"></i> 更新于 2020-08-02</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Redis/">Redis</a></span></div><div class="meta-secondline"> </div><div class="meta-thirdline"><span class="post-meta-pv-cv"><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h1 id="Redis-NoSQL"><a href="#Redis-NoSQL" class="headerlink" title="Redis NoSQL"></a>Redis NoSQL</h1><!-- TOC -->

<ul>
<li><a href="#nosqlnot-only-sql">NoSQL(Not-only SQL)</a><ul>
<li><a href="#什么是nosql数据库">什么是NoSQL数据库?</a><ul>
<li><a href="#为什么要有nosql数据库">为什么要有NoSQL数据库?</a></li>
<li><a href="#非关系型数据库与关系型数据库的区别">非关系型数据库与关系型数据库的区别</a></li>
<li><a href="#有哪些类型的nosql数据库">有哪些类型的NoSQL数据库?</a></li>
</ul>
</li>
<li><a href="#redis">Redis</a><ul>
<li><a href="#什么是redis">什么是Redis?</a></li>
<li><a href="#redis常见知识点">Redis常见知识点</a><ul>
<li><a href="#redis优缺点">Redis优缺点</a></li>
<li><a href="#redis为什么这么快">Redis为什么这么快?</a></li>
<li><a href="#redis应用场景">Redis应用场景</a></li>
<li><a href="#为什么不用map或guava做缓存">为什么不用Map或Guava做缓存?</a></li>
<li><a href="#redis和memcached异同">Redis和Memcached异同</a></li>
</ul>
</li>
<li><a href="#redis-io模型">Redis IO模型</a><ul>
<li><a href="#redis-6-之前">Redis 6 之前</a></li>
<li><a href="#redis-6-之后">Redis 6 之后</a></li>
</ul>
</li>
<li><a href="#redis事务">Redis事务</a><ul>
<li><a href="#redis事务执行过程">Redis事务执行过程</a></li>
<li><a href="#redis事务队列">Redis事务队列</a></li>
<li><a href="#redis事务错误">Redis事务错误</a></li>
</ul>
</li>
<li><a href="#redis数据结构">Redis数据结构</a></li>
<li><a href="#redis缓存淘汰策略key回收">Redis缓存淘汰策略(key回收)</a><ul>
<li><a href="#noeviction">noeviction</a></li>
<li><a href="#volatile">volatile</a></li>
<li><a href="#allkeys">allkeys</a></li>
</ul>
</li>
<li><a href="#redis持久化">Redis持久化</a><ul>
<li><a href="#rdbredis-data-base">RDB(Redis Data Base)</a></li>
<li><a href="#rdb优缺点">RDB优缺点</a></li>
<li><a href="#aofappend-only-file">AOF(Append Only File)</a></li>
<li><a href="#aof优缺点">AOF优缺点</a></li>
<li><a href="#如何选择持久化策略">如何选择持久化策略?</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- /TOC -->

<h1 id="NoSQL-Not-only-SQL"><a href="#NoSQL-Not-only-SQL" class="headerlink" title="NoSQL(Not-only SQL)"></a>NoSQL(Not-only SQL)</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">如有错误之处，敬请指教。</span><br></pre></td></tr></table></figure>

<p>PS:部分图片源于网络,如有侵权，请联系俺，俺会立刻删除。</p>
<h2 id="什么是NoSQL数据库"><a href="#什么是NoSQL数据库" class="headerlink" title="什么是NoSQL数据库?"></a>什么是NoSQL数据库?</h2><p>NoSQL数据库泛指非关系型数据库，与关系型数据库不同，非关系型数据库并没有一种固定的存储数据的结构，<br>相对来说比较灵活。</p>
<h3 id="为什么要有NoSQL数据库"><a href="#为什么要有NoSQL数据库" class="headerlink" title="为什么要有NoSQL数据库?"></a>为什么要有NoSQL数据库?</h3><p>个人认为非关系型数据库与关系型数据库是一种相辅相成的关系，起到了互补的作用。</p>
<p>关系型数据库的数据看上去很直观且支持事务，保证了数据的一致性。</p>
<p>非关系型数据库读写速度块，在高并发的压力下仍有不俗的表现且数据结构丰富，<br>更多的是对关系型数据库的一种补充。</p>
<h3 id="非关系型数据库与关系型数据库的区别"><a href="#非关系型数据库与关系型数据库的区别" class="headerlink" title="非关系型数据库与关系型数据库的区别"></a>非关系型数据库与关系型数据库的区别</h3><ul>
<li>存储结构</li>
</ul>
<blockquote>
<p>关系型数据库按照结构化的方式存储数据，需要先定义好数据库表的字段，<br>再存储数据。这样做的好处就是可靠性比较高，但是如果后期应用扩展功能，<br>需要扩展表的话，会有些受限。</p>
<p>非关系型数据库存储的结构则不像关系型数据库那样固定，相对来说较为灵活，<br>可以根据数据调整数据库的结构。</p>
</blockquote>
<ul>
<li>存储方式</li>
</ul>
<blockquote>
<p>关系型数据库大多采用行和列这样的表格关系存储数据。</p>
<p>非关系型数据库存储数据的方式则不固定，有的采用K-V键值对存储，<br>有的采用文档存储，还有的图数据库使用图结构存储。</p>
</blockquote>
<ul>
<li>SQL标准</li>
</ul>
<blockquote>
<p>关系型数据库采用结构化的语言SQL来对数据库进行操作，并且SQL已成为大多数数据库的标准规范。</p>
<p>非关系型数据库则各自为战，一直没有一个统一的标准，每种厂商提供的数据库规范都不一样。</p>
</blockquote>
<ul>
<li>读写速度</li>
</ul>
<blockquote>
<p>关系型数据库强调数据的一致性，所以在遇到高并发读写操作时，会显得力不从心。</p>
<p>非关系型数据库强调BASE理论:<br><strong>Basically Available(基本可用),Soft-state(软状态),Eventual Consistency(最终一致性)。</strong><br>它允许一定程度的数据不一致，但保证数据的最终一致性。<br>因此，面对高并发读写操作时，表现的会比关系型数据库好的多，<br>这也是redis,memcached这类高性能的NoSQL数据库被用于缓存的主要原因。</p>
</blockquote>
<h3 id="有哪些类型的NoSQL数据库"><a href="#有哪些类型的NoSQL数据库" class="headerlink" title="有哪些类型的NoSQL数据库?"></a>有哪些类型的NoSQL数据库?</h3><ul>
<li><p>K-V键值对: K-V键值对类型的NoSQL数据库类似于Hash表，将数据存储在内存中，<br>操作速度非常的快，因此常被用于缓存数据库。K-V键值对类型的NoSQL数据库主要有:Memcached,Redis等。</p>
</li>
<li><p>文档: 文档类型的NoSQL数据库结构则不固定，无需像关系型数据库一样预先定义字段，它存储数据的方式类似于JSON，<br>可以清晰的描述数据之间的复杂关系。文档类型的NoSQL数据库主要有:MongoDB,CouchDB等。</p>
</li>
<li><p>列式存储: 列式存储的NoSQL数据库以列簇形式存储数据，将同一列的数据存储在一起，<br>这样可以分割为多列，查询速度是很快的，但是列式存储的数据库功能也会收到限制。<br>列式NoSQL数据库主要有:HBase等;</p>
</li>
</ul>
<p><img src="E:/%E5%B0%9A%E7%A1%85%E8%B0%B7java/JVMzhouyang/framework-learning/img/database/redis/%E8%A1%8C%E5%BC%8F%E5%AD%98%E5%82%A8%E5%92%8C%E5%88%97%E5%BC%8F%E5%AD%98%E5%82%A8.png" alt="行式存储和列式存储"></p>
<ul>
<li>图结构: 图数据库主要用于构建节点的关系图谱，以图算法和图结构进行计算和存储。<br>图数据库主要有:Neo4j等。</li>
</ul>
<hr>
<h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><p>推荐一个学习Redis的网站: <a href="http://redisbook.com/" target="_blank" rel="noopener">RedisBook</a></p>
<h3 id="什么是Redis"><a href="#什么是Redis" class="headerlink" title="什么是Redis?"></a>什么是Redis?</h3><blockquote>
<p>Redis是一个使用ANSI C语言编写，遵守BSD协议规范的开源的K-V类型的NoSQL数据库服务器。<br>Redis是当前最流行的K-V类型的NoSQL数据库之一，在通往系统架构的方向，它是我们不得不学习的知识。</p>
</blockquote>
<p><a href="https://www.redis.net.cn/" target="_blank" rel="noopener">Redis官网</a></p>
<h3 id="Redis常见知识点"><a href="#Redis常见知识点" class="headerlink" title="Redis常见知识点"></a>Redis常见知识点</h3><h4 id="Redis优缺点"><a href="#Redis优缺点" class="headerlink" title="Redis优缺点"></a>Redis优缺点</h4><ul>
<li><p>Redis的优点:</p>
<ul>
<li><p>性能高: 用c语言编写的应用我就没见过慢的<del>_</del>。</p>
</li>
<li><p>丰富的数据结构: 总体上来说Redis是以K-V形式存储数据，但是细分来说，<br>它支持STRING，HASH，LIST，SET，SORTED_SET，HyperLogLog等多种数据结构。 </p>
</li>
<li><p>支持Lua脚本: Redis使用Lua脚本解释器来执行脚本，所以它支持Lua脚本。</p>
</li>
<li><p>支持事务: Redis是为数不多的支持事务的NoSQL数据库之一。</p>
</li>
<li><p>支持数据持久化: Redis支持rdb和aof两种数据持久化方式。</p>
</li>
<li><p>支持发布者/订阅者功能</p>
</li>
<li><p>支持主从模式: Redis支持Sentinel哨兵模式搭建高可用集群配置。</p>
</li>
</ul>
</li>
<li><p>Redis的缺点:</p>
<ul>
<li>受限于物理内存: Redis属于内存数据库，它在内存中存储数据的大小是受物理内存限制的，<br>所以它不适合存储海量数据。</li>
</ul>
</li>
</ul>
<h4 id="Redis为什么这么快"><a href="#Redis为什么这么快" class="headerlink" title="Redis为什么这么快?"></a>Redis为什么这么快?</h4><ul>
<li><p>内存操作: Redis绝大部分操作都是基于内存的，想不快都难。</p>
</li>
<li><p>优秀的数据结构: Redis虽然支持的数据结构众多，但是它的每种数据结构都是专门设计和优化过的。</p>
</li>
<li><p>IO多路复用: Redis整体采用IO多路复用模型，核心操作使用单线程处理。</p>
</li>
</ul>
<h4 id="Redis应用场景"><a href="#Redis应用场景" class="headerlink" title="Redis应用场景"></a>Redis应用场景</h4><ul>
<li><p>缓存: 缓存可能是Redis用的最多的场景了。由于Redis的高性能，<br>高并发场景下作为缓存服务数据库，再适合不过了。<br>并且Redis支持的key自动过期功能，更是可以定制热点数据的过期时间。</p>
</li>
<li><p>多功能业务场景: Redis支持多种丰富的数据结构，不仅可以存储简单的K-V数据，还可以使用Hash存储用户，商品等信息，<br>List存储有序的数据，Set还有交集，并集，差集等功能。</p>
</li>
<li><p>分布式锁: Redis的操作具有原子性的，可以利用这点来完成分布式锁。</p>
</li>
</ul>
<h4 id="为什么不用Map或Guava做缓存"><a href="#为什么不用Map或Guava做缓存" class="headerlink" title="为什么不用Map或Guava做缓存?"></a>为什么不用Map或Guava做缓存?</h4><p>因为无论是Map还是Guava，都属于本地缓存，数据都存在一个JVM进程内的。<br>如果是单机模式，这样做尚可。但如果是分布式或者Java应用有多个实例，那就不能保证每个JVM进程内的缓存是一致的，<br>所以需要使用Redis这种第三方数据库作为缓存容器。</p>
<h4 id="Redis和Memcached异同"><a href="#Redis和Memcached异同" class="headerlink" title="Redis和Memcached异同"></a>Redis和Memcached异同</h4><ul>
<li><p>都属于内存数据库</p>
</li>
<li><p>持久化支持: Redis支持RDB和AOF两种持久化机制；<br>Memcached只在内存中存储数据，不支持持久化机制。</p>
</li>
<li><p>数据结构: Redis从整体上来说是以K-V类型的为存储结构，<br>但它细分可以支持String，Hash，List，Set，Sorted Set等数据类型；<br>Memcached只支持K-V类型的存储结构。</p>
</li>
<li><p>IO模型: Redis是以IO多路复用为模型的设计；<br>Memached是以非阻塞IO为模型的设计。</p>
</li>
<li><p>事件库: Redis采用自制的AeEven事件库处理Socket事件;<br>Memcached采用的是LibEvent事件库。</p>
</li>
<li><p>使用场景: 不考虑性能，Redis更适用于需要复杂数据结构，需要持久化的应用，<br>如果你的应用以后需要扩展，那么也可以选择Redis；<br>Memcached则适用于高并发和只需要K-V数据结构的应用。  </p>
</li>
</ul>
<hr>
<h3 id="Redis-IO模型"><a href="#Redis-IO模型" class="headerlink" title="Redis IO模型"></a>Redis IO模型</h3><p>Redis IO模型按Redis的版本可以分为Redis 6之前和Redis 6之后。</p>
<h4 id="Redis-6-之前"><a href="#Redis-6-之前" class="headerlink" title="Redis 6 之前"></a>Redis 6 之前</h4><p>Redis是基于IO多路复用模型处理Socket请求的，关于多路复用的知识，我在<br><a href="https://github.com/guang19/framework-learning/blob/dev/jdk-jvm-juc/Jdk&Jvm&Juc.md#%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8io%E7%BD%91%E7%BB%9Cio%E6%A8%A1%E5%9E%8B" target="_blank" rel="noopener">Linux五种IO模型中</a><br>已经说过了:<br>IO多路复用模型依赖于操作系统的select/poll/epoll函数，<br>epoll函数使得内核不断轮询客户端socket，<br>用户进程(线程)也需要阻塞在对epoll函数的调用上，当Socket有事件时，<br>用户线程便发起系统调用，处理Socket事件。</p>
<p>IO多路复用模型简单理解就是一个线程处理多个Socket连接。<br>所以<strong>可以把Redis看成是单线程模型，但并不是说Redis只有一个线程，<br>而是说它执行核心操作的线程只有一个，它还有其他辅助线程完成其它功能。<br>Redis这样设计就避免了多线程切换的开销和简化了Redis的设计。</strong></p>
<p>Redis IO模型:</p>
<p>![Redis 6之前IO模型](E:/尚硅谷java/JVMzhouyang/framework-learning/img/database/redis/Redis 6之前IO模型.png)</p>
<h4 id="Redis-6-之后"><a href="#Redis-6-之后" class="headerlink" title="Redis 6 之后"></a>Redis 6 之后</h4><p>Redis 6 之前一个线程处理所有的Socket和核心操作，<br>这样做的好处就是单线程无需考虑像多线程切换带来的困扰，<br>简化了Redis的模型，但随之而来的也有性能上的瓶颈。</p>
<p><strong>虽然Redis确实够快，但它的数据是在内存中操作的，会受到内存的限制。<br>且一个线程处理所有的Socket会带来网络IO的限制，并不能发挥多核CPU的优势。</strong></p>
<p>那有什么办法既能够发挥多核cpu的优势，又不会复杂化Redis的架构呢？</p>
<p>Redis 6 之前的瓶颈主要在于内存和网络IO。</p>
<p>关于内存这块，只得靠Redis自身的优化和机器条件了。<br>但是网络IO这块就可以通过新增多线程来处理大量Socket连接来优化了。<br>Redis 6 正是通过新增监听线程来解决网络IO的瓶颈，线程监听到Socket事件后，<br>再交由main线程处理。<br>所以<strong>整体来说，Redis 6 在处理Socket事件上由单线程优化成了多线程，但核心操作还是由单线程执行。</strong></p>
<p>Redis 6 IO模型：</p>
<p>![Redis 6 IO模型](E:/尚硅谷java/JVMzhouyang/framework-learning/img/database/redis/Redis 6 IO模型.png)</p>
<hr>
<h3 id="Redis事务"><a href="#Redis事务" class="headerlink" title="Redis事务"></a>Redis事务</h3><blockquote>
<p>Redis的事务主要依赖于WATCH ,UNWATCH,MULTI , EXEC, DISCARD等命令。<br>其中 MULTI , EXEC , DISCARD 分别对应关系型数据库的 BEGIN,COMMIT,ROLLBACK操作。</p>
</blockquote>
<h4 id="Redis事务执行过程"><a href="#Redis事务执行过程" class="headerlink" title="Redis事务执行过程"></a>Redis事务执行过程</h4><p>客户端使用MULTI命令开启事务，此时用户就可以开始发出要执行的命令。<br><strong>如果命令为WATCH/MULTI/EXEC/DISCARD这四个中的任意一个，<br>那么会被直接执行，</strong>因为它们属于事务操作。</p>
<p>当执行DISCARD的时候，会清空事务队列并退出事务。<br>如果是普通命令，就将命令加入事务队列，然后<strong>当EXEC命令执行时，<br>事务中的队列将会被一一执行，最后执行的结果也是一个数组。</strong></p>
<p><img src="E:/%E5%B0%9A%E7%A1%85%E8%B0%B7java/JVMzhouyang/framework-learning/img/database/redis/Redis%E6%89%A7%E8%A1%8C%E4%BA%8B%E5%8A%A1.png" alt="Redis执行事务"></p>
<p>参考: <a href="https://redisbook.readthedocs.io/en/latest/feature/transaction.html" target="_blank" rel="noopener">Redis事务的设计与实现</a></p>
<h4 id="Redis事务队列"><a href="#Redis事务队列" class="headerlink" title="Redis事务队列"></a>Redis事务队列</h4><p>在开启事务后，用户命令并不会被立刻执行，而是被添加到事务队列中，<br>这个队列其实是一个数组，每个数组元素由3部分组成:</p>
<ol>
<li>要执行的命令(cmd)</li>
<li>命令的参数(argv)</li>
<li>参数的数量(argc)</li>
</ol>
<p>命令被添加到队列中的结构大致如下:</p>
<p><img src="E:/%E5%B0%9A%E7%A1%85%E8%B0%B7java/JVMzhouyang/framework-learning/img/database/redis/Redis%E4%BA%8B%E5%8A%A1%E9%98%9F%E5%88%97%E8%AF%A6%E6%83%85-%E6%89%A7%E8%A1%8C%E5%89%8D.png" alt="Redis事务队列详情-执行前"></p>
<p>命令被执行后，也会生成一个结果数组，Redis就将这个结果数组返回:</p>
<p><img src="E:/%E5%B0%9A%E7%A1%85%E8%B0%B7java/JVMzhouyang/framework-learning/img/database/redis/Redis%E4%BA%8B%E5%8A%A1%E9%98%9F%E5%88%97%E8%AF%A6%E6%83%85-%E6%89%A7%E8%A1%8C%E5%90%8E.png" alt="Redis事务队列详情-执行后.png"></p>
<h4 id="Redis事务错误"><a href="#Redis事务错误" class="headerlink" title="Redis事务错误"></a>Redis事务错误</h4><p>Redis事务有两个错误时机。</p>
<ul>
<li>EXEC执行命令之前出现错误: 在EXEC命令之前的错误，也就是开启事务后，用户发出了错误的命令，<br>参数数量不对或其他原因，服务端会累积这些错误。<br>当EXEC命令执行时，将拒绝执行事务，并返回错误原因，清空事务队列。</li>
</ul>
<p><img src="E:/%E5%B0%9A%E7%A1%85%E8%B0%B7java/JVMzhouyang/framework-learning/img/database/redis/Redis%E4%BA%8B%E5%8A%A1%E9%94%99%E8%AF%AF-EXEC%E6%89%A7%E8%A1%8C%E5%89%8D.png" alt="Redis事务错误-EXEC执行前"></p>
<ul>
<li>EXEC执行命令时出现错误: EXEC执行命令时出现错误，也就是用户发出的命令没有错，<br>但是在执行命令的时候出现了错误(可能是参数类型不对)，这时候仍然返回结果数组,<br>也就是说错误的命令并不影响其他命令的执行。</li>
</ul>
<p><img src="E:/%E5%B0%9A%E7%A1%85%E8%B0%B7java/JVMzhouyang/framework-learning/img/database/redis/Redis%E4%BA%8B%E5%8A%A1%E9%94%99%E8%AF%AF-EXEC%E6%89%A7%E8%A1%8C%E6%97%B6.png" alt="Redis事务错误-EXEC执行时"></p>
<hr>
<h3 id="Redis数据结构"><a href="#Redis数据结构" class="headerlink" title="Redis数据结构"></a>Redis数据结构</h3><p>关于Redis数据结构这块，还是推荐学习: <a href="http://redisbook.com/" target="_blank" rel="noopener">RedisBook</a></p>
<blockquote>
<p>Redis有着非常丰富的数据结构，这些数据结构可以满足非常多的应用场景，<br>如果对这些数据结构有一个比较清晰的认知，使用Redis也会更加得心应手。</p>
</blockquote>
<p>Redis主要支持以下数据结构:</p>
<ol>
<li>String(字符串)</li>
<li>List(双端链表)</li>
<li>Hash(Hash字典)</li>
<li>Set(无序集合)</li>
<li>Sorted Set(有序集合)</li>
</ol>
<table>
<thead>
<tr>
<th align="center">数据结构</th>
<th align="center">描述</th>
<th align="center">实现</th>
</tr>
</thead>
<tbody><tr>
<td align="center">String</td>
<td align="center">可以存储字符串，整型和浮点型等类型的数据。适合于简单的K-V数据场景。</td>
<td align="center">Redis并没有使用字符数组来实现这一数据类型，而是自己定义了简单动态字符串(SDS: Simple Dynamic String)类型来实现这一数据结构。</td>
</tr>
<tr>
<td align="center">List</td>
<td align="center">既可以存储操作有序的数据，还可以当做栈来使用，它适合存储列表性质的数据。</td>
<td align="center">List在Redis中使用的是双端链表和压缩列表实现的，这就解释了它为什么能在头尾操作元素。 C语言并没有双端链表的实现，所以Redis自定义了这一数据结构。</td>
</tr>
<tr>
<td align="center">Hash</td>
<td align="center">Hash字典，也是关联数组，数组的每个元素都是key到value的映射，它适合存储对象这样的结构化数据。</td>
<td align="center">Hash在Redis中是使用Hash字典和压缩列表实现的。</td>
</tr>
<tr>
<td align="center">Set</td>
<td align="center">Set无序集合，它适合存储需要去重的元素，且有并集，交集，差集等功能在多个Set之间进行比较计算。</td>
<td align="center">整数集合是Set的底层实现之一，当集合只有整型元素且元素数量不多的时候，Redis就会使用整数集合来实现Set。当新添加元素的时候，整数集合会根据新元素的类型自动扩容，并将所有元素的类型都转为与新元素一样的类型，在这个过程中，还需要保持原来的顺序不变，最后才添加新元素。</td>
</tr>
<tr>
<td align="center">Sorted Set</td>
<td align="center">Sorted Set有序集合，可以看做加强版的Set。Sorted Set 与  Set不同的是，Sorted Set可以根据元素的score分数进行排序。它适合存储需要排序的不重复的元素。</td>
<td align="center">Sorted Set在Redis中使用的是跳表实现的，跳表是一种有序且查询速度很快的数据结构。跳表每个节点都维持指向其他节点的指针，从而达到快速访问的目的。</td>
</tr>
</tbody></table>
<hr>
<h3 id="Redis缓存淘汰策略-key回收"><a href="#Redis缓存淘汰策略-key回收" class="headerlink" title="Redis缓存淘汰策略(key回收)"></a>Redis缓存淘汰策略(key回收)</h3><p><strong>当Redis使用的内存超出物理内存限制时，<br>Redis的内存会和Swap(虚拟内存)频繁切换，使得Redis性能下降。<br>为了不让Redis内存占用超过物理内存占用，可以给Redis配置一个 maxmemory 的值，<br>当Redis占用内存超过了这个maxamemory的值，<br>那么Redis将启用缓存淘汰策略来删除内存中的key，<br>缓存淘汰策略可以通过 maxmemory-policy 设置。</strong></p>
<p>缓存淘汰策略主要分为3类:</p>
<ol>
<li>noeviction</li>
<li>volatile</li>
<li>allkeys</li>
</ol>
<h4 id="noeviction"><a href="#noeviction" class="headerlink" title="noeviction"></a>noeviction</h4><p>noeviction策略是Redis默认的淘汰策略。<br><strong>它可以继续接受请求，但只执行读请求，不执行写请求，<br>这样做可以保证内存中的数据不会被修改和删除。</strong></p>
<h4 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h4><p><strong>volatile只淘汰设置了过期时间的key。</strong></p>
<p>volatile有三种算法实现:</p>
<ol>
<li><p><strong>volatile-lru</strong>:根据lru算法淘汰设置了过期时间的key，<strong>lru算法优先删除最近最少使用的key</strong>。</p>
</li>
<li><p><strong>volatile-ttl</strong>:根据key的过期时间的长短 淘汰设置了过期时间的key，<strong>过期时间越小的key优先被删除</strong>。</p>
</li>
<li><p><strong>volatile-random</strong>:<strong>随机淘汰设置了过期时间的key</strong>。</p>
</li>
</ol>
<h4 id="allkeys"><a href="#allkeys" class="headerlink" title="allkeys"></a>allkeys</h4><p><strong>allkeys对所有key无差别淘汰</strong></p>
<p>allkeys有两种算法实现:</p>
<ol>
<li><p><strong>allkeys-lru</strong>: 根据lru算法淘汰所有的key，最近最少使用的key优先被删除。</p>
</li>
<li><p><strong>allkeys-random</strong>:随机淘汰所有的key。</p>
</li>
</ol>
<hr>
<h3 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h3><p>Redis有2种持久化策略: RDB和AOF。</p>
<h4 id="RDB-Redis-Data-Base"><a href="#RDB-Redis-Data-Base" class="headerlink" title="RDB(Redis Data Base)"></a>RDB(Redis Data Base)</h4><p>RDB是Redis默认的持久化策略，这种策略是把数据库的快照以二进制形式的副本保存在磁盘上。</p>
<ul>
<li><p>RDB持久化触发条件</p>
<ul>
<li><p>SAVE命令: 当客户端执行SAVE命令时，会阻塞Redis主线程进行数据持久化，直到持久化完成。Redis在阻塞期间不能处理客户端的请求。 </p>
</li>
<li><p>BGSAVE命令: 当客户端执行BGSAVE命令时，Redis会fork一个子进程进行数据持久化，因此并不会阻塞Redis服务。</p>
</li>
<li><p>FLUSHALL命令: 当客户端执行FLUSHALL命令时，会清空Redis所有数据库的数据，并且也会触发数据同步。</p>
</li>
<li><p>save配置: Redis会按照配置文件中的save配置的条件进行数据同步，一旦满足条件，就会执行BGSAVE命令，即fork一个子进程进行同步。</p>
</li>
<li><p>shutdown: 当Redis服务关闭时，也会将数据同步到磁盘，以便下次启动时恢复。</p>
</li>
</ul>
</li>
</ul>
<h4 id="RDB优缺点"><a href="#RDB优缺点" class="headerlink" title="RDB优缺点"></a>RDB优缺点</h4><ul>
<li><p>RDB的优点:</p>
<ul>
<li><p>文件体积小,恢复大数据较快</p>
</li>
<li><p>最大化Redis性能: Redis会fork出子进程进行数据同步，并不影响Redis的性能。</p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>RDB的缺点:</p>
<ul>
<li>数据安全性较低: 如果不显示的执行SAVE命令，那么Redis隔一段时间才会同步数据，可能会造成一定程度的数据丢失。</li>
</ul>
</li>
</ul>
<h4 id="AOF-Append-Only-File"><a href="#AOF-Append-Only-File" class="headerlink" title="AOF(Append Only File)"></a>AOF(Append Only File)</h4><p>AOF策略是把已经执行过的命令以文本的方式追加到AOF文件的末尾，以此达到记录数据库状态的目的。<br>AOF默认情况下是关闭的，当配置选项 appendonly 设置为yes后才会进行AOF的持久化。</p>
<p>appendfsync指定了AOF的同步策略，它有三个可选值。</p>
<ol>
<li><p>no: no代表Redis不亲自持久化，而是通过系统调用write函数每隔一段时间将数据写入文件。<br>这种情况下如果服务器发生故障，可能会有数据还没来得及同步就丢失了。</p>
</li>
<li><p>always: always表示Redis每次执行写操作都会将数据同步到文件中。<br>这种策略虽然保证了数据的安全性，但是对Redis的性能会有影响。</p>
</li>
<li><p>everysec: everysec是AOF默认的持久化策略，这种策略下，<br>系统每一秒都会将数据写入文件，兼顾了性能和数据安全性。</p>
</li>
</ol>
<h4 id="AOF优缺点"><a href="#AOF优缺点" class="headerlink" title="AOF优缺点"></a>AOF优缺点</h4><ul>
<li><p>AOF优点:</p>
<ul>
<li>数据安全性较高,秒级丢失</li>
</ul>
</li>
</ul>
<ul>
<li><p>AOF缺点:</p>
<ul>
<li>文件体积大,恢复大数据较慢</li>
</ul>
</li>
</ul>
<h4 id="如何选择持久化策略"><a href="#如何选择持久化策略" class="headerlink" title="如何选择持久化策略?"></a>如何选择持久化策略?</h4><p>两种持久化方式各有优缺点，可以选择混合的方式进行备份。<br><strong>混合持久化后，文件的内容大部分都是RDB格式的，恢复起来较快，<br>以AOF的方式同步也能保证数据的安全性。</strong></p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">陈涛</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://somunstao.github.io/2020/03/22/NoSQL/">https://somunstao.github.io/2020/03/22/NoSQL/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://SomunsTao.github.io" target="_blank">Somuns ` Tao</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Redis/">Redis</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="post-qr-code__img" src="/img/wechat.jpg" alt="微信"/><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="post-qr-code__img" src="/img/alipay.jpg" alt="支付寶"/><div class="post-qr-code__desc">支付寶</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2020/03/22/Java%20--%20%E6%9E%9A%E4%B8%BE%E7%B1%BB/"><img class="prev_cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Java -- 枚举类</div></div></a></div><div class="next-post pull_right"><a href="/2020/03/22/SpringCloud%20%E7%AC%94%E8%AE%B0/"><img class="next_cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">SpringCloud 笔记</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2020/04/11/Redis 01——NOSQL、Redis概述、通用命令、Redis五大数据类型、三大特殊类型/" title="Redis 01——NOSQL、Redis概述、通用命令、Redis五大数据类型、三大特殊类型"><img class="relatedPosts_cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-04-11</div><div class="relatedPosts_title">Redis 01——NOSQL、Redis概述、通用命令、Redis五大数据类型、三大特殊类型</div></div></a></div><div class="relatedPosts_item"><a href="/2020/04/12/Redis 02——Redis持久化机制、RDB持久化、AOF持久化/" title="Redis 02——NOSQL、Redis概述、通用命令、Redis五大数据类型、三大特殊类型"><img class="relatedPosts_cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-04-12</div><div class="relatedPosts_title">Redis 02——NOSQL、Redis概述、通用命令、Redis五大数据类型、三大特殊类型</div></div></a></div><div class="relatedPosts_item"><a href="/2020/04/13/Redis 03——Java操作Redis、Jedis连接池/" title="Redis 03——Java操作Redis、Jedis连接池"><img class="relatedPosts_cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-04-13</div><div class="relatedPosts_title">Redis 03——Java操作Redis、Jedis连接池</div></div></a></div><div class="relatedPosts_item"><a href="/2020/04/14/Redis 04——SpringBoot整合Redis/" title="Redis 04——SpringBoot整合Redis"><img class="relatedPosts_cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-04-14</div><div class="relatedPosts_title">Redis 04——SpringBoot整合Redis</div></div></a></div><div class="relatedPosts_item"><a href="/2020/04/15/Redis 05——Redis事务、watch锁、数据的删除策略/" title="Redis 05——Redis事务、watch锁、数据的删除策略"><img class="relatedPosts_cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-04-15</div><div class="relatedPosts_title">Redis 05——Redis事务、watch锁、数据的删除策略</div></div></a></div><div class="relatedPosts_item"><a href="/2020/04/16/Redis 06--利用MyBatis自身本地缓存结合Redis实现分布式缓存 (一)/" title="Redis 06——利用MyBatis自身本地缓存结合Redis实现分布式缓存 (一)"><img class="relatedPosts_cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-04-16</div><div class="relatedPosts_title">Redis 06——利用MyBatis自身本地缓存结合Redis实现分布式缓存 (一)</div></div></a></div></div><div class="clear_both"></div></div><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div id="lv-container" data-id="city" data-uid="MTAyMC80OTk1Ni8yNjQ0Nw=="><script>(function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
})(document, 'script');</script></div></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 By 陈涛</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">簡</a><i class="darkmode far fa-moon" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script defer id="ribbon" src="/js/third-party/canvas-ribbon.js" size="150" alpha="0.6" zIndex="-1" mobile="true" data-click="true"></script><script id="ribbon_piao" mobile="true" src="/js/third-party/piao.js"></script><script id="canvas_nest" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="true" src="/js/third-party/canvas-nest.js"></script><script src="/js/third-party/activate-power-mode.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
document.body.addEventListener('input', POWERMODE);
</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="/js/third-party/click_heart.js"></script></body></html>