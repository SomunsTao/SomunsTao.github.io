---
title: java 基础知识点复习
date: 2020-3-21
tags: java
categories: java
keywords: java
description: java 复习
---



## **Java 开发环境**

### Java 的特点

面向对象、跨平台、能把中小型程序写成大型程序

### 开发 Java 的流程

1. 设计类
2. 写代码
3. 重构

### Java 程序规范

- Javadoc 风格注释
- 接口以 able 结尾
- 接口、类使用 Pascal 风格命名
- 成员方法，成员变量使用 camel 风格命名
- 高内聚，低耦合

## **Java 基本语法**

### 数据类型

| 基本类型 | 字节个数 | 默认初始值     | 取值范围                                                     |
| -------- | -------- | -------------- | ------------------------------------------------------------ |
| byte     | 1        | 0              | -128~127                                                     |
| short    | 2        | 0              | -32769~32767                                                 |
| int      | 4        | 0              | -2,147,483,648（-231）~2,147,485,647（231 - 1）              |
| long     | 8        | 0L             | -9,223,372,036,854,775,808（-263）~9,223,372,036,854,775,807（263 -1） |
| float    | 4        | 0.0f           | 符合IEEE 754标准的浮点数                                     |
| double   | 8        | 0.0d           | 符合IEEE 754标准的浮点数                                     |
| boolean  | 1位      | false          | true/false                                                   |
| char     | 2        | 必须手动初始化 | '\u0000'~'\uffff'                                            |

### 8进制与16进制表示

前缀0表示8进制，而前缀0x代表16进制。例如：

```
int octal = 0144;
int hexa =  0x64;
```

### 转义字符

| 符号   | 字符含义                 |
| ------ | ------------------------ |
| \n     | 换行 (0x0a)              |
| \r     | 回车 (0x0d)              |
| \f     | 换页符(0x0c)             |
| \b     | 退格 (0x08)              |
| \t     | 制表符                   |
| "      | 双引号                   |
| '      | 单引号                   |
| \\     | 反斜杠                   |
| \ddd   | 八进制字符 (ddd)         |
| \uxxxx | 16进制Unicode字符 (xxxx) |

### 基本类型与引用类型的区别

1. **从概念方面来说**
   基本类型：变量名指向具体的数值
   引用类型：变量名指向存数据对象的内存地址
2. **从内存构建方面来说**
   基本类型：基本数据类型在被创建时，在**栈**上给其划分一块内存，将数值直接存储在**栈**上；
   引用类型：引用数据类型在被创建时，**首先**要在**栈**上给其引用（句柄）分配一块内存，而对象的**具体信息**都存储在**堆**内存上，然后由栈上面的引用指向堆中对象的地址。
3. **从使用方面来说**
   基本类型：使用时需要赋具体值,判断时使用“==”号
   引用类型：使用时可以赋null,判断时使用equals方法

### 强制类型转换

```
(target_type)variable;
```

### 关键字

| 关键字     | 作用                                                         |
| ---------- | ------------------------------------------------------------ |
| break      | 用来改变程序执行流程，立刻从当前语句的下一句开始执行从。如果后面跟有一个标签，则从标签对应的地方开始执行 |
| case       | 用来定义一组分支选择，如果某个值和switch中给出的值一样，就会从该分支开始执行 |
| catch      | 用来声明当try语句块中发生运行时错误或非运行时异常时运行的一个块 |
| continue   | 用来打断当前循环过程，从当前循环的最后重新开始执行，如果后面跟有一个标签，则从标签对应的地方开始执行 |
| do         | 用来声明一个循环，这个循环的结束条件可以通过while关键字设置  |
| else       | 如果if语句的条件不满足就会执行该语句                         |
| final      | **final 修饰的类不能被继承**。**final 修饰的方法不能被子类重写**。**final 修饰的变量（成员变量或局部变量）即成为常量，只能赋值一次**。final 修饰的成员变量必须在声明的同时赋值，如果在声明的时候没有赋值，那么只有 一次赋值的机会，而且只能在构造方法中显式赋值，然后才能使用。final 修饰的局部变量可以只声明不赋值，然后再进行一次性的赋值。 |
| finally    | 用来执行一段代码不管在前面定义的try语句中是否有异常或运行时错误发生 |
| for        | 用来声明一个循环。程序员可以指定要循环的语句，推出条件和初始化变量 |
| if         | 用来生成一个条件测试，如果条件为真，就执行if下的语句         |
| implements | 在类的声明中是可选的，用来指明当前类实现的接口               |
| import     | 在源文件的开始部分指明后面将要引用的一个类或整个包，这样就不必在使用的时候加上包的名字 |
| instanceof | 用来测试第一个参数的运行时类型是否和第二个参数兼容           |
| interface  | 用来定义一系列的方法和常量。它可以被类实现，通过 `implements` 关键字 |
| private    | 用在方法或变量的声中。它表示这个方法或变量只能被这个类的其它元素所访问 |
| protected  | 在方法和变量的声明中使用，它表示这个方法或变量只能被同一个类中的，子类中的或者同一个包中的类中的元素所访问 |
| public     | 在方法和变量的声明中使用，它表示这个方法或变量能够被其它类中的元素访问 |
| return     | 用来结束一个方法的执行。它后面可以跟一个方法声明中要求的值   |
| static     | 用来定义一个变量为类变量。类只维护一个类变量的拷贝，不管该类当前有多少个实例。 `static` 同样能够用来定义一个方法为类方法。类方法通过类名调用而不是特定的实例，并且只能操作类变量 |
| this       | 用来代表它出现的类的一个实例。this可以用来访问类变量和类方法 |
| throw      | 允许用户抛出一个exception对象或者任何实现throwable的对象     |
| throws     | 用在方法的声明中来说明哪些异常这个方法是不处理的，而是提交到程序的更高一层 |
| try        | 用来定义一个可能抛出异常语句块。如果一个异常被抛出，一个可选的catch语句块会处理try语句块中抛出的异常。同时，一个finally语句块会被执行，无论一个异常是否被抛出 |
| void       | 用在Java语言的方法声明中说明这个方法没有任何返回值。"void"也可以用来表示一句没有任何功能的语句 |
| while      | 用来定义一段反复执行的循环语句。循环的退出条件是while语句的一部分 |

### 运算符优先级表

| 优先级 | 运算符                                     | 结合性   |
| ------ | ------------------------------------------ | -------- |
| 1      | () [] .                                    | 从左到右 |
| 2      | ! +(正) -(负) ~ ++ --                      | 从右向左 |
| 3      | * / %                                      | 从左向右 |
| 4      | +(加) -(减)                                | 从左向右 |
| 5      | << >> >>>                                  | 从左向右 |
| 6      | < <= > >= instanceof                       | 从左向右 |
| 7      | == !=                                      | 从左向右 |
| 8      | &(按位与)                                  | 从左向右 |
| 9      | ^                                          | 从左向右 |
| 10     | \|                                         | 从左向右 |
| 11     | &&                                         | 从左向右 |
| 12     | \|\|                                       | 从左向右 |
| 13     | ?:                                         | 从右向左 |
| 14     | = += -= *= /= %= &= \|= ^= ~= <<= >>= >>>= | 从右向左 |

说明：

1. 该表中优先级按照从高到低的顺序书写，也就是优先级为1的优先级最高，优先级14的优先级最低。
2. 结合性是指运算符结合的顺序，通常都是从左到右。从右向左的运算符最典型的就是负号，例如3+-4，则意义为3加-4，符号首先和运算符右侧的内容结合。 　　
3. instanceof作用是判断对象是否为某个类或接口类型

### 短路原则

- 对于a && b，只有当a和b同时为true时，整个表达式才为true，在java中，首先运算表达式a，如果a为true，则继续运算表达式b，如果表达式a为false，那么整个表达式也肯定为false，所以表达式b不会被运算。
- 对于a || b，至少有一个为true，则表达式为true，如果a为false，整个表达式的值等于表达式b的值，因此继续运算表达式b，如果a为true，整个表达式的值为true，则没有必要再运算表达式b。

## 数组和字符串

### 声明数组变量

```
double[] array;   // 首选的方法

//或

double array[];  // 效果相同，但不是首选方法
```

数组变量的声明，和创建数组可以用一条语句完成，如下所示：

```
    // 数组大小
    int size = 10;
    // 定义数组
    double[] myList = new double[size];
    
    //或者
    
    double[] myList = {1.9, 2.9, 3.4, 3.5};
```

### 常用属性

`length` , 获取数组的长度

### 常用数组方法（在 `Arrays` 类中 ）

| 方法                                                     | 说明                                                         |
| -------------------------------------------------------- | ------------------------------------------------------------ |
| `public static int binarySearch(Object[] a, Object key)` | 用二分查找算法在给定数组中搜索给定值的对象(Byte,Int,double等)。数组在调用前必须排序好的。如果查找值包含在数组中，则返回搜索键的索引；否则返回 (-(插入点) - 1)。 |
| `public static boolean equals(long[] a, long[] a2)`      | 如果两个指定的 `long` 型数组彼此相等，则返回 `true`。如果两个数组包含相同数量的元素，并且两个数组中的所有相应元素对都是相等的，则认为这两个数组是相等的。换句话说，如果两个数组以相同顺序包含相同的元素，则两个数组是相等的。同样的方法适用于所有的其他基本数据类型（`Byte`，`short`，`int`等）。 |
| `public static void fill(int[] a, int val)`              | 将指定的 `int` 值分配给指定 `int` 型数组指定范围中的每个元素。同样的方法适用于所有的其他基本数据类型（`byte`，`short`，`int`等）。 |
| `public static void sort(Object[] a)`                    | 对指定对象数组根据其元素的自然顺序进行升序排列。同样的方法适用于所有的其他基本数据类型（`byte`，`short`，`int`等）。 |

### 遍历数组

```
for (double item:arrays)
{
    //do something here
}
```

### `String`类的常用方法

| 方法                                             | 作用                                                         |
| ------------------------------------------------ | ------------------------------------------------------------ |
| `int length()`                                   | 返回字符串对象包含的字符数                                   |
| `String format()`                                | 创建格式化字符串                                             |
| `int charAt(int index)`                          | 返回指定索引处的 char 值                                     |
| `int compareTo(String anotherString)`            | 按字典顺序比较两个字符串                                     |
| `int compareToIgnoreCase(String str)`            | 按字典顺序比较两个字符串，不考虑大小写                       |
| `boolean endsWith(String suffix)`                | 测试此字符串是否以指定的后缀结束                             |
| `boolean equalsIgnoreCase(String anotherString)` | 将此 String 与另一个 String 比较，不考虑大小写               |
| `boolean equals(String anotherString)`           | 将此 String 与另一个 String 比较                             |
| `String replace(char oldChar, char newChar)`     | 返回一个新的字符串，它是通过用 newChar 替换此字符串中出现的所有 oldChar 得到的 |
| `boolean startsWith(String prefix)`              | 测试此字符串是否以指定的前缀开始                             |
| `String toLowerCase()`                           | 使用默认语言环境的规则将此 String 中的所有字符都转换为小写   |
| `String toUpperCase()`                           | 使用默认语言环境的规则将此 String 中的所有字符都转换为大写   |
| `String trim()`                                  | 返回字符串的副本，忽略前导空白和尾部空白                     |

**String 类的 == 判断的是变量是否引用的同一个实例，而不是他们所引用的实例的内容是否相等**

## **Java 面向对象基础**

### 基本概念：

- 成员变量

- 成员方法

- 创建对象的关键字 `new`

- 构造函数的定义：无返回值，与类同名

- ```
  this
  ```

   

  表示当前实例，

  ```
  super
  ```

  表示父类

  - 当使用 `super(someargs)` 来继承父类的构造函数的时候，这句话必须放在最前面
  - `this(someargs)`表示调用此类中与参数相符的构造函数重载，也必须放在构造函数的最前面
  - 上面两个语句不能出现在同一个构造函数中
  - 本质上来说，`this` 是一个指向当前对象的指针，`super` 是一个关键字

- `static` 关键字修饰的成员变量和成员方法独立于该类的任何对象。也就是说，它不依赖类特定的实例，被类的所有实例共享。

- ```
  final
  ```

  关键字有一下几种含义：

  - 一个编译时恒定不变的常量
  - 一个在运行时初始化，而你不希望它被改变的变量
  - 参数列表中的参数以声明的方式声指明为final，这意味着你无法改变参数所指向的对象
  - 把方法锁定，以防止任何继承它的类修改它的含义

### 类的继承

```
// A.java
public class A {
    private int i;
    protected int j;
 
    public void func() {
 
    }
}
 
// B.java
public class B extends A {
}
```

- 类只能有一个爸爸（父类），但可以实现多个接口
- 子类可以继承父类所有的方法和属性，但是无法使用 `private`(私有) 的方法和属性
- 通过使用`instanceof` 操作符，能够确定对象是否是一个类或者其子类的实例
- 继承基本类和抽象类用`extends`关键字，实现接口类的继承用`implements`关键字。

### 重写与重载

#### **重写**

*重写是子类对父类的允许访问的方法的实现过程进行重新编写！返回值和形参都不能改变。即外壳不变，核心重写！*

#### **方法的重写规则**

- 参数列表必须完全与被重写方法的相同；
- 返回类型必须完全与被重写方法的返回类型相同；
- 访问权限不能比父类中被重写的方法的访问权限更高。例如：如果父类的一个方法被声明为`public`，那么在子类中重写该方法就不能声明为`protected`。
- 父类的成员方法只能被它的子类重写。
- 声明为final的方法不能被重写。
- 声明为static的方法不能被重写，但是能够被再次声明。
- 子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为`private`和`final`的方法。
- 子类和父类不在同一个包中，那么子类只能够重写父类的声明为`public`和`protected`的非`final`方法。
- 重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。
- 构造方法不能被重写。
- 如果不能继承一个方法，则不能重写这个方法。

#### **重载**

重载(overloading) 是在一个类里面，方法名字相同，而参数不同。返回类型呢？可以相同也可以不同。

#### **重载规则**

- 被重载的方法必须改变参数列表；
- 被重载的方法可以改变返回类型；
- 被重载的方法可以改变访问修饰符；
- 被重载的方法可以声明新的或更广的检查异常；
- 方法能够在同一个类中或者在一个子类中被重载。

#### **重写与重载的区别**

| 区别点   | 重载方法 | 重写方法                                       |
| -------- | -------- | ---------------------------------------------- |
| 参数列表 | 必须修改 | 一定不能修改                                   |
| 返回类型 | 可以修改 | 一定不能修改                                   |
| 异常     | 可以修改 | 可以减少或删除，一定不能抛出新的或者更广的异常 |
| 访问     | 可以修改 | 一定不能做更严格的限制（可以降低限制）         |

### 多态性

多态是同一个行为具有多个不同表现形式或形态的能力。
多态存在的三个必要条件:

- 继承
- 重写
- 父类引用指向子类对象

### Java 包(package)

#### 包的作用

1. 把功能相似或相关的类或接口组织在同一个包中，方便类的查找和使用。
2. 如同文件夹一样，包也采用了树形目录的存储方式。同一个包中的类名字是不同的，不同的包中的类的名字是可以相同的，当同时调用两个不同包中相同类名的类时，应该加上包名加以区别。因此，包可以避免名字冲突。
3. 包也限定了访问权限，拥有包访问权限的类才能访问某个包中的类。

默认导入的包是`java.lang`

### 抽象方法：

```
public abstract <returnType> <methodName>(...);
```

仅有方法头，而没有方法体和操作实现，具体实现由当前类的不同子类在它们各自的类声明中完成，抽象类可以包含抽象方法
**注意**

- 一个抽象类的子类如果不是抽象类，则它必须为父类中的所有抽象方法书写方法体，即重写父类中的所有抽象方法
- 只**有抽象类才能具有抽象方法**，即如果一个类中含有抽象方法，则必须将这个类声明为抽象类
- 除了抽象方法，抽象类中还可以包括非抽象方法

### 抽象类

```
abstract class Number 
{
    //. . .
}
```

- 没有具体实例对象的类，不能使用`new`方法进行实例化
- 类前需加修饰符`abstract`
- 可包含常规类能够包含的任何东西，例如构造方法，非抽象方法
- 也可包含抽象方法，这种方法只有方法的声明，而没有方法的实现

## **集合类**

### Set

- 集合中的对象不按特定的方式排序，**并且没有重复对象**。
- 实现：
  - HashSet： HashSet类按照哈希算法来存取集合中的对象，存取速度比较快
  - TreeSet ：TreeSet类实现了SortedSet接口，能够对集合中的对象进行排序

### List

- 元素以线性方式存储，集合中可以存放重复对象。
- 实现：
  - ArrayList : 代表长度可以改变的数组。可以对元素进行随机的访问，向ArrayList()中插入与删除元素的速度慢
  - LinkedList : 在实现中采用链表数据结构。插入和删除速度快，访问速度慢。

### Map

一种把键对象和值对象映射的集合，它的每一个元素都包含一对键对象和值对象
常用操作：

```
Object put(Object key, Object value)    //向集合中加入元素   
Object remove(Object key)               //删除与KEY相关的元素   
void putAll(Map t)                      //将来自特定映像的所有元素添加给该映像   
void clear()                            //从映像中删除所有映射   
Object get(Object key)                  //获得与关键字key相关的值
put(Object key, Object value)           //添加一个“值”(想要得东西)和与“值”相关联的“键”(key)(使用它来查找)
```

### 数组、List相互转换

```
//List to array
Employee[] employees = employeeList.toArray(new Employee[employeeList.size()]);

//Array to list
employeeList = Arrays.asList(employees);
```

### 常用集合操作

```
//遍历
employeeList
    .stream()
    .forEach(employee -> 
    {
        //Do something here
    }));
    
//去重
employeeList = employeeList
        .stream()
        .distinct()  //使用 equals()方法 
        .collect(Collectors.toList());
        
//字符串列表转小写并去重
list = list
        .stream()
        .map(s->s.toLowerCase()+"或者你也可以在这里加上自己喜欢的话")
        .distinct()
        .collect(Collectors.toList()); //list 必须是 List 接口类型变量
        
//或者我们还可以排个序
list.sort((s1,s2)->
        {
            //或者在这里写你自己的比较方法
            //返回类型是 int
            return s1.compareTo(s2);
        });

//最后我们还可以删库跑路
list.clear();
```

## **IO 操作**

常用的读写文件的操作

```
//从控制台读入
//先背一波类名
BufferedReader brConsole = new BufferedReader(new InputStreamReader(System.in));
        try
        {
        //读取文件
            BufferedWriter bwFile = new BufferedWriter(new OutputStreamWriter(new FileOutputStream("worldcup.txt",true)));

            String line = null;
            while((line=brConsole.readLine())!=null)
            {
                if ("Done".equalsIgnoreCase(line))
                {
                    break;
                }
                else
                {
                    bwFile.write(line);
                    bwFile.newLine();
                }
            }
            bwFile.flush();
            
//好烦啊，其他的都差不多了，不写了
```

## **自定义异常**

### 声明一个异常

```
class MyException extends Exception
{
}
```

### 捕获异常

```
try
{
   // 程序代码
}
catch(ExceptionName e1)
{
   //Catch 块
}
```

### 捕获多重异常

```
 try
 {
    // 程序代码
 }
 catch(异常类型1 异常的变量名1)
 {
    // 程序代码
 }
 catch(异常类型2 异常的变量名2)
 {
    // 程序代码
 }
 catch(异常类型3 异常的变量名3)
 {
    // 程序代码
 }
 
 //或者
 
  try
 {
    // 程序代码
 }
 catch(异常类型1 | 异常类型2 | 异常类型3 异常的变量名)
 {
    // 程序代码
 }
```